# å½¢å¼åŒ–å®šä¹‰æ ‡å‡†æ¨¡æ¿

> **ç‰ˆæœ¬**: 1.0
> **åˆ›å»ºæ—¥æœŸ**: 2025-01-25
> **çŠ¶æ€**: âœ… å·²å®Œæˆ
> **é€‚ç”¨èŒƒå›´**: æ‰€æœ‰ç®—æ³•å’Œæ•°æ®ç»“æ„çš„å½¢å¼åŒ–å®šä¹‰

---

## ğŸ“‹ æ¨¡æ¿è¯´æ˜

æœ¬æ–‡æ¡£å®šä¹‰äº†ç®—æ³•å’Œæ•°æ®ç»“æ„å½¢å¼åŒ–å®šä¹‰çš„æ ‡å‡†æ¨¡æ¿ï¼Œç¡®ä¿æ‰€æœ‰å®šä¹‰çš„ä¸€è‡´æ€§å’Œä¸¥è°¨æ€§ã€‚

**This document defines the standard template for formal definitions of algorithms and data structures to ensure consistency and rigor of all definitions.**

---

## 1. ç®—æ³•å½¢å¼åŒ–å®šä¹‰æ¨¡æ¿

### 1.1 åŸºæœ¬ç»“æ„

```markdown
    **å®šä¹‰ X.X.X** (ç®—æ³•åç§°) [æ¥æºå¼•ç”¨]
    ç®—æ³•åç§°çš„ç®€æ´æè¿°ã€‚
    **Definition X.X.X** (Algorithm Name) [Source Citation]
    Brief description of the algorithm name.

    **å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

    è®¾è¾“å…¥ä¸º $I$ï¼Œè¾“å‡ºä¸º $O$ï¼Œç®—æ³• $A$ å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š
    Let input be $I$, output be $O$, algorithm $A$ can be formally defined as:

    $$A: I \to O$$

    å…¶ä¸­ï¼š
    Where:

    - $I = \{i_1, i_2, \ldots, i_n\}$ æ˜¯è¾“å…¥é›†åˆ
    - $O = \{o_1, o_2, \ldots, o_m\}$ æ˜¯è¾“å‡ºé›†åˆ
    - $A$ æ»¡è¶³æ€§è´¨ $P$

    - $I = \{i_1, i_2, \ldots, i_n\}$ is the input set
    - $O = \{o_1, o_2, \ldots, o_m\}$ is the output set
    - $A$ satisfies property $P$

    **å‰ç½®æ¡ä»¶ / Precondition**:
    - æ¡ä»¶1
    - æ¡ä»¶2
    **Condition 1**
    **Condition 2**

    **åç½®æ¡ä»¶ / Postcondition**:
    - æ¡ä»¶1
    - æ¡ä»¶2
    **Condition 1**
    **Condition 2**

    **ç®—æ³•æè¿° / Algorithm Description:**

    ```text
    AlgorithmName(I):
        // ç®—æ³•ä¼ªä»£ç 
        ...
        return O
    ```

```

**å¤æ‚åº¦ / Complexity:**

- **æ—¶é—´å¤æ‚åº¦**: $T(n) = O(f(n))$
- **ç©ºé—´å¤æ‚åº¦**: $S(n) = O(g(n))$
- **Time complexity**: $T(n) = O(f(n))$
- **Space complexity**: $S(n) = O(g(n))$

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**

### 1.2 ç¤ºä¾‹ï¼šå½’å¹¶æ’åº

```markdown
    **å®šä¹‰ 2.4.1** (å½’å¹¶æ’åº) [Cormen 2022]
    å½’å¹¶æ’åºæ˜¯ä¸€ç§åŸºäºåˆ†æ²»ç­–ç•¥çš„ç¨³å®šæ’åºç®—æ³•ã€‚
    **Definition 2.4.1** (Merge Sort) [Cormen 2022]
    Merge sort is a stable sorting algorithm based on divide-and-conquer strategy.

    **å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

    è®¾ $A[1..n]$ ä¸ºè¾“å…¥æ•°ç»„ï¼Œå½’å¹¶æ’åºç®—æ³• $MergeSort$ å®šä¹‰ä¸ºï¼š
    Let $A[1..n]$ be the input array, merge sort algorithm $MergeSort$ is defined as:

    $$MergeSort: \mathbb{R}^n \to \mathbb{R}^n$$

    å…¶ä¸­ $MergeSort(A)$ è¿”å›æ’åºåçš„æ•°ç»„ $A'$ï¼Œæ»¡è¶³ï¼š
    where $MergeSort(A)$ returns sorted array $A'$ such that:

    $$\forall i \in [1, n-1]: A'[i] \leq A'[i+1]$$

    **å‰ç½®æ¡ä»¶ / Precondition**:
    - è¾“å…¥æ•°ç»„ $A[1..n]$ åŒ…å«å¯æ¯”è¾ƒå…ƒç´ 
    **Input array $A[1..n]$ contains comparable elements**

    **åç½®æ¡ä»¶ / Postcondition**:
    - è¾“å‡ºæ•°ç»„ $A'[1..n]$ å·²æ’åº
    - è¾“å‡ºæ•°ç»„ $A'[1..n]$ åŒ…å«è¾“å…¥æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
    **Output array $A'[1..n]$ is sorted**
    **Output array $A'[1..n]$ contains all elements of input array**
```

---

## 2. æ•°æ®ç»“æ„å½¢å¼åŒ–å®šä¹‰æ¨¡æ¿

### 2.1 åŸºæœ¬ç»“æ„

```markdown
**å®šä¹‰ X.X.X** (æ•°æ®ç»“æ„åç§°) [æ¥æºå¼•ç”¨]
æ•°æ®ç»“æ„åç§°çš„ç®€æ´æè¿°ã€‚
**Definition X.X.X** (Data Structure Name) [Source Citation]
Brief description of the data structure name.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

æ•°æ®ç»“æ„ $D$ å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºå…ƒç»„ï¼š
Data structure $D$ can be formally defined as a tuple:

$$D = (S, O, I)$$

å…¶ä¸­ï¼š
Where:

- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $O$ æ˜¯æ“ä½œé›†åˆ
- $I$ æ˜¯ä¸å˜å¼é›†åˆ

- $S$ is the set of states
- $O$ is the set of operations
- $I$ is the set of invariants

**çŠ¶æ€ç©ºé—´ / State Space:**

$$S = \{s_1, s_2, \ldots, s_n\}$$

**æ“ä½œé›†åˆ / Operation Set:**

$$O = \{op_1: S \to S, op_2: S \times T \to S, \ldots\}$$

**ä¸å˜å¼ / Invariants:**

$$\forall s \in S: I(s)$$

**å¤æ‚åº¦ / Complexity:**
- **æ“ä½œå¤æ‚åº¦**: $T(op_i) = O(f(n))$
- **ç©ºé—´å¤æ‚åº¦**: $S(D) = O(g(n))$
- **Operation complexity**: $T(op_i) = O(f(n))$
- **Space complexity**: $S(D) = O(g(n))$

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**
- [Author Year]: å¼•ç”¨ä¿¡æ¯
```

### 2.2 ç¤ºä¾‹ï¼šå †

```markdown
**å®šä¹‰ X.X.X** (æœ€å¤§å †) [Cormen 2022]
æœ€å¤§å †æ˜¯ä¸€ç§å®Œå…¨äºŒå‰æ ‘ï¼Œæ»¡è¶³å †æ€§è´¨ã€‚
**Definition X.X.X** (Max-Heap) [Cormen 2022]
A max-heap is a complete binary tree satisfying the heap property.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

æœ€å¤§å † $H$ å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š
Max-heap $H$ can be formally defined as:

$$H = (A, heap\_size)$$

å…¶ä¸­ï¼š
Where:

- $A[1..heap\_size]$ æ˜¯æ•°ç»„è¡¨ç¤º
- $heap\_size \leq |A|$
- æ»¡è¶³å †æ€§è´¨ï¼š$\forall i \in [1, \lfloor heap\_size/2 \rfloor]: A[i] \geq A[2i] \land A[i] \geq A[2i+1]$

- $A[1..heap\_size]$ is array representation
- $heap\_size \leq |A|$
- Satisfies heap property: $\forall i \in [1, \lfloor heap\_size/2 \rfloor]: A[i] \geq A[2i] \land A[i] \geq A[2i+1]$

**å †æ€§è´¨ / Heap Property:**

$$\forall i \in [1, \lfloor n/2 \rfloor]: A[parent(i)] \geq A[i]$$

å…¶ä¸­ $parent(i) = \lfloor i/2 \rfloor$ã€‚
where $parent(i) = \lfloor i/2 \rfloor$.
```

---

## 3. å®šç†å½¢å¼åŒ–å®šä¹‰æ¨¡æ¿

### 3.1 åŸºæœ¬ç»“æ„

```markdown
**å®šç† X.X.X** (å®šç†åç§°) [æ¥æºå¼•ç”¨]
å®šç†çš„ç®€æ´é™ˆè¿°ã€‚
**Theorem X.X.X** (Theorem Name) [Source Citation]
Brief statement of the theorem.

**å½¢å¼åŒ–é™ˆè¿° / Formal Statement:**

è®¾æ¡ä»¶ $C_1, C_2, \ldots, C_n$ï¼Œåˆ™ç»“è®º $R$ æˆç«‹ã€‚
Given conditions $C_1, C_2, \ldots, C_n$, then conclusion $R$ holds.

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**

$$\forall x \in X: (C_1(x) \land C_2(x) \land \ldots \land C_n(x)) \to R(x)$$

**è¯æ˜ / Proof:**

[è¯æ˜å†…å®¹]
[Proof content]

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**
- [Author Year]: å¼•ç”¨ä¿¡æ¯
```

### 3.2 ç¤ºä¾‹ï¼šä¸»å®šç†

```markdown
**å®šç† 2.1** (ä¸»å®šç†) [Bentley 1980, Cormen 2022]
å¯¹äºé€’å½’å¼ $T(n) = aT(n/b) + f(n)$ï¼Œå…¶ä¸­ $a \geq 1, b > 1$ï¼Œ$f(n)$ æ¸è¿‘æ­£å‡½æ•°ï¼š
**Theorem 2.1** (Master Theorem) [Bentley 1980, Cormen 2022]
For recurrence $T(n) = aT(n/b) + f(n)$, where $a \geq 1, b > 1$, $f(n)$ asymptotically positive:

**å½¢å¼åŒ–é™ˆè¿° / Formal Statement:**

1. å¦‚æœ $f(n) = O(n^{\log_b a - \epsilon})$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a})$
2. å¦‚æœ $f(n) = \Theta(n^{\log_b a})$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a} \log n)$
3. å¦‚æœ $f(n) = \Omega(n^{\log_b a + \epsilon})$ï¼Œåˆ™ $T(n) = \Theta(f(n))$

**1. If $f(n) = O(n^{\log_b a - \epsilon})$, then $T(n) = \Theta(n^{\log_b a})$**
**2. If $f(n) = \Theta(n^{\log_b a})$, then $T(n) = \Theta(n^{\log_b a} \log n)$**
**3. If $f(n) = \Omega(n^{\log_b a + \epsilon})$, then $T(n) = \Theta(f(n))$**

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**

$$T(n) = \begin{cases}
\Theta(n^{\log_b a}) & \text{if } f(n) = O(n^{\log_b a - \epsilon}) \\
\Theta(n^{\log_b a} \log n) & \text{if } f(n) = \Theta(n^{\log_b a}) \\
\Theta(f(n)) & \text{if } f(n) = \Omega(n^{\log_b a + \epsilon})
\end{cases}$$
```

---

## 4. æ€§è´¨å½¢å¼åŒ–å®šä¹‰æ¨¡æ¿

### 4.1 åŸºæœ¬ç»“æ„

```markdown
**æ€§è´¨ X.X.X** (æ€§è´¨åç§°) [æ¥æºå¼•ç”¨]
æ€§è´¨çš„ç®€æ´æè¿°ã€‚
**Property X.X.X** (Property Name) [Source Citation]
Brief description of the property.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

ç®—æ³•/æ•°æ®ç»“æ„ $X$ æ»¡è¶³æ€§è´¨ $P$ï¼Œå½“ä¸”ä»…å½“ï¼š
Algorithm/data structure $X$ satisfies property $P$ if and only if:

$$\forall x \in X: P(x)$$

**ç­‰ä»·å®šä¹‰ / Equivalent Definition:**

æ€§è´¨ $P$ ç­‰ä»·äºï¼š
Property $P$ is equivalent to:

$$\exists y: Q(x, y) \land R(y)$$

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**
- [Author Year]: å¼•ç”¨ä¿¡æ¯
```

### 4.2 ç¤ºä¾‹ï¼šç¨³å®šæ€§

```markdown
**æ€§è´¨ 2.4.1** (æ’åºç®—æ³•ç¨³å®šæ€§) [Cormen 2022]
æ’åºç®—æ³•æ˜¯ç¨³å®šçš„ï¼Œå¦‚æœç›¸ç­‰å…ƒç´ çš„ç›¸å¯¹é¡ºåºä¿æŒä¸å˜ã€‚
**Property 2.4.1** (Sorting Algorithm Stability) [Cormen 2022]
A sorting algorithm is stable if the relative order of equal elements is preserved.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

æ’åºç®—æ³• $Sort$ æ˜¯ç¨³å®šçš„ï¼Œå½“ä¸”ä»…å½“ï¼š
Sorting algorithm $Sort$ is stable if and only if:

$$\forall A[1..n], \forall i, j \in [1, n]: (A[i] = A[j] \land i < j) \to (Sort(A)[i'] = Sort(A)[j'] \land i' < j')$$

å…¶ä¸­ $i'$ å’Œ $j'$ æ˜¯ $A[i]$ å’Œ $A[j]$ åœ¨æ’åºåæ•°ç»„ä¸­çš„ä½ç½®ã€‚
where $i'$ and $j'$ are positions of $A[i]$ and $A[j]$ in sorted array.
```

---

## 5. å¤æ‚åº¦å½¢å¼åŒ–å®šä¹‰æ¨¡æ¿

### 5.1 æ—¶é—´å¤æ‚åº¦

```markdown
**å®šä¹‰ X.X.X** (æ—¶é—´å¤æ‚åº¦) [Cormen 2022]
ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯è¾“å…¥è§„æ¨¡çš„å‡½æ•°ï¼Œè¡¨ç¤ºç®—æ³•æ‰§è¡Œæ‰€éœ€çš„æ—¶é—´ã€‚
**Definition X.X.X** (Time Complexity) [Cormen 2022]
Time complexity of an algorithm is a function of input size, representing the time required for algorithm execution.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

è®¾ç®—æ³• $A$ çš„è¾“å…¥è§„æ¨¡ä¸º $n$ï¼Œæ—¶é—´å¤æ‚åº¦ $T_A(n)$ å®šä¹‰ä¸ºï¼š
Let input size of algorithm $A$ be $n$, time complexity $T_A(n)$ is defined as:

$$T_A(n) = \max_{I \in \mathcal{I}_n} \{ \text{execution\_time}(A, I) \}$$

å…¶ä¸­ $\mathcal{I}_n$ æ˜¯æ‰€æœ‰è§„æ¨¡ä¸º $n$ çš„è¾“å…¥é›†åˆã€‚
where $\mathcal{I}_n$ is the set of all inputs of size $n$.

**æ¸è¿‘è¡¨ç¤º / Asymptotic Notation:**

$$T_A(n) = O(f(n)) \text{ å½“ä¸”ä»…å½“ } \exists c > 0, n_0 > 0: \forall n \geq n_0, T_A(n) \leq c \cdot f(n)$$
$$T_A(n) = O(f(n)) \text{ if and only if } \exists c > 0, n_0 > 0: \forall n \geq n_0, T_A(n) \leq c \cdot f(n)$$
```

### 5.2 ç©ºé—´å¤æ‚åº¦

```markdown
**å®šä¹‰ X.X.X** (ç©ºé—´å¤æ‚åº¦) [Cormen 2022]
ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦æ˜¯è¾“å…¥è§„æ¨¡çš„å‡½æ•°ï¼Œè¡¨ç¤ºç®—æ³•æ‰§è¡Œæ‰€éœ€çš„é¢å¤–ç©ºé—´ã€‚
**Definition X.X.X** (Space Complexity) [Cormen 2022]
Space complexity of an algorithm is a function of input size, representing the extra space required for algorithm execution.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

è®¾ç®—æ³• $A$ çš„è¾“å…¥è§„æ¨¡ä¸º $n$ï¼Œç©ºé—´å¤æ‚åº¦ $S_A(n)$ å®šä¹‰ä¸ºï¼š
Let input size of algorithm $A$ be $n$, space complexity $S_A(n)$ is defined as:

$$S_A(n) = \max_{I \in \mathcal{I}_n} \{ \text{extra\_space}(A, I) \}$$

å…¶ä¸­ $\mathcal{I}_n$ æ˜¯æ‰€æœ‰è§„æ¨¡ä¸º $n$ çš„è¾“å…¥é›†åˆã€‚
where $\mathcal{I}_n$ is the set of all inputs of size $n$.
```

---

## 6. è´¨é‡æ£€æŸ¥æ¸…å•

### 6.1 å®šä¹‰å®Œæ•´æ€§

- [ ] æœ‰æ˜ç¡®çš„æ•°å­¦ç¬¦å·è¡¨ç¤º
- [ ] æœ‰å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶
- [ ] æœ‰å¤æ‚åº¦åˆ†æ
- [ ] æœ‰å­¦æœ¯å¼•ç”¨

### 6.2 å½¢å¼åŒ–ç¨‹åº¦

- [ ] ä½¿ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·ï¼ˆå‚è€ƒISO 80000-2ï¼‰
- [ ] å®šä¹‰æ— æ­§ä¹‰
- [ ] é€»è¾‘ä¸¥è°¨
- [ ] ä¸­è‹±æ–‡å¯¹ç…§å®Œæ•´

### 6.3 æ ¼å¼è§„èŒƒæ€§

- [ ] å®šä¹‰ç¼–å·æ­£ç¡®
- [ ] å¼•ç”¨æ ¼å¼æ­£ç¡®
- [ ] ç¬¦å·ä½¿ç”¨ä¸€è‡´
- [ ] ä»£ç å—æ ¼å¼æ­£ç¡®

---

## 7. ä½¿ç”¨æŒ‡å—

### 7.1 ä½•æ—¶ä½¿ç”¨ç®—æ³•å®šä¹‰æ¨¡æ¿

- å¼•å…¥æ–°ç®—æ³•æ—¶
- éœ€è¦ä¸¥æ ¼å®šä¹‰ç®—æ³•æ—¶
- éœ€è¦å½¢å¼åŒ–æè¿°ç®—æ³•æ—¶

### 7.2 ä½•æ—¶ä½¿ç”¨æ•°æ®ç»“æ„å®šä¹‰æ¨¡æ¿

- å¼•å…¥æ–°æ•°æ®ç»“æ„æ—¶
- éœ€è¦ä¸¥æ ¼å®šä¹‰æ•°æ®ç»“æ„æ—¶
- éœ€è¦å½¢å¼åŒ–æè¿°æ•°æ®ç»“æ„æ—¶

### 7.3 ä½•æ—¶ä½¿ç”¨å®šç†å®šä¹‰æ¨¡æ¿

- é™ˆè¿°é‡è¦å®šç†æ—¶
- éœ€è¦å½¢å¼åŒ–è¯æ˜æ—¶
- éœ€è¦å¼•ç”¨åŸå§‹æ¥æºæ—¶

---

## 8. å‚è€ƒæ–‡æ¡£

- [æ•°å­¦ç¬¦å·è§„èŒƒ-ISO80000å¯¹é½ç‰ˆ](æ•°å­¦ç¬¦å·è§„èŒƒ-ISO80000å¯¹é½ç‰ˆ.md)
- [æ•°å­¦æ¨å¯¼æ ‡å‡†æ¨¡æ¿](æ•°å­¦æ¨å¯¼æ ‡å‡†æ¨¡æ¿.md)
- [å½¢å¼åŒ–è¯æ˜æ ‡å‡†æ¨¡æ¿](å½¢å¼åŒ–è¯æ˜æ ‡å‡†æ¨¡æ¿.md)
- [å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ](å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: é¡¹ç›®æ”¹è¿›å·¥ä½œç»„
**æœ€åæ›´æ–°**: 2025-01-25
**ä¸‹æ¬¡å®¡æŸ¥**: 2025-04-25
