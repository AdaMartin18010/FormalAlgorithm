# 24. 算法演化与遗传编程理论

> 说明：本文档中的代码/伪代码为说明性片段，仅用于理论阐释；本仓库不提供可运行工程或 CI。

## 概述

算法演化与遗传编程理论基于生物进化原理，通过选择、交叉、变异等操作自动生成和优化算法，实现算法的自动发现与改进。

## 学习目标

1. **基础级** 理解遗传算法的基本操作（选择/交叉/变异/精英保留）
2. **进阶级** 掌握多目标优化与适应度函数的设计方法
3. **进阶级** 能够分析演化算法的收敛性与复杂度
4. **高级级** 了解遗传编程的语法树表示与操作
5. **高级级** 掌握演化算法在算法合成中的应用

## 基本概念

### 演化算法 (Evolutionary Algorithm)

演化算法是一类基于自然选择和遗传机制的优化算法。

```rust
// 演化算法的基本框架
pub trait EvolutionaryAlgorithm {
    type Individual;
    type Fitness;
    
    fn initialize_population(&self) -> Vec<Self::Individual>;
    fn evaluate_fitness(&self, individual: &Self::Individual) -> Self::Fitness;
    fn select_parents(&self, population: &[Self::Individual]) -> Vec<Self::Individual>;
    fn crossover(&self, parents: &[Self::Individual]) -> Vec<Self::Individual>;
    fn mutate(&self, individual: &mut Self::Individual);
    fn replace_population(&self, old: &[Self::Individual], new: &[Self::Individual]) -> Vec<Self::Individual>;
}

// 演化计算系统
pub struct EvolutionarySystem {
    algorithm: Box<dyn EvolutionaryAlgorithm>,
    population_size: usize,
    generations: usize,
    selection_pressure: f64,
    mutation_rate: f64,
    crossover_rate: f64,
}

impl EvolutionarySystem {
    pub fn new(algorithm: Box<dyn EvolutionaryAlgorithm>) -> Self {
        Self {
            algorithm,
            population_size: 100,
            generations: 1000,
            selection_pressure: 0.8,
            mutation_rate: 0.01,
            crossover_rate: 0.8,
        }
    }
    
    pub fn evolve(&self) -> Result<Vec<Individual>, EvolutionError> {
        // 初始化种群
        let mut population = self.algorithm.initialize_population();
        
        for generation in 0..self.generations {
            // 评估适应度
            let fitness_scores: Vec<Fitness> = population
                .iter()
                .map(|ind| self.algorithm.evaluate_fitness(ind))
                .collect();
            
            // 选择父代
            let parents = self.algorithm.select_parents(&population);
            
            // 交叉操作
            let offspring = self.algorithm.crossover(&parents);
            
            // 变异操作
            for child in &mut offspring {
                self.algorithm.mutate(child);
            }
            
            // 种群替换
            population = self.algorithm.replace_population(&population, &offspring);
            
            // 记录进化过程
            self.record_generation(generation, &population, &fitness_scores);
        }
        
        Ok(population)
    }
}
```

## 遗传算法 (Genetic Algorithm)

### 基本遗传算法实现

```rust
// 遗传算法个体
#[derive(Clone, Debug)]
pub struct GAIndividual {
    genes: Vec<f64>,
    fitness: Option<f64>,
}

impl GAIndividual {
    pub fn new(genes: Vec<f64>) -> Self {
        Self {
            genes,
            fitness: None,
        }
    }
    
    pub fn random(length: usize) -> Self {
        let genes: Vec<f64> = (0..length)
            .map(|_| rand::random::<f64>())
            .collect();
        Self::new(genes)
    }
}

// 遗传算法实现
pub struct GeneticAlgorithm {
    chromosome_length: usize,
    fitness_function: Box<dyn Fn(&[f64]) -> f64>,
}

impl EvolutionaryAlgorithm for GeneticAlgorithm {
    type Individual = GAIndividual;
    type Fitness = f64;
    
    fn initialize_population(&self) -> Vec<Self::Individual> {
        (0..100)
            .map(|_| GAIndividual::random(self.chromosome_length))
            .collect()
    }
    
    fn evaluate_fitness(&self, individual: &Self::Individual) -> Self::Fitness {
        (self.fitness_function)(&individual.genes)
    }
    
    fn select_parents(&self, population: &[Self::Individual]) -> Vec<Self::Individual> {
        // 轮盘赌选择
        let total_fitness: f64 = population
            .iter()
            .map(|ind| ind.fitness.unwrap_or(0.0))
            .sum();
        
        let mut parents = Vec::new();
        for _ in 0..population.len() {
            let random_value = rand::random::<f64>() * total_fitness;
            let mut cumulative_fitness = 0.0;
            
            for individual in population {
                cumulative_fitness += individual.fitness.unwrap_or(0.0);
                if cumulative_fitness >= random_value {
                    parents.push(individual.clone());
                    break;
                }
            }
        }
        
        parents
    }
    
    fn crossover(&self, parents: &[Self::Individual]) -> Vec<Self::Individual> {
        let mut offspring = Vec::new();
        
        for chunk in parents.chunks(2) {
            if chunk.len() == 2 {
                let (child1, child2) = self.single_point_crossover(&chunk[0], &chunk[1]);
                offspring.push(child1);
                offspring.push(child2);
            }
        }
        
        offspring
    }
    
    fn mutate(&self, individual: &mut Self::Individual) {
        for gene in &mut individual.genes {
            if rand::random::<f64>() < 0.01 {
                *gene = rand::random::<f64>();
            }
        }
    }
    
    fn replace_population(&self, old: &[Self::Individual], new: &[Self::Individual]) -> Vec<Self::Individual> {
        // 精英保留策略
        let mut combined = [old, new].concat();
        combined.sort_by(|a, b| b.fitness.partial_cmp(&a.fitness).unwrap());
        combined[..old.len()].to_vec()
    }
}

impl GeneticAlgorithm {
    fn single_point_crossover(&self, parent1: &GAIndividual, parent2: &GAIndividual) -> (GAIndividual, GAIndividual) {
        let crossover_point = rand::random::<usize>() % parent1.genes.len();
        
        let mut child1_genes = parent1.genes.clone();
        let mut child2_genes = parent2.genes.clone();
        
        for i in crossover_point..parent1.genes.len() {
            child1_genes[i] = parent2.genes[i];
            child2_genes[i] = parent1.genes[i];
        }
        
        (GAIndividual::new(child1_genes), GAIndividual::new(child2_genes))
    }
}
```

## 进化策略 (Evolution Strategy)

### 进化策略实现

```rust
// 进化策略个体
#[derive(Clone, Debug)]
pub struct ESIndividual {
    parameters: Vec<f64>,
    strategy_parameters: Vec<f64>, // 变异强度参数
    fitness: Option<f64>,
}

impl ESIndividual {
    pub fn new(parameters: Vec<f64>) -> Self {
        let strategy_parameters = vec![0.1; parameters.len()];
        Self {
            parameters,
            strategy_parameters,
            fitness: None,
        }
    }
}

// 进化策略实现
pub struct EvolutionStrategy {
    problem_dimension: usize,
    fitness_function: Box<dyn Fn(&[f64]) -> f64>,
}

impl EvolutionaryAlgorithm for EvolutionStrategy {
    type Individual = ESIndividual;
    type Fitness = f64;
    
    fn initialize_population(&self) -> Vec<Self::Individual> {
        (0..100)
            .map(|_| {
                let parameters: Vec<f64> = (0..self.problem_dimension)
                    .map(|_| rand::random::<f64>() * 10.0 - 5.0)
                    .collect();
                ESIndividual::new(parameters)
            })
            .collect()
    }
    
    fn evaluate_fitness(&self, individual: &Self::Individual) -> Self::Fitness {
        (self.fitness_function)(&individual.parameters)
    }
    
    fn select_parents(&self, population: &[Self::Individual]) -> Vec<Self::Individual> {
        // 锦标赛选择
        let tournament_size = 3;
        let mut parents = Vec::new();
        
        for _ in 0..population.len() {
            let tournament: Vec<&ESIndividual> = population
                .choose_multiple(&mut rand::thread_rng(), tournament_size)
                .collect();
            
            let best = tournament
                .iter()
                .max_by(|a, b| a.fitness.partial_cmp(&b.fitness).unwrap())
                .unwrap();
            
            parents.push((**best).clone());
        }
        
        parents
    }
    
    fn crossover(&self, parents: &[Self::Individual]) -> Vec<Self::Individual> {
        let mut offspring = Vec::new();
        
        for chunk in parents.chunks(2) {
            if chunk.len() == 2 {
                let child = self.intermediate_crossover(&chunk[0], &chunk[1]);
                offspring.push(child);
            }
        }
        
        offspring
    }
    
    fn mutate(&self, individual: &mut Self::Individual) {
        // 自适应变异
        for i in 0..individual.parameters.len() {
            // 更新策略参数
            individual.strategy_parameters[i] *= (0.2 * rand::random::<f64>() + 0.9).exp();
            
            // 变异参数
            individual.parameters[i] += individual.strategy_parameters[i] * rand::random::<f64>();
        }
    }
    
    fn replace_population(&self, old: &[Self::Individual], new: &[Self::Individual]) -> Vec<Self::Individual> {
        // (μ+λ) 选择策略
        let mut combined = [old, new].concat();
        combined.sort_by(|a, b| b.fitness.partial_cmp(&a.fitness).unwrap());
        combined[..old.len()].to_vec()
    }
}

impl EvolutionStrategy {
    fn intermediate_crossover(&self, parent1: &ESIndividual, parent2: &ESIndividual) -> ESIndividual {
        let alpha = rand::random::<f64>();
        
        let parameters: Vec<f64> = parent1.parameters
            .iter()
            .zip(parent2.parameters.iter())
            .map(|(p1, p2)| alpha * p1 + (1.0 - alpha) * p2)
            .collect();
        
        let strategy_parameters: Vec<f64> = parent1.strategy_parameters
            .iter()
            .zip(parent2.strategy_parameters.iter())
            .map(|(s1, s2)| alpha * s1 + (1.0 - alpha) * s2)
            .collect();
        
        ESIndividual {
            parameters,
            strategy_parameters,
            fitness: None,
        }
    }
}
```

## 遗传编程 (Genetic Programming)

### 遗传编程实现

```rust
// 遗传编程树节点
#[derive(Clone, Debug)]
pub enum GPNode {
    Terminal(f64),
    Function(Box<dyn Fn(f64, f64) -> f64>),
    Variable(usize),
}

// 遗传编程个体
#[derive(Clone, Debug)]
pub struct GPIndividual {
    tree: GPNode,
    fitness: Option<f64>,
}

impl GPIndividual {
    pub fn new(tree: GPNode) -> Self {
        Self {
            tree,
            fitness: None,
        }
    }
    
    pub fn evaluate(&self, inputs: &[f64]) -> Result<f64, EvaluationError> {
        self.evaluate_node(&self.tree, inputs)
    }
    
    fn evaluate_node(&self, node: &GPNode, inputs: &[f64]) -> Result<f64, EvaluationError> {
        match node {
            GPNode::Terminal(value) => Ok(*value),
            GPNode::Variable(index) => {
                if *index < inputs.len() {
                    Ok(inputs[*index])
                } else {
                    Err(EvaluationError::InvalidVariableIndex)
                }
            }
            GPNode::Function(func) => {
                // 简化版本，假设所有函数都是二元函数
                let left = self.evaluate_node(&GPNode::Terminal(1.0), inputs)?;
                let right = self.evaluate_node(&GPNode::Terminal(2.0), inputs)?;
                Ok(func(left, right))
            }
        }
    }
}

// 遗传编程实现
pub struct GeneticProgramming {
    terminal_set: Vec<GPNode>,
    function_set: Vec<Box<dyn Fn(f64, f64) -> f64>>,
    max_depth: usize,
    training_data: Vec<(Vec<f64>, f64)>,
}

impl EvolutionaryAlgorithm for GeneticProgramming {
    type Individual = GPIndividual;
    type Fitness = f64;
    
    fn initialize_population(&self) -> Vec<Self::Individual> {
        (0..100)
            .map(|_| {
                let tree = self.grow_tree(0, self.max_depth);
                GPIndividual::new(tree)
            })
            .collect()
    }
    
    fn evaluate_fitness(&self, individual: &Self::Individual) -> Self::Fitness {
        let mut total_error = 0.0;
        
        for (inputs, target) in &self.training_data {
            match individual.evaluate(inputs) {
                Ok(prediction) => {
                    total_error += (prediction - target).powi(2);
                }
                Err(_) => {
                    total_error += f64::INFINITY;
                }
            }
        }
        
        // 适应度是误差的倒数
        if total_error == 0.0 {
            f64::INFINITY
        } else {
            1.0 / total_error
        }
    }
    
    fn select_parents(&self, population: &[Self::Individual]) -> Vec<Self::Individual> {
        // 锦标赛选择
        let tournament_size = 3;
        let mut parents = Vec::new();
        
        for _ in 0..population.len() {
            let tournament: Vec<&GPIndividual> = population
                .choose_multiple(&mut rand::thread_rng(), tournament_size)
                .collect();
            
            let best = tournament
                .iter()
                .max_by(|a, b| a.fitness.partial_cmp(&b.fitness).unwrap())
                .unwrap();
            
            parents.push((**best).clone());
        }
        
        parents
    }
    
    fn crossover(&self, parents: &[Self::Individual]) -> Vec<Self::Individual> {
        let mut offspring = Vec::new();
        
        for chunk in parents.chunks(2) {
            if chunk.len() == 2 {
                let (child1, child2) = self.subtree_crossover(&chunk[0], &chunk[1]);
                offspring.push(child1);
                offspring.push(child2);
            }
        }
        
        offspring
    }
    
    fn mutate(&self, individual: &mut Self::Individual) {
        // 子树变异
        individual.tree = self.subtree_mutation(&individual.tree);
    }
    
    fn replace_population(&self, old: &[Self::Individual], new: &[Self::Individual]) -> Vec<Self::Individual> {
        // 精英保留
        let mut combined = [old, new].concat();
        combined.sort_by(|a, b| b.fitness.partial_cmp(&a.fitness).unwrap());
        combined[..old.len()].to_vec()
    }
}

impl GeneticProgramming {
    fn grow_tree(&self, current_depth: usize, max_depth: usize) -> GPNode {
        if current_depth >= max_depth {
            // 只能选择终端节点
            self.terminal_set.choose(&mut rand::thread_rng()).unwrap().clone()
        } else {
            if rand::random::<f64>() < 0.5 {
                // 选择函数节点
                let func = self.function_set.choose(&mut rand::thread_rng()).unwrap();
                GPNode::Function(func.clone())
            } else {
                // 选择终端节点
                self.terminal_set.choose(&mut rand::thread_rng()).unwrap().clone()
            }
        }
    }
    
    fn subtree_crossover(&self, parent1: &GPIndividual, parent2: &GPIndividual) -> (GPIndividual, GPIndividual) {
        // 简化版本：随机交换子树
        (parent1.clone(), parent2.clone())
    }
    
    fn subtree_mutation(&self, tree: &GPNode) -> GPNode {
        // 简化版本：随机生成新树
        self.grow_tree(0, self.max_depth)
    }
}
```

## 应用示例

### 函数优化示例

```rust
// 使用遗传算法优化函数
fn genetic_algorithm_example() -> Result<(), Box<dyn std::error::Error>> {
    // 定义适应度函数（Rastrigin函数）
    let fitness_function = Box::new(|x: &[f64]| {
        let n = x.len() as f64;
        let a = 10.0;
        let sum: f64 = x.iter()
            .map(|&xi| xi.powi(2) - a * (2.0 * std::f64::consts::PI * xi).cos())
            .sum();
        a * n + sum
    });
    
    let ga = GeneticAlgorithm {
        chromosome_length: 10,
        fitness_function,
    };
    
    let system = EvolutionarySystem::new(Box::new(ga));
    let final_population = system.evolve()?;
    
    // 找到最优解
    let best_individual = final_population
        .iter()
        .max_by(|a, b| a.fitness.partial_cmp(&b.fitness).unwrap())
        .unwrap();
    
    println!("最优解: {:?}", best_individual.genes);
    println!("最优适应度: {}", best_individual.fitness.unwrap());
    
    Ok(())
}
```

### 符号回归示例

```rust
// 使用遗传编程进行符号回归
fn genetic_programming_example() -> Result<(), Box<dyn std::error::Error>> {
    // 生成训练数据：y = x^2 + 2x + 1
    let training_data: Vec<(Vec<f64>, f64)> = (-10..=10)
        .map(|x| {
            let x_f64 = x as f64;
            let y = x_f64.powi(2) + 2.0 * x_f64 + 1.0;
            (vec![x_f64], y)
        })
        .collect();
    
    let gp = GeneticProgramming {
        terminal_set: vec![
            GPNode::Terminal(1.0),
            GPNode::Terminal(2.0),
            GPNode::Variable(0),
        ],
        function_set: vec![
            Box::new(|a, b| a + b),
            Box::new(|a, b| a * b),
            Box::new(|a, b| a - b),
        ],
        max_depth: 5,
        training_data,
    };
    
    let system = EvolutionarySystem::new(Box::new(gp));
    let final_population = system.evolve()?;
    
    // 找到最优解
    let best_individual = final_population
        .iter()
        .max_by(|a, b| a.fitness.partial_cmp(&b.fitness).unwrap())
        .unwrap();
    
    println!("最优程序适应度: {}", best_individual.fitness.unwrap());
    
    Ok(())
}
```

## 数学基础

### 遗传算法的数学表示

```latex
\text{种群:} \quad P(t) = \{x_1(t), x_2(t), \ldots, x_N(t)\}

\text{选择概率:} \quad p_i = \frac{f(x_i)}{\sum_{j=1}^{N} f(x_j)}

\text{交叉操作:} \quad x_{new} = \alpha x_{parent1} + (1-\alpha) x_{parent2}

\text{变异操作:} \quad x_{mutated} = x + \mathcal{N}(0, \sigma^2)
```

### 进化策略的数学框架

```latex
\text{个体表示:} \quad (x, \sigma) \in \mathbb{R}^n \times \mathbb{R}^n

\text{变异:} \quad \sigma' = \sigma \exp(\tau \mathcal{N}(0,1))
\quad x' = x + \sigma' \mathcal{N}(0,1)

\text{重组:} \quad x_{new} = \frac{x_1 + x_2}{2}
\quad \sigma_{new} = \frac{\sigma_1 + \sigma_2}{2}
```

## 复杂度分析

### 演化算法的复杂度

- **时间复杂度**: $O(G \cdot N \cdot F)$
  - $G$: 代数
  - $N$: 种群大小
  - $F$: 适应度计算复杂度

- **空间复杂度**: $O(N \cdot L)$
  - $L$: 个体编码长度

### 收敛性分析

- **期望收敛时间**: $O(\log N)$ (对于某些问题)
- **全局最优保证**: 在无限时间内以概率1收敛

## 未来发展方向

### 1. 多目标演化算法

- 帕累托最优解集
- 目标权重自适应
- 偏好引导搜索

### 2. 协同演化

- 种群间竞争
- 共生关系建模
- 生态系统模拟

### 3. 量子演化算法

- 量子遗传算法
- 量子进化策略
- 量子遗传编程

### 4. 混合演化算法

- 与局部搜索结合
- 与机器学习结合
- 与深度学习结合

## 总结

算法演化与遗传编程理论为复杂优化问题提供了强大的求解工具。通过模拟生物进化过程，这些算法能够在没有先验知识的情况下自动发现解决方案。

随着计算能力的提升和算法的不断改进，演化算法将在更多领域发挥重要作用，特别是在人工智能、机器学习、工程设计等复杂问题求解中。

通过持续的研究和实践，演化算法将继续发展，为人类解决更加复杂和挑战性的问题提供新的思路和方法。

## 术语与定义

| 术语 | 英文 | 定义 |
|------|------|------|
| 演化算法 | Evolutionary Algorithm | 基于自然选择/遗传机理的随机优化框架 |
| 适应度 | Fitness | 个体对问题目标的匹配程度度量 |
| 选择 | Selection | 从种群中选取个体用于繁殖的过程（轮盘赌/锦标赛等）|
| 交叉 | Crossover | 通过重组父代基因生成子代的操作 |
| 变异 | Mutation | 随机扰动个体基因以增加多样性 |
| 精英保留 | Elitism | 将最优个体直接保留到下一代的策略 |
| 遗传编程 | Genetic Programming | 以程序结构为个体的演化方法 |
| 进化策略 | Evolution Strategy | 以连续参数与策略参数联合演化的算法族 |

## 架构图（Mermaid）

```mermaid
flowchart LR
  I[初始种群] --> E[评估适应度]
  E --> S[选择]
  S --> C[交叉]
  C --> M[变异]
  M --> R[替换/精英保留]
  R --> E
```

## 交叉链接

- 参见 `23-算法自适应学习理论.md`
- 参见 `21-算法合成与元编程高级应用.md`
- 参见 `26-算法鲁棒性与对抗性防御理论.md`

## 相关文档（交叉链接）

- `10-高级主题/23-算法自适应学习理论.md`
- `09-算法理论/04-高级算法理论/21-算法演化理论.md`
- `09-算法理论/03-优化理论/04-启发式算法理论.md`

## 参考文献（占位）

- Eiben, A. E., Smith, J. E. "Introduction to Evolutionary Computing."
- Koza, J. R. "Genetic Programming."
- Hansen, N., Ostermeier, A. "Completely Derandomized Self-Adaptation in Evolution Strategies."

## 可运行Rust最小示例骨架（GA）

```rust
use rand::Rng;

#[derive(Clone)]
struct Individual { genes: Vec<f64>, fitness: f64 }

fn fitness_fn(genes: &[f64]) -> f64 {
    // 目标：最小化 sum((x-1)^2) -> 将其转为最大化适应度
    let loss: f64 = genes.iter().map(|&x| (x-1.0).powi(2)).sum();
    -loss
}

fn init_population(n: usize, dim: usize) -> Vec<Individual> {
    let mut rng = rand::thread_rng();
    (0..n).map(|_| {
        let genes = (0..dim).map(|_| rng.gen_range(-5.0..5.0)).collect::<Vec<_>>();
        let fitness = fitness_fn(&genes);
        Individual{ genes, fitness }
    }).collect()
}

fn tournament_select(pop: &[Individual], k: usize) -> Individual {
    let mut rng = rand::thread_rng();
    let mut best = None;
    for _ in 0..k {
        let cand = &pop[rng.gen_range(0..pop.len())];
        if best.as_ref().map(|b:&Individual| cand.fitness > b.fitness).unwrap_or(true) { best = Some(cand.clone()); }
    }
    best.unwrap()
}

fn crossover(a: &Individual, b: &Individual) -> (Individual, Individual) {
    let n = a.genes.len();
    let cut = rand::thread_rng().gen_range(0..n);
    let mut g1 = a.genes.clone();
    let mut g2 = b.genes.clone();
    for i in cut..n { std::mem::swap(&mut g1[i], &mut g2[i]); }
    let f1 = fitness_fn(&g1); let f2 = fitness_fn(&g2);
    (Individual{genes:g1, fitness:f1}, Individual{genes:g2, fitness:f2})
}

fn mutate(ind: &mut Individual, rate: f64) {
    let mut rng = rand::thread_rng();
    for g in &mut ind.genes { if rng.gen::<f64>() < rate { *g += rng.gen_range(-0.1..0.1); } }
    ind.fitness = fitness_fn(&ind.genes);
}

fn main() {
    let mut pop = init_population(100, 8);
    let mut rng = rand::thread_rng();
    for gen in 0..200 {
        pop.sort_by(|a,b| b.fitness.partial_cmp(&a.fitness).unwrap());
        let elite = pop[0].clone();
        let mut next = vec![elite.clone()];
        while next.len() < pop.len() {
            let p1 = tournament_select(&pop, 3);
            let p2 = tournament_select(&pop, 3);
            let (mut c1, mut c2) = crossover(&p1, &p2);
            mutate(&mut c1, 0.1);
            mutate(&mut c2, 0.1);
            next.push(c1); if next.len() < pop.len() { next.push(c2); }
        }
        pop = next;
        if gen % 20 == 0 { println!("gen {:3}, best fitness {:.4}", gen, elite.fitness); }
    }
    pop.sort_by(|a,b| b.fitness.partial_cmp(&a.fitness).unwrap());
    println!("best genes: {:?}, fitness {:.4}", pop[0].genes, pop[0].fitness);
}
```

## 前置阅读（建议）

- 演化计算与遗传算法基础（选择/交叉/变异/精英）
- 多目标优化与适应度设计
- 复杂度与收敛性分析入门
- 统计学习与过拟合控制（正则化/交叉验证）

## 参考文献（示例）

1. Holland, J. H. Adaptation in Natural and Artificial Systems. University of Michigan Press, 1975.
2. Goldberg, D. E. Genetic Algorithms in Search, Optimization and Machine Learning. Addison-Wesley, 1989.
3. Koza, J. R. Genetic Programming: On the Programming of Computers by Means of Natural Selection. MIT Press, 1992.
