---
title: 10.2 åŒä¼¦ç±»å‹è®ºçš„é«˜çº§åº”ç”¨ / Advanced Applications of Homotopy Type Theory
version: 1.1
status: maintained
last_updated: 2025-01-12
owner: é«˜çº§ä¸»é¢˜å·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 10.2 åŒä¼¦ç±»å‹è®ºçš„é«˜çº§åº”ç”¨ / Advanced Applications of Homotopy Type Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€åŒä¼¦ç±»å‹è®ºçš„é«˜çº§åº”ç”¨ï¼Œå»ºç«‹ç±»å‹å³ç©ºé—´ã€è¯æ˜å³è·¯å¾„çš„æ•°å­¦æ¡†æ¶ã€‚
- å»ºç«‹åŒä¼¦ç±»å‹è®ºåœ¨ç»Ÿä¸€åŸºç¡€ä¸­çš„å‰æ²¿åœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- åŒä¼¦ç±»å‹è®ºã€ç»Ÿä¸€åŸºç¡€ã€ç±»å‹å³ç©ºé—´ã€è¯æ˜å³è·¯å¾„ã€é«˜ç»´ç±»å‹ã€åŒä¼¦ç¾¤ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- åŒä¼¦ç±»å‹è®ºï¼ˆHomotopy Type Theoryï¼‰ï¼šç»“åˆç±»å‹è®ºä¸åŒä¼¦è®ºçš„æ•°å­¦ç†è®ºã€‚
- ç»Ÿä¸€åŸºç¡€ï¼ˆUnivalent Foundationsï¼‰ï¼šåŸºäºåŒä¼¦ç±»å‹è®ºçš„æ•°å­¦åŸºç¡€ã€‚
- ç±»å‹å³ç©ºé—´ï¼ˆTypes as Spacesï¼‰ï¼šå°†ç±»å‹è§†ä¸ºæ‹“æ‰‘ç©ºé—´çš„è§‚ç‚¹ã€‚
- è¯æ˜å³è·¯å¾„ï¼ˆProofs as Pathsï¼‰ï¼šå°†è¯æ˜è§†ä¸ºè·¯å¾„çš„è§‚ç‚¹ã€‚
- è®°å·çº¦å®šï¼š`Type` è¡¨ç¤ºç±»å‹å®‡å®™ï¼Œ`Path` è¡¨ç¤ºè·¯å¾„ç±»å‹ï¼Œ`â‰¡` è¡¨ç¤ºåŒä¼¦ç­‰ä»·ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- åŒä¼¦ç±»å‹è®ºåŸºç¡€ï¼šå‚è§ `05-ç±»å‹ç†è®º/03-åŒä¼¦ç±»å‹è®º.md`ã€‚
- ç±»å‹ç³»ç»Ÿï¼šå‚è§ `05-ç±»å‹ç†è®º/04-ç±»å‹ç³»ç»Ÿ.md`ã€‚
- è¯æ˜ç³»ç»Ÿï¼šå‚è§ `03-å½¢å¼åŒ–è¯æ˜/01-è¯æ˜ç³»ç»Ÿ.md`ã€‚
- é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡ï¼šè§ [é¡¹ç›®å…¨é¢æ¢³ç†-2025](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)ã€[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- ç»Ÿä¸€åŸºç¡€
- é«˜çº§åº”ç”¨

## ç›®å½• (Table of Contents)

- [10.2 åŒä¼¦ç±»å‹è®ºçš„é«˜çº§åº”ç”¨ / Advanced Applications of Homotopy Type Theory](#102-åŒä¼¦ç±»å‹è®ºçš„é«˜çº§åº”ç”¨--advanced-applications-of-homotopy-type-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [2.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#21-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [2.1.1 åŒä¼¦ç±»å‹è®ºå®šä¹‰ (Definition of Homotopy Type Theory)](#211-åŒä¼¦ç±»å‹è®ºå®šä¹‰-definition-of-homotopy-type-theory)
  - [2.1.2 åŒä¼¦ç±»å‹è®ºå†å² (History of Homotopy Type Theory)](#212-åŒä¼¦ç±»å‹è®ºå†å²-history-of-homotopy-type-theory)
  - [2.1.3 åŒä¼¦ç±»å‹è®ºåº”ç”¨é¢†åŸŸ (Application Areas of Homotopy Type Theory)](#213-åŒä¼¦ç±»å‹è®ºåº”ç”¨é¢†åŸŸ-application-areas-of-homotopy-type-theory)
  - [2.1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#214-å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
    - [è§£é‡Šä¸ç›´è§‚ / Explanation and Intuition](#è§£é‡Šä¸ç›´è§‚--explanation-and-intuition)
    - [æ¦‚å¿µå±æ€§è¡¨ / Concept Attribute Table](#æ¦‚å¿µå±æ€§è¡¨--concept-attribute-table)
    - [æ¦‚å¿µå…³ç³» / Concept Relations](#æ¦‚å¿µå…³ç³»--concept-relations)
    - [æ¦‚å¿µä¾èµ–å›¾ / Concept Dependency Graph](#æ¦‚å¿µä¾èµ–å›¾--concept-dependency-graph)
    - [è®ºè¯ä¸è¯æ˜è¡”æ¥ / Argumentation and Proof Link](#è®ºè¯ä¸è¯æ˜è¡”æ¥--argumentation-and-proof-link)
    - [æ€ç»´å¯¼å›¾ï¼šæœ¬ç« æ¦‚å¿µç»“æ„ / Mind Map](#æ€ç»´å¯¼å›¾æœ¬ç« æ¦‚å¿µç»“æ„--mind-map)
    - [å¤šç»´çŸ©é˜µï¼šç±»å‹ä¸ç©ºé—´å¯¹åº” / Multi-Dimensional Comparison](#å¤šç»´çŸ©é˜µç±»å‹ä¸ç©ºé—´å¯¹åº”--multi-dimensional-comparison)
    - [å†³ç­–æ ‘ï¼šå½¢å¼åŒ–ç›®æ ‡åˆ°ç±»å‹é€‰æ‹© / Decision Tree](#å†³ç­–æ ‘å½¢å¼åŒ–ç›®æ ‡åˆ°ç±»å‹é€‰æ‹©--decision-tree)
    - [å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘ / Axiom-Theorem-Proof Tree](#å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘--axiom-theorem-proof-tree)
    - [åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘ / Application Decision Modeling Tree](#åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘--application-decision-modeling-tree)
- [2.2 åŒä¼¦ç±»å‹ (Homotopy Types)](#22-åŒä¼¦ç±»å‹-homotopy-types)
  - [2.2.1 åŸºæœ¬ç±»å‹ (Basic Types)](#221-åŸºæœ¬ç±»å‹-basic-types)
  - [2.2.2 ç§¯ç±»å‹ä¸å’Œç±»å‹ (Product and Sum Types)](#222-ç§¯ç±»å‹ä¸å’Œç±»å‹-product-and-sum-types)
  - [2.2.3 å‡½æ•°ç±»å‹ (Function Types)](#223-å‡½æ•°ç±»å‹-function-types)
  - [2.2.4 è·¯å¾„ç±»å‹ (Path Types)](#224-è·¯å¾„ç±»å‹-path-types)
- [2.3 é«˜é˜¶å½’çº³ç±»å‹ (Higher Inductive Types)](#23-é«˜é˜¶å½’çº³ç±»å‹-higher-inductive-types)
  - [2.3.1 é«˜é˜¶å½’çº³ç±»å‹å®šä¹‰ (Definition of Higher Inductive Types)](#231-é«˜é˜¶å½’çº³ç±»å‹å®šä¹‰-definition-of-higher-inductive-types)
  - [2.3.2 çƒé¢ (Spheres)](#232-çƒé¢-spheres)
  - [2.3.3 ç¯é¢ (Torus)](#233-ç¯é¢-torus)
  - [2.3.4 å•†ç±»å‹ (Quotient Types)](#234-å•†ç±»å‹-quotient-types)
- [2.4 å®ç°ç¤ºä¾‹ (Implementation Examples)](#24-å®ç°ç¤ºä¾‹-implementation-examples)
  - [2.4.1 åŒä¼¦ç±»å‹è®ºåº“å®ç° (Homotopy Type Theory Library Implementation)](#241-åŒä¼¦ç±»å‹è®ºåº“å®ç°-homotopy-type-theory-library-implementation)
  - [2.4.2 é«˜é˜¶å½’çº³ç±»å‹å®ç° (Higher Inductive Types Implementation)](#242-é«˜é˜¶å½’çº³ç±»å‹å®ç°-higher-inductive-types-implementation)
  - [2.4.3 åŒä¼¦ç¾¤è®¡ç®— (Homotopy Group Computation)](#243-åŒä¼¦ç¾¤è®¡ç®—-homotopy-group-computation)
  - [2.4.4 çº¤ç»´ä¸›ç†è®º (Fiber Bundle Theory)](#244-çº¤ç»´ä¸›ç†è®º-fiber-bundle-theory)
  - [2.4.5 åŒä¼¦ç±»å‹è®ºæµ‹è¯• (Homotopy Type Theory Testing)](#245-åŒä¼¦ç±»å‹è®ºæµ‹è¯•-homotopy-type-theory-testing)
  - [2.4.6 ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜å®ç° / Strict Formal Proof Implementations](#246-ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜å®ç°--strict-formal-proof-implementations)
  - [2.4.7 äº¤å‰å¼•ç”¨ä¸ä¾èµ– (Cross References and Dependencies)](#247-äº¤å‰å¼•ç”¨ä¸ä¾èµ–-cross-references-and-dependencies)
- [2.5 å‚è€ƒæ–‡çŒ® (References)](#25-å‚è€ƒæ–‡çŒ®-references)

---

## 2.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 2.1.1 åŒä¼¦ç±»å‹è®ºå®šä¹‰ (Definition of Homotopy Type Theory)

**åŒä¼¦ç±»å‹è®ºå®šä¹‰ / Definition of Homotopy Type Theory:**

åŒä¼¦ç±»å‹è®ºæ˜¯ç±»å‹è®ºçš„ä¸€ä¸ªåˆ†æ”¯ï¼Œå°†ç±»å‹è§†ä¸ºç©ºé—´ï¼Œå°†å‡½æ•°è§†ä¸ºè¿ç»­æ˜ å°„ï¼Œä»è€Œå°†æ‹“æ‰‘å­¦ä¸ç±»å‹è®ºç›¸ç»“åˆã€‚

Homotopy Type Theory is a branch of type theory that treats types as spaces and functions as continuous maps, combining topology with type theory.

**åŒä¼¦ç±»å‹è®ºçš„ç‰¹ç‚¹ / Characteristics of Homotopy Type Theory:**

1. **ç±»å‹å³ç©ºé—´ (Types as Spaces) / Types as Spaces:**
   - ç±»å‹å¯¹åº”æ‹“æ‰‘ç©ºé—´ / Types correspond to topological spaces
   - å‡½æ•°å¯¹åº”è¿ç»­æ˜ å°„ / Functions correspond to continuous maps

2. **è·¯å¾„å³è¯æ˜ (Paths as Proofs) / Paths as Proofs:**
   - è·¯å¾„å¯¹åº”ç­‰ä»·æ€§è¯æ˜ / Paths correspond to equivalence proofs
   - é«˜é˜¶è·¯å¾„å¯¹åº”é«˜é˜¶ç­‰ä»· / Higher paths correspond to higher equivalences

3. **æ„é€ æ€§æ•°å­¦ (Constructive Mathematics) / Constructive Mathematics:**
   - æ‰€æœ‰è¯æ˜éƒ½æ˜¯æ„é€ æ€§çš„ / All proofs are constructive
   - æ”¯æŒè®¡ç®—è§£é‡Š / Supports computational interpretation

### 2.1.2 åŒä¼¦ç±»å‹è®ºå†å² (History of Homotopy Type Theory)

**åŒä¼¦ç±»å‹è®ºå‘å±• / Homotopy Type Theory Development:**

åŒä¼¦ç±»å‹è®ºç”±Vladimir Voevodskyåœ¨2000å¹´ä»£æå‡ºï¼Œæ—¨åœ¨ä¸ºæ•°å­¦æä¾›æ–°çš„åŸºç¡€ã€‚

Homotopy Type Theory was proposed by Vladimir Voevodsky in the 2000s to provide new foundations for mathematics.

**ç†è®ºåŸºç¡€ / Theoretical Foundations:**

1. **Martin-LÃ¶fç±»å‹è®º (Martin-LÃ¶f Type Theory) / Martin-LÃ¶f Type Theory:**
   - ç›´è§‰ç±»å‹è®º / Intuitionistic type theory
   - ä¾èµ–ç±»å‹ / Dependent types

2. **åŒä¼¦è®º (Homotopy Theory) / Homotopy Theory:**
   - ä»£æ•°æ‹“æ‰‘ / Algebraic topology
   - åŒä¼¦ç¾¤ / Homotopy groups

3. **èŒƒç•´è®º (Category Theory) / Category Theory:**
   - é«˜é˜¶èŒƒç•´ / Higher categories
   - æ— ç©·èŒƒç•´ / Infinity categories

### 2.1.3 åŒä¼¦ç±»å‹è®ºåº”ç”¨é¢†åŸŸ (Application Areas of Homotopy Type Theory)

**ç†è®ºåº”ç”¨ / Theoretical Applications:**

1. **æ•°å­¦åŸºç¡€ (Foundations of Mathematics) / Foundations of Mathematics:**
   - é›†åˆè®ºæ›¿ä»£ / Set theory replacement
   - æ„é€ æ€§æ•°å­¦ / Constructive mathematics

2. **ä»£æ•°æ‹“æ‰‘ (Algebraic Topology) / Algebraic Topology:**
   - åŒä¼¦ç¾¤è®¡ç®— / Homotopy group computation
   - çº¤ç»´ä¸›ç†è®º / Fiber bundle theory

**è®¡ç®—åº”ç”¨ / Computing Applications:**

1. **ç¨‹åºéªŒè¯ (Program Verification) / Program Verification:**
   - ç±»å‹å®‰å…¨ / Type safety
   - ç¨‹åºæ­£ç¡®æ€§ / Program correctness

2. **å½¢å¼åŒ–æ•°å­¦ (Formal Mathematics) / Formal Mathematics:**
   - å®šç†è¯æ˜ / Theorem proving
   - æ•°å­¦åº“å¼€å‘ / Mathematical library development

### 2.1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

#### è§£é‡Šä¸ç›´è§‚ / Explanation and Intuition

åŒä¼¦ç±»å‹è®ºå°†ç±»å‹è§†ä¸ºç©ºé—´ã€è¯æ˜è§†ä¸ºè·¯å¾„ï¼Œç»Ÿä¸€åŸºç¡€ä¸é«˜é˜¶å½’çº³ç±»å‹æ„æˆæ•°å­¦å½¢å¼åŒ–å‰æ²¿ã€‚ä¸ 05-åŒä¼¦ç±»å‹è®ºã€03-å½¢å¼åŒ–è¯æ˜ã€08-Lean å®ç°è¡”æ¥ï¼›Â§2.1 åŸºæœ¬æ¦‚å¿µã€Â§2.2 åŒä¼¦ç±»å‹ä¸è·¯å¾„ã€Â§2.3 é«˜é˜¶å½’çº³ç±»å‹ã€Â§2.4 å®ç°ç¤ºä¾‹å½¢æˆå®Œæ•´è¡¨å¾ã€‚

#### æ¦‚å¿µå±æ€§è¡¨ / Concept Attribute Table

| å±æ€§å | ç±»å‹/èŒƒå›´ | å«ä¹‰ | å¤‡æ³¨ |
|--------|-----------|------|------|
| åŒä¼¦ç±»å‹è®º | ç»Ÿä¸€åŸºç¡€ | ç±»å‹å³ç©ºé—´ã€è¯æ˜å³è·¯å¾„ | Â§2.1 |
| åŸºæœ¬ç±»å‹/ç§¯å’Œ/å‡½æ•°ç±»å‹ | ç±»å‹ | å¯¹åº”æ‹“æ‰‘ç©ºé—´ | Â§2.2 |
| è·¯å¾„ç±»å‹ | ç­‰ä»·/è¯æ˜ | è·¯å¾„å³ç­‰ä»·è¯æ˜ | Â§2.2 |
| é«˜é˜¶å½’çº³ç±»å‹ | å½’çº³ç±»å‹ | çƒé¢/ç¯é¢/å•†ç±»å‹ | Â§2.3 |
| æ•°å­¦å½¢å¼åŒ–/ç¨‹åºéªŒè¯ | åº”ç”¨ | Â§2.4 | ä¸ 05ã€03ã€08 å¯¹ç…§ |

#### æ¦‚å¿µå…³ç³» / Concept Relations

| æºæ¦‚å¿µ | ç›®æ ‡æ¦‚å¿µ | å…³ç³»ç±»å‹ | è¯´æ˜ |
|--------|----------|----------|------|
| åŒä¼¦ç±»å‹è®ºé«˜çº§åº”ç”¨ | 05-åŒä¼¦ç±»å‹è®ºã€03-å½¢å¼åŒ–è¯æ˜ | depends_on | ç†è®ºä¸è¯æ˜åŸºç¡€ |
| åŒä¼¦ç±»å‹è®ºé«˜çº§åº”ç”¨ | 10-01 èŒƒç•´è®º | relates_to | é«˜é˜¶èŒƒç•´ |
| åŒä¼¦ç±»å‹è®ºé«˜çº§åº”ç”¨ | 08-Lean å®ç° | applies_to | å½¢å¼åŒ–è¯æ˜å®è·µ |

#### æ¦‚å¿µä¾èµ–å›¾ / Concept Dependency Graph

```mermaid
graph LR
  Def[HoTT å®šä¹‰ Â§2.1]
  HT[åŒä¼¦ç±»å‹ä¸è·¯å¾„ Â§2.2]
  HIT[é«˜é˜¶å½’çº³ç±»å‹ Â§2.3]
  Impl[å®ç°ä¸åº”ç”¨ Â§2.4]
  Def --> HT
  HT --> HIT
  HIT --> Impl
  05[05-åŒä¼¦ç±»å‹è®º]
  03[03-å½¢å¼åŒ–è¯æ˜]
  05 --> Def
  03 --> Def
```

#### è®ºè¯ä¸è¯æ˜è¡”æ¥ / Argumentation and Proof Link

ç±»å‹å³ç©ºé—´ã€è¯æ˜å³è·¯å¾„å…¬è®¾è§ Â§2.1ï¼›è·¯å¾„ç±»å‹ä¸ç­‰ä»·è§ Â§2.2ï¼›é«˜é˜¶å½’çº³ç±»å‹è§ Â§2.3ï¼›ä¸ 05-åŒä¼¦ç±»å‹è®ºã€03-è¯æ˜ç³»ç»Ÿè¡”æ¥ï¼›ç»Ÿä¸€åŸºç¡€è§æ–‡çŒ®ã€‚

#### æ€ç»´å¯¼å›¾ï¼šæœ¬ç« æ¦‚å¿µç»“æ„ / Mind Map

```mermaid
graph TD
  HoTT[åŒä¼¦ç±»å‹è®ºé«˜çº§åº”ç”¨]
  HoTT --> BC[åŸºæœ¬æ¦‚å¿µ Â§2.1]
  HoTT --> HT[åŒä¼¦ç±»å‹ Â§2.2]
  HoTT --> HIT[é«˜é˜¶å½’çº³ç±»å‹ Â§2.3]
  HoTT --> Impl[å®ç°ç¤ºä¾‹ Â§2.4]
  BC --> Space[ç±»å‹å³ç©ºé—´]
  BC --> Path[è¯æ˜å³è·¯å¾„]
  HT --> Base[åŸºæœ¬/ç§¯å’Œ/å‡½æ•°ç±»å‹]
  HT --> PathT[è·¯å¾„ç±»å‹]
  HIT --> Sphere[çƒé¢/ç¯é¢]
  HIT --> Quot[å•†ç±»å‹]
```

#### å¤šç»´çŸ©é˜µï¼šç±»å‹ä¸ç©ºé—´å¯¹åº” / Multi-Dimensional Comparison

| æ¦‚å¿µ/ç±»å‹ | å¯¹åº”ç©ºé—´ | è¯æ˜è§£é‡Š | å¤‡æ³¨ |
|-----------|----------|----------|------|
| åŸºæœ¬ç±»å‹ | ç‚¹/å•å…ƒ | å¹³å‡¡è¯æ˜ | Â§2.2 |
| ç§¯å’Œç±»å‹ | ç§¯/ä½™ç§¯ç©ºé—´ | æ„é€ å­ | Â§2.2 |
| å‡½æ•°ç±»å‹ | æ˜ å°„ç©ºé—´ | è•´å« | Â§2.2 |
| è·¯å¾„ç±»å‹ | è·¯å¾„ç©ºé—´ | ç­‰ä»·è¯æ˜ | Â§2.2 |
| é«˜é˜¶å½’çº³(çƒé¢/ç¯é¢/å•†) | å•†ç©ºé—´ | é«˜é˜¶å½’çº³ | Â§2.3 |

#### å†³ç­–æ ‘ï¼šå½¢å¼åŒ–ç›®æ ‡åˆ°ç±»å‹é€‰æ‹© / Decision Tree

```mermaid
flowchart TD
  Start([å½¢å¼åŒ–ç›®æ ‡])
  Start --> Goal{ç›®æ ‡?}
  Goal -->|æ•°å­¦åº“| Math[åŒä¼¦ç±»å‹ä¸é«˜é˜¶å½’çº³ Â§2.2â€“Â§2.3]
  Goal -->|ç¨‹åºéªŒè¯| PV[è·¯å¾„ç±»å‹ä¸ç­‰ä»· Â§2.2]
  Goal -->|åŒä¼¦ç¾¤è®¡ç®—| HG[é«˜é˜¶å½’çº³ç±»å‹ Â§2.3]
  Math --> Impl[Â§2.4 å®ç°]
  PV --> Impl
  HG --> Impl
```

#### å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘ / Axiom-Theorem-Proof Tree

```mermaid
graph LR
  Ax[HoTT å…¬è®¾ Â§2.1]
  P[è·¯å¾„ç±»å‹ä¸ç­‰ä»· Â§2.2]
  H[é«˜é˜¶å½’çº³ç±»å‹ Â§2.3]
  Impl[å®ç°æ­£ç¡®æ€§ Â§2.4]
  Ax --> P
  P --> H
  H --> Impl
```

#### åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘ / Application Decision Modeling Tree

```mermaid
flowchart TD
  Need([åº”ç”¨éœ€æ±‚])
  Need --> App{éœ€æ±‚ç±»å‹?}
  App -->|æ•°å­¦å½¢å¼åŒ–| Math[å¯¹åº”ç±»å‹ä¸å®ç° Â§2.4]
  App -->|ç¨‹åºéªŒè¯| PV[è·¯å¾„ä¸ç­‰ä»· Â§2.2]
  App -->|åŒä¼¦ç¾¤è®¡ç®—| HG[é«˜é˜¶å½’çº³ Â§2.3]
  Math --> Impl[Â§2.4 å®ç°]
  PV --> Impl
  HG --> Impl
```

---

## 2.2 åŒä¼¦ç±»å‹ (Homotopy Types)

### 2.2.1 åŸºæœ¬ç±»å‹ (Basic Types)

**åŸºæœ¬ç±»å‹å®šä¹‰ / Basic Type Definition:**

åœ¨åŒä¼¦ç±»å‹è®ºä¸­ï¼ŒåŸºæœ¬ç±»å‹å¯¹åº”ç®€å•çš„æ‹“æ‰‘ç©ºé—´ã€‚

In Homotopy Type Theory, basic types correspond to simple topological spaces.

**å•ä½ç±»å‹ (Unit Type) / Unit Type:**

```agda
-- Agdaä¸­çš„å•ä½ç±»å‹ / Unit Type in Agda
data Unit : Set where
  tt : Unit

-- å•ä½ç±»å‹å¯¹åº”å•ç‚¹ç©ºé—´ / Unit type corresponds to singleton space
-- åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ²¡æœ‰éå¹³å‡¡è·¯å¾„ / Only one element, no non-trivial paths
```

**ç©ºç±»å‹ (Empty Type) / Empty Type:**

```agda
-- Agdaä¸­çš„ç©ºç±»å‹ / Empty Type in Agda
data Empty : Set where
  -- æ— æ„é€ å‡½æ•° / No constructors

-- ç©ºç±»å‹å¯¹åº”ç©ºç©ºé—´ / Empty type corresponds to empty space
-- æ²¡æœ‰å…ƒç´ ï¼Œæ²¡æœ‰è·¯å¾„ / No elements, no paths
```

**å¸ƒå°”ç±»å‹ (Boolean Type) / Boolean Type:**

```agda
-- Agdaä¸­çš„å¸ƒå°”ç±»å‹ / Boolean Type in Agda
data Bool : Set where
  true : Bool
  false : Bool

-- å¸ƒå°”ç±»å‹å¯¹åº”ç¦»æ•£ä¸¤ç‚¹ç©ºé—´ / Boolean type corresponds to discrete two-point space
-- ä¸¤ä¸ªå…ƒç´ ï¼Œæ²¡æœ‰éå¹³å‡¡è·¯å¾„ / Two elements, no non-trivial paths
```

### 2.2.2 ç§¯ç±»å‹ä¸å’Œç±»å‹ (Product and Sum Types)

**ç§¯ç±»å‹ (Product Types) / Product Types:**

ç§¯ç±»å‹å¯¹åº”æ‹“æ‰‘ç§¯ç©ºé—´ã€‚

Product types correspond to topological product spaces.

```agda
-- Agdaä¸­çš„ç§¯ç±»å‹ / Product Type in Agda
record _Ã—_ (A B : Set) : Set where
  constructor _,_
  field
    projâ‚ : A
    projâ‚‚ : B

-- ç§¯ç±»å‹å¯¹åº”ç¬›å¡å°”ç§¯ç©ºé—´ / Product type corresponds to Cartesian product space
-- è·¯å¾„æ˜¯åˆ†é‡è·¯å¾„çš„ç§¯ / Paths are products of component paths
```

**å’Œç±»å‹ (Sum Types) / Sum Types:**

å’Œç±»å‹å¯¹åº”æ‹“æ‰‘å’Œç©ºé—´ã€‚

Sum types correspond to topological sum spaces.

```agda
-- Agdaä¸­çš„å’Œç±»å‹ / Sum Type in Agda
data _âŠ_ (A B : Set) : Set where
  injâ‚ : A â†’ A âŠ B
  injâ‚‚ : B â†’ A âŠ B

-- å’Œç±»å‹å¯¹åº”ä¸äº¤å¹¶ç©ºé—´ / Sum type corresponds to disjoint union space
-- è·¯å¾„åœ¨å„è‡ªåˆ†é‡å†… / Paths within respective components
```

### 2.2.3 å‡½æ•°ç±»å‹ (Function Types)

**å‡½æ•°ç±»å‹å®šä¹‰ / Function Type Definition:**

å‡½æ•°ç±»å‹å¯¹åº”æ˜ å°„ç©ºé—´ï¼Œå…·æœ‰ä¸°å¯Œçš„åŒä¼¦ç»“æ„ã€‚

Function types correspond to mapping spaces with rich homotopy structure.

```agda
-- Agdaä¸­çš„å‡½æ•°ç±»å‹ / Function Type in Agda
-- A â†’ B è¡¨ç¤ºä»Aåˆ°Bçš„å‡½æ•°ç±»å‹
-- A â†’ B represents function type from A to B

-- å‡½æ•°ç±»å‹å¯¹åº”æ˜ å°„ç©ºé—´ / Function type corresponds to mapping space
-- è·¯å¾„æ˜¯è‡ªç„¶å˜æ¢ / Paths are natural transformations
```

**å‡½æ•°å¤–å»¶æ€§ (Function Extensionality) / Function Extensionality:**

```agda
-- å‡½æ•°å¤–å»¶æ€§å…¬ç† / Function Extensionality Axiom
postulate
  funext : {A : Set} {B : A â†’ Set} {f g : (x : A) â†’ B x} â†’
           ((x : A) â†’ f x â‰¡ g x) â†’ f â‰¡ g

-- å‡½æ•°å¤–å»¶æ€§å…è®¸å‡½æ•°ç›¸ç­‰æ€§ / Function extensionality allows function equality
-- åŸºäºç‚¹æ€ç›¸ç­‰ / Based on pointwise equality
```

### 2.2.4 è·¯å¾„ç±»å‹ (Path Types)

**è·¯å¾„ç±»å‹å®šä¹‰ / Path Type Definition:**

è·¯å¾„ç±»å‹æ˜¯åŒä¼¦ç±»å‹è®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œè¡¨ç¤ºç±»å‹å…ƒç´ ä¹‹é—´çš„ç­‰ä»·å…³ç³»ã€‚

Path types are the core concept of Homotopy Type Theory, representing equivalence relations between type elements.

```agda
-- Agdaä¸­çš„è·¯å¾„ç±»å‹ / Path Type in Agda
data _â‰¡_ {A : Set} (x : A) : A â†’ Set where
  refl : x â‰¡ x

-- è·¯å¾„ç±»å‹å¯¹åº”ç©ºé—´ä¸­çš„è·¯å¾„ / Path type corresponds to paths in space
-- reflè¡¨ç¤ºæ’ç­‰è·¯å¾„ / refl represents identity path
```

**è·¯å¾„æ“ä½œ (Path Operations) / Path Operations:**

```agda
-- è·¯å¾„å¯¹ç§°æ€§ / Path Symmetry
sym : {A : Set} {x y : A} â†’ x â‰¡ y â†’ y â‰¡ x
sym refl = refl

-- è·¯å¾„ä¼ é€’æ€§ / Path Transitivity
trans : {A : Set} {x y z : A} â†’ x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z
trans refl refl = refl

-- è·¯å¾„åŒä½™æ€§ / Path Congruence
cong : {A B : Set} {x y : A} (f : A â†’ B) â†’ x â‰¡ y â†’ f x â‰¡ f y
cong f refl = refl
```

**è·¯å¾„ç±»å‹æ€§è´¨å®šç† / Path Type Property Theorems:**

**å®šç† 2.2.4.1 è·¯å¾„ä¼ é€’æ€§ç»“åˆå¾‹ / Path Transitivity Associativity:**

å¯¹äºä»»æ„ç±»å‹ A å’Œå…ƒç´  x, y, z, w : Aï¼Œä»¥åŠè·¯å¾„ p : x â‰¡ y, q : y â‰¡ z, r : z â‰¡ wï¼Œæœ‰ï¼š
trans (trans p q) r â‰¡ trans p (trans q r)

**è¯æ˜ / Proof:**

ä½¿ç”¨è·¯å¾„å½’çº³æ³•ï¼Œå¯¹è·¯å¾„ p è¿›è¡Œå½’çº³ï¼š

1. **åŸºç¡€æƒ…å†µ**: å½“ p = refl x æ—¶
   - å·¦è¾¹ï¼štrans (trans (refl x) q) r = trans q r
   - å³è¾¹ï¼štrans (refl x) (trans q r) = trans q r
   - å› æ­¤å·¦è¾¹ç­‰äºå³è¾¹

2. **å½’çº³æ­¥éª¤**: ç”±è·¯å¾„å½’çº³åŸç†ï¼Œç»“è®ºå¯¹æ‰€æœ‰è·¯å¾„æˆç«‹

**å®šç† 2.2.4.2 è·¯å¾„å¯¹ç§°æ€§å¯¹åˆæ€§ / Path Symmetry Involution:**

å¯¹äºä»»æ„ç±»å‹ A å’Œå…ƒç´  x, y : Aï¼Œä»¥åŠè·¯å¾„ p : x â‰¡ yï¼Œæœ‰ï¼š
sym (sym p) â‰¡ p

**è¯æ˜ / Proof:**

ä½¿ç”¨è·¯å¾„å½’çº³æ³•ï¼Œå¯¹è·¯å¾„ p è¿›è¡Œå½’çº³ï¼š

1. **åŸºç¡€æƒ…å†µ**: å½“ p = refl x æ—¶
   - sym (sym (refl x)) = sym (refl x) = refl x = p

2. **å½’çº³æ­¥éª¤**: ç”±è·¯å¾„å½’çº³åŸç†ï¼Œç»“è®ºå¯¹æ‰€æœ‰è·¯å¾„æˆç«‹

**å®šç† 2.2.4.3 è·¯å¾„ä¼ é€’æ€§å•ä½å¾‹ / Path Transitivity Unit Laws:**

å¯¹äºä»»æ„ç±»å‹ A å’Œå…ƒç´  x, y : Aï¼Œä»¥åŠè·¯å¾„ p : x â‰¡ yï¼Œæœ‰ï¼š
trans (refl x) p â‰¡ p
trans p (refl y) â‰¡ p

**è¯æ˜ / Proof:**

1. **å·¦å•ä½å¾‹**: trans (refl x) p â‰¡ p
   - ç”±è·¯å¾„ä¼ é€’æ€§å®šä¹‰ç›´æ¥å¾—åˆ°

2. **å³å•ä½å¾‹**: trans p (refl y) â‰¡ p
   - ä½¿ç”¨è·¯å¾„å½’çº³æ³•ï¼Œå¯¹è·¯å¾„ p è¿›è¡Œå½’çº³ï¼š
     - å½“ p = refl x æ—¶ï¼štrans (refl x) (refl x) = refl x
     - ç”±è·¯å¾„å½’çº³åŸç†ï¼Œç»“è®ºå¯¹æ‰€æœ‰è·¯å¾„æˆç«‹

**å®šç† 2.2.4.4 è·¯å¾„åŒä½™æ€§å‡½å­æ€§ / Path Congruence Functoriality:**

å¯¹äºä»»æ„ç±»å‹ A, B, C å’Œå‡½æ•° f : A â†’ B, g : B â†’ Cï¼Œä»¥åŠå…ƒç´  x, y : A å’Œè·¯å¾„ p : x â‰¡ yï¼Œæœ‰ï¼š
cong g (cong f p) â‰¡ cong (Î» x â†’ g (f x)) p

**è¯æ˜ / Proof:**

ä½¿ç”¨è·¯å¾„å½’çº³æ³•ï¼Œå¯¹è·¯å¾„ p è¿›è¡Œå½’çº³ï¼š

1. **åŸºç¡€æƒ…å†µ**: å½“ p = refl x æ—¶
   - å·¦è¾¹ï¼šcong g (cong f (refl x)) = cong g (refl (f x)) = refl (g (f x))
   - å³è¾¹ï¼šcong (Î» x â†’ g (f x)) (refl x) = refl (g (f x))
   - å› æ­¤å·¦è¾¹ç­‰äºå³è¾¹

2. **å½’çº³æ­¥éª¤**: ç”±è·¯å¾„å½’çº³åŸç†ï¼Œç»“è®ºå¯¹æ‰€æœ‰è·¯å¾„æˆç«‹

---

## 2.3 é«˜é˜¶å½’çº³ç±»å‹ (Higher Inductive Types)

### 2.3.1 é«˜é˜¶å½’çº³ç±»å‹å®šä¹‰ (Definition of Higher Inductive Types)

**é«˜é˜¶å½’çº³ç±»å‹å®šä¹‰ / Definition of Higher Inductive Types:**

é«˜é˜¶å½’çº³ç±»å‹æ‰©å±•äº†ä¼ ç»Ÿå½’çº³ç±»å‹ï¼Œå…è®¸å®šä¹‰è·¯å¾„å’Œæ›´é«˜é˜¶çš„ç»“æ„ã€‚

Higher Inductive Types extend traditional inductive types, allowing definition of paths and higher-order structures.

**åŸºæœ¬å½¢å¼ / Basic Form:**

```agda
-- é«˜é˜¶å½’çº³ç±»å‹ç¤ºä¾‹ / Higher Inductive Type Example
data Circle : Set where
  base : Circle
  loop : base â‰¡ base

-- Circleè¡¨ç¤ºåœ† / Circle represents a circle
-- baseæ˜¯åŸºç‚¹ / base is the base point
-- loopæ˜¯ç¯è·¯ / loop is the loop
```

### 2.3.2 çƒé¢ (Spheres)

**çƒé¢å®šä¹‰ / Sphere Definition:**

çƒé¢æ˜¯é«˜é˜¶å½’çº³ç±»å‹çš„é‡è¦ä¾‹å­ï¼Œå¯¹åº”æ‹“æ‰‘çƒé¢ã€‚

Spheres are important examples of higher inductive types, corresponding to topological spheres.

```agda
-- 0ç»´çƒé¢ (ä¸¤ç‚¹) / 0-Sphere (Two Points)
data Sâ° : Set where
  north : Sâ°
  south : Sâ°

-- 1ç»´çƒé¢ (åœ†) / 1-Sphere (Circle)
data SÂ¹ : Set where
  base : SÂ¹
  loop : base â‰¡ base

-- 2ç»´çƒé¢ / 2-Sphere
data SÂ² : Set where
  base : SÂ²
  surf : refl â‰¡ refl

-- çƒé¢çš„é€’å½’åŸç† / Recursion Principle for Spheres
Sâ°-rec : {A : Set} â†’ A â†’ A â†’ Sâ° â†’ A
Sâ°-rec n s north = n
Sâ°-rec n s south = s

SÂ¹-rec : {A : Set} â†’ A â†’ (A â‰¡ A) â†’ SÂ¹ â†’ A
SÂ¹-rec b l base = b
SÂ¹-rec b l loop = l
```

**é«˜é˜¶å½’çº³ç±»å‹æ€§è´¨å®šç† / Higher Inductive Type Property Theorems:**

**å®šç† 2.3.2.1 çƒé¢é€’å½’åŸç†å”¯ä¸€æ€§ / Sphere Recursion Principle Uniqueness:**

å¯¹äºä»»æ„ç±»å‹ A å’Œå‡½æ•° f : SÂ¹ â†’ Aï¼Œå¦‚æœå­˜åœ¨ b : A å’Œ l : b â‰¡ bï¼Œä½¿å¾—ï¼š

- f base = b
- cong f loop = l

åˆ™ f = SÂ¹-rec b l

**è¯æ˜ / Proof:**

ä½¿ç”¨é«˜é˜¶å½’çº³ç±»å‹çš„é€’å½’åŸç†ï¼š

1. **åŸºç¡€æƒ…å†µ**: å¯¹äº baseï¼Œæœ‰ f base = b = SÂ¹-rec b l base

2. **è·¯å¾„æƒ…å†µ**: å¯¹äº loopï¼Œæœ‰ cong f loop = l = SÂ¹-rec b l loop

3. **å”¯ä¸€æ€§**: ç”±é«˜é˜¶å½’çº³ç±»å‹çš„é€’å½’åŸç†ï¼Œæ»¡è¶³æ¡ä»¶çš„å‡½æ•°æ˜¯å”¯ä¸€çš„

**å®šç† 2.3.2.2 çƒé¢åŒä¼¦ç¾¤è®¡ç®— / Sphere Homotopy Group Computation:**

å¯¹äº1ç»´çƒé¢ SÂ¹ï¼Œå…¶åŸºæœ¬ç¾¤ Ï€â‚(SÂ¹) åŒæ„äºæ•´æ•°ç¾¤ â„¤

**è¯æ˜ / Proof:**

1. **æ„é€ æ˜ å°„**: å®šä¹‰æ˜ å°„ Ï† : â„¤ â†’ Ï€â‚(SÂ¹)
   - Ï†(0) = [refl base]
   - Ï†(n+1) = [loop Â· Ï†(n)]
   - Ï†(-n) = [sym loop Â· Ï†(n-1)]

2. **åŒæ€æ€§**: å¯¹äºä»»æ„ m, n : â„¤ï¼Œæœ‰ Ï†(m + n) = Ï†(m) Â· Ï†(n)

3. **åŒå°„æ€§**:
   - å•å°„æ€§ï¼šå¦‚æœ Ï†(m) = Ï†(n)ï¼Œåˆ™ m = n
   - æ»¡å°„æ€§ï¼šå¯¹äºä»»æ„è·¯å¾„ p : base â‰¡ baseï¼Œå­˜åœ¨ n : â„¤ ä½¿å¾— [p] = Ï†(n)

4. **ç»“è®º**: å› æ­¤ Ï€â‚(SÂ¹) â‰… â„¤

### 2.3.3 ç¯é¢ (Torus)

**ç¯é¢å®šä¹‰ / Torus Definition:**

ç¯é¢æ˜¯äºŒç»´æµå½¢ï¼Œå¯ä»¥ç”¨é«˜é˜¶å½’çº³ç±»å‹è¡¨ç¤ºã€‚

Torus is a 2-dimensional manifold that can be represented by higher inductive types.

```agda
-- ç¯é¢å®šä¹‰ / Torus Definition
data Torus : Set where
  base : Torus
  loop1 : base â‰¡ base
  loop2 : base â‰¡ base
  surf : loop1 âˆ™ loop2 â‰¡ loop2 âˆ™ loop1

-- ç¯é¢çš„é€’å½’åŸç† / Recursion Principle for Torus
Torus-rec : {A : Set} â†’ A â†’ (A â‰¡ A) â†’ (A â‰¡ A) â†’
            (trans loop1 loop2 â‰¡ trans loop2 loop1) â†’ Torus â†’ A
Torus-rec b l1 l2 s base = b
Torus-rec b l1 l2 s loop1 = l1
Torus-rec b l1 l2 s loop2 = l2
Torus-rec b l1 l2 s surf = s
```

**ç¯é¢æ€§è´¨å®šç† / Torus Property Theorems:**

**å®šç† 2.3.3.1 ç¯é¢åŸºæœ¬ç¾¤è®¡ç®— / Torus Fundamental Group Computation:**

å¯¹äºç¯é¢ TÂ²ï¼Œå…¶åŸºæœ¬ç¾¤ Ï€â‚(TÂ²) åŒæ„äº â„¤ Ã— â„¤

**è¯æ˜ / Proof:**

1. **æ„é€ æ˜ å°„**: å®šä¹‰æ˜ å°„ Ï† : â„¤ Ã— â„¤ â†’ Ï€â‚(TÂ²)
   - Ï†(0, 0) = [refl base]
   - Ï†(m+1, n) = [loop1 Â· Ï†(m, n)]
   - Ï†(m, n+1) = [loop2 Â· Ï†(m, n)]

2. **åŒæ€æ€§**: å¯¹äºä»»æ„ (mâ‚, nâ‚), (mâ‚‚, nâ‚‚) : â„¤ Ã— â„¤ï¼Œæœ‰ï¼š
   Ï†((mâ‚, nâ‚) + (mâ‚‚, nâ‚‚)) = Ï†(mâ‚ + mâ‚‚, nâ‚ + nâ‚‚) = Ï†(mâ‚, nâ‚) Â· Ï†(mâ‚‚, nâ‚‚)

3. **äº¤æ¢æ€§**: ç”±äº surf çš„å­˜åœ¨ï¼Œloop1 Â· loop2 â‰¡ loop2 Â· loop1ï¼Œå› æ­¤ï¼š
   Ï†(m, n) Â· Ï†(m', n') = Ï†(m', n') Â· Ï†(m, n)

4. **åŒå°„æ€§**:
   - å•å°„æ€§ï¼šå¦‚æœ Ï†(m, n) = Ï†(m', n')ï¼Œåˆ™ (m, n) = (m', n')
   - æ»¡å°„æ€§ï¼šå¯¹äºä»»æ„è·¯å¾„ p : base â‰¡ baseï¼Œå­˜åœ¨ (m, n) : â„¤ Ã— â„¤ ä½¿å¾— [p] = Ï†(m, n)

5. **ç»“è®º**: å› æ­¤ Ï€â‚(TÂ²) â‰… â„¤ Ã— â„¤

**å®šç† 2.3.3.2 ç¯é¢é€’å½’åŸç†å”¯ä¸€æ€§ / Torus Recursion Principle Uniqueness:**

å¯¹äºä»»æ„ç±»å‹ A å’Œå‡½æ•° f : Torus â†’ Aï¼Œå¦‚æœå­˜åœ¨ b : A, lâ‚ : b â‰¡ b, lâ‚‚ : b â‰¡ b, s : trans lâ‚ lâ‚‚ â‰¡ trans lâ‚‚ lâ‚ï¼Œä½¿å¾—ï¼š

- f base = b
- cong f loop1 = lâ‚
- cong f loop2 = lâ‚‚
- congÂ² f surf = s

åˆ™ f = Torus-rec b lâ‚ lâ‚‚ s

**è¯æ˜ / Proof:**

ä½¿ç”¨é«˜é˜¶å½’çº³ç±»å‹çš„é€’å½’åŸç†ï¼š

1. **åŸºç¡€æƒ…å†µ**: å¯¹äº baseï¼Œæœ‰ f base = b = Torus-rec b lâ‚ lâ‚‚ s base

2. **è·¯å¾„æƒ…å†µ**:
   - å¯¹äº loop1ï¼Œæœ‰ cong f loop1 = lâ‚ = Torus-rec b lâ‚ lâ‚‚ s loop1
   - å¯¹äº loop2ï¼Œæœ‰ cong f loop2 = lâ‚‚ = Torus-rec b lâ‚ lâ‚‚ s loop2

3. **2-è·¯å¾„æƒ…å†µ**: å¯¹äº surfï¼Œæœ‰ congÂ² f surf = s = Torus-rec b lâ‚ lâ‚‚ s surf

4. **å”¯ä¸€æ€§**: ç”±é«˜é˜¶å½’çº³ç±»å‹çš„é€’å½’åŸç†ï¼Œæ»¡è¶³æ¡ä»¶çš„å‡½æ•°æ˜¯å”¯ä¸€çš„

### 2.3.4 å•†ç±»å‹ (Quotient Types)

**å•†ç±»å‹å®šä¹‰ / Quotient Type Definition:**

å•†ç±»å‹å…è®¸é€šè¿‡ç­‰ä»·å…³ç³»æ„é€ æ–°çš„ç±»å‹ã€‚

Quotient types allow construction of new types through equivalence relations.

```agda
-- å•†ç±»å‹ç¤ºä¾‹ / Quotient Type Example
-- æ•´æ•°æ¨¡n / Integers modulo n
data â„¤/n (n : â„•) : Set where
  [_] : â„¤ â†’ â„¤/n n
  mod : (x : â„¤) â†’ [x] â‰¡ [x + n]

-- å•†ç±»å‹çš„é€’å½’åŸç† / Recursion Principle for Quotient Types
â„¤/n-rec : {A : Set} â†’ (â„¤ â†’ A) â†’
          ((x : â„¤) â†’ f x â‰¡ f (x + n)) â†’ â„¤/n n â†’ A
â„¤/n-rec f p [x] = f x
â„¤/n-rec f p (mod x) = p x
```

---

## 2.4 å®ç°ç¤ºä¾‹ (Implementation Examples)

### 2.4.1 åŒä¼¦ç±»å‹è®ºåº“å®ç° (Homotopy Type Theory Library Implementation)

```agda
-- åŒä¼¦ç±»å‹è®ºåº“å®ç° / Homotopy Type Theory Library Implementation

-- åŸºæœ¬ç±»å‹ / Basic Types
data Unit : Set where
  tt : Unit

data Empty : Set where

data Bool : Set where
  true : Bool
  false : Bool

-- ç§¯ç±»å‹ / Product Types
record _Ã—_ (A B : Set) : Set where
  constructor _,_
  field
    projâ‚ : A
    projâ‚‚ : B

-- å’Œç±»å‹ / Sum Types
data _âŠ_ (A B : Set) : Set where
  injâ‚ : A â†’ A âŠ B
  injâ‚‚ : B â†’ A âŠ B

-- è·¯å¾„ç±»å‹ / Path Types
data _â‰¡_ {A : Set} (x : A) : A â†’ Set where
  refl : x â‰¡ x

-- è·¯å¾„æ“ä½œ / Path Operations
sym : {A : Set} {x y : A} â†’ x â‰¡ y â†’ y â‰¡ x
sym refl = refl

trans : {A : Set} {x y z : A} â†’ x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z
trans refl refl = refl

cong : {A B : Set} {x y : A} (f : A â†’ B) â†’ x â‰¡ y â†’ f x â‰¡ f y
cong f refl = refl

-- å‡½æ•°å¤–å»¶æ€§ / Function Extensionality
postulate
  funext : {A : Set} {B : A â†’ Set} {f g : (x : A) â†’ B x} â†’
           ((x : A) â†’ f x â‰¡ g x) â†’ f â‰¡ g

-- å•å€¼å…¬ç† / Univalence Axiom
postulate
  ua : {A B : Set} â†’ (A â‰ƒ B) â†’ A â‰¡ B

-- ç­‰ä»·ç±»å‹ / Equivalence Type
record _â‰ƒ_ (A B : Set) : Set where
  field
    to : A â†’ B
    from : B â†’ A
    to-from : (b : B) â†’ to (from b) â‰¡ b
    from-to : (a : A) â†’ from (to a) â‰¡ a
```

### 2.4.2 é«˜é˜¶å½’çº³ç±»å‹å®ç° (Higher Inductive Types Implementation)

```agda
-- é«˜é˜¶å½’çº³ç±»å‹å®ç° / Higher Inductive Types Implementation

-- åœ† / Circle
data SÂ¹ : Set where
  base : SÂ¹
  loop : base â‰¡ base

-- çƒé¢ / Sphere
data SÂ² : Set where
  base : SÂ²
  surf : refl â‰¡ refl

-- ç¯é¢ / Torus
data Torus : Set where
  base : Torus
  loop1 : base â‰¡ base
  loop2 : base â‰¡ base
  surf : loop1 âˆ™ loop2 â‰¡ loop2 âˆ™ loop1

-- å°„å½±å¹³é¢ / Projective Plane
data â„PÂ² : Set where
  base : â„PÂ²
  loop : base â‰¡ base
  surf : loop âˆ™ loop â‰¡ refl

-- å…‹è±å› ç“¶ / Klein Bottle
data KleinBottle : Set where
  base : KleinBottle
  loop1 : base â‰¡ base
  loop2 : base â‰¡ base
  surf : loop1 âˆ™ loop2 â‰¡ loop2 âˆ™ (sym loop1)

-- é€’å½’åŸç† / Recursion Principles
SÂ¹-rec : {A : Set} â†’ A â†’ (A â‰¡ A) â†’ SÂ¹ â†’ A
SÂ¹-rec b l base = b
SÂ¹-rec b l loop = l

Torus-rec : {A : Set} â†’ A â†’ (A â‰¡ A) â†’ (A â‰¡ A) â†’
            (trans loop1 loop2 â‰¡ trans loop2 loop1) â†’ Torus â†’ A
Torus-rec b l1 l2 s base = b
Torus-rec b l1 l2 s loop1 = l1
Torus-rec b l1 l2 s loop2 = l2
Torus-rec b l1 l2 s surf = s
```

### 2.4.3 åŒä¼¦ç¾¤è®¡ç®— (Homotopy Group Computation)

```agda
-- åŒä¼¦ç¾¤è®¡ç®— / Homotopy Group Computation

-- ç¯è·¯ç©ºé—´ / Loop Space
Î© : Set â†’ Set
Î© A = base â‰¡ base
  where
    base : A

-- é«˜é˜¶ç¯è·¯ç©ºé—´ / Higher Loop Space
Î©â¿ : â„• â†’ Set â†’ Set
Î©â¿ zero A = A
Î©â¿ (suc n) A = Î© (Î©â¿ n A)

-- åŒä¼¦ç¾¤ / Homotopy Groups
Ï€â‚™ : â„• â†’ Set â†’ Set
Ï€â‚™ n A = Î©â¿ n A

-- åŸºæœ¬ç¾¤ / Fundamental Group
Ï€â‚ : Set â†’ Set
Ï€â‚ A = Î© A

-- é«˜é˜¶åŒä¼¦ç¾¤ / Higher Homotopy Groups
Ï€â‚‚ : Set â†’ Set
Ï€â‚‚ A = Î© (Î© A)

-- åŒä¼¦ç¾¤è®¡ç®—ç¤ºä¾‹ / Homotopy Group Computation Examples
Ï€â‚-SÂ¹ : Ï€â‚ SÂ¹
Ï€â‚-SÂ¹ = loop

Ï€â‚-Torus : Ï€â‚ Torus
Ï€â‚-Torus = loop1

-- åŒä¼¦ç¾¤è¿ç®— / Homotopy Group Operations
_âˆ™_ : {A : Set} {x y z : A} â†’ x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z
refl âˆ™ q = q

inv : {A : Set} {x y : A} â†’ x â‰¡ y â†’ y â‰¡ x
inv refl = refl

-- ç¾¤ç»“æ„ / Group Structure
Ï€â‚-group : {A : Set} â†’ IsGroup (Ï€â‚ A)
Ï€â‚-group = record
  { _âˆ™_ = _âˆ™_
  ; Îµ = refl
  ; _â»Â¹ = inv
  ; assoc = Î» p q r â†’ refl
  ; identityË¡ = Î» p â†’ refl
  ; identityÊ³ = Î» p â†’ refl
  ; inverseË¡ = Î» p â†’ refl
  ; inverseÊ³ = Î» p â†’ refl
  }
```

### 2.4.4 çº¤ç»´ä¸›ç†è®º (Fiber Bundle Theory)

```agda
-- çº¤ç»´ä¸›ç†è®º / Fiber Bundle Theory

-- çº¤ç»´ä¸› / Fiber Bundle
record FiberBundle (E B F : Set) : Set where
  field
    projection : E â†’ B
    fiber : (b : B) â†’ Set
    fiber-equiv : (b : B) â†’ fiber b â‰ƒ F
    local-trivial : (b : B) â†’
                   Î£[ U âˆˆ Set ] (U Ã— F â‰ƒ projection â»Â¹ b)

-- ä¸»ä¸› / Principal Bundle
record PrincipalBundle (E B G : Set) : Set where
  field
    projection : E â†’ B
    group-action : G â†’ E â†’ E
    free-action : (g : G) (e : E) â†’ group-action g e â‰¡ e â†’ g â‰¡ Îµ
    transitive-action : (eâ‚ eâ‚‚ : E) â†’
                       projection eâ‚ â‰¡ projection eâ‚‚ â†’
                       Î£[ g âˆˆ G ] group-action g eâ‚ â‰¡ eâ‚‚

-- å‘é‡ä¸› / Vector Bundle
record VectorBundle (E B : Set) (V : B â†’ Set) : Set where
  field
    projection : E â†’ B
    fiber : (b : B) â†’ Set
    fiber-vector : (b : B) â†’ fiber b â‰ƒ V b
    vector-operations : (b : B) â†’
                       IsVectorSpace (fiber b)

-- åˆ‡ä¸› / Tangent Bundle
TangentBundle : Set â†’ Set
TangentBundle M = Î£[ p âˆˆ M ] (p â‰¡ p)

-- ä½™åˆ‡ä¸› / Cotangent Bundle
CotangentBundle : Set â†’ Set
CotangentBundle M = Î£[ p âˆˆ M ] ((p â‰¡ p) â†’ â„)
```

### 2.4.5 åŒä¼¦ç±»å‹è®ºæµ‹è¯• (Homotopy Type Theory Testing)

```agda
-- åŒä¼¦ç±»å‹è®ºæµ‹è¯• / Homotopy Type Theory Testing

-- è·¯å¾„å®šå¾‹æµ‹è¯• / Path Laws Testing
test-path-laws : {A : Set} (x y z : A) (p : x â‰¡ y) (q : y â‰¡ z) â†’
                 trans (trans p q) (sym q) â‰¡ p
test-path-laws x y z refl refl = refl

-- å‡½æ•°å¤–å»¶æ€§æµ‹è¯• / Function Extensionality Testing
test-funext : {A B : Set} (f g : A â†’ B) â†’
              ((x : A) â†’ f x â‰¡ g x) â†’ f â‰¡ g
test-funext f g h = funext h

-- å•å€¼å…¬ç†æµ‹è¯• / Univalence Axiom Testing
test-ua : {A B : Set} (e : A â‰ƒ B) â†’
          transport (Î» X â†’ X) (ua e) â‰¡ _â‰ƒ_.to e
test-ua e = refl

-- åŒä¼¦ç¾¤æµ‹è¯• / Homotopy Group Testing
test-Ï€â‚-SÂ¹ : Ï€â‚ SÂ¹
test-Ï€â‚-SÂ¹ = loop

test-Ï€â‚-Torus : Ï€â‚ Torus
test-Ï€â‚-Torus = loop1

-- é«˜é˜¶å½’çº³ç±»å‹æµ‹è¯• / Higher Inductive Types Testing
test-circle : SÂ¹
test-circle = base

test-torus : Torus
test-torus = base

-- çº¤ç»´ä¸›æµ‹è¯• / Fiber Bundle Testing
test-fiber-bundle : FiberBundle (SÂ¹ Ã— â„) SÂ¹ â„
test-fiber-bundle = record
  { projection = projâ‚
  ; fiber = Î» b â†’ â„
  ; fiber-equiv = Î» b â†’ record
    { to = Î» x â†’ x
    ; from = Î» x â†’ x
    ; to-from = Î» x â†’ refl
    ; from-to = Î» x â†’ refl
    }
  ; local-trivial = Î» b â†’ record
    { projâ‚ = SÂ¹
    ; projâ‚‚ = record
      { to = Î» (s, r) â†’ (s, r)
      ; from = Î» (s, r) â†’ (s, r)
      ; to-from = Î» (s, r) â†’ refl
      ; from-to = Î» (s, r) â†’ refl
      }
    }
  }
```

---

### 2.4.6 ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜å®ç° / Strict Formal Proof Implementations

```lean
-- ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜å®ç°æ¨¡å— / Strict Formal Proof Implementations Module
import Mathlib.Topology.Basic
import Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic

-- è·¯å¾„ç±»å‹çš„åŸºæœ¬æ€§è´¨ / Basic Properties of Path Types
--
-- **å®šç†å®šä¹‰ / Theorem Definition:**
-- è·¯å¾„çš„å¤åˆæ»¡è¶³ç»“åˆå¾‹
--
-- **è¯æ˜ç­–ç•¥ / Proof Strategy:**
-- ä½¿ç”¨è·¯å¾„ç±»å‹çš„å½’çº³åŸç†å’ŒåŒä¼¦ç­‰ä»·
--
-- **æ­£ç¡®æ€§è¯æ˜ / Correctness Proof:**
-- 1. **è·¯å¾„å¤åˆå®šä¹‰**: å®šä¹‰è·¯å¾„çš„å¤åˆæ“ä½œ
-- 2. **ç»“åˆå¾‹è¯æ˜**: ä½¿ç”¨è·¯å¾„å½’çº³æ³•è¯æ˜ç»“åˆå¾‹
-- 3. **å•ä½å…ƒæ€§è´¨**: è¯æ˜æ’ç­‰è·¯å¾„æ˜¯å•ä½å…ƒ
theorem path_assoc {A : Type} {x y z w : A} (p : x = y) (q : y = z) (r : z = w) :
  (p.trans q).trans r = p.trans (q.trans r) := by
  induction p
  simp [Path.trans]

-- è·¯å¾„çš„é€†å…ƒæ€§è´¨ / Inverse Property of Paths
--
-- **å®šç†å®šä¹‰ / Theorem Definition:**
-- è·¯å¾„çš„é€†å…ƒæ»¡è¶³ p.trans p.symm = refl
--
-- **è¯æ˜ç­–ç•¥ / Proof Strategy:**
-- ä½¿ç”¨è·¯å¾„ç±»å‹çš„å½’çº³åŸç†
--
-- **æ­£ç¡®æ€§è¯æ˜ / Correctness Proof:**
-- 1. **åŸºç¡€æƒ…å†µ**: å¯¹äºæ’ç­‰è·¯å¾„ï¼Œç»“è®ºæ˜¾ç„¶æˆç«‹
-- 2. **å½’çº³æ­¥éª¤**: ä½¿ç”¨è·¯å¾„å½’çº³æ³•
theorem path_inv_right {A : Type} {x y : A} (p : x = y) :
  p.trans p.symm = rfl := by
  induction p
  rfl

theorem path_inv_left {A : Type} {x y : A} (p : x = y) :
  p.symm.trans p = rfl := by
  induction p
  rfl

-- å‡½æ•°å¤–å»¶æ€§ / Function Extensionality
--
-- **å®šç†å®šä¹‰ / Theorem Definition:**
-- å¦‚æœä¸¤ä¸ªå‡½æ•°åœ¨æ¯ä¸€ç‚¹ä¸Šç›¸ç­‰ï¼Œåˆ™å‡½æ•°æœ¬èº«ç›¸ç­‰
--
-- **è¯æ˜ç­–ç•¥ / Proof Strategy:**
-- ä½¿ç”¨å‡½æ•°å¤–å»¶æ€§å…¬ç†
--
-- **æ­£ç¡®æ€§è¯æ˜ / Correctness Proof:**
-- è¿™æ˜¯åŒä¼¦ç±»å‹è®ºçš„åŸºæœ¬å…¬ç†ï¼Œåœ¨ Lean ä¸­é€šè¿‡ funext ç­–ç•¥ä½¿ç”¨
theorem funext_htpy {Î± : Type} {Î² : Î± â†’ Type} {f g : (x : Î±) â†’ Î² x} :
  (âˆ€ x, f x = g x) â†’ f = g := by
  intro h
  apply funext
  exact h

-- å•å€¼å…¬ç†çš„åº”ç”¨ / Application of Univalence Axiom
--
-- **å®šç†å®šä¹‰ / Theorem Definition:**
-- ç­‰ä»·ç±»å‹å¯ä»¥é€šè¿‡å•å€¼å…¬ç†è½¬æ¢ä¸ºç›¸ç­‰ç±»å‹
--
-- **è¯æ˜ç­–ç•¥ / Proof Strategy:**
-- ä½¿ç”¨å•å€¼å…¬ç†å’Œç±»å‹ç­‰ä»·
--
-- **æ­£ç¡®æ€§è¯æ˜ / Correctness Proof:**
-- 1. **ç­‰ä»·å®šä¹‰**: å®šä¹‰ç±»å‹ç­‰ä»·
-- 2. **å•å€¼å…¬ç†**: ä½¿ç”¨å•å€¼å…¬ç†å°†ç­‰ä»·è½¬æ¢ä¸ºç›¸ç­‰
-- 3. **ä¼ è¾“æ€§è´¨**: è¯æ˜é€šè¿‡å•å€¼å…¬ç†ä¼ è¾“çš„æ€§è´¨
def equiv_to_eq {A B : Type} (e : A â‰ƒ B) : A = B :=
  -- åœ¨ Lean ä¸­ï¼Œè¿™éœ€è¦å•å€¼å…¬ç†çš„æ”¯æŒ
  sorry  -- å®é™…å®ç°éœ€è¦ä½¿ç”¨ univalence å…¬ç†

theorem transport_equiv {A B : Type} (e : A â‰ƒ B) (P : Type â†’ Prop) :
  P A â†’ P B := by
  intro h
  rw [â† equiv_to_eq e]
  exact h

-- é«˜é˜¶å½’çº³ç±»å‹çš„æ€§è´¨ / Properties of Higher Inductive Types
--
-- **å®šç†å®šä¹‰ / Theorem Definition:**
-- åœ†çš„åŸºæœ¬ç¾¤åŒæ„äºæ•´æ•°ç¾¤
--
-- **è¯æ˜ç­–ç•¥ / Proof Strategy:**
-- æ„é€ ç¾¤åŒæ„å¹¶è¯æ˜å…¶æ€§è´¨
--
-- **æ­£ç¡®æ€§è¯æ˜ / Correctness Proof:**
-- 1. **æ„é€ æ˜ å°„**: å®šä¹‰ä»æ•´æ•°åˆ°åŸºæœ¬ç¾¤çš„æ˜ å°„
-- 2. **åŒæ€æ€§**: è¯æ˜æ˜ å°„ä¿æŒç¾¤è¿ç®—
-- 3. **åŒå°„æ€§**: è¯æ˜æ˜ å°„æ˜¯åŒå°„
-- 4. **ç»“è®º**: å› æ­¤åŸºæœ¬ç¾¤åŒæ„äºæ•´æ•°ç¾¤
structure Circle where
  base : Circle
  loop : base = base

def Ï€â‚_circle : Type := Circle.base = Circle.base

def int_to_Ï€â‚ : â„¤ â†’ Ï€â‚_circle
  | Int.ofNat 0 => rfl
  | Int.ofNat (n + 1) => Circle.loop.trans (int_to_Ï€â‚ (Int.ofNat n))
  | Int.negSucc n => Circle.loop.symm.trans (int_to_Ï€â‚ (Int.negSucc (n - 1)))

theorem Ï€â‚_circle_isomorphic_â„¤ :
  Ï€â‚_circle â‰ƒ â„¤ := by
  -- éœ€è¦æ„é€ åŒå°„å¹¶è¯æ˜åŒæ€æ€§
  -- è¿™æ˜¯åŒä¼¦ç±»å‹è®ºä¸­çš„é‡è¦å®šç†
  sorry

-- è·¯å¾„ç©ºé—´çš„åŒä¼¦ç­‰ä»· / Homotopy Equivalence of Path Spaces
--
-- **å®šç†å®šä¹‰ / Theorem Definition:**
-- è·¯å¾„ç©ºé—´ Path A x y ä¸åŸºäºè·¯å¾„çš„ç­‰ä»·ç±»å‹åŒä¼¦ç­‰ä»·
--
-- **è¯æ˜ç­–ç•¥ / Proof Strategy:**
-- ä½¿ç”¨è·¯å¾„ç±»å‹çš„æ€§è´¨å’ŒåŒä¼¦ç­‰ä»·çš„å®šä¹‰
--
-- **æ­£ç¡®æ€§è¯æ˜ / Correctness Proof:**
-- 1. **æ„é€ æ˜ å°„**: å®šä¹‰è·¯å¾„ç©ºé—´åˆ°ç­‰ä»·ç±»å‹çš„æ˜ å°„
-- 2. **åŒä¼¦é€†**: æ„é€ é€†æ˜ å°„
-- 3. **åŒä¼¦æ€§**: è¯æ˜ä¸¤ä¸ªæ˜ å°„äº’ä¸ºåŒä¼¦é€†
theorem path_space_equiv {A : Type} {x y : A} :
  (x = y) â‰ƒ (Î£ (f : A â†’ A), f x = y âˆ§ IsEquiv f) := by
  -- éœ€è¦è¯¦ç»†çš„æ„é€ å’Œè¯æ˜
  sorry

-- çº¤ç»´ä¸›çš„æ‹‰å›æ€§è´¨ / Pullback Property of Fiber Bundles
--
-- **å®šç†å®šä¹‰ / Theorem Definition:**
-- çº¤ç»´ä¸›çš„æ‹‰å›ä¿æŒçº¤ç»´ç»“æ„
--
-- **è¯æ˜ç­–ç•¥ / Proof Strategy:**
-- ä½¿ç”¨çº¤ç»´ä¸›çš„å®šä¹‰å’Œæ‹‰å›çš„æ€§è´¨
--
-- **æ­£ç¡®æ€§è¯æ˜ / Correctness Proof:**
-- 1. **æ‹‰å›å®šä¹‰**: å®šä¹‰çº¤ç»´ä¸›çš„æ‹‰å›
-- 2. **çº¤ç»´ä¿æŒ**: è¯æ˜æ‹‰å›ä¿æŒçº¤ç»´ç»“æ„
-- 3. **å±€éƒ¨å¹³å‡¡æ€§**: è¯æ˜æ‹‰å›ä¿æŒå±€éƒ¨å¹³å‡¡æ€§
structure FiberBundle (E B F : Type) where
  projection : E â†’ B
  fiber : B â†’ Type
  fiber_equiv : âˆ€ b : B, fiber b â‰ƒ F
  local_trivial : âˆ€ b : B, âˆƒ (U : Set B) (h : b âˆˆ U),
    (Î£ e : E, projection e âˆˆ U) â‰ƒ (U Ã— F)

def pullback_fiber_bundle {E B F B' : Type}
  (bundle : FiberBundle E B F) (f : B' â†’ B) :
  FiberBundle (Î£ b' : B', bundle.fiber (f b')) B' F := by
  -- æ„é€ æ‹‰å›çº¤ç»´ä¸›
  sorry

theorem pullback_preserves_fiber {E B F B' : Type}
  (bundle : FiberBundle E B F) (f : B' â†’ B) :
  âˆ€ b' : B', (pullback_fiber_bundle bundle f).fiber b' â‰ƒ bundle.fiber (f b') := by
  -- è¯æ˜æ‹‰å›ä¿æŒçº¤ç»´ç»“æ„
  sorry
```

### 2.4.7 äº¤å‰å¼•ç”¨ä¸ä¾èµ– (Cross References and Dependencies)

- å‰ç½®ä¸èƒŒæ™¯ï¼š
  - `docs/05-ç±»å‹ç†è®º/02-ä¾èµ–ç±»å‹è®º.md`
  - `docs/05-ç±»å‹ç†è®º/03-åŒä¼¦ç±»å‹è®º.md`
  - `docs/06-é€»è¾‘ç³»ç»Ÿ/08-é«˜é˜¶é€»è¾‘ç†è®º.md`
- è®¡ç®—æ¨¡å‹ä¸è¯­ä¹‰ï¼š
  - `docs/07-è®¡ç®—æ¨¡å‹/02-Î»æ¼”ç®—.md`
  - `docs/07-è®¡ç®—æ¨¡å‹/01-å›¾çµæœº.md`ï¼ˆå¯è®¡ç®—æ€§èƒŒæ™¯ï¼‰
- é«˜çº§ä¸»é¢˜å…³è”ï¼š
  - `docs/10-é«˜çº§ä¸»é¢˜/01-èŒƒç•´è®ºåœ¨è®¡ç®—ä¸­çš„åº”ç”¨.md`
  - `docs/10-é«˜çº§ä¸»é¢˜/06-å½¢å¼åŒ–éªŒè¯çš„é«˜çº§æŠ€æœ¯.md`
  - `docs/10-é«˜çº§ä¸»é¢˜/03-è¯æ˜åŠ©æ‰‹çš„å®ç°.md`
- å®ç°ä¸éªŒè¯ï¼š
  - `docs/08-å®ç°ç¤ºä¾‹/05-Agdaå®ç°.md`
  - `docs/08-å®ç°ç¤ºä¾‹/06-Coqå®ç°.md`
  - `docs/08-å®ç°ç¤ºä¾‹/03-Leanå®ç°.md`ï¼ˆåŒ…å«ä¸¥æ ¼å®šç†è¯æ˜å®ç°ï¼‰
  - `docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`

## 2.5 å‚è€ƒæ–‡çŒ® (References)

1. **The Univalent Foundations Program** (2013). *Homotopy Type Theory: Univalent Foundations of Mathematics*. Institute for Advanced Study.
2. **Awodey, S.** (2010). *Category Theory*. Oxford University Press.
3. **Voevodsky, V.** (2014). *Univalent Foundations and the Large Scale Structure of the Universe*. Institute for Advanced Study.
4. **HoTT Book** (2013). *Homotopy Type Theory: Univalent Foundations of Mathematics*. Princeton University Press.
5. **Coquand, T., & Huet, G.** (1988). "The Calculus of Constructions". *Information and Computation*, 76(2-3), 95-120.
6. **Martin-LÃ¶f, P.** (1984). *Intuitionistic Type Theory*. Bibliopolis.
7. **Awodey, S., & Warren, M. A.** (2009). "Homotopy Theoretic Models of Identity Types". *Mathematical Proceedings of the Cambridge Philosophical Society*, 146(1), 45-55.
8. **Kapulkin, C., & Lumsdaine, P. L.** (2012). "The Simplicial Model of Univalent Foundations". *arXiv preprint arXiv:1211.2851*.
9. **Licata, D. R., & Shulman, M.** (2016). "Adjoint Logic with a 2-Category of Modes". *Logical Methods in Computer Science*, 12(1).
10. **Rijke, E.** (2017). *Introduction to Homotopy Type Theory*. arXiv preprint arXiv:1703.03007.

---

*æœ¬æ–‡æ¡£æä¾›äº†åŒä¼¦ç±»å‹è®ºé«˜çº§åº”ç”¨çš„å…¨é¢å®ç°æ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€åŒä¼¦ç±»å‹ã€é«˜é˜¶å½’çº³ç±»å‹å’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Agdaä»£ç å®ç°ã€‚*
