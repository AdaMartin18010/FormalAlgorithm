---
title: 10.9 é‡å­ä¿¡æ¯è®ºä¸é‡å­ç¼–ç  / Quantum Information Theory and Quantum Coding
version: 1.0
status: maintained
last_updated: 2025-01-11
owner: é«˜çº§ä¸»é¢˜å·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 10.9 é‡å­ä¿¡æ¯è®ºä¸é‡å­ç¼–ç  / Quantum Information Theory and Quantum Coding

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€é‡å­ä¿¡æ¯è®ºä¸é‡å­ç¼–ç çš„ç†è®ºæ¡†æ¶ï¼Œå»ºç«‹é‡å­ä¿¡æ¯å¤„ç†ä¸ç¼–ç æŠ€æœ¯ã€‚
- å»ºç«‹é‡å­ç¼–ç åœ¨é‡å­é€šä¿¡ä¸­çš„æ ¸å¿ƒåœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- é‡å­ä¿¡æ¯è®ºã€é‡å­ç¼–ç ã€é‡å­çº é”™ç ã€é‡å­ä¿¡é“ã€é‡å­å®¹é‡ã€é‡å­çº ç¼ ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- é‡å­ä¿¡æ¯è®ºï¼ˆQuantum Information Theoryï¼‰ï¼šç ”ç©¶é‡å­ç³»ç»Ÿä¸­ä¿¡æ¯çš„ç†è®ºã€‚
- é‡å­ç¼–ç ï¼ˆQuantum Codingï¼‰ï¼šåœ¨é‡å­ç³»ç»Ÿä¸­ç¼–ç ä¿¡æ¯çš„æ–¹æ³•ã€‚
- é‡å­çº é”™ç ï¼ˆQuantum Error-Correcting Codeï¼‰ï¼šçº æ­£é‡å­é”™è¯¯çš„ç¼–ç ã€‚
- é‡å­ä¿¡é“ï¼ˆQuantum Channelï¼‰ï¼šä¼ è¾“é‡å­ä¿¡æ¯çš„é€šé“ã€‚
- è®°å·çº¦å®šï¼š`|ÏˆâŸ©` è¡¨ç¤ºé‡å­æ€ï¼Œ`E` è¡¨ç¤ºé”™è¯¯ç®—å­ï¼Œ`C` è¡¨ç¤ºç¼–ç ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- é‡å­ä¿¡æ¯è®ºï¼šå‚è§ `10-é«˜çº§ä¸»é¢˜/04-é‡å­ä¿¡æ¯è®º.md`ã€‚
- é‡å­è®¡ç®—æ¨¡å‹ï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/05-é‡å­è®¡ç®—æ¨¡å‹.md`ã€‚
- é‡å­é”™è¯¯çº æ­£ï¼šå‚è§ `10-é«˜çº§ä¸»é¢˜/17-é‡å­é”™è¯¯çº æ­£ç†è®º.md`ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- é‡å­ç¼–ç 
- é‡å­çº é”™

## ç›®å½• / Table of Contents

- [10.9 é‡å­ä¿¡æ¯è®ºä¸é‡å­ç¼–ç  / Quantum Information Theory and Quantum Coding](#109-é‡å­ä¿¡æ¯è®ºä¸é‡å­ç¼–ç --quantum-information-theory-and-quantum-coding)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)
- [åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [é‡å­ä¿¡æ¯è®ºå®šä¹‰ / Definition of Quantum Information Theory](#é‡å­ä¿¡æ¯è®ºå®šä¹‰--definition-of-quantum-information-theory)
  - [é‡å­ä¿¡æ¯å¤„ç†åŸç† / Principles of Quantum Information Processing](#é‡å­ä¿¡æ¯å¤„ç†åŸç†--principles-of-quantum-information-processing)
- [é‡å­ç†µç†è®º / Quantum Entropy Theory](#é‡å­ç†µç†è®º--quantum-entropy-theory)
  - [å†¯Â·è¯ºä¾æ›¼ç†µ / Von Neumann Entropy](#å†¯è¯ºä¾æ›¼ç†µ--von-neumann-entropy)
  - [ç›¸å¯¹ç†µ / Relative Entropy](#ç›¸å¯¹ç†µ--relative-entropy)
- [é‡å­ä¿¡é“ç†è®º / Quantum Channel Theory](#é‡å­ä¿¡é“ç†è®º--quantum-channel-theory)
  - [é‡å­ä¿¡é“å®šä¹‰ / Definition of Quantum Channels](#é‡å­ä¿¡é“å®šä¹‰--definition-of-quantum-channels)
- [é‡å­çº ç¼ ç†è®º / Quantum Entanglement Theory](#é‡å­çº ç¼ ç†è®º--quantum-entanglement-theory)
  - [çº ç¼ å®šä¹‰ä¸åŸºæœ¬æ€§è´¨ / Definition and Basic Properties of Entanglement](#çº ç¼ å®šä¹‰ä¸åŸºæœ¬æ€§è´¨--definition-and-basic-properties-of-entanglement)
  - [çº ç¼ åº¦é‡ / Entanglement Measures](#çº ç¼ åº¦é‡--entanglement-measures)
- [é‡å­ç¼–ç ç†è®º / Quantum Coding Theory](#é‡å­ç¼–ç ç†è®º--quantum-coding-theory)
  - [é‡å­ç¼–ç åŸºç¡€ç†è®º / Quantum Coding Foundation Theory](#é‡å­ç¼–ç åŸºç¡€ç†è®º--quantum-coding-foundation-theory)
  - [é‡å­çº é”™ç åŸºç¡€ / Quantum Error Correction Foundation](#é‡å­çº é”™ç åŸºç¡€--quantum-error-correction-foundation)
  - [ç¨³å®šå­ç ç†è®º / Stabilizer Code Theory](#ç¨³å®šå­ç ç†è®º--stabilizer-code-theory)
  - [é‡å­çº é”™ç  / Quantum Error Correction Codes](#é‡å­çº é”™ç --quantum-error-correction-codes)
    - [é”™è¯¯æ¨¡å‹ç†è®º / Error Model Theory](#é”™è¯¯æ¨¡å‹ç†è®º--error-model-theory)
    - [é”™è¯¯çº æ­£ç†è®º / Error Correction Theory](#é”™è¯¯çº æ­£ç†è®º--error-correction-theory)
- [é‡å­å‹ç¼©ç†è®º / Quantum Compression Theory](#é‡å­å‹ç¼©ç†è®º--quantum-compression-theory)
  - [é‡å­å‹ç¼©åŸºç¡€ç†è®º / Quantum Compression Foundation Theory](#é‡å­å‹ç¼©åŸºç¡€ç†è®º--quantum-compression-foundation-theory)
  - [é‡å­æ•°æ®å‹ç¼© / Quantum Data Compression](#é‡å­æ•°æ®å‹ç¼©--quantum-data-compression)
    - [Schumacherå‹ç¼©ç†è®º / Schumacher Compression Theory](#schumacherå‹ç¼©ç†è®º--schumacher-compression-theory)
    - [é‡å­æºç¼–ç ç†è®º / Quantum Source Coding Theory](#é‡å­æºç¼–ç ç†è®º--quantum-source-coding-theory)
- [å®ç°ç¤ºä¾‹ / Implementation Examples](#å®ç°ç¤ºä¾‹--implementation-examples)
  - [å®Œæ•´çš„é‡å­ä¿¡æ¯å¤„ç†ç³»ç»Ÿ / Complete Quantum Information Processing System](#å®Œæ•´çš„é‡å­ä¿¡æ¯å¤„ç†ç³»ç»Ÿ--complete-quantum-information-processing-system)
- [æ€»ç»“ / Summary](#æ€»ç»“--summary)
- [äº¤å‰å¼•ç”¨ä¸ä¾èµ– / Cross-References and Dependencies](#äº¤å‰å¼•ç”¨ä¸ä¾èµ–--cross-references-and-dependencies)
- [å‚è€ƒæ–‡çŒ® / References](#å‚è€ƒæ–‡çŒ®--references)

## åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### é‡å­ä¿¡æ¯è®ºå®šä¹‰ / Definition of Quantum Information Theory

é‡å­ä¿¡æ¯è®ºæ˜¯ç ”ç©¶é‡å­ç³»ç»Ÿä¸­ä¿¡æ¯å¤„ç†ã€ä¼ è¾“å’Œå­˜å‚¨çš„æ•°å­¦ç†è®ºã€‚

**Definition 1.1** é‡å­ä¿¡æ¯è®ºæ˜¯ç ”ç©¶é‡å­ç³»ç»Ÿä¸­ä¿¡æ¯å¤„ç†ã€ä¼ è¾“å’Œå­˜å‚¨çš„æ•°å­¦ç†è®ºã€‚

**Definition 1.1** Quantum information theory is the mathematical theory that studies information processing, transmission, and storage in quantum systems.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

è®¾ $\mathcal{H}$ ä¸ºå¸Œå°”ä¼¯ç‰¹ç©ºé—´ï¼Œ$\mathcal{D}(\mathcal{H})$ ä¸ºå¯†åº¦ç®—å­é›†åˆï¼Œåˆ™é‡å­ä¿¡æ¯è®ºç ”ç©¶ï¼š
Let $\mathcal{H}$ be a Hilbert space and $\mathcal{D}(\mathcal{H})$ be the set of density operators, then quantum information theory studies:

$$I(\rho) = S(\rho) - \sum_i p_i S(\rho_i)$$

å…¶ä¸­ $S(\rho)$ æ˜¯å†¯Â·è¯ºä¾æ›¼ç†µï¼Œ$\rho \in \mathcal{D}(\mathcal{H})$ã€‚
where $S(\rho)$ is the von Neumann entropy and $\rho \in \mathcal{D}(\mathcal{H})$.

**å®šä¹‰ 1.2** é‡å­ä¿¡æ¯æ˜¯é‡å­æ€ä¸­ç¼–ç çš„ä¿¡æ¯é‡ã€‚
**Definition 1.2** Quantum information is the amount of information encoded in quantum states.

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**
é‡å­ä¿¡æ¯ $I_q(\rho)$ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
Quantum information $I_q(\rho)$ can be represented as:

$$I_q(\rho) = \log_2 d - S(\rho)$$

å…¶ä¸­ $d$ æ˜¯å¸Œå°”ä¼¯ç‰¹ç©ºé—´çš„ç»´åº¦ã€‚
where $d$ is the dimension of the Hilbert space.

**å®šç† 1.1** (é‡å­ä¿¡æ¯éè´Ÿæ€§å®šç†) å¯¹äºä»»æ„å¯†åº¦ç®—å­ $\rho$ï¼Œé‡å­ä¿¡æ¯ $I_q(\rho) \geq 0$ã€‚
**Theorem 1.1** (Quantum Information Non-negativity Theorem) For any density operator $\rho$, the quantum information $I_q(\rho) \geq 0$.

**è¯æ˜ / Proof:**
æ ¹æ®å†¯Â·è¯ºä¾æ›¼ç†µçš„æ€§è´¨ï¼Œ$S(\rho) \leq \log_2 d$ã€‚
According to the properties of von Neumann entropy, $S(\rho) \leq \log_2 d$.

å› æ­¤ï¼š
Therefore:

$$I_q(\rho) = \log_2 d - S(\rho) \geq 0$$

**å®šç† 1.2** (é‡å­ä¿¡æ¯å•è°ƒæ€§å®šç†) åœ¨é‡å­æ“ä½œä¸‹ï¼Œé‡å­ä¿¡æ¯ä¸ä¼šå¢åŠ ã€‚
**Theorem 1.2** (Quantum Information Monotonicity Theorem) Under quantum operations, quantum information does not increase.

**è¯æ˜ / Proof:**
è®¾ $\mathcal{E}$ ä¸ºé‡å­æ“ä½œï¼Œåˆ™ï¼š
Let $\mathcal{E}$ be a quantum operation, then:

$$S(\mathcal{E}(\rho)) \geq S(\rho)$$

å› æ­¤ï¼š
Therefore:

$$I_q(\mathcal{E}(\rho)) = \log_2 d - S(\mathcal{E}(\rho)) \leq \log_2 d - S(\rho) = I_q(\rho)$$

### é‡å­ä¿¡æ¯å¤„ç†åŸç† / Principles of Quantum Information Processing

1. **é‡å­å åŠ åŸç† / Quantum Superposition**: é‡å­æ¯”ç‰¹å¯ä»¥åŒæ—¶å¤„äºå¤šä¸ªçŠ¶æ€çš„å åŠ 
2. **é‡å­çº ç¼ åŸç† / Quantum Entanglement**: å¤šä¸ªé‡å­æ¯”ç‰¹ä¹‹é—´çš„éå±€åŸŸå…³è”
3. **ä¸å¯å…‹éš†å®šç† / No-Cloning Theorem**: æœªçŸ¥é‡å­æ€æ— æ³•è¢«å®Œç¾å¤åˆ¶
4. **æµ·æ£®å ¡ä¸ç¡®å®šæ€§åŸç† / Heisenberg Uncertainty Principle**: æ— æ³•åŒæ—¶ç²¾ç¡®æµ‹é‡å…±è½­å¯è§‚æµ‹é‡

**å®šç† 1.3** (é‡å­å åŠ åŸç†å½¢å¼åŒ–å®šç†) é‡å­æ€å¯ä»¥è¡¨ç¤ºä¸ºåŸºæ€çš„çº¿æ€§å åŠ ã€‚
**Theorem 1.3** (Formal Quantum Superposition Theorem) Quantum states can be represented as linear superpositions of basis states.

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**
è®¾ $\{|i\rangle\}$ ä¸ºæ­£äº¤åŸºï¼Œåˆ™ä»»æ„é‡å­æ€ $|\psi\rangle$ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
Let $\{|i\rangle\}$ be an orthonormal basis, then any quantum state $|\psi\rangle$ can be represented as:

$$|\psi\rangle = \sum_i c_i |i\rangle$$

å…¶ä¸­ $\sum_i |c_i|^2 = 1$ã€‚
where $\sum_i |c_i|^2 = 1$.

**å®šç† 1.4** (ä¸å¯å…‹éš†å®šç†) ä¸å­˜åœ¨èƒ½å¤Ÿå®Œç¾å¤åˆ¶æœªçŸ¥é‡å­æ€çš„é‡å­æ“ä½œã€‚
**Theorem 1.4** (No-Cloning Theorem) There does not exist a quantum operation that can perfectly copy an unknown quantum state.

**è¯æ˜ / Proof:**
å‡è®¾å­˜åœ¨å…‹éš†æ“ä½œ $U$ï¼Œä½¿å¾—ï¼š
Assume there exists a cloning operation $U$ such that:

$$U|\psi\rangle|0\rangle = |\psi\rangle|\psi\rangle$$

å¯¹äºä¸¤ä¸ªä¸åŒçš„æ€ $|\psi\rangle$ å’Œ $|\phi\rangle$ï¼š
For two different states $|\psi\rangle$ and $|\phi\rangle$:

$$U|\psi\rangle|0\rangle = |\psi\rangle|\psi\rangle$$
$$U|\phi\rangle|0\rangle = |\phi\rangle|\phi\rangle$$

å–å†…ç§¯ï¼š
Taking inner product:

$$\langle\psi|\phi\rangle = \langle\psi|\phi\rangle^2$$

è¿™æ„å‘³ç€ $\langle\psi|\phi\rangle = 0$ æˆ– $1$ï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚
This means $\langle\psi|\phi\rangle = 0$ or $1$, which contradicts the assumption.

**å®šç† 1.5** (æµ·æ£®å ¡ä¸ç¡®å®šæ€§åŸç†) å¯¹äºä»»æ„ä¸¤ä¸ªä¸å¯¹æ˜“çš„è§‚æµ‹ç®—ç¬¦ $A$ å’Œ $B$ï¼š
**Theorem 1.5** (Heisenberg Uncertainty Principle) For any two non-commuting observables $A$ and $B$:

$$\Delta A \Delta B \geq \frac{1}{2}|\langle[A,B]\rangle|$$

å…¶ä¸­ $\Delta A = \sqrt{\langle A^2 \rangle - \langle A \rangle^2}$ã€‚
where $\Delta A = \sqrt{\langle A^2 \rangle - \langle A \rangle^2}$.

**è¯æ˜ / Proof:**
è®¾ $|\psi\rangle$ ä¸ºé‡å­æ€ï¼Œå®šä¹‰ï¼š
Let $|\psi\rangle$ be a quantum state, define:

$$A' = A - \langle A \rangle I$$
$$B' = B - \langle B \rangle I$$

åˆ™ï¼š
Then:

$$(\Delta A)^2 = \langle\psi|A'^2|\psi\rangle$$
$$(\Delta B)^2 = \langle\psi|B'^2|\psi\rangle$$

æ ¹æ®æŸ¯è¥¿-æ–½ç“¦èŒ¨ä¸ç­‰å¼ï¼š
According to Cauchy-Schwarz inequality:

$$(\Delta A)^2(\Delta B)^2 \geq |\langle\psi|A'B'|\psi\rangle|^2$$

ç”±äº $[A',B'] = [A,B]$ï¼Œå› æ­¤ï¼š
Since $[A',B'] = [A,B]$, therefore:

$$\Delta A \Delta B \geq \frac{1}{2}|\langle[A,B]\rangle|$$

## é‡å­ç†µç†è®º / Quantum Entropy Theory

### å†¯Â·è¯ºä¾æ›¼ç†µ / Von Neumann Entropy

å†¯Â·è¯ºä¾æ›¼ç†µæ˜¯é‡å­ä¿¡æ¯è®ºä¸­çš„åŸºæœ¬æ¦‚å¿µã€‚

**Definition 2.1** å†¯Â·è¯ºä¾æ›¼ç†µæ˜¯é‡å­ä¿¡æ¯è®ºä¸­çš„åŸºæœ¬æ¦‚å¿µã€‚
**Definition 2.1** Von Neumann entropy is a fundamental concept in quantum information theory.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

ç»™å®šå¯†åº¦çŸ©é˜µ $\rho$ï¼Œå†¯Â·è¯ºä¾æ›¼ç†µå®šä¹‰ä¸ºï¼š
Given a density matrix $\rho$, the von Neumann entropy is defined as:

$$S(\rho) = -\text{Tr}(\rho \log \rho)$$

**å®šç† 2.1** (å†¯Â·è¯ºä¾æ›¼ç†µéè´Ÿæ€§å®šç†) å¯¹äºä»»æ„å¯†åº¦ç®—å­ $\rho$ï¼Œ$S(\rho) \geq 0$ã€‚
**Theorem 2.1** (Von Neumann Entropy Non-negativity Theorem) For any density operator $\rho$, $S(\rho) \geq 0$.

**è¯æ˜ / Proof:**
è®¾ $\rho$ çš„ç‰¹å¾å€¼ä¸º $\{\lambda_i\}$ï¼Œåˆ™ï¼š
Let the eigenvalues of $\rho$ be $\{\lambda_i\}$, then:

$$S(\rho) = -\sum_i \lambda_i \log \lambda_i$$

ç”±äº $0 \leq \lambda_i \leq 1$ï¼Œä¸” $\sum_i \lambda_i = 1$ï¼Œå› æ­¤ï¼š
Since $0 \leq \lambda_i \leq 1$ and $\sum_i \lambda_i = 1$, therefore:

$$-\lambda_i \log \lambda_i \geq 0$$

å› æ­¤ $S(\rho) \geq 0$ã€‚
Therefore $S(\rho) \geq 0$.

**å®šç† 2.2** (å†¯Â·è¯ºä¾æ›¼ç†µæœ€å¤§å€¼å®šç†) å¯¹äº $d$ ç»´ç³»ç»Ÿï¼Œ$S(\rho) \leq \log_2 d$ã€‚
**Theorem 2.2** (Von Neumann Entropy Maximum Theorem) For a $d$-dimensional system, $S(\rho) \leq \log_2 d$.

**è¯æ˜ / Proof:**
ä½¿ç”¨æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•ï¼Œåœ¨çº¦æŸ $\sum_i \lambda_i = 1$ ä¸‹æœ€å¤§åŒ–ï¼š
Using Lagrange multipliers, maximize under constraint $\sum_i \lambda_i = 1$:

$$S(\rho) = -\sum_i \lambda_i \log \lambda_i$$

å¾—åˆ° $\lambda_i = \frac{1}{d}$ æ—¶è¾¾åˆ°æœ€å¤§å€¼ $\log_2 d$ã€‚
The maximum $\log_2 d$ is achieved when $\lambda_i = \frac{1}{d}$.

**å®šç† 2.3** (å†¯Â·è¯ºä¾æ›¼ç†µå•è°ƒæ€§å®šç†) åœ¨é‡å­æ“ä½œä¸‹ï¼Œå†¯Â·è¯ºä¾æ›¼ç†µä¸ä¼šå‡å°‘ã€‚
**Theorem 2.3** (Von Neumann Entropy Monotonicity Theorem) Under quantum operations, von Neumann entropy does not decrease.

**è¯æ˜ / Proof:**
è®¾ $\mathcal{E}$ ä¸ºé‡å­æ“ä½œï¼Œåˆ™ï¼š
Let $\mathcal{E}$ be a quantum operation, then:

$$S(\mathcal{E}(\rho)) \geq S(\rho)$$

è¿™æ˜¯å› ä¸ºé‡å­æ“ä½œå¢åŠ äº†ç³»ç»Ÿçš„ä¸ç¡®å®šæ€§ã€‚
This is because quantum operations increase the uncertainty of the system.

**å®šç† 2.4** (å†¯Â·è¯ºä¾æ›¼ç†µå¼ºæ¬¡å¯åŠ æ€§å®šç†) å¯¹äºå¤åˆç³»ç»Ÿ $\rho_{ABC}$ï¼š
**Theorem 2.4** (Von Neumann Entropy Strong Subadditivity Theorem) For composite system $\rho_{ABC}$:

$$S(\rho_{ABC}) + S(\rho_B) \leq S(\rho_{AB}) + S(\rho_{BC})$$

**è¯æ˜ / Proof:**
è¿™æ˜¯é‡å­ä¿¡æ¯è®ºä¸­æœ€æ·±åˆ»çš„å®šç†ä¹‹ä¸€ï¼Œè¯æ˜æ¶‰åŠç›¸å¯¹ç†µçš„å•è°ƒæ€§ã€‚
This is one of the deepest theorems in quantum information theory, and the proof involves the monotonicity of relative entropy.

```rust
// å†¯Â·è¯ºä¾æ›¼ç†µå®ç°
pub struct VonNeumannEntropy;

impl VonNeumannEntropy {
    pub fn calculate(&self, density_matrix: &Matrix) -> f64 {
        // è®¡ç®—å¯†åº¦çŸ©é˜µçš„ç‰¹å¾å€¼
        let eigenvalues = density_matrix.eigenvalues();

        // è®¡ç®—ç†µ
        let mut entropy = 0.0;
        for eigenvalue in eigenvalues {
            if eigenvalue > 1e-10 { // é¿å…log(0)
                entropy -= eigenvalue * eigenvalue.log2();
            }
        }

        entropy
    }

    pub fn conditional_entropy(&self, rho_ab: &Matrix, rho_b: &Matrix) -> f64 {
        // è®¡ç®—æ¡ä»¶ç†µ S(A|B) = S(AB) - S(B)
        let entropy_ab = self.calculate(rho_ab);
        let entropy_b = self.calculate(rho_b);

        entropy_ab - entropy_b
    }

    pub fn mutual_information(&self, rho_ab: &Matrix, rho_a: &Matrix, rho_b: &Matrix) -> f64 {
        // è®¡ç®—äº’ä¿¡æ¯ I(A;B) = S(A) + S(B) - S(AB)
        let entropy_a = self.calculate(rho_a);
        let entropy_b = self.calculate(rho_b);
        let entropy_ab = self.calculate(rho_ab);

        entropy_a + entropy_b - entropy_ab
    }
}

// å¯†åº¦çŸ©é˜µ
#[derive(Debug, Clone)]
pub struct DensityMatrix {
    matrix: Matrix,
    dimension: usize,
}

impl DensityMatrix {
    pub fn new(dimension: usize) -> Self {
        let matrix = Matrix::identity(dimension);
        DensityMatrix { matrix, dimension }
    }

    pub fn from_pure_state(state: &QuantumState) -> Self {
        let matrix = state.outer_product(state);
        DensityMatrix {
            matrix,
            dimension: state.dimension(),
        }
    }

    pub fn eigenvalues(&self) -> Vec<f64> {
        self.matrix.eigenvalues()
    }

    pub fn trace(&self) -> f64 {
        self.matrix.trace()
    }

    pub fn is_valid(&self) -> bool {
        // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„å¯†åº¦çŸ©é˜µ
        let trace = self.trace();
        let eigenvalues = self.eigenvalues();

        // è¿¹ä¸º1ä¸”æ‰€æœ‰ç‰¹å¾å€¼éè´Ÿ
        (trace - 1.0).abs() < 1e-10 && eigenvalues.iter().all(|&e| e >= -1e-10)
    }
}
```

### ç›¸å¯¹ç†µ / Relative Entropy

**Definition 2.5** ç›¸å¯¹ç†µæ˜¯è¡¡é‡ä¸¤ä¸ªé‡å­æ€ä¹‹é—´å·®å¼‚çš„åº¦é‡ã€‚
**Definition 2.5** Relative entropy is a measure of the difference between two quantum states.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

ç»™å®šä¸¤ä¸ªå¯†åº¦ç®—å­ $\rho$ å’Œ $\sigma$ï¼Œç›¸å¯¹ç†µå®šä¹‰ä¸ºï¼š
Given two density operators $\rho$ and $\sigma$, the relative entropy is defined as:

$$S(\rho \|\sigma) = \text{Tr}(\rho \log \rho - \rho \log \sigma)$$

**å®šç† 2.5** (ç›¸å¯¹ç†µéè´Ÿæ€§å®šç†) å¯¹äºä»»æ„å¯†åº¦ç®—å­ $\rho$ å’Œ $\sigma$ï¼Œ$S(\rho \|\sigma) \geq 0$ã€‚
**Theorem 2.5** (Relative Entropy Non-negativity Theorem) For any density operators $\rho$ and $\sigma$, $S(\rho \|\sigma) \geq 0$.

**è¯æ˜ / Proof:**
ä½¿ç”¨ Klein ä¸ç­‰å¼ï¼š
Using Klein's inequality:

$$S(\rho \|\sigma) = \text{Tr}(\rho \log \rho - \rho \log \sigma) \geq 0$$

å½“ä¸”ä»…å½“ $\rho = \sigma$ æ—¶ç­‰å·æˆç«‹ã€‚
Equality holds if and only if $\rho = \sigma$.

**å®šç† 2.6** (ç›¸å¯¹ç†µå•è°ƒæ€§å®šç†) åœ¨é‡å­æ“ä½œä¸‹ï¼Œç›¸å¯¹ç†µä¸ä¼šå¢åŠ ã€‚
**Theorem 2.6** (Relative Entropy Monotonicity Theorem) Under quantum operations, relative entropy does not increase.

**è¯æ˜ / Proof:**
è®¾ $\mathcal{E}$ ä¸ºé‡å­æ“ä½œï¼Œåˆ™ï¼š
Let $\mathcal{E}$ be a quantum operation, then:

$$S(\mathcal{E}(\rho) \|\mathcal{E}(\sigma)) \leq S(\rho \|\sigma)$$

è¿™æ˜¯é‡å­ä¿¡æ¯è®ºä¸­çš„åŸºæœ¬å®šç†ï¼Œç§°ä¸ºæ•°æ®å¤„ç†ä¸ç­‰å¼ã€‚
This is a fundamental theorem in quantum information theory, called the data processing inequality.

**å®šç† 2.7** (ç›¸å¯¹ç†µå‡¸æ€§å®šç†) ç›¸å¯¹ç†µåœ¨ç¬¬ä¸€ä¸ªå‚æ•°ä¸Šæ˜¯å‡¸çš„ã€‚
**Theorem 2.7** (Relative Entropy Convexity Theorem) Relative entropy is convex in the first parameter.

**è¯æ˜ / Proof:**
å¯¹äº $0 \leq \lambda \leq 1$ å’Œå¯†åº¦ç®—å­ $\rho_1, \rho_2, \sigma$ï¼š
For $0 \leq \lambda \leq 1$ and density operators $\rho_1, \rho_2, \sigma$:

$$S(\lambda \rho_1 + (1-\lambda) \rho_2 \|\sigma) \leq \lambda S(\rho_1 \|\sigma) + (1-\lambda) S(\rho_2 \|\sigma)$$

**å®šç† 2.8** (ç›¸å¯¹ç†µä¸‰è§’ä¸ç­‰å¼) å¯¹äºä¸‰ä¸ªå¯†åº¦ç®—å­ $\rho, \sigma, \tau$ï¼š
**Theorem 2.8** (Relative Entropy Triangle Inequality) For three density operators $\rho, \sigma, \tau$:

$$S(\rho \|\tau) \leq S(\rho \|\sigma) + S(\sigma \|\tau)$$

**è¯æ˜ / Proof:**
ä½¿ç”¨ç›¸å¯¹ç†µçš„å®šä¹‰å’Œæ€§è´¨ï¼š
Using the definition and properties of relative entropy:

$$S(\rho \|\tau) = \text{Tr}(\rho \log \rho - \rho \log \tau)$$
$$= \text{Tr}(\rho \log \rho - \rho \log \sigma + \rho \log \sigma - \rho \log \tau)$$
$$= S(\rho \|\sigma) + \text{Tr}(\rho \log \sigma - \rho \log \tau)$$
$$\leq S(\rho \|\sigma) + S(\sigma \|\tau)$$

ç›¸å¯¹ç†µï¼ˆé‡å­KLæ•£åº¦ï¼‰æ˜¯é‡å­ä¿¡æ¯è®ºä¸­çš„é‡è¦æ¦‚å¿µã€‚

**æ•°å­¦å®šä¹‰ / Mathematical Definition:**

ç»™å®šå¯†åº¦çŸ©é˜µ $\rho$ å’Œ $\sigma$ï¼Œç›¸å¯¹ç†µå®šä¹‰ä¸ºï¼š
$$D(\rho \| \sigma) = \text{Tr}(\rho \log \rho - \rho \log \sigma)$$

Given density matrices $\rho$ and $\sigma$, the relative entropy is defined as:
$$D(\rho \| \sigma) = \text{Tr}(\rho \log \rho - \rho \log \sigma)$$

```rust
// ç›¸å¯¹ç†µå®ç°
pub struct RelativeEntropy;

impl RelativeEntropy {
    pub fn calculate(&self, rho: &DensityMatrix, sigma: &DensityMatrix) -> f64 {
        let entropy_rho = VonNeumannEntropy.calculate(&rho.matrix);
        let cross_entropy = self.calculate_cross_entropy(rho, sigma);

        cross_entropy - entropy_rho
    }

    fn calculate_cross_entropy(&self, rho: &DensityMatrix, sigma: &DensityMatrix) -> f64 {
        // è®¡ç®—äº¤å‰ç†µ Tr(Ï log Ïƒ)
        let product = rho.matrix.multiply(&sigma.matrix.log());
        product.trace()
    }

    pub fn data_processing_inequality(&self, rho: &DensityMatrix, sigma: &DensityMatrix,
                                     channel: &QuantumChannel) -> bool {
        // éªŒè¯æ•°æ®å¤„ç†ä¸ç­‰å¼ D(Ï||Ïƒ) â‰¥ D(Î¦(Ï)||Î¦(Ïƒ))
        let original_divergence = self.calculate(rho, sigma);

        let rho_after = channel.apply(rho);
        let sigma_after = channel.apply(sigma);
        let final_divergence = self.calculate(&rho_after, &sigma_after);

        original_divergence >= final_divergence
    }
}
```

## é‡å­ä¿¡é“ç†è®º / Quantum Channel Theory

### é‡å­ä¿¡é“å®šä¹‰ / Definition of Quantum Channels

é‡å­ä¿¡é“æ˜¯é‡å­ä¿¡æ¯ä¼ è¾“çš„æ•°å­¦æ¨¡å‹ã€‚

**Definition 3.1** é‡å­ä¿¡é“æ˜¯é‡å­ä¿¡æ¯ä¼ è¾“çš„æ•°å­¦æ¨¡å‹ã€‚
**Definition 3.1** Quantum channels are mathematical models for quantum information transmission.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

é‡å­ä¿¡é“ $\Phi$ æ˜¯å®Œå…¨æ­£æ˜ å°„ï¼Œæ»¡è¶³ï¼š
A quantum channel $\Phi$ is a completely positive map satisfying:

$$\Phi(\rho) = \sum_i E_i \rho E_i^\dagger$$

å…¶ä¸­ $\sum_i E_i^\dagger E_i = I$ï¼Œ$\{E_i\}$ ç§°ä¸º Kraus ç®—å­ã€‚
where $\sum_i E_i^\dagger E_i = I$, and $\{E_i\}$ are called Kraus operators.

**å®šç† 3.1** (é‡å­ä¿¡é“ä¿è¿¹æ€§å®šç†) é‡å­ä¿¡é“ä¿æŒå¯†åº¦ç®—å­çš„è¿¹ã€‚
**Theorem 3.1** (Quantum Channel Trace-Preserving Theorem) Quantum channels preserve the trace of density operators.

**è¯æ˜ / Proof:**
å¯¹äºä»»æ„å¯†åº¦ç®—å­ $\rho$ï¼š
For any density operator $\rho$:

$$\text{Tr}(\Phi(\rho)) = \text{Tr}\left(\sum_i E_i \rho E_i^\dagger\right) = \sum_i \text{Tr}(E_i \rho E_i^\dagger)$$
$$= \sum_i \text{Tr}(E_i^\dagger E_i \rho) = \text{Tr}\left(\left(\sum_i E_i^\dagger E_i\right) \rho\right) = \text{Tr}(\rho)$$

**å®šç† 3.2** (é‡å­ä¿¡é“å®Œå…¨æ­£æ€§å®šç†) é‡å­ä¿¡é“æ˜¯å®Œå…¨æ­£çš„ã€‚
**Theorem 3.2** (Quantum Channel Complete Positivity Theorem) Quantum channels are completely positive.

**è¯æ˜ / Proof:**
å¯¹äºä»»æ„æ­£ç®—å­ $A$ å’Œä»»æ„è¾…åŠ©ç³»ç»Ÿï¼š
For any positive operator $A$ and any auxiliary system:

$$(\Phi \otimes I)(A) = \sum_i (E_i \otimes I) A (E_i^\dagger \otimes I) \geq 0$$

å› ä¸º $E_i \otimes I$ æ˜¯æ­£ç®—å­ï¼Œæ‰€ä»¥ç»“æœä¹Ÿæ˜¯æ­£çš„ã€‚
Since $E_i \otimes I$ are positive operators, the result is also positive.

**å®šç† 3.3** (é‡å­ä¿¡é“å®¹é‡å®šç†) é‡å­ä¿¡é“çš„ç»å…¸å®¹é‡ä¸ºï¼š
**Theorem 3.3** (Quantum Channel Capacity Theorem) The classical capacity of a quantum channel is:

$$C(\Phi) = \max_{\{p_i, \rho_i\}} \left[S\left(\sum_i p_i \Phi(\rho_i)\right) - \sum_i p_i S(\Phi(\rho_i))\right]$$

**è¯æ˜ / Proof:**
è¿™æ˜¯ Holevo-Schumacher-Westmoreland å®šç†ï¼Œè¯æ˜æ¶‰åŠç¼–ç å®šç†å’Œå…¸å‹åºåˆ—ã€‚
This is the Holevo-Schumacher-Westmoreland theorem, and the proof involves coding theorems and typical sequences.

**å®šç† 3.4** (é‡å­ä¿¡é“æ•°æ®å¤„ç†å®šç†) å¯¹äºé‡å­ä¿¡é“ $\Phi$ å’Œ $\Psi$ï¼š
**Theorem 3.4** (Quantum Channel Data Processing Theorem) For quantum channels $\Phi$ and $\Psi$:

$$C(\Psi \circ \Phi) \leq C(\Phi)$$

**è¯æ˜ / Proof:**
ä½¿ç”¨æ•°æ®å¤„ç†ä¸ç­‰å¼ï¼š
Using the data processing inequality:

$$I(\rho; \Psi \circ \Phi) \leq I(\rho; \Phi)$$

å› æ­¤ï¼š
Therefore:

$$C(\Psi \circ \Phi) = \max_{\rho} I(\rho; \Psi \circ \Phi) \leq \max_{\rho} I(\rho; \Phi) = C(\Phi)$$

```rust
// é‡å­ä¿¡é“å®ç°
pub struct QuantumChannel {
    kraus_operators: Vec<Matrix>,
}

impl QuantumChannel {
    pub fn new(kraus_operators: Vec<Matrix>) -> Self {
        QuantumChannel { kraus_operators }
    }

    pub fn apply(&self, density_matrix: &DensityMatrix) -> DensityMatrix {
        let mut result = Matrix::zeros(density_matrix.dimension, density_matrix.dimension);

        for kraus in &self.kraus_operators {
            let term = kraus.multiply(&density_matrix.matrix).multiply(&kraus.adjoint());
            result = result.add(&term);
        }

        DensityMatrix {
            matrix: result,
            dimension: density_matrix.dimension,
        }
    }

    pub fn is_trace_preserving(&self) -> bool {
        let mut sum = Matrix::zeros(self.kraus_operators[0].rows(), self.kraus_operators[0].cols());

        for kraus in &self.kraus_operators {
            let product = kraus.adjoint().multiply(kraus);
            sum = sum.add(&product);
        }

        // æ£€æŸ¥æ˜¯å¦ç­‰äºå•ä½çŸ©é˜µ
        let identity = Matrix::identity(sum.rows());
        sum.is_close_to(&identity, 1e-10)
    }

    pub fn channel_capacity(&self) -> f64 {
        // è®¡ç®—ä¿¡é“å®¹é‡
        let mut max_mutual_info = 0.0;

        // å°è¯•ä¸åŒçš„è¾“å…¥çŠ¶æ€
        for input_state in self.generate_input_states() {
            let output_state = self.apply(&input_state);
            let mutual_info = self.calculate_mutual_information(&input_state, &output_state);
            max_mutual_info = max_mutual_info.max(mutual_info);
        }

        max_mutual_info
    }

    fn generate_input_states(&self) -> Vec<DensityMatrix> {
        // ç”Ÿæˆæµ‹è¯•è¾“å…¥çŠ¶æ€
        let mut states = Vec::new();
        let dimension = self.kraus_operators[0].rows();

        // çº¯æ€
        for i in 0..dimension {
            let mut matrix = Matrix::zeros(dimension, dimension);
            matrix.set(i, i, 1.0);
            states.push(DensityMatrix { matrix, dimension });
        }

        // æ··åˆæ€
        let uniform_matrix = Matrix::scalar(1.0 / dimension as f64, dimension);
        states.push(DensityMatrix { matrix: uniform_matrix, dimension });

        states
    }
}

// å¸¸è§é‡å­ä¿¡é“
pub struct DepolarizingChannel {
    probability: f64,
    dimension: usize,
}

impl DepolarizingChannel {
    pub fn new(probability: f64, dimension: usize) -> Self {
        DepolarizingChannel { probability, dimension }
    }

    pub fn apply(&self, density_matrix: &DensityMatrix) -> DensityMatrix {
        let identity = Matrix::identity(self.dimension);
        let scaled_identity = identity.scalar_multiply(self.probability / self.dimension as f64);

        let scaled_input = density_matrix.matrix.scalar_multiply(1.0 - self.probability);
        let result_matrix = scaled_input.add(&scaled_identity);

        DensityMatrix {
            matrix: result_matrix,
            dimension: self.dimension,
        }
    }
}

pub struct AmplitudeDampingChannel {
    gamma: f64,
}

impl AmplitudeDampingChannel {
    pub fn new(gamma: f64) -> Self {
        AmplitudeDampingChannel { gamma }
    }

    pub fn apply(&self, density_matrix: &DensityMatrix) -> DensityMatrix {
        let e0 = Matrix::new(2, 2, vec![1.0, 0.0, 0.0, (1.0 - self.gamma).sqrt()]);
        let e1 = Matrix::new(2, 2, vec![0.0, self.gamma.sqrt(), 0.0, 0.0]);

        let kraus_operators = vec![e0, e1];
        let channel = QuantumChannel::new(kraus_operators);

        channel.apply(density_matrix)
    }
}
```

## é‡å­çº ç¼ ç†è®º / Quantum Entanglement Theory

### çº ç¼ å®šä¹‰ä¸åŸºæœ¬æ€§è´¨ / Definition and Basic Properties of Entanglement

é‡å­çº ç¼ æ˜¯é‡å­åŠ›å­¦ä¸­æœ€æ·±åˆ»çš„ç°è±¡ä¹‹ä¸€ï¼Œæ˜¯é‡å­ä¿¡æ¯å¤„ç†çš„æ ¸å¿ƒèµ„æºã€‚

**å®šä¹‰ 4.1** é‡å­çº ç¼ æ˜¯æŒ‡å¤åˆé‡å­ç³»ç»Ÿä¸­ï¼Œå­ç³»ç»Ÿä¹‹é—´çš„éå±€åŸŸå…³è”ã€‚
**Definition 4.1** Quantum entanglement refers to the non-local correlations between subsystems in a composite quantum system.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\mathcal{H}_A$ å’Œ $\mathcal{H}_B$ ä¸ºä¸¤ä¸ªå¸Œå°”ä¼¯ç‰¹ç©ºé—´ï¼Œå¤åˆç³»ç»Ÿ $\mathcal{H}_{AB} = \mathcal{H}_A \otimes \mathcal{H}_B$ã€‚
Let $\mathcal{H}_A$ and $\mathcal{H}_B$ be two Hilbert spaces, and the composite system $\mathcal{H}_{AB} = \mathcal{H}_A \otimes \mathcal{H}_B$.

å¦‚æœå¯†åº¦ç®—å­ $\rho_{AB}$ ä¸èƒ½è¡¨ç¤ºä¸ºï¼š
If the density operator $\rho_{AB}$ cannot be expressed as:

$$\rho_{AB} = \sum_i p_i \rho_A^{(i)} \otimes \rho_B^{(i)}$$

å…¶ä¸­ $p_i \geq 0$ï¼Œ$\sum_i p_i = 1$ï¼Œåˆ™ç§° $\rho_{AB}$ æ˜¯çº ç¼ çš„ã€‚
where $p_i \geq 0$, $\sum_i p_i = 1$, then $\rho_{AB}$ is said to be entangled.

**å®šç† 4.1** (çº ç¼ å­˜åœ¨æ€§å®šç†) å¯¹äºä»»æ„ç»´åº¦ $d \geq 2$ çš„å¤åˆç³»ç»Ÿï¼Œéƒ½å­˜åœ¨çº ç¼ æ€ã€‚
**Theorem 4.1** (Entanglement Existence Theorem) For any composite system of dimension $d \geq 2$, entangled states exist.

**è¯æ˜ / Proof:**
è€ƒè™‘è´å°”æ€ï¼š
Consider the Bell state:

$$|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$$

å…¶å¯†åº¦ç®—å­ä¸ºï¼š
Its density operator is:

$$\rho_{AB} = |\Phi^+\rangle\langle\Phi^+| = \frac{1}{2}(|00\rangle\langle00| + |00\rangle\langle11| + |11\rangle\langle00| + |11\rangle\langle11|)$$

é€šè¿‡è®¡ç®—çº¦åŒ–å¯†åº¦ç®—å­å¯ä»¥è¯æ˜è¿™æ˜¯çº ç¼ æ€ã€‚
By calculating the reduced density operators, we can prove this is an entangled state.

**å®šç† 4.2** (çº ç¼ å•è°ƒæ€§å®šç†) åœ¨å±€åŸŸæ“ä½œå’Œç»å…¸é€šä¿¡(LOCC)ä¸‹ï¼Œçº ç¼ ä¸ä¼šå¢åŠ ã€‚
**Theorem 4.2** (Entanglement Monotonicity Theorem) Under local operations and classical communication (LOCC), entanglement does not increase.

**è¯æ˜ / Proof:**
è®¾ $\Lambda$ ä¸º LOCC æ“ä½œï¼Œåˆ™å¯¹äºä»»æ„çº ç¼ åº¦é‡ $E$ï¼š
Let $\Lambda$ be a LOCC operation, then for any entanglement measure $E$:

$$E(\Lambda(\rho)) \leq E(\rho)$$

è¿™æ˜¯å› ä¸º LOCC æ“ä½œåªèƒ½å‡å°‘éå±€åŸŸå…³è”ã€‚
This is because LOCC operations can only reduce non-local correlations.

### çº ç¼ åº¦é‡ / Entanglement Measures

çº ç¼ åº¦é‡æ˜¯é‡åŒ–é‡å­çº ç¼ ç¨‹åº¦çš„å·¥å…·ã€‚

**å®šä¹‰ 4.2** çº ç¼ åº¦é‡æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„å‡½æ•° $E: \mathcal{D}(\mathcal{H}_{AB}) \rightarrow \mathbb{R}^+$ï¼š
**Definition 4.2** An entanglement measure is a function $E: \mathcal{D}(\mathcal{H}_{AB}) \rightarrow \mathbb{R}^+$ satisfying:

1. **éè´Ÿæ€§ / Non-negativity:** $E(\rho) \geq 0$
2. **å•è°ƒæ€§ / Monotonicity:** $E(\Lambda(\rho)) \leq E(\rho)$ å¯¹äºä»»æ„ LOCC æ“ä½œ $\Lambda$
3. **å‡¸æ€§ / Convexity:** $E(\sum_i p_i \rho_i) \leq \sum_i p_i E(\rho_i)$

**å®šç† 4.3** (å†¯Â·è¯ºä¾æ›¼ç†µçº ç¼ åº¦é‡å®šç†) å¯¹äºçº¯æ€ $|\psi\rangle_{AB}$ï¼Œçº ç¼ ç†µå®šä¹‰ä¸ºï¼š
**Theorem 4.3** (Von Neumann Entropy Entanglement Measure Theorem) For pure state $|\psi\rangle_{AB}$, the entanglement entropy is defined as:

$$E(|\psi\rangle_{AB}) = S(\rho_A) = S(\rho_B)$$

å…¶ä¸­ $\rho_A = \text{Tr}_B(|\psi\rangle\langle\psi|_{AB})$ã€‚
where $\rho_A = \text{Tr}_B(|\psi\rangle\langle\psi|_{AB})$.

**è¯æ˜ / Proof:**
ç”±äº $|\psi\rangle_{AB}$ æ˜¯çº¯æ€ï¼Œå…¶çº¦åŒ–å¯†åº¦ç®—å­ $\rho_A$ å’Œ $\rho_B$ å…·æœ‰ç›¸åŒçš„éé›¶ç‰¹å¾å€¼ã€‚
Since $|\psi\rangle_{AB}$ is a pure state, its reduced density operators $\rho_A$ and $\rho_B$ have the same non-zero eigenvalues.

å› æ­¤ï¼š
Therefore:

$$S(\rho_A) = S(\rho_B)$$

**å®šç† 4.4** (ç›¸å¯¹ç†µçº ç¼ åº¦é‡å®šç†) ç›¸å¯¹ç†µçº ç¼ å®šä¹‰ä¸ºï¼š
**Theorem 4.4** (Relative Entropy Entanglement Measure Theorem) The relative entropy of entanglement is defined as:

$$E_R(\rho) = \min_{\sigma \in \mathcal{S}} S(\rho \|\sigma)$$

å…¶ä¸­ $\mathcal{S}$ ä¸ºå¯åˆ†æ€é›†åˆã€‚
where $\mathcal{S}$ is the set of separable states.

**è¯æ˜ / Proof:**
ç›¸å¯¹ç†µçº ç¼ æ»¡è¶³çº ç¼ åº¦é‡çš„æ‰€æœ‰æ¡ä»¶ï¼š
The relative entropy of entanglement satisfies all conditions of entanglement measures:

1. **éè´Ÿæ€§:** ç”± Klein ä¸ç­‰å¼
2. **å•è°ƒæ€§:** ç”±ç›¸å¯¹ç†µçš„å•è°ƒæ€§
3. **å‡¸æ€§:** ç”±ç›¸å¯¹ç†µçš„å‡¸æ€§

**å®šç† 4.5** (çº ç¼ å½¢æˆå®šç†) çº ç¼ å½¢æˆå®šä¹‰ä¸ºï¼š
**Theorem 4.5** (Entanglement of Formation Theorem) The entanglement of formation is defined as:

$$E_F(\rho) = \min_{\{p_i, |\psi_i\rangle\}} \sum_i p_i E(|\psi_i\rangle)$$

å…¶ä¸­æœ€å°åŒ–åœ¨æ‰€æœ‰åˆ†è§£ $\rho = \sum_i p_i |\psi_i\rangle\langle\psi_i|$ ä¸Šã€‚
where the minimization is over all decompositions $\rho = \sum_i p_i |\psi_i\rangle\langle\psi_i|$.

**è¯æ˜ / Proof:**
çº ç¼ å½¢æˆæ˜¯å‡¸å‡½æ•°ï¼Œå› ä¸ºå®ƒæ˜¯å‡¸åŒ…ç»œã€‚
The entanglement of formation is convex because it is a convex hull.

**å®šç† 4.6** (Concurrence çº ç¼ åº¦é‡å®šç†) å¯¹äºä¸¤é‡å­æ¯”ç‰¹ç³»ç»Ÿï¼ŒConcurrence å®šä¹‰ä¸ºï¼š
**Theorem 4.6** (Concurrence Entanglement Measure Theorem) For two-qubit systems, Concurrence is defined as:

$$C(\rho) = \max\{0, \lambda_1 - \lambda_2 - \lambda_3 - \lambda_4\}$$

å…¶ä¸­ $\lambda_i$ æ˜¯çŸ©é˜µ $\sqrt{\sqrt{\rho}\tilde{\rho}\sqrt{\rho}}$ çš„ç‰¹å¾å€¼çš„é™åºæ’åˆ—ã€‚
where $\lambda_i$ are the eigenvalues of matrix $\sqrt{\sqrt{\rho}\tilde{\rho}\sqrt{\rho}}$ in descending order.

**è¯æ˜ / Proof:**
å¯¹äºä¸¤é‡å­æ¯”ç‰¹ç³»ç»Ÿï¼Œ$\tilde{\rho} = (\sigma_y \otimes \sigma_y)\rho^*(\sigma_y \otimes \sigma_y)$ã€‚
For two-qubit systems, $\tilde{\rho} = (\sigma_y \otimes \sigma_y)\rho^*(\sigma_y \otimes \sigma_y)$.

Concurrence æ»¡è¶³çº ç¼ åº¦é‡çš„æ‰€æœ‰æ¡ä»¶ï¼š
Concurrence satisfies all conditions of entanglement measures:

1. **éè´Ÿæ€§:** ç”±å®šä¹‰ç›´æ¥å¾—åˆ°
2. **å•è°ƒæ€§:** åœ¨ LOCC æ“ä½œä¸‹å•è°ƒé€’å‡
3. **å‡¸æ€§:** ç”±å‡¸å‡½æ•°çš„æ€§è´¨

**å®šç† 4.7** (Negativity çº ç¼ åº¦é‡å®šç†) Negativity å®šä¹‰ä¸ºï¼š
**Theorem 4.7** (Negativity Entanglement Measure Theorem) Negativity is defined as:

$$N(\rho) = \frac{\|\rho^{T_A}\|_1 - 1}{2}$$

å…¶ä¸­ $\rho^{T_A}$ æ˜¯ $\rho$ å…³äºå­ç³»ç»Ÿ A çš„éƒ¨åˆ†è½¬ç½®ã€‚
where $\rho^{T_A}$ is the partial transpose of $\rho$ with respect to subsystem A.

**è¯æ˜ / Proof:**
Negativity åŸºäºéƒ¨åˆ†è½¬ç½®åˆ¤æ®ï¼š
Negativity is based on the partial transpose criterion:

$$\rho^{T_A} = \sum_{i,j,k,l} \rho_{ij,kl} |i\rangle\langle j| \otimes |l\rangle\langle k|$$

å¦‚æœ $\rho$ æ˜¯å¯åˆ†çš„ï¼Œåˆ™ $\rho^{T_A} \geq 0$ï¼Œå› æ­¤ $N(\rho) = 0$ã€‚
If $\rho$ is separable, then $\rho^{T_A} \geq 0$, so $N(\rho) = 0$.

**å®šç† 4.8** (çº ç¼ è’¸é¦å®šç†) çº ç¼ è’¸é¦æ˜¯ LOCC æ“ä½œä¸‹ä»å¤šä¸ªå¼±çº ç¼ æ€åˆ¶å¤‡å°‘é‡å¼ºçº ç¼ æ€çš„è¿‡ç¨‹ã€‚
**Theorem 4.8** (Entanglement Distillation Theorem) Entanglement distillation is the process of preparing a small number of strongly entangled states from multiple weakly entangled states under LOCC operations.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\rho^{\otimes n}$ ä¸º n ä¸ªç›¸åŒçš„çº ç¼ æ€ï¼Œè’¸é¦è¿‡ç¨‹ä¸ºï¼š
Let $\rho^{\otimes n}$ be n identical entangled states, the distillation process is:

$$\Lambda: \rho^{\otimes n} \rightarrow |\Phi^+\rangle\langle\Phi^+|^{\otimes m}$$

å…¶ä¸­ $\Lambda$ ä¸º LOCC æ“ä½œï¼Œ$m$ ä¸ºè’¸é¦å‡ºçš„è´å°”æ€æ•°é‡ã€‚
where $\Lambda$ is a LOCC operation, and $m$ is the number of distilled Bell states.

**å®šç† 4.9** (çº ç¼ è’¸é¦ç‡å®šç†) çº ç¼ è’¸é¦ç‡å®šä¹‰ä¸ºï¼š
**Theorem 4.9** (Entanglement Distillation Rate Theorem) The entanglement distillation rate is defined as:

$$D(\rho) = \lim_{n \rightarrow \infty} \frac{m(n)}{n}$$

å…¶ä¸­ $m(n)$ æ˜¯ä» $n$ ä¸ª $\rho$ æ€ä¸­è’¸é¦å‡ºçš„è´å°”æ€æ•°é‡ã€‚
where $m(n)$ is the number of Bell states distilled from $n$ copies of $\rho$.

**è¯æ˜ / Proof:**
è’¸é¦ç‡æ˜¯çº ç¼ åº¦é‡çš„ä¸Šç•Œï¼š
The distillation rate is an upper bound for entanglement measures:

$$D(\rho) \geq E(\rho)$$

å¯¹äºä»»æ„çº ç¼ åº¦é‡ $E$ã€‚
for any entanglement measure $E$.

**å®šç† 4.10** (çº ç¼ ç¨€é‡Šå®šç†) çº ç¼ ç¨€é‡Šæ˜¯ LOCC æ“ä½œä¸‹ä»å°‘é‡å¼ºçº ç¼ æ€åˆ¶å¤‡å¤šä¸ªå¼±çº ç¼ æ€çš„è¿‡ç¨‹ã€‚
**Theorem 4.10** (Entanglement Dilution Theorem) Entanglement dilution is the process of preparing multiple weakly entangled states from a small number of strongly entangled states under LOCC operations.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $|\Phi^+\rangle^{\otimes m}$ ä¸º $m$ ä¸ªè´å°”æ€ï¼Œç¨€é‡Šè¿‡ç¨‹ä¸ºï¼š
Let $|\Phi^+\rangle^{\otimes m}$ be $m$ Bell states, the dilution process is:

$$\Lambda: |\Phi^+\rangle\langle\Phi^+|^{\otimes m} \rightarrow \rho^{\otimes n}$$

å…¶ä¸­ $\Lambda$ ä¸º LOCC æ“ä½œã€‚
where $\Lambda$ is a LOCC operation.

**å®šç† 4.11** (çº ç¼ ç¨€é‡Šç‡å®šç†) çº ç¼ ç¨€é‡Šç‡å®šä¹‰ä¸ºï¼š
**Theorem 4.11** (Entanglement Dilution Rate Theorem) The entanglement dilution rate is defined as:

$$C(\rho) = \lim_{m \rightarrow \infty} \frac{n(m)}{m}$$

å…¶ä¸­ $n(m)$ æ˜¯ä» $m$ ä¸ªè´å°”æ€ä¸­ç¨€é‡Šå‡ºçš„ $\rho$ æ€æ•°é‡ã€‚
where $n(m)$ is the number of $\rho$ states diluted from $m$ Bell states.

**è¯æ˜ / Proof:**
ç¨€é‡Šç‡æ˜¯çº ç¼ åº¦é‡çš„ä¸‹ç•Œï¼š
The dilution rate is a lower bound for entanglement measures:

$$C(\rho) \leq E(\rho)$$

å¯¹äºä»»æ„çº ç¼ åº¦é‡ $E$ã€‚
for any entanglement measure $E$.

```rust
// çº ç¼ åº¦é‡å®ç°
pub struct EntanglementMeasures;

impl EntanglementMeasures {
    pub fn concurrence(&self, density_matrix: &DensityMatrix) -> f64 {
        // è®¡ç®—Concurrence
        if density_matrix.dimension != 4 {
            return 0.0; // åªé€‚ç”¨äºä¸¤é‡å­æ¯”ç‰¹ç³»ç»Ÿ
        }

        let rho_tilde = self.calculate_rho_tilde(density_matrix);
        let eigenvalues = rho_tilde.eigenvalues();

        let mut lambda_values = Vec::new();
        for eigenvalue in eigenvalues {
            if eigenvalue > 0.0 {
                lambda_values.push(eigenvalue.sqrt());
            }
        }

        lambda_values.sort_by(|a, b| b.partial_cmp(a).unwrap());

        if lambda_values.len() >= 4 {
            (lambda_values[0] - lambda_values[1] - lambda_values[2] - lambda_values[3]).max(0.0)
        } else {
            0.0
        }
    }

    pub fn negativity(&self, density_matrix: &DensityMatrix) -> f64 {
        // è®¡ç®—Negativity
        let partial_transpose = self.partial_transpose(density_matrix);
        let eigenvalues = partial_transpose.eigenvalues();

        let mut negativity = 0.0;
        for eigenvalue in eigenvalues {
            if eigenvalue < 0.0 {
                negativity += eigenvalue.abs();
            }
        }

        negativity
    }

    pub fn von_neumann_entropy_of_entanglement(&self, pure_state: &QuantumState) -> f64 {
        // è®¡ç®—çº¯æ€çš„å†¯Â·è¯ºä¾æ›¼çº ç¼ ç†µ
        let reduced_density_matrix = self.calculate_reduced_density_matrix(pure_state);
        VonNeumannEntropy.calculate(&reduced_density_matrix.matrix)
    }

    fn calculate_rho_tilde(&self, density_matrix: &DensityMatrix) -> Matrix {
        // è®¡ç®— ÏÌƒ = (Ïƒ_y âŠ— Ïƒ_y) Ï* (Ïƒ_y âŠ— Ïƒ_y)
        let sigma_y = Matrix::new(2, 2, vec![0.0, -1.0, 1.0, 0.0]);
        let sigma_y_tensor = sigma_y.tensor_product(&sigma_y);

        let complex_conjugate = density_matrix.matrix.complex_conjugate();
        let term1 = sigma_y_tensor.multiply(&complex_conjugate);
        term1.multiply(&sigma_y_tensor)
    }

    fn partial_transpose(&self, density_matrix: &DensityMatrix) -> Matrix {
        // è®¡ç®—éƒ¨åˆ†è½¬ç½®
        let mut result = Matrix::zeros(density_matrix.dimension, density_matrix.dimension);

        for i in 0..2 {
            for j in 0..2 {
                for k in 0..2 {
                    for l in 0..2 {
                        let row = 2 * i + k;
                        let col = 2 * j + l;
                        let value = density_matrix.matrix.get(2 * i + j, 2 * k + l);
                        result.set(row, col, value);
                    }
                }
            }
        }

        result
    }

    fn calculate_reduced_density_matrix(&self, pure_state: &QuantumState) -> DensityMatrix {
        // è®¡ç®—çº¦åŒ–å¯†åº¦çŸ©é˜µ
        let full_density = DensityMatrix::from_pure_state(pure_state);
        let mut reduced = Matrix::zeros(2, 2);

        for i in 0..2 {
            for j in 0..2 {
                let mut sum = 0.0;
                for k in 0..2 {
                    let index1 = 2 * i + k;
                    let index2 = 2 * j + k;
                    sum += full_density.matrix.get(index1, index2);
                }
                reduced.set(i, j, sum);
            }
        }

        DensityMatrix {
            matrix: reduced,
            dimension: 2,
        }
    }
}
```

## é‡å­ç¼–ç ç†è®º / Quantum Coding Theory

### é‡å­ç¼–ç åŸºç¡€ç†è®º / Quantum Coding Foundation Theory

**å®šä¹‰ 5.1** é‡å­ç¼–ç æ˜¯å°†é€»è¾‘é‡å­æ¯”ç‰¹æ˜ å°„åˆ°ç‰©ç†é‡å­æ¯”ç‰¹çš„è¿‡ç¨‹ã€‚
**Definition 5.1** Quantum coding is the process of mapping logical qubits to physical qubits.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\mathcal{H}_L$ ä¸ºé€»è¾‘å¸Œå°”ä¼¯ç‰¹ç©ºé—´ï¼Œ$\mathcal{H}_P$ ä¸ºç‰©ç†å¸Œå°”ä¼¯ç‰¹ç©ºé—´ï¼Œé‡å­ç¼–ç ä¸ºï¼š
Let $\mathcal{H}_L$ be the logical Hilbert space, $\mathcal{H}_P$ be the physical Hilbert space, quantum coding is:

$$\mathcal{E}: \mathcal{H}_L \rightarrow \mathcal{H}_P$$

å…¶ä¸­ $\mathcal{E}$ ä¸ºç¼–ç æ˜ å°„ã€‚
where $\mathcal{E}$ is the encoding map.

**å®šç† 5.1** (é‡å­ç¼–ç å­˜åœ¨æ€§å®šç†) å¯¹äºä»»æ„æœ‰é™ç»´é€»è¾‘ç©ºé—´ï¼Œéƒ½å­˜åœ¨åˆ°æ›´é«˜ç»´ç‰©ç†ç©ºé—´çš„ç¼–ç ã€‚
**Theorem 5.1** (Quantum Coding Existence Theorem) For any finite-dimensional logical space, there exists an encoding to a higher-dimensional physical space.

**è¯æ˜ / Proof:**
è®¾ $\dim(\mathcal{H}_L) = d_L$ï¼Œ$\dim(\mathcal{H}_P) = d_P$ï¼Œä¸” $d_P > d_L$ã€‚
Let $\dim(\mathcal{H}_L) = d_L$, $\dim(\mathcal{H}_P) = d_P$, and $d_P > d_L$.

åˆ™å­˜åœ¨ç­‰è·åµŒå…¥ $\mathcal{E}: \mathcal{H}_L \rightarrow \mathcal{H}_P$ã€‚
Then there exists an isometric embedding $\mathcal{E}: \mathcal{H}_L \rightarrow \mathcal{H}_P$.

**å®šç† 5.2** (é‡å­ç¼–ç ä¿çœŸåº¦å®šç†) é‡å­ç¼–ç çš„ä¿çœŸåº¦å®šä¹‰ä¸ºï¼š
**Theorem 5.2** (Quantum Coding Fidelity Theorem) The fidelity of quantum coding is defined as:

$$F(\mathcal{E}) = \min_{|\psi\rangle \in \mathcal{H}_L} F(|\psi\rangle, \mathcal{E}(|\psi\rangle))$$

å…¶ä¸­ $F(|\psi\rangle, |\phi\rangle) = |\langle\psi|\phi\rangle|^2$ã€‚
where $F(|\psi\rangle, |\phi\rangle) = |\langle\psi|\phi\rangle|^2$.

**è¯æ˜ / Proof:**
ç”±äº $\mathcal{E}$ æ˜¯ç­‰è·æ˜ å°„ï¼Œå¯¹äºä»»æ„ $|\psi\rangle \in \mathcal{H}_L$ï¼š
Since $\mathcal{E}$ is an isometric map, for any $|\psi\rangle \in \mathcal{H}_L$:

$$F(|\psi\rangle, \mathcal{E}(|\psi\rangle)) = |\langle\psi|\mathcal{E}^\dagger\mathcal{E}|\psi\rangle|^2 = |\langle\psi|\psi\rangle|^2 = 1$$

å› æ­¤ $F(\mathcal{E}) = 1$ã€‚
Therefore $F(\mathcal{E}) = 1$.

### é‡å­çº é”™ç åŸºç¡€ / Quantum Error Correction Foundation

**å®šä¹‰ 5.2** é‡å­çº é”™ç æ˜¯èƒ½å¤Ÿæ£€æµ‹å’Œçº æ­£é‡å­é”™è¯¯çš„ç¼–ç æ–¹æ¡ˆã€‚
**Definition 5.2** A quantum error correction code is an encoding scheme that can detect and correct quantum errors.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\mathcal{C} \subset \mathcal{H}_P$ ä¸ºç¼–ç å­ç©ºé—´ï¼Œ$\mathcal{E}$ ä¸ºé”™è¯¯é›†åˆï¼Œé‡å­çº é”™ç æ»¡è¶³ï¼š
Let $\mathcal{C} \subset \mathcal{H}_P$ be the code subspace, $\mathcal{E}$ be the error set, quantum error correction code satisfies:

1. **é”™è¯¯æ£€æµ‹æ¡ä»¶ / Error Detection Condition:**
   $$\forall E \in \mathcal{E}, \forall |\psi\rangle, |\phi\rangle \in \mathcal{C}: \langle\psi|E|\phi\rangle = c_E \langle\psi|\phi\rangle$$

2. **é”™è¯¯çº æ­£æ¡ä»¶ / Error Correction Condition:**
   $$\forall E_1, E_2 \in \mathcal{E}, \forall |\psi\rangle, |\phi\rangle \in \mathcal{C}: \langle\psi|E_1^\dagger E_2|\phi\rangle = c_{E_1,E_2} \langle\psi|\phi\rangle$$

**å®šç† 5.3** (é‡å­çº é”™ç å­˜åœ¨æ€§å®šç†) å¯¹äºä»»æ„æœ‰é™é”™è¯¯é›†åˆï¼Œå­˜åœ¨èƒ½å¤Ÿçº æ­£è¿™äº›é”™è¯¯çš„é‡å­çº é”™ç ã€‚
**Theorem 5.3** (Quantum Error Correction Code Existence Theorem) For any finite error set, there exists a quantum error correction code that can correct these errors.

**è¯æ˜ / Proof:**
è®¾ $\mathcal{E} = \{E_1, E_2, \ldots, E_n\}$ ä¸ºé”™è¯¯é›†åˆã€‚
Let $\mathcal{E} = \{E_1, E_2, \ldots, E_n\}$ be the error set.

æ„é€ ç¼–ç å­ç©ºé—´ $\mathcal{C}$ ä½¿å¾—ï¼š
Construct the code subspace $\mathcal{C}$ such that:

$$\forall E_i, E_j \in \mathcal{E}, \forall |\psi\rangle, |\phi\rangle \in \mathcal{C}: \langle\psi|E_i^\dagger E_j|\phi\rangle = c_{ij} \langle\psi|\phi\rangle$$

è¿™å¯ä»¥é€šè¿‡é€‰æ‹©åˆé€‚çš„æ­£äº¤åŸºå®ç°ã€‚
This can be achieved by choosing appropriate orthogonal bases.

**å®šç† 5.4** (Knill-Laflammeæ¡ä»¶å®šç†) é‡å­çº é”™ç çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ï¼š
**Theorem 5.4** (Knill-Laflamme Condition Theorem) The necessary and sufficient condition for quantum error correction is:

$$\forall E_i, E_j \in \mathcal{E}, \forall |\psi\rangle, |\phi\rangle \in \mathcal{C}: \langle\psi|E_i^\dagger E_j|\phi\rangle = c_{ij} \langle\psi|\phi\rangle$$

å…¶ä¸­ $c_{ij}$ ä¸ºå¸¸æ•°ã€‚
where $c_{ij}$ are constants.

**è¯æ˜ / Proof:**
**å¿…è¦æ€§ / Necessity:** å¦‚æœå­˜åœ¨çº é”™æ“ä½œ $\mathcal{R}$ï¼Œåˆ™ï¼š
If there exists a correction operation $\mathcal{R}$, then:

$$\mathcal{R}(E_i|\psi\rangle) = |\psi\rangle, \quad \mathcal{R}(E_j|\phi\rangle) = |\phi\rangle$$

å› æ­¤ï¼š
Therefore:

$$\langle\psi|E_i^\dagger E_j|\phi\rangle = \langle\psi|\mathcal{R}^\dagger\mathcal{R}E_i^\dagger E_j|\phi\rangle = c_{ij} \langle\psi|\phi\rangle$$

**å……åˆ†æ€§ / Sufficiency:** å¦‚æœæ¡ä»¶æ»¡è¶³ï¼Œå¯ä»¥æ„é€ çº é”™æ“ä½œï¼š
If the condition is satisfied, we can construct the correction operation:

$$\mathcal{R}(\rho) = \sum_k P_k \rho P_k$$

å…¶ä¸­ $P_k$ ä¸ºæŠ•å½±åˆ°é”™è¯¯å­ç©ºé—´çš„æŠ•å½±ç®—å­ã€‚
where $P_k$ are projection operators onto error subspaces.

### ç¨³å®šå­ç ç†è®º / Stabilizer Code Theory

**å®šä¹‰ 5.3** ç¨³å®šå­ç æ˜¯ç”±ç¨³å®šå­ç¾¤å®šä¹‰çš„é‡å­çº é”™ç ã€‚
**Definition 5.3** A stabilizer code is a quantum error correction code defined by a stabilizer group.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\mathcal{S} = \langle S_1, S_2, \ldots, S_{n-k} \rangle$ ä¸ºç¨³å®šå­ç¾¤ï¼Œå…¶ä¸­ $S_i$ ä¸ºæ³¡åˆ©ç®—å­ã€‚
Let $\mathcal{S} = \langle S_1, S_2, \ldots, S_{n-k} \rangle$ be the stabilizer group, where $S_i$ are Pauli operators.

ç¼–ç å­ç©ºé—´ä¸ºï¼š
The code subspace is:

$$\mathcal{C} = \{|\psi\rangle : S_i|\psi\rangle = |\psi\rangle, \forall S_i \in \mathcal{S}\}$$

**å®šç† 5.5** (ç¨³å®šå­ç ç»´åº¦å®šç†) å¯¹äº $n$ ä¸ªç‰©ç†é‡å­æ¯”ç‰¹çš„ç¨³å®šå­ç ï¼Œç¼–ç  $k$ ä¸ªé€»è¾‘é‡å­æ¯”ç‰¹ï¼Œç¨³å®šå­ç¾¤çš„å¤§å°ä¸ºï¼š
**Theorem 5.5** (Stabilizer Code Dimension Theorem) For a stabilizer code on $n$ physical qubits encoding $k$ logical qubits, the size of the stabilizer group is:

$$|\mathcal{S}| = 2^{n-k}$$

**è¯æ˜ / Proof:**
ç¨³å®šå­ç¾¤æ˜¯é˜¿è´å°”ç¾¤ï¼Œæ¯ä¸ªç”Ÿæˆå…ƒ $S_i$ çš„é˜¶ä¸º 2ã€‚
The stabilizer group is abelian, and each generator $S_i$ has order 2.

å› æ­¤ç¾¤çš„å¤§å°ä¸º $2^{n-k}$ã€‚
Therefore the group size is $2^{n-k}$.

**å®šç† 5.6** (ç¨³å®šå­ç è·ç¦»å®šç†) ç¨³å®šå­ç çš„è·ç¦» $d$ æ˜¯èƒ½å¤Ÿè¢«æ£€æµ‹çš„æœ€å°é”™è¯¯æƒé‡ã€‚
**Theorem 5.6** (Stabilizer Code Distance Theorem) The distance $d$ of a stabilizer code is the minimum weight of errors that can be detected.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
$$d = \min\{w(E) : E \notin \mathcal{S}, E \in \mathcal{P}_n\}$$

å…¶ä¸­ $\mathcal{P}_n$ ä¸º $n$ é‡å­æ¯”ç‰¹çš„æ³¡åˆ©ç¾¤ï¼Œ$w(E)$ ä¸ºé”™è¯¯ $E$ çš„æƒé‡ã€‚
where $\mathcal{P}_n$ is the Pauli group on $n$ qubits, and $w(E)$ is the weight of error $E$.

**è¯æ˜ / Proof:**
å¦‚æœ $E \in \mathcal{S}$ï¼Œåˆ™ $E$ ä¸èƒ½æ”¹å˜ç¼–ç çŠ¶æ€ã€‚
If $E \in \mathcal{S}$, then $E$ cannot change the encoded state.

å¦‚æœ $E \notin \mathcal{S}$ ä¸”æƒé‡å°äº $d$ï¼Œåˆ™ $E$ å¯ä»¥è¢«æ£€æµ‹ã€‚
If $E \notin \mathcal{S}$ and has weight less than $d$, then $E$ can be detected.

### é‡å­çº é”™ç  / Quantum Error Correction Codes

é‡å­çº é”™ç æ˜¯ä¿æŠ¤é‡å­ä¿¡æ¯å…å—å™ªå£°å½±å“çš„æŠ€æœ¯ã€‚

#### é”™è¯¯æ¨¡å‹ç†è®º / Error Model Theory

**å®šä¹‰ 5.4** é‡å­é”™è¯¯æ¨¡å‹æ˜¯æè¿°é‡å­ç³»ç»Ÿå™ªå£°çš„æ•°å­¦æ¨¡å‹ã€‚
**Definition 5.4** A quantum error model is a mathematical model describing noise in quantum systems.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\mathcal{E}$ ä¸ºé”™è¯¯é›†åˆï¼Œé”™è¯¯æ¨¡å‹ä¸ºï¼š
Let $\mathcal{E}$ be the error set, the error model is:

$$\mathcal{N}(\rho) = \sum_{E \in \mathcal{E}} p_E E \rho E^\dagger$$

å…¶ä¸­ $p_E$ ä¸ºé”™è¯¯ $E$ çš„æ¦‚ç‡ã€‚
where $p_E$ is the probability of error $E$.

**å®šç† 5.7** (æ³¡åˆ©é”™è¯¯æ¨¡å‹å®šç†) å¯¹äºå•é‡å­æ¯”ç‰¹ç³»ç»Ÿï¼Œä»»æ„é”™è¯¯éƒ½å¯ä»¥è¡¨ç¤ºä¸ºæ³¡åˆ©ç®—å­çš„çº¿æ€§ç»„åˆã€‚
**Theorem 5.7** (Pauli Error Model Theorem) For single-qubit systems, any error can be expressed as a linear combination of Pauli operators.

**è¯æ˜ / Proof:**
ä»»æ„ $2 \times 2$ çŸ©é˜µå¯ä»¥è¡¨ç¤ºä¸ºï¼š
Any $2 \times 2$ matrix can be expressed as:

$$E = aI + bX + cY + dZ$$

å…¶ä¸­ $X, Y, Z$ ä¸ºæ³¡åˆ©çŸ©é˜µï¼Œ$a, b, c, d \in \mathbb{C}$ã€‚
where $X, Y, Z$ are Pauli matrices, and $a, b, c, d \in \mathbb{C}$.

**å®šç† 5.8** (é”™è¯¯æƒé‡å®šç†) é”™è¯¯çš„æƒé‡å®šä¹‰ä¸ºé”™è¯¯å½±å“çš„é‡å­æ¯”ç‰¹æ•°é‡ã€‚
**Theorem 5.8** (Error Weight Theorem) The weight of an error is defined as the number of qubits affected by the error.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
å¯¹äºæ³¡åˆ©é”™è¯¯ $E = \otimes_{i=1}^n E_i$ï¼Œæƒé‡ä¸ºï¼š
For Pauli error $E = \otimes_{i=1}^n E_i$, the weight is:

$$w(E) = |\{i : E_i \neq I\}|$$

**å®šç† 5.9** (é”™è¯¯æ£€æµ‹å®šç†) é‡å­çº é”™ç èƒ½å¤Ÿæ£€æµ‹æƒé‡å°äº $d$ çš„æ‰€æœ‰é”™è¯¯ã€‚
**Theorem 5.9** (Error Detection Theorem) A quantum error correction code can detect all errors with weight less than $d$.

**è¯æ˜ / Proof:**
è®¾ $E$ ä¸ºæƒé‡ $w(E) < d$ çš„é”™è¯¯ã€‚
Let $E$ be an error with weight $w(E) < d$.

ç”±äº $E \notin \mathcal{S}$ï¼Œä¸” $w(E) < d$ï¼Œæ ¹æ®è·ç¦»å®šä¹‰ï¼Œ$E$ å¯ä»¥è¢«æ£€æµ‹ã€‚
Since $E \notin \mathcal{S}$ and $w(E) < d$, by the distance definition, $E$ can be detected.

#### é”™è¯¯çº æ­£ç†è®º / Error Correction Theory

**å®šä¹‰ 5.5** é”™è¯¯çº æ­£æ˜¯å°†é”™è¯¯çŠ¶æ€æ¢å¤åˆ°æ­£ç¡®çŠ¶æ€çš„è¿‡ç¨‹ã€‚
**Definition 5.5** Error correction is the process of recovering the correct state from an erroneous state.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\mathcal{R}$ ä¸ºçº é”™æ“ä½œï¼Œåˆ™ï¼š
Let $\mathcal{R}$ be the correction operation, then:

$$\mathcal{R}(\mathcal{N}(\rho)) = \rho$$

å¯¹äºæ‰€æœ‰ç¼–ç çŠ¶æ€ $\rho$ã€‚
for all encoded states $\rho$.

**å®šç† 5.10** (é”™è¯¯çº æ­£å……åˆ†æ¡ä»¶å®šç†) å¦‚æœé”™è¯¯é›†åˆ $\mathcal{E}$ æ»¡è¶³ï¼š
**Theorem 5.10** (Error Correction Sufficient Condition Theorem) If the error set $\mathcal{E}$ satisfies:

$$\forall E_i, E_j \in \mathcal{E}, \forall |\psi\rangle, |\phi\rangle \in \mathcal{C}: \langle\psi|E_i^\dagger E_j|\phi\rangle = c_{ij} \langle\psi|\phi\rangle$$

åˆ™å­˜åœ¨çº é”™æ“ä½œ $\mathcal{R}$ã€‚
then there exists a correction operation $\mathcal{R}$.

**è¯æ˜ / Proof:**
æ„é€ çº é”™æ“ä½œï¼š
Construct the correction operation:

$$\mathcal{R}(\rho) = \sum_k P_k \rho P_k$$

å…¶ä¸­ $P_k$ ä¸ºæŠ•å½±åˆ°é”™è¯¯å­ç©ºé—´çš„æŠ•å½±ç®—å­ã€‚
where $P_k$ are projection operators onto error subspaces.

**å®šç† 5.11** (é”™è¯¯çº æ­£ç‡å®šç†) é”™è¯¯çº æ­£çš„æˆåŠŸæ¦‚ç‡ä¸ºï¼š
**Theorem 5.11** (Error Correction Rate Theorem) The success probability of error correction is:

$$P_{success} = \sum_{E \in \mathcal{E}_{correctable}} p_E$$

å…¶ä¸­ $\mathcal{E}_{correctable}$ ä¸ºå¯çº æ­£é”™è¯¯é›†åˆã€‚
where $\mathcal{E}_{correctable}$ is the set of correctable errors.

**è¯æ˜ / Proof:**
å¯¹äºå¯çº æ­£é”™è¯¯ $E$ï¼Œçº é”™æ“ä½œ $\mathcal{R}$ æ»¡è¶³ï¼š
For correctable error $E$, the correction operation $\mathcal{R}$ satisfies:

$$\mathcal{R}(E|\psi\rangle) = |\psi\rangle$$

å› æ­¤æˆåŠŸæ¦‚ç‡ä¸ºå¯çº æ­£é”™è¯¯çš„æ¦‚ç‡ä¹‹å’Œã€‚
Therefore the success probability is the sum of probabilities of correctable errors.

```rust
// é‡å­çº é”™ç å®ç°
pub struct QuantumErrorCorrectionCode {
    stabilizers: Vec<Matrix>,
    logical_operators: Vec<Matrix>,
    code_distance: usize,
}

impl QuantumErrorCorrectionCode {
    pub fn new(stabilizers: Vec<Matrix>, logical_operators: Vec<Matrix>, code_distance: usize) -> Self {
        QuantumErrorCorrectionCode {
            stabilizers,
            logical_operators,
            code_distance,
        }
    }

    pub fn encode(&self, logical_state: &QuantumState) -> QuantumState {
        // ç¼–ç é€»è¾‘é‡å­æ¯”ç‰¹åˆ°ç‰©ç†é‡å­æ¯”ç‰¹
        let mut encoded_state = logical_state.clone();

        // åº”ç”¨ç¨³å®šå­
        for stabilizer in &self.stabilizers {
            encoded_state = stabilizer.apply(encoded_state);
        }

        encoded_state
    }

    pub fn decode(&self, noisy_state: &QuantumState) -> QuantumState {
        // ä»å™ªå£°çŠ¶æ€è§£ç é€»è¾‘é‡å­æ¯”ç‰¹
        let syndrome = self.measure_syndrome(noisy_state);
        let corrected_state = self.correct_errors(noisy_state, &syndrome);

        self.extract_logical_state(&corrected_state)
    }

    pub fn detect_errors(&self, state: &QuantumState) -> Vec<bool> {
        // æ£€æµ‹é”™è¯¯
        let mut syndrome = Vec::new();

        for stabilizer in &self.stabilizers {
            let measurement = self.measure_stabilizer(state, stabilizer);
            syndrome.push(measurement);
        }

        syndrome
    }

    fn measure_syndrome(&self, state: &QuantumState) -> Vec<bool> {
        // æµ‹é‡é”™è¯¯ç»¼åˆå¾
        self.detect_errors(state)
    }

    fn correct_errors(&self, state: &QuantumState, syndrome: &[bool]) -> QuantumState {
        // æ ¹æ®ç»¼åˆå¾çº æ­£é”™è¯¯
        let error_operator = self.find_error_operator(syndrome);
        error_operator.apply(state.clone())
    }

    fn find_error_operator(&self, syndrome: &[bool]) -> Matrix {
        // æ ¹æ®ç»¼åˆå¾æ‰¾åˆ°å¯¹åº”çš„é”™è¯¯ç®—å­
        // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„æŸ¥æ‰¾ç®—æ³•
        Matrix::identity(self.stabilizers[0].rows())
    }
}

// ä¸‰é‡å­æ¯”ç‰¹é‡å¤ç 
pub struct ThreeQubitRepetitionCode;

impl ThreeQubitRepetitionCode {
    pub fn new() -> QuantumErrorCorrectionCode {
        let stabilizers = vec![
            Matrix::new(8, 8, vec![1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                                   0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                                   0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                                   0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0,
                                   0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0,
                                   0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0,
                                   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
                                   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]), // Z1Z2
        ];

        let logical_operators = vec![
            Matrix::new(8, 8, vec![1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                                   0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                                   0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                                   0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
                                   0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
                                   0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                                   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
                                   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]), // X1X2X3
        ];

        QuantumErrorCorrectionCode::new(stabilizers, logical_operators, 1)
    }
}
```

## é‡å­å‹ç¼©ç†è®º / Quantum Compression Theory

### é‡å­å‹ç¼©åŸºç¡€ç†è®º / Quantum Compression Foundation Theory

**å®šä¹‰ 6.1** é‡å­å‹ç¼©æ˜¯å°†é‡å­ä¿¡æ¯ç¼–ç ä¸ºæ›´å°‘é‡å­æ¯”ç‰¹çš„è¿‡ç¨‹ã€‚
**Definition 6.1** Quantum compression is the process of encoding quantum information into fewer qubits.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\mathcal{H}_S$ ä¸ºæºå¸Œå°”ä¼¯ç‰¹ç©ºé—´ï¼Œ$\mathcal{H}_C$ ä¸ºå‹ç¼©å¸Œå°”ä¼¯ç‰¹ç©ºé—´ï¼Œé‡å­å‹ç¼©ä¸ºï¼š
Let $\mathcal{H}_S$ be the source Hilbert space, $\mathcal{H}_C$ be the compressed Hilbert space, quantum compression is:

$$\mathcal{C}: \mathcal{H}_S \rightarrow \mathcal{H}_C$$

å…¶ä¸­ $\dim(\mathcal{H}_C) < \dim(\mathcal{H}_S)$ã€‚
where $\dim(\mathcal{H}_C) < \dim(\mathcal{H}_S)$.

**å®šç† 6.1** (é‡å­å‹ç¼©å­˜åœ¨æ€§å®šç†) å¯¹äºä»»æ„é‡å­æºï¼Œéƒ½å­˜åœ¨å‹ç¼©ç¼–ç ã€‚
**Theorem 6.1** (Quantum Compression Existence Theorem) For any quantum source, there exists a compression encoding.

**è¯æ˜ / Proof:**
è®¾é‡å­æº $\rho$ çš„å†¯Â·è¯ºä¾æ›¼ç†µä¸º $S(\rho)$ã€‚
Let the von Neumann entropy of quantum source $\rho$ be $S(\rho)$.

æ ¹æ®å…¸å‹å­ç©ºé—´ç†è®ºï¼Œå­˜åœ¨ç»´åº¦ä¸º $2^{nS(\rho)}$ çš„å…¸å‹å­ç©ºé—´ã€‚
By the typical subspace theory, there exists a typical subspace with dimension $2^{nS(\rho)}$.

**å®šç† 6.2** (é‡å­å‹ç¼©æé™å®šç†) é‡å­å‹ç¼©çš„ç†è®ºæé™ç”±å†¯Â·è¯ºä¾æ›¼ç†µå†³å®šã€‚
**Theorem 6.2** (Quantum Compression Limit Theorem) The theoretical limit of quantum compression is determined by the von Neumann entropy.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
å¯¹äºé‡å­æº $\rho$ï¼Œå‹ç¼©ç‡çš„ä¸‹ç•Œä¸ºï¼š
For quantum source $\rho$, the lower bound of compression ratio is:

$$R \geq S(\rho)$$

å…¶ä¸­ $R$ ä¸ºå‹ç¼©ç‡ï¼ˆæ¯”ç‰¹/é‡å­æ¯”ç‰¹ï¼‰ã€‚
where $R$ is the compression rate (bits per qubit).

**è¯æ˜ / Proof:**
æ ¹æ®é‡å­æ•°æ®å¤„ç†ä¸ç­‰å¼ï¼š
By the quantum data processing inequality:

$$S(\mathcal{C}(\rho)) \geq S(\rho)$$

å› æ­¤å‹ç¼©ç‡ä¸èƒ½å°äºå†¯Â·è¯ºä¾æ›¼ç†µã€‚
Therefore the compression rate cannot be less than the von Neumann entropy.

### é‡å­æ•°æ®å‹ç¼© / Quantum Data Compression

é‡å­æ•°æ®å‹ç¼©æ˜¯å‡å°‘é‡å­ä¿¡æ¯å­˜å‚¨ç©ºé—´çš„æŠ€æœ¯ã€‚

#### Schumacherå‹ç¼©ç†è®º / Schumacher Compression Theory

**å®šä¹‰ 6.2** Schumacherå‹ç¼©æ˜¯åŸºäºå…¸å‹å­ç©ºé—´çš„é‡å­å‹ç¼©æ–¹æ³•ã€‚
**Definition 6.2** Schumacher compression is a quantum compression method based on typical subspaces.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\rho^{\otimes n}$ ä¸º $n$ ä¸ªç›¸åŒçš„é‡å­æ€ï¼Œå…¸å‹å­ç©ºé—´ä¸ºï¼š
Let $\rho^{\otimes n}$ be $n$ identical quantum states, the typical subspace is:

$$\mathcal{T}_\delta^{(n)} = \text{span}\{|\lambda_1, \lambda_2, \ldots, \lambda_n\rangle : |\frac{1}{n}\sum_{i=1}^n \lambda_i - S(\rho)| \leq \delta\}$$

å…¶ä¸­ $\lambda_i$ ä¸º $\rho$ çš„ç‰¹å¾å€¼ã€‚
where $\lambda_i$ are eigenvalues of $\rho$.

**å®šç† 6.3** (å…¸å‹å­ç©ºé—´ç»´åº¦å®šç†) å…¸å‹å­ç©ºé—´çš„ç»´åº¦ä¸ºï¼š
**Theorem 6.3** (Typical Subspace Dimension Theorem) The dimension of the typical subspace is:

$$\dim(\mathcal{T}_\delta^{(n)}) \approx 2^{nS(\rho)}$$

**è¯æ˜ / Proof:**
æ ¹æ®å¤§æ•°å®šå¾‹ï¼Œå¯¹äºè¶³å¤Ÿå¤§çš„ $n$ï¼š
By the law of large numbers, for sufficiently large $n$:

$$\frac{1}{n}\sum_{i=1}^n \lambda_i \rightarrow S(\rho)$$

å› æ­¤å…¸å‹å­ç©ºé—´çš„ç»´åº¦çº¦ä¸º $2^{nS(\rho)}$ã€‚
Therefore the dimension of the typical subspace is approximately $2^{nS(\rho)}$.

**å®šç† 6.4** (Schumacherå‹ç¼©å®šç†) å¯¹äºä»»æ„ $\epsilon > 0$ï¼Œå­˜åœ¨å‹ç¼©ç¼–ç  $\mathcal{C}$ å’Œè§£ç  $\mathcal{D}$ ä½¿å¾—ï¼š
**Theorem 6.4** (Schumacher Compression Theorem) For any $\epsilon > 0$, there exist compression encoding $\mathcal{C}$ and decoding $\mathcal{D}$ such that:

$$F(\mathcal{D} \circ \mathcal{C}(\rho^{\otimes n}), \rho^{\otimes n}) \geq 1 - \epsilon$$

å…¶ä¸­ $F$ ä¸ºä¿çœŸåº¦ã€‚
where $F$ is the fidelity.

**è¯æ˜ / Proof:**
æ„é€ å‹ç¼©ç¼–ç ï¼š
Construct the compression encoding:

$$\mathcal{C}(\rho^{\otimes n}) = P_{\mathcal{T}_\delta^{(n)}} \rho^{\otimes n} P_{\mathcal{T}_\delta^{(n)}}$$

å…¶ä¸­ $P_{\mathcal{T}_\delta^{(n)}}$ ä¸ºæŠ•å½±åˆ°å…¸å‹å­ç©ºé—´çš„æŠ•å½±ç®—å­ã€‚
where $P_{\mathcal{T}_\delta^{(n)}}$ is the projection operator onto the typical subspace.

**å®šç† 6.5** (é‡å­å‹ç¼©ç‡å®šç†) é‡å­å‹ç¼©çš„æ¸è¿‘å‹ç¼©ç‡ä¸ºï¼š
**Theorem 6.5** (Quantum Compression Rate Theorem) The asymptotic compression rate is:

$$R = \lim_{n \rightarrow \infty} \frac{\log_2 \dim(\mathcal{T}_\delta^{(n)})}{n} = S(\rho)$$

**è¯æ˜ / Proof:**
ç”±å…¸å‹å­ç©ºé—´ç»´åº¦å®šç†ï¼š
By the typical subspace dimension theorem:

$$\dim(\mathcal{T}_\delta^{(n)}) \approx 2^{nS(\rho)}$$

å› æ­¤ï¼š
Therefore:

$$R = \lim_{n \rightarrow \infty} \frac{\log_2 2^{nS(\rho)}}{n} = S(\rho)$$

#### é‡å­æºç¼–ç ç†è®º / Quantum Source Coding Theory

**å®šä¹‰ 6.3** é‡å­æºç¼–ç æ˜¯å¤„ç†é‡å­ä¿¡æ¯æºçš„ç¼–ç æ–¹æ³•ã€‚
**Definition 6.3** Quantum source coding is an encoding method for processing quantum information sources.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
è®¾ $\mathcal{S} = \{\rho_i, p_i\}_{i=1}^N$ ä¸ºé‡å­æºï¼Œæºç¼–ç ä¸ºï¼š
Let $\mathcal{S} = \{\rho_i, p_i\}_{i=1}^N$ be a quantum source, source coding is:

$$\mathcal{E}: \{\rho_i\} \rightarrow \{|\psi_i\rangle\}$$

å…¶ä¸­ $|\psi_i\rangle$ ä¸ºç¼–ç åçš„çº¯æ€ã€‚
where $|\psi_i\rangle$ are encoded pure states.

**å®šç† 6.6** (é‡å­æºç¼–ç å®šç†) é‡å­æºç¼–ç çš„æœ€å°å¹³å‡é•¿åº¦ç”±å†¯Â·è¯ºä¾æ›¼ç†µå†³å®šã€‚
**Theorem 6.6** (Quantum Source Coding Theorem) The minimum average length of quantum source coding is determined by the von Neumann entropy.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**
å¯¹äºé‡å­æº $\mathcal{S}$ï¼Œæœ€å°å¹³å‡é•¿åº¦ä¸ºï¼š
For quantum source $\mathcal{S}$, the minimum average length is:

$$L_{min} = S(\rho_{avg})$$

å…¶ä¸­ $\rho_{avg} = \sum_i p_i \rho_i$ã€‚
where $\rho_{avg} = \sum_i p_i \rho_i$.

**è¯æ˜ / Proof:**
æ ¹æ®é‡å­å‹ç¼©æé™å®šç†ï¼š
By the quantum compression limit theorem:

$$L \geq S(\rho_{avg})$$

ä¸”å­˜åœ¨ç¼–ç è¾¾åˆ°æ­¤æé™ã€‚
And there exists encoding that achieves this limit.

```rust
// é‡å­æ•°æ®å‹ç¼©å®ç°
pub struct QuantumCompression {
    schumacher_compression: SchumacherCompression,
    quantum_source_coding: QuantumSourceCoding,
}

impl QuantumCompression {
    pub fn compress(&self, quantum_source: &QuantumSource, compression_ratio: f64) -> CompressedData {
        // ä½¿ç”¨Schumacherå‹ç¼©
        let compressed_state = self.schumacher_compression.compress(quantum_source, compression_ratio);

        CompressedData {
            compressed_state,
            compression_ratio,
            original_entropy: quantum_source.von_neumann_entropy(),
        }
    }

    pub fn decompress(&self, compressed_data: &CompressedData) -> QuantumState {
        // è§£å‹ç¼©é‡å­æ•°æ®
        self.schumacher_compression.decompress(&compressed_data.compressed_state)
    }

    pub fn compression_efficiency(&self, quantum_source: &QuantumSource) -> f64 {
        // è®¡ç®—å‹ç¼©æ•ˆç‡
        let original_size = quantum_source.state_count();
        let compressed_size = self.schumacher_compression.compressed_size(quantum_source);

        compressed_size as f64 / original_size as f64
    }
}

// Schumacherå‹ç¼©
pub struct SchumacherCompression;

impl SchumacherCompression {
    pub fn compress(&self, quantum_source: &QuantumSource, compression_ratio: f64) -> QuantumState {
        // 1. è®¡ç®—å…¸å‹å­ç©ºé—´
        let typical_subspace = self.calculate_typical_subspace(quantum_source);

        // 2. æŠ•å½±åˆ°å…¸å‹å­ç©ºé—´
        let projected_state = self.project_to_typical_subspace(quantum_source.state(), &typical_subspace);

        // 3. å‹ç¼©è¡¨ç¤º
        self.compress_representation(&projected_state, compression_ratio)
    }

    pub fn decompress(&self, compressed_state: &QuantumState) -> QuantumState {
        // è§£å‹ç¼©è¿‡ç¨‹
        let decompressed_representation = self.decompress_representation(compressed_state);
        self.reconstruct_state(&decompressed_representation)
    }

    fn calculate_typical_subspace(&self, quantum_source: &QuantumSource) -> Matrix {
        // è®¡ç®—å…¸å‹å­ç©ºé—´
        let entropy = quantum_source.von_neumann_entropy();
        let dimension = quantum_source.state().dimension();
        let typical_dimension = (2.0_f64.powf(entropy * dimension as f64)) as usize;

        // æ„å»ºå…¸å‹å­ç©ºé—´æŠ•å½±ç®—å­
        let mut projection = Matrix::zeros(dimension, dimension);
        for i in 0..typical_dimension {
            projection.set(i, i, 1.0);
        }

        projection
    }

    fn project_to_typical_subspace(&self, state: &QuantumState, projection: &Matrix) -> QuantumState {
        // å°†çŠ¶æ€æŠ•å½±åˆ°å…¸å‹å­ç©ºé—´
        let projected_matrix = projection.multiply(&state.density_matrix());
        projected_matrix.multiply(projection)
    }
}

// é‡å­æº
pub struct QuantumSource {
    states: Vec<QuantumState>,
    probabilities: Vec<f64>,
}

impl QuantumSource {
    pub fn new(states: Vec<QuantumState>, probabilities: Vec<f64>) -> Self {
        QuantumSource { states, probabilities }
    }

    pub fn von_neumann_entropy(&self) -> f64 {
        let density_matrix = self.average_density_matrix();
        VonNeumannEntropy.calculate(&density_matrix.matrix)
    }

    pub fn state_count(&self) -> usize {
        self.states.len()
    }

    pub fn state(&self) -> &QuantumState {
        &self.states[0] // ç®€åŒ–å®ç°
    }

    fn average_density_matrix(&self) -> DensityMatrix {
        let mut average = Matrix::zeros(self.states[0].dimension(), self.states[0].dimension());

        for (state, probability) in self.states.iter().zip(self.probabilities.iter()) {
            let density = DensityMatrix::from_pure_state(state);
            let weighted_density = density.matrix.scalar_multiply(*probability);
            average = average.add(&weighted_density);
        }

        DensityMatrix {
            matrix: average,
            dimension: self.states[0].dimension(),
        }
    }
}
```

## å®ç°ç¤ºä¾‹ / Implementation Examples

### å®Œæ•´çš„é‡å­ä¿¡æ¯å¤„ç†ç³»ç»Ÿ / Complete Quantum Information Processing System

```rust
// å®Œæ•´çš„é‡å­ä¿¡æ¯å¤„ç†ç³»ç»Ÿ
pub struct QuantumInformationSystem {
    entropy_calculator: VonNeumannEntropy,
    channel_simulator: QuantumChannel,
    entanglement_analyzer: EntanglementMeasures,
    error_correction: QuantumErrorCorrectionCode,
    compression: QuantumCompression,
}

impl QuantumInformationSystem {
    pub fn analyze_quantum_state(&self, state: &QuantumState) -> QuantumAnalysis {
        let density_matrix = DensityMatrix::from_pure_state(state);

        QuantumAnalysis {
            von_neumann_entropy: self.entropy_calculator.calculate(&density_matrix.matrix),
            purity: self.calculate_purity(&density_matrix),
            fidelity: self.calculate_fidelity(state, state),
        }
    }

    pub fn simulate_channel_transmission(&self, input_state: &QuantumState,
                                       channel: &QuantumChannel) -> ChannelResult {
        let input_density = DensityMatrix::from_pure_state(input_state);
        let output_density = channel.apply(&input_density);

        ChannelResult {
            input_state: input_density,
            output_state: output_density,
            channel_capacity: channel.channel_capacity(),
            mutual_information: self.calculate_mutual_information(&input_density, &output_density),
        }
    }

    pub fn analyze_entanglement(&self, state: &QuantumState) -> EntanglementAnalysis {
        let density_matrix = DensityMatrix::from_pure_state(state);

        EntanglementAnalysis {
            concurrence: self.entanglement_analyzer.concurrence(&density_matrix),
            negativity: self.entanglement_analyzer.negativity(&density_matrix),
            von_neumann_entropy: self.entanglement_analyzer.von_neumann_entropy_of_entanglement(state),
        }
    }

    pub fn error_correction_demo(&self) -> ErrorCorrectionDemo {
        // åˆ›å»ºé€»è¾‘çŠ¶æ€
        let logical_state = QuantumState::new(vec![1.0, 0.0]); // |0âŸ©

        // ç¼–ç 
        let encoded_state = self.error_correction.encode(&logical_state);

        // å¼•å…¥é”™è¯¯
        let noisy_state = self.introduce_errors(&encoded_state);

        // è§£ç å’Œçº æ­£
        let corrected_state = self.error_correction.decode(&noisy_state);

        ErrorCorrectionDemo {
            original: logical_state,
            encoded: encoded_state,
            noisy: noisy_state,
            corrected: corrected_state,
        }
    }

    pub fn compression_demo(&self) -> CompressionDemo {
        // åˆ›å»ºé‡å­æº
        let states = vec![
            QuantumState::new(vec![1.0, 0.0]), // |0âŸ©
            QuantumState::new(vec![0.0, 1.0]), // |1âŸ©
        ];
        let probabilities = vec![0.7, 0.3];
        let quantum_source = QuantumSource::new(states, probabilities);

        // å‹ç¼©
        let compressed_data = self.compression.compress(&quantum_source, 0.5);

        // è§£å‹ç¼©
        let decompressed_state = self.compression.decompress(&compressed_data);

        CompressionDemo {
            original_source: quantum_source,
            compressed_data,
            decompressed_state,
        }
    }

    fn calculate_purity(&self, density_matrix: &DensityMatrix) -> f64 {
        let squared = density_matrix.matrix.multiply(&density_matrix.matrix);
        squared.trace()
    }

    fn calculate_fidelity(&self, state1: &QuantumState, state2: &QuantumState) -> f64 {
        let overlap = state1.inner_product(state2);
        overlap.norm().powi(2)
    }

    fn calculate_mutual_information(&self, rho_a: &DensityMatrix, rho_b: &DensityMatrix) -> f64 {
        // ç®€åŒ–å®ç°ï¼Œå‡è®¾ç‹¬ç«‹ç³»ç»Ÿ
        let entropy_a = self.entropy_calculator.calculate(&rho_a.matrix);
        let entropy_b = self.entropy_calculator.calculate(&rho_b.matrix);
        let entropy_ab = self.entropy_calculator.calculate(&rho_a.matrix.add(&rho_b.matrix));

        entropy_a + entropy_b - entropy_ab
    }

    fn introduce_errors(&self, state: &QuantumState) -> QuantumState {
        // å¼•å…¥éšæœºé”™è¯¯
        let error_channel = DepolarizingChannel::new(0.1, 2);
        let density_matrix = DensityMatrix::from_pure_state(state);
        let noisy_density = error_channel.apply(&density_matrix);

        // è½¬æ¢å›é‡å­æ€ï¼ˆç®€åŒ–ï¼‰
        QuantumState::new(vec![1.0, 0.0])
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let quantum_system = QuantumInformationSystem::new();

    // åˆ†æé‡å­æ€
    let state = QuantumState::new(vec![1.0/2.0_f64.sqrt(), 1.0/2.0_f64.sqrt()]);
    let analysis = quantum_system.analyze_quantum_state(&state);
    println!("Quantum state analysis: {:?}", analysis);

    // ä¿¡é“ä¼ è¾“æ¨¡æ‹Ÿ
    let channel = DepolarizingChannel::new(0.1, 2);
    let result = quantum_system.simulate_channel_transmission(&state, &channel);
    println!("Channel transmission result: {:?}", result);

    // çº ç¼ åˆ†æ
    let bell_state = QuantumState::new(vec![1.0/2.0_f64.sqrt(), 0.0, 0.0, 1.0/2.0_f64.sqrt()]);
    let entanglement = quantum_system.analyze_entanglement(&bell_state);
    println!("Entanglement analysis: {:?}", entanglement);

    // é”™è¯¯çº æ­£æ¼”ç¤º
    let error_demo = quantum_system.error_correction_demo();
    println!("Error correction demo: {:?}", error_demo);

    // å‹ç¼©æ¼”ç¤º
    let compression_demo = quantum_system.compression_demo();
    println!("Compression demo: {:?}", compression_demo);
}
```

## æ€»ç»“ / Summary

æœ¬æ–‡æ¡£ä»‹ç»äº†é‡å­ä¿¡æ¯è®ºä¸é‡å­ç¼–ç çš„æ ¸å¿ƒæ¦‚å¿µï¼ŒåŒ…æ‹¬ï¼š

1. **é‡å­ç†µç†è®º**: å†¯Â·è¯ºä¾æ›¼ç†µã€ç›¸å¯¹ç†µç­‰ç†µåº¦é‡
2. **é‡å­ä¿¡é“ç†è®º**: é‡å­ä¿¡é“æ¨¡å‹å’Œä¿¡é“å®¹é‡
3. **é‡å­çº ç¼ ç†è®º**: çº ç¼ åº¦é‡å’Œçº ç¼ æ£€æµ‹
4. **é‡å­ç¼–ç ç†è®º**: é‡å­çº é”™ç å’Œé”™è¯¯çº æ­£
5. **é‡å­å‹ç¼©ç†è®º**: é‡å­æ•°æ®å‹ç¼©å’ŒSchumacherå‹ç¼©

è¿™äº›ç†è®ºä¸ºé‡å­ä¿¡æ¯å¤„ç†æä¾›äº†å®Œæ•´çš„æ•°å­¦æ¡†æ¶ã€‚

This document introduces core concepts of quantum information theory and quantum coding, including:

1. **Quantum Entropy Theory**: Von Neumann entropy, relative entropy, and other entropy measures
2. **Quantum Channel Theory**: Quantum channel models and channel capacity
3. **Quantum Entanglement Theory**: Entanglement measures and entanglement detection
4. **Quantum Coding Theory**: Quantum error correction codes and error correction
5. **Quantum Compression Theory**: Quantum data compression and Schumacher compression

These theories provide a complete mathematical framework for quantum information processing.

## äº¤å‰å¼•ç”¨ä¸ä¾èµ– / Cross-References and Dependencies

- é‡å­å¤æ‚æ€§ä¸ç®—æ³•ï¼š`10-é«˜çº§ä¸»é¢˜/08-é‡å­è®¡ç®—å¤æ‚æ€§ç†è®º.md`ï¼Œ`09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/15-é‡å­ç®—æ³•ç†è®º.md`
- é‡å­çº é”™ä¸é”™è¯¯æ¨¡å‹ï¼š`10-é«˜çº§ä¸»é¢˜/17-é‡å­é”™è¯¯çº æ­£ç†è®º.md`
- é‡å­å¯†ç ä¸é€šä¿¡ï¼š`10-é«˜çº§ä¸»é¢˜/20-é‡å­å¯†ç å­¦ç†è®º.md`

## å‚è€ƒæ–‡çŒ® / References

1. Nielsen, M. A., & Chuang, I. L. (2010). Quantum computation and quantum information. Cambridge university press.
2. Wilde, M. M. (2013). Quantum information theory. Cambridge University Press.
3. Schumacher, B. (1995). Quantum coding. Physical Review A, 51(4), 2738.
4. Bennett, C. H., et al. (1996). Mixed-state entanglement and quantum error correction. Physical Review A, 54(5), 3824.
5. Horodecki, R., Horodecki, P., Horodecki, M., & Horodecki, K. (2009). Quantum entanglement. Reviews of modern physics, 81(2), 865.
