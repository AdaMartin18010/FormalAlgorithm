# 算法设计模式理论 / Algorithm Design Pattern Theory

## 概述 / Overview

算法设计模式理论研究在算法设计中反复出现的通用解决方案。这些模式提供了解决特定类型问题的可复用模板，帮助开发者更高效地设计和实现算法。

Algorithm design pattern theory studies common reusable solutions that occur repeatedly in algorithm design. These patterns provide reusable templates for solving specific types of problems, helping developers design and implement algorithms more efficiently.

## 基本概念 / Basic Concepts

### 算法设计模式定义 / Definition of Algorithm Design Patterns

**定义 1.1** (算法设计模式 / Algorithm Design Pattern)
算法设计模式是在特定情境下解决特定问题的可复用设计方案，它描述了问题、解决方案以及何时使用该方案。

**Definition 1.1** (Algorithm Design Pattern)
An algorithm design pattern is a reusable design solution for solving specific problems in specific contexts. It describes the problem, solution, and when to use the solution.

### 模式分类 / Pattern Classification

1. **创建型模式** / Creational Patterns
   - 算法实例化的模式
   - 动态算法选择

2. **结构型模式** / Structural Patterns
   - 算法组合的模式
   - 算法适配和桥接

3. **行为型模式** / Behavioral Patterns
   - 算法执行的模式
   - 算法间的协作

4. **优化模式** / Optimization Patterns
   - 性能优化的模式
   - 资源利用的模式

## 经典算法模式 / Classic Algorithm Patterns

### 分治模式 / Divide and Conquer Pattern

```rust
// 分治模式实现
// Divide and Conquer pattern implementation

pub trait DivideAndConquer<T, R> {
    fn is_base_case(&self, problem: &T) -> bool;
    fn solve_base_case(&self, problem: &T) -> R;
    fn divide(&self, problem: &T) -> Vec<T>;
    fn combine(&self, subresults: Vec<R>) -> R;
    
    fn solve(&self, problem: &T) -> R {
        if self.is_base_case(problem) {
            self.solve_base_case(problem)
        } else {
            let subproblems = self.divide(problem);
            let subresults: Vec<R> = subproblems
                .iter()
                .map(|subproblem| self.solve(subproblem))
                .collect();
            self.combine(subresults)
        }
    }
}

// 归并排序的分治实现
// Merge sort divide and conquer implementation
pub struct MergeSort;

impl DivideAndConquer<Vec<i32>, Vec<i32>> for MergeSort {
    fn is_base_case(&self, problem: &Vec<i32>) -> bool {
        problem.len() <= 1
    }
    
    fn solve_base_case(&self, problem: &Vec<i32>) -> Vec<i32> {
        problem.clone()
    }
    
    fn divide(&self, problem: &Vec<i32>) -> Vec<Vec<i32>> {
        let mid = problem.len() / 2;
        vec![
            problem[..mid].to_vec(),
            problem[mid..].to_vec(),
        ]
    }
    
    fn combine(&self, mut subresults: Vec<Vec<i32>>) -> Vec<i32> {
        if subresults.len() != 2 {
            return vec![];
        }
        
        let right = subresults.pop().unwrap();
        let left = subresults.pop().unwrap();
        
        self.merge(left, right)
    }
}

impl MergeSort {
    fn merge(&self, left: Vec<i32>, right: Vec<i32>) -> Vec<i32> {
        let mut result = Vec::new();
        let mut i = 0;
        let mut j = 0;
        
        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                result.push(left[i]);
                i += 1;
            } else {
                result.push(right[j]);
                j += 1;
            }
        }
        
        result.extend_from_slice(&left[i..]);
        result.extend_from_slice(&right[j..]);
        result
    }
}

// 快速排序的分治实现
// Quick sort divide and conquer implementation
pub struct QuickSort;

impl DivideAndConquer<Vec<i32>, Vec<i32>> for QuickSort {
    fn is_base_case(&self, problem: &Vec<i32>) -> bool {
        problem.len() <= 1
    }
    
    fn solve_base_case(&self, problem: &Vec<i32>) -> Vec<i32> {
        problem.clone()
    }
    
    fn divide(&self, problem: &Vec<i32>) -> Vec<Vec<i32>> {
        if problem.is_empty() {
            return vec![];
        }
        
        let pivot = problem[0];
        let mut less = Vec::new();
        let mut equal = Vec::new();
        let mut greater = Vec::new();
        
        for &item in problem {
            if item < pivot {
                less.push(item);
            } else if item == pivot {
                equal.push(item);
            } else {
                greater.push(item);
            }
        }
        
        vec![less, greater] // equal部分在combine中处理
    }
    
    fn combine(&self, mut subresults: Vec<Vec<i32>>) -> Vec<i32> {
        if subresults.len() != 2 {
            return vec![];
        }
        
        let greater = subresults.pop().unwrap();
        let less = subresults.pop().unwrap();
        
        let mut result = less;
        // 这里简化处理，实际应该包含equal部分
        result.extend(greater);
        result
    }
}
```

### 动态规划模式 / Dynamic Programming Pattern

```rust
// 动态规划模式实现
// Dynamic Programming pattern implementation

use std::collections::HashMap;

pub trait DynamicProgramming<K, V> {
    fn solve_recursive(&self, key: &K, memo: &mut HashMap<K, V>) -> V
    where K: Clone + std::hash::Hash + Eq,
          V: Clone;
    
    fn solve(&self, key: &K) -> V
    where K: Clone + std::hash::Hash + Eq,
          V: Clone {
        let mut memo = HashMap::new();
        self.solve_recursive(key, &mut memo)
    }
}

// 斐波那契数列的动态规划实现
// Fibonacci sequence dynamic programming implementation
pub struct Fibonacci;

impl DynamicProgramming<usize, u64> for Fibonacci {
    fn solve_recursive(&self, key: &usize, memo: &mut HashMap<usize, u64>) -> u64 {
        if let Some(&result) = memo.get(key) {
            return result;
        }
        
        let result = match *key {
            0 => 0,
            1 => 1,
            n => {
                self.solve_recursive(&(n - 1), memo) + 
                self.solve_recursive(&(n - 2), memo)
            }
        };
        
        memo.insert(*key, result);
        result
    }
}

// 最长公共子序列的动态规划实现
// Longest Common Subsequence dynamic programming implementation
pub struct LongestCommonSubsequence;

impl DynamicProgramming<(String, String), usize> for LongestCommonSubsequence {
    fn solve_recursive(&self, key: &(String, String), memo: &mut HashMap<(String, String), usize>) -> usize {
        if let Some(&result) = memo.get(key) {
            return result;
        }
        
        let (s1, s2) = key;
        let result = if s1.is_empty() || s2.is_empty() {
            0
        } else if s1.chars().last() == s2.chars().last() {
            1 + self.solve_recursive(&(
                s1[..s1.len() - 1].to_string(),
                s2[..s2.len() - 1].to_string()
            ), memo)
        } else {
            std::cmp::max(
                self.solve_recursive(&(
                    s1[..s1.len() - 1].to_string(),
                    s2.clone()
                ), memo),
                self.solve_recursive(&(
                    s1.clone(),
                    s2[..s2.len() - 1].to_string()
                ), memo)
            )
        };
        
        memo.insert(key.clone(), result);
        result
    }
}

// 背包问题的动态规划实现
// Knapsack problem dynamic programming implementation
pub struct Knapsack {
    weights: Vec<usize>,
    values: Vec<usize>,
}

impl Knapsack {
    pub fn new(weights: Vec<usize>, values: Vec<usize>) -> Self {
        Self { weights, values }
    }
}

impl DynamicProgramming<(usize, usize), usize> for Knapsack {
    fn solve_recursive(&self, key: &(usize, usize), memo: &mut HashMap<(usize, usize), usize>) -> usize {
        if let Some(&result) = memo.get(key) {
            return result;
        }
        
        let (item_index, capacity) = *key;
        let result = if item_index >= self.weights.len() || capacity == 0 {
            0
        } else if self.weights[item_index] > capacity {
            self.solve_recursive(&(item_index + 1, capacity), memo)
        } else {
            std::cmp::max(
                self.solve_recursive(&(item_index + 1, capacity), memo),
                self.values[item_index] + self.solve_recursive(&(
                    item_index + 1,
                    capacity - self.weights[item_index]
                ), memo)
            )
        };
        
        memo.insert(*key, result);
        result
    }
}
```

### 贪心模式 / Greedy Pattern

```rust
// 贪心模式实现
// Greedy pattern implementation

pub trait GreedyAlgorithm<T, R> {
    fn is_solution(&self, candidate_set: &[T]) -> bool;
    fn select_candidate(&self, candidate_set: &[T]) -> Option<T>;
    fn is_feasible(&self, partial_solution: &[T], candidate: &T) -> bool;
    fn construct_solution(&self, partial_solution: Vec<T>) -> R;
    
    fn solve(&self, mut candidate_set: Vec<T>) -> R {
        let mut solution = Vec::new();
        
        while !self.is_solution(&solution) && !candidate_set.is_empty() {
            if let Some(candidate) = self.select_candidate(&candidate_set) {
                if self.is_feasible(&solution, &candidate) {
                    solution.push(candidate.clone());
                }
                // 移除已选择的候选项
                candidate_set.retain(|x| !self.same_candidate(x, &candidate));
            } else {
                break;
            }
        }
        
        self.construct_solution(solution)
    }
    
    fn same_candidate(&self, a: &T, b: &T) -> bool;
}

// 活动选择问题的贪心实现
// Activity selection greedy implementation
#[derive(Clone, Debug)]
pub struct Activity {
    id: usize,
    start_time: usize,
    end_time: usize,
}

impl Activity {
    pub fn new(id: usize, start_time: usize, end_time: usize) -> Self {
        Self { id, start_time, end_time }
    }
}

pub struct ActivitySelection;

impl GreedyAlgorithm<Activity, Vec<Activity>> for ActivitySelection {
    fn is_solution(&self, candidate_set: &[Activity]) -> bool {
        // 当没有更多可选活动时，解构建完成
        candidate_set.is_empty()
    }
    
    fn select_candidate(&self, candidate_set: &[Activity]) -> Option<Activity> {
        // 选择最早结束的活动
        candidate_set.iter()
            .min_by_key(|activity| activity.end_time)
            .cloned()
    }
    
    fn is_feasible(&self, partial_solution: &[Activity], candidate: &Activity) -> bool {
        // 检查是否与已选择的活动冲突
        partial_solution.iter().all(|activity| {
            activity.end_time <= candidate.start_time || 
            candidate.end_time <= activity.start_time
        })
    }
    
    fn construct_solution(&self, partial_solution: Vec<Activity>) -> Vec<Activity> {
        partial_solution
    }
    
    fn same_candidate(&self, a: &Activity, b: &Activity) -> bool {
        a.id == b.id
    }
}

// 分数背包问题的贪心实现
// Fractional knapsack greedy implementation
#[derive(Clone, Debug)]
pub struct Item {
    weight: f64,
    value: f64,
    ratio: f64,
}

impl Item {
    pub fn new(weight: f64, value: f64) -> Self {
        Self {
            weight,
            value,
            ratio: value / weight,
        }
    }
}

pub struct FractionalKnapsack {
    capacity: f64,
}

impl FractionalKnapsack {
    pub fn new(capacity: f64) -> Self {
        Self { capacity }
    }
}

impl GreedyAlgorithm<Item, (Vec<Item>, f64)> for FractionalKnapsack {
    fn is_solution(&self, _candidate_set: &[Item]) -> bool {
        false // 总是处理所有候选项
    }
    
    fn select_candidate(&self, candidate_set: &[Item]) -> Option<Item> {
        // 选择性价比最高的物品
        candidate_set.iter()
            .max_by(|a, b| a.ratio.partial_cmp(&b.ratio).unwrap())
            .cloned()
    }
    
    fn is_feasible(&self, partial_solution: &[Item], candidate: &Item) -> bool {
        let current_weight: f64 = partial_solution.iter().map(|item| item.weight).sum();
        current_weight + candidate.weight <= self.capacity
    }
    
    fn construct_solution(&self, partial_solution: Vec<Item>) -> (Vec<Item>, f64) {
        let total_value: f64 = partial_solution.iter().map(|item| item.value).sum();
        (partial_solution, total_value)
    }
    
    fn same_candidate(&self, a: &Item, b: &Item) -> bool {
        (a.weight - b.weight).abs() < f64::EPSILON && 
        (a.value - b.value).abs() < f64::EPSILON
    }
}
```

## 创建型模式 / Creational Patterns

### 算法工厂模式 / Algorithm Factory Pattern

```rust
// 算法工厂模式实现
// Algorithm Factory pattern implementation

pub trait SortingAlgorithm {
    fn sort(&self, data: &mut [i32]);
    fn name(&self) -> &str;
}

// 具体算法实现
// Concrete algorithm implementations
pub struct BubbleSort;
pub struct QuickSortImpl;
pub struct MergeSortImpl;

impl SortingAlgorithm for BubbleSort {
    fn sort(&self, data: &mut [i32]) {
        let n = data.len();
        for i in 0..n {
            for j in 0..n - 1 - i {
                if data[j] > data[j + 1] {
                    data.swap(j, j + 1);
                }
            }
        }
    }
    
    fn name(&self) -> &str {
        "Bubble Sort"
    }
}

impl SortingAlgorithm for QuickSortImpl {
    fn sort(&self, data: &mut [i32]) {
        if data.len() <= 1 {
            return;
        }
        
        let pivot = self.partition(data);
        let (left, right) = data.split_at_mut(pivot);
        
        self.sort(left);
        self.sort(&mut right[1..]);
    }
    
    fn name(&self) -> &str {
        "Quick Sort"
    }
}

impl QuickSortImpl {
    fn partition(&self, data: &mut [i32]) -> usize {
        let pivot = data[data.len() - 1];
        let mut i = 0;
        
        for j in 0..data.len() - 1 {
            if data[j] <= pivot {
                data.swap(i, j);
                i += 1;
            }
        }
        
        data.swap(i, data.len() - 1);
        i
    }
}

impl SortingAlgorithm for MergeSortImpl {
    fn sort(&self, data: &mut [i32]) {
        if data.len() <= 1 {
            return;
        }
        
        let mid = data.len() / 2;
        let (left, right) = data.split_at_mut(mid);
        
        self.sort(left);
        self.sort(right);
        
        self.merge(data, mid);
    }
    
    fn name(&self) -> &str {
        "Merge Sort"
    }
}

impl MergeSortImpl {
    fn merge(&self, data: &mut [i32], mid: usize) {
        let left = data[..mid].to_vec();
        let right = data[mid..].to_vec();
        
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;
        
        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                data[k] = left[i];
                i += 1;
            } else {
                data[k] = right[j];
                j += 1;
            }
            k += 1;
        }
        
        while i < left.len() {
            data[k] = left[i];
            i += 1;
            k += 1;
        }
        
        while j < right.len() {
            data[k] = right[j];
            j += 1;
            k += 1;
        }
    }
}

// 算法工厂
// Algorithm factory
pub struct AlgorithmFactory;

impl AlgorithmFactory {
    pub fn create_sorting_algorithm(algorithm_type: &str) -> Option<Box<dyn SortingAlgorithm>> {
        match algorithm_type.to_lowercase().as_str() {
            "bubble" => Some(Box::new(BubbleSort)),
            "quick" => Some(Box::new(QuickSortImpl)),
            "merge" => Some(Box::new(MergeSortImpl)),
            _ => None,
        }
    }
    
    pub fn get_best_algorithm_for_size(size: usize) -> Box<dyn SortingAlgorithm> {
        if size < 10 {
            Box::new(BubbleSort)
        } else if size < 1000 {
            Box::new(QuickSortImpl)
        } else {
            Box::new(MergeSortImpl)
        }
    }
}

// 使用示例
// Usage example
pub struct SortingService;

impl SortingService {
    pub fn sort_with_algorithm(&self, data: &mut [i32], algorithm_name: &str) -> Result<(), String> {
        if let Some(algorithm) = AlgorithmFactory::create_sorting_algorithm(algorithm_name) {
            println!("Using {} to sort {} elements", algorithm.name(), data.len());
            algorithm.sort(data);
            Ok(())
        } else {
            Err(format!("Unknown algorithm: {}", algorithm_name))
        }
    }
    
    pub fn smart_sort(&self, data: &mut [i32]) {
        let algorithm = AlgorithmFactory::get_best_algorithm_for_size(data.len());
        println!("Auto-selected {} for {} elements", algorithm.name(), data.len());
        algorithm.sort(data);
    }
}
```

### 算法建造者模式 / Algorithm Builder Pattern

```rust
// 算法建造者模式实现
// Algorithm Builder pattern implementation

pub struct AlgorithmConfig {
    pub timeout_ms: Option<u64>,
    pub max_memory_mb: Option<usize>,
    pub parallel: bool,
    pub cache_enabled: bool,
    pub debug_mode: bool,
}

impl Default for AlgorithmConfig {
    fn default() -> Self {
        Self {
            timeout_ms: None,
            max_memory_mb: None,
            parallel: false,
            cache_enabled: false,
            debug_mode: false,
        }
    }
}

// 可配置的算法执行器
// Configurable algorithm executor
pub struct ConfigurableAlgorithm {
    config: AlgorithmConfig,
    algorithm: Box<dyn SortingAlgorithm>,
}

impl ConfigurableAlgorithm {
    pub fn execute(&self, data: &mut [i32]) -> Result<(), String> {
        if self.config.debug_mode {
            println!("Executing {} with config: parallel={}, cache={}", 
                self.algorithm.name(), self.config.parallel, self.config.cache_enabled);
        }
        
        // 检查超时设置
        if let Some(timeout) = self.config.timeout_ms {
            println!("Timeout set to {} ms", timeout);
        }
        
        // 检查内存限制
        if let Some(memory_limit) = self.config.max_memory_mb {
            println!("Memory limit set to {} MB", memory_limit);
        }
        
        // 执行算法
        self.algorithm.sort(data);
        
        Ok(())
    }
}

// 算法建造者
// Algorithm builder
pub struct AlgorithmBuilder {
    config: AlgorithmConfig,
}

impl AlgorithmBuilder {
    pub fn new() -> Self {
        Self {
            config: AlgorithmConfig::default(),
        }
    }
    
    pub fn with_timeout(mut self, timeout_ms: u64) -> Self {
        self.config.timeout_ms = Some(timeout_ms);
        self
    }
    
    pub fn with_memory_limit(mut self, memory_mb: usize) -> Self {
        self.config.max_memory_mb = Some(memory_mb);
        self
    }
    
    pub fn enable_parallel(mut self) -> Self {
        self.config.parallel = true;
        self
    }
    
    pub fn enable_cache(mut self) -> Self {
        self.config.cache_enabled = true;
        self
    }
    
    pub fn enable_debug(mut self) -> Self {
        self.config.debug_mode = true;
        self
    }
    
    pub fn build(self, algorithm_type: &str) -> Result<ConfigurableAlgorithm, String> {
        if let Some(algorithm) = AlgorithmFactory::create_sorting_algorithm(algorithm_type) {
            Ok(ConfigurableAlgorithm {
                config: self.config,
                algorithm,
            })
        } else {
            Err(format!("Unknown algorithm type: {}", algorithm_type))
        }
    }
}

// 使用示例
// Usage example
pub fn example_usage() {
    let algorithm = AlgorithmBuilder::new()
        .with_timeout(5000)
        .with_memory_limit(100)
        .enable_parallel()
        .enable_cache()
        .enable_debug()
        .build("quick")
        .unwrap();
    
    let mut data = vec![3, 1, 4, 1, 5, 9, 2, 6, 5, 3];
    algorithm.execute(&mut data).unwrap();
    println!("Sorted data: {:?}", data);
}
```

## 结构型模式 / Structural Patterns

### 算法适配器模式 / Algorithm Adapter Pattern

```rust
// 算法适配器模式实现
// Algorithm Adapter pattern implementation

// 旧的排序接口
// Old sorting interface
pub trait LegacySorter {
    fn legacy_sort(&self, array: &mut Vec<i32>);
}

// 现代排序接口
// Modern sorting interface
pub trait ModernSorter {
    fn sort(&self, data: &mut [i32]);
    fn sort_range(&self, data: &mut [i32], start: usize, end: usize);
}

// 旧的冒泡排序实现
// Old bubble sort implementation
pub struct LegacyBubbleSort;

impl LegacySorter for LegacyBubbleSort {
    fn legacy_sort(&self, array: &mut Vec<i32>) {
        let n = array.len();
        for i in 0..n {
            for j in 0..n - 1 - i {
                if array[j] > array[j + 1] {
                    array.swap(j, j + 1);
                }
            }
        }
    }
}

// 适配器：将旧接口适配到新接口
// Adapter: adapting old interface to new interface
pub struct SortingAdapter<T: LegacySorter> {
    legacy_sorter: T,
}

impl<T: LegacySorter> SortingAdapter<T> {
    pub fn new(legacy_sorter: T) -> Self {
        Self { legacy_sorter }
    }
}

impl<T: LegacySorter> ModernSorter for SortingAdapter<T> {
    fn sort(&self, data: &mut [i32]) {
        let mut vec_data = data.to_vec();
        self.legacy_sorter.legacy_sort(&mut vec_data);
        data.copy_from_slice(&vec_data);
    }
    
    fn sort_range(&self, data: &mut [i32], start: usize, end: usize) {
        if start < end && end <= data.len() {
            let mut range_data = data[start..end].to_vec();
            self.legacy_sorter.legacy_sort(&mut range_data);
            data[start..end].copy_from_slice(&range_data);
        }
    }
}

// 现代客户端代码
// Modern client code
pub struct ModernSortingService;

impl ModernSortingService {
    pub fn process_data(&self, sorter: &dyn ModernSorter, data: &mut [i32]) {
        println!("Processing {} elements with modern interface", data.len());
        sorter.sort(data);
        println!("Sorting completed");
    }
    
    pub fn process_range(&self, sorter: &dyn ModernSorter, data: &mut [i32], start: usize, end: usize) {
        println!("Processing range [{}, {}) with modern interface", start, end);
        sorter.sort_range(data, start, end);
        println!("Range sorting completed");
    }
}
```

### 算法装饰器模式 / Algorithm Decorator Pattern

```rust
// 算法装饰器模式实现
// Algorithm Decorator pattern implementation

use std::time::Instant;

// 基础算法特征
// Base algorithm trait
pub trait Algorithm {
    fn execute(&self, data: &mut [i32]) -> Result<(), String>;
    fn name(&self) -> String;
}

// 基础快速排序算法
// Base quick sort algorithm
pub struct BaseQuickSort;

impl Algorithm for BaseQuickSort {
    fn execute(&self, data: &mut [i32]) -> Result<(), String> {
        self.quicksort(data);
        Ok(())
    }
    
    fn name(&self) -> String {
        "QuickSort".to_string()
    }
}

impl BaseQuickSort {
    fn quicksort(&self, data: &mut [i32]) {
        if data.len() <= 1 {
            return;
        }
        
        let pivot = self.partition(data);
        let (left, right) = data.split_at_mut(pivot);
        
        self.quicksort(left);
        self.quicksort(&mut right[1..]);
    }
    
    fn partition(&self, data: &mut [i32]) -> usize {
        let pivot = data[data.len() - 1];
        let mut i = 0;
        
        for j in 0..data.len() - 1 {
            if data[j] <= pivot {
                data.swap(i, j);
                i += 1;
            }
        }
        
        data.swap(i, data.len() - 1);
        i
    }
}

// 装饰器基类
// Decorator base class
pub struct AlgorithmDecorator<T: Algorithm> {
    algorithm: T,
}

impl<T: Algorithm> AlgorithmDecorator<T> {
    pub fn new(algorithm: T) -> Self {
        Self { algorithm }
    }
}

impl<T: Algorithm> Algorithm for AlgorithmDecorator<T> {
    fn execute(&self, data: &mut [i32]) -> Result<(), String> {
        self.algorithm.execute(data)
    }
    
    fn name(&self) -> String {
        self.algorithm.name()
    }
}

// 性能监控装饰器
// Performance monitoring decorator
pub struct PerformanceMonitor<T: Algorithm> {
    inner: AlgorithmDecorator<T>,
}

impl<T: Algorithm> PerformanceMonitor<T> {
    pub fn new(algorithm: T) -> Self {
        Self {
            inner: AlgorithmDecorator::new(algorithm),
        }
    }
}

impl<T: Algorithm> Algorithm for PerformanceMonitor<T> {
    fn execute(&self, data: &mut [i32]) -> Result<(), String> {
        let start = Instant::now();
        println!("Starting execution of {} on {} elements", self.name(), data.len());
        
        let result = self.inner.execute(data);
        
        let duration = start.elapsed();
        println!("Execution completed in {:?}", duration);
        
        result
    }
    
    fn name(&self) -> String {
        format!("PerformanceMonitor({})", self.inner.name())
    }
}

// 日志装饰器
// Logging decorator
pub struct Logger<T: Algorithm> {
    inner: T,
    log_level: LogLevel,
}

#[derive(Clone, Copy)]
pub enum LogLevel {
    Debug,
    Info,
    Warning,
    Error,
}

impl<T: Algorithm> Logger<T> {
    pub fn new(algorithm: T, log_level: LogLevel) -> Self {
        Self {
            inner: algorithm,
            log_level,
        }
    }
    
    fn log(&self, level: LogLevel, message: &str) {
        match (self.log_level, level) {
            (LogLevel::Debug, _) => println!("[{:?}] {}", level, message),
            (LogLevel::Info, LogLevel::Info | LogLevel::Warning | LogLevel::Error) => 
                println!("[{:?}] {}", level, message),
            (LogLevel::Warning, LogLevel::Warning | LogLevel::Error) => 
                println!("[{:?}] {}", level, message),
            (LogLevel::Error, LogLevel::Error) => 
                println!("[{:?}] {}", level, message),
            _ => {}
        }
    }
}

impl<T: Algorithm> Algorithm for Logger<T> {
    fn execute(&self, data: &mut [i32]) -> Result<(), String> {
        self.log(LogLevel::Info, &format!("Starting {} execution", self.name()));
        
        if data.is_empty() {
            self.log(LogLevel::Warning, "Empty data array provided");
            return Ok(());
        }
        
        self.log(LogLevel::Debug, &format!("Input data: {:?}", 
            if data.len() <= 10 { data.to_vec() } else { data[..10].to_vec() }));
        
        let result = self.inner.execute(data);
        
        match &result {
            Ok(_) => self.log(LogLevel::Info, "Execution completed successfully"),
            Err(e) => self.log(LogLevel::Error, &format!("Execution failed: {}", e)),
        }
        
        result
    }
    
    fn name(&self) -> String {
        format!("Logger({})", self.inner.name())
    }
}

// 缓存装饰器
// Cache decorator
use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::collections::hash_map::DefaultHasher;

pub struct Cache<T: Algorithm> {
    inner: T,
    cache: std::cell::RefCell<HashMap<u64, Vec<i32>>>,
    max_cache_size: usize,
}

impl<T: Algorithm> Cache<T> {
    pub fn new(algorithm: T, max_cache_size: usize) -> Self {
        Self {
            inner: algorithm,
            cache: std::cell::RefCell::new(HashMap::new()),
            max_cache_size,
        }
    }
    
    fn hash_data(data: &[i32]) -> u64 {
        let mut hasher = DefaultHasher::new();
        data.hash(&mut hasher);
        hasher.finish()
    }
}

impl<T: Algorithm> Algorithm for Cache<T> {
    fn execute(&self, data: &mut [i32]) -> Result<(), String> {
        let hash = Self::hash_data(data);
        
        // 检查缓存
        {
            let cache = self.cache.borrow();
            if let Some(cached_result) = cache.get(&hash) {
                data.copy_from_slice(cached_result);
                return Ok(());
            }
        }
        
        // 执行算法
        let result = self.inner.execute(data);
        
        // 更新缓存
        if result.is_ok() {
            let mut cache = self.cache.borrow_mut();
            
            // 如果缓存已满，移除最旧的条目
            if cache.len() >= self.max_cache_size {
                if let Some(key) = cache.keys().next().copied() {
                    cache.remove(&key);
                }
            }
            
            cache.insert(hash, data.to_vec());
        }
        
        result
    }
    
    fn name(&self) -> String {
        format!("Cache({})", self.inner.name())
    }
}

// 组合装饰器使用示例
// Combined decorator usage example
pub fn decorated_algorithm_example() {
    let base_algorithm = BaseQuickSort;
    
    // 创建装饰器链
    let decorated_algorithm = Cache::new(
        Logger::new(
            PerformanceMonitor::new(base_algorithm),
            LogLevel::Debug
        ),
        10
    );
    
    let mut data = vec![3, 1, 4, 1, 5, 9, 2, 6, 5, 3];
    println!("Original data: {:?}", data);
    
    decorated_algorithm.execute(&mut data).unwrap();
    println!("Sorted data: {:?}", data);
    
    // 第二次执行相同数据（应该命中缓存）
    let mut data2 = vec![3, 1, 4, 1, 5, 9, 2, 6, 5, 3];
    decorated_algorithm.execute(&mut data2).unwrap();
}
```

## 行为型模式 / Behavioral Patterns

### 策略模式 / Strategy Pattern

```rust
// 策略模式实现
// Strategy pattern implementation

// 排序策略特征
// Sorting strategy trait
pub trait SortingStrategy {
    fn sort(&self, data: &mut [i32]);
    fn strategy_name(&self) -> &str;
    fn time_complexity(&self) -> &str;
    fn space_complexity(&self) -> &str;
}

// 具体策略实现
// Concrete strategy implementations
pub struct BubbleSortStrategy;
pub struct SelectionSortStrategy;
pub struct InsertionSortStrategy;

impl SortingStrategy for BubbleSortStrategy {
    fn sort(&self, data: &mut [i32]) {
        let n = data.len();
        for i in 0..n {
            for j in 0..n - 1 - i {
                if data[j] > data[j + 1] {
                    data.swap(j, j + 1);
                }
            }
        }
    }
    
    fn strategy_name(&self) -> &str {
        "Bubble Sort"
    }
    
    fn time_complexity(&self) -> &str {
        "O(n²)"
    }
    
    fn space_complexity(&self) -> &str {
        "O(1)"
    }
}

impl SortingStrategy for SelectionSortStrategy {
    fn sort(&self, data: &mut [i32]) {
        let n = data.len();
        for i in 0..n {
            let mut min_idx = i;
            for j in i + 1..n {
                if data[j] < data[min_idx] {
                    min_idx = j;
                }
            }
            data.swap(i, min_idx);
        }
    }
    
    fn strategy_name(&self) -> &str {
        "Selection Sort"
    }
    
    fn time_complexity(&self) -> &str {
        "O(n²)"
    }
    
    fn space_complexity(&self) -> &str {
        "O(1)"
    }
}

impl SortingStrategy for InsertionSortStrategy {
    fn sort(&self, data: &mut [i32]) {
        for i in 1..data.len() {
            let key = data[i];
            let mut j = i;
            
            while j > 0 && data[j - 1] > key {
                data[j] = data[j - 1];
                j -= 1;
            }
            
            data[j] = key;
        }
    }
    
    fn strategy_name(&self) -> &str {
        "Insertion Sort"
    }
    
    fn time_complexity(&self) -> &str {
        "O(n²) worst case, O(n) best case"
    }
    
    fn space_complexity(&self) -> &str {
        "O(1)"
    }
}

// 上下文类
// Context class
pub struct SortingContext {
    strategy: Box<dyn SortingStrategy>,
}

impl SortingContext {
    pub fn new(strategy: Box<dyn SortingStrategy>) -> Self {
        Self { strategy }
    }
    
    pub fn set_strategy(&mut self, strategy: Box<dyn SortingStrategy>) {
        self.strategy = strategy;
    }
    
    pub fn execute_sort(&self, data: &mut [i32]) {
        println!("Using {} strategy", self.strategy.strategy_name());
        println!("Time complexity: {}", self.strategy.time_complexity());
        println!("Space complexity: {}", self.strategy.space_complexity());
        
        self.strategy.sort(data);
    }
    
    pub fn get_strategy_info(&self) -> (&str, &str, &str) {
        (
            self.strategy.strategy_name(),
            self.strategy.time_complexity(),
            self.strategy.space_complexity()
        )
    }
}

// 策略选择器
// Strategy selector
pub struct StrategySelector;

impl StrategySelector {
    pub fn select_best_strategy(data_size: usize, is_nearly_sorted: bool) -> Box<dyn SortingStrategy> {
        match (data_size, is_nearly_sorted) {
            (size, true) if size < 50 => Box::new(InsertionSortStrategy),
            (size, _) if size < 20 => Box::new(BubbleSortStrategy),
            (size, _) if size < 100 => Box::new(SelectionSortStrategy),
            _ => Box::new(InsertionSortStrategy), // 对于大数据，实际应该使用更高效的算法
        }
    }
    
    pub fn select_strategy_by_name(name: &str) -> Option<Box<dyn SortingStrategy>> {
        match name.to_lowercase().as_str() {
            "bubble" => Some(Box::new(BubbleSortStrategy)),
            "selection" => Some(Box::new(SelectionSortStrategy)),
            "insertion" => Some(Box::new(InsertionSortStrategy)),
            _ => None,
        }
    }
}

// 自适应排序器
// Adaptive sorter
pub struct AdaptiveSorter;

impl AdaptiveSorter {
    pub fn sort_with_analysis(&self, data: &mut [i32]) {
        let is_nearly_sorted = self.analyze_sortedness(data);
        let strategy = StrategySelector::select_best_strategy(data.len(), is_nearly_sorted);
        
        let mut context = SortingContext::new(strategy);
        
        println!("Data analysis:");
        println!("  Size: {}", data.len());
        println!("  Nearly sorted: {}", is_nearly_sorted);
        
        context.execute_sort(data);
    }
    
    fn analyze_sortedness(&self, data: &[i32]) -> bool {
        if data.len() <= 1 {
            return true;
        }
        
        let mut inversions = 0;
        for i in 0..data.len() - 1 {
            if data[i] > data[i + 1] {
                inversions += 1;
            }
        }
        
        let inversion_ratio = inversions as f64 / (data.len() - 1) as f64;
        inversion_ratio < 0.1 // 如果逆序对少于10%，认为是近似有序
    }
}
```

### 观察者模式 / Observer Pattern

```rust
// 观察者模式实现
// Observer pattern implementation

// 算法事件类型
// Algorithm event types
#[derive(Clone, Debug)]
pub enum AlgorithmEvent {
    Started { algorithm_name: String, data_size: usize },
    Progress { current_step: usize, total_steps: usize },
    Completed { duration_ms: u64 },
    Error { message: String },
}

// 观察者特征
// Observer trait
pub trait AlgorithmObserver {
    fn notify(&self, event: &AlgorithmEvent);
    fn observer_name(&self) -> &str;
}

// 具体观察者实现
// Concrete observer implementations
pub struct ConsoleLogger;

impl AlgorithmObserver for ConsoleLogger {
    fn notify(&self, event: &AlgorithmEvent) {
        match event {
            AlgorithmEvent::Started { algorithm_name, data_size } => {
                println!("[CONSOLE] Algorithm '{}' started with {} elements", 
                    algorithm_name, data_size);
            }
            AlgorithmEvent::Progress { current_step, total_steps } => {
                let progress = (*current_step as f64 / *total_steps as f64) * 100.0;
                println!("[CONSOLE] Progress: {:.1}% ({}/{})", 
                    progress, current_step, total_steps);
            }
            AlgorithmEvent::Completed { duration_ms } => {
                println!("[CONSOLE] Algorithm completed in {} ms", duration_ms);
            }
            AlgorithmEvent::Error { message } => {
                println!("[CONSOLE] Error: {}", message);
            }
        }
    }
    
    fn observer_name(&self) -> &str {
        "ConsoleLogger"
    }
}

pub struct PerformanceMetrics {
    metrics: std::cell::RefCell<Vec<(String, u64)>>,
}

impl PerformanceMetrics {
    pub fn new() -> Self {
        Self {
            metrics: std::cell::RefCell::new(Vec::new()),
        }
    }
    
    pub fn get_metrics(&self) -> Vec<(String, u64)> {
        self.metrics.borrow().clone()
    }
}

impl AlgorithmObserver for PerformanceMetrics {
    fn notify(&self, event: &AlgorithmEvent) {
        match event {
            AlgorithmEvent::Completed { duration_ms } => {
                // 这里简化处理，实际应该记录算法名称
                self.metrics.borrow_mut().push(("Algorithm".to_string(), *duration_ms));
            }
            _ => {}
        }
    }
    
    fn observer_name(&self) -> &str {
        "PerformanceMetrics"
    }
}

pub struct ProgressBar {
    width: usize,
}

impl ProgressBar {
    pub fn new(width: usize) -> Self {
        Self { width }
    }
}

impl AlgorithmObserver for ProgressBar {
    fn notify(&self, event: &AlgorithmEvent) {
        match event {
            AlgorithmEvent::Started { .. } => {
                println!("[PROGRESS] Starting...");
                self.draw_progress_bar(0.0);
            }
            AlgorithmEvent::Progress { current_step, total_steps } => {
                let progress = *current_step as f64 / *total_steps as f64;
                self.draw_progress_bar(progress);
            }
            AlgorithmEvent::Completed { .. } => {
                self.draw_progress_bar(1.0);
                println!("\n[PROGRESS] Completed!");
            }
            _ => {}
        }
    }
    
    fn observer_name(&self) -> &str {
        "ProgressBar"
    }
}

impl ProgressBar {
    fn draw_progress_bar(&self, progress: f64) {
        let filled = (progress * self.width as f64) as usize;
        let empty = self.width - filled;
        
        print!("\r[PROGRESS] [{}{}] {:.1}%", 
            "=".repeat(filled),
            " ".repeat(empty),
            progress * 100.0);
        
        use std::io::{self, Write};
        io::stdout().flush().unwrap();
    }
}

// 主题（被观察者）
// Subject (Observable)
pub struct ObservableAlgorithm {
    observers: Vec<Box<dyn AlgorithmObserver>>,
    algorithm: Box<dyn SortingStrategy>,
}

impl ObservableAlgorithm {
    pub fn new(algorithm: Box<dyn SortingStrategy>) -> Self {
        Self {
            observers: Vec::new(),
            algorithm,
        }
    }
    
    pub fn add_observer(&mut self, observer: Box<dyn AlgorithmObserver>) {
        println!("Added observer: {}", observer.observer_name());
        self.observers.push(observer);
    }
    
    pub fn remove_observer(&mut self, observer_name: &str) {
        self.observers.retain(|observer| observer.observer_name() != observer_name);
        println!("Removed observer: {}", observer_name);
    }
    
    fn notify_observers(&self, event: &AlgorithmEvent) {
        for observer in &self.observers {
            observer.notify(event);
        }
    }
    
    pub fn execute(&self, data: &mut [i32]) -> Result<(), String> {
        let start_time = std::time::Instant::now();
        
        // 通知开始
        self.notify_observers(&AlgorithmEvent::Started {
            algorithm_name: self.algorithm.strategy_name().to_string(),
            data_size: data.len(),
        });
        
        // 模拟带进度的排序过程
        self.sort_with_progress(data);
        
        let duration = start_time.elapsed().as_millis() as u64;
        
        // 通知完成
        self.notify_observers(&AlgorithmEvent::Completed { duration_ms: duration });
        
        Ok(())
    }
    
    fn sort_with_progress(&self, data: &mut [i32]) {
        // 这里简化实现，实际应该根据具体算法提供进度更新
        let total_steps = data.len();
        
        for step in 0..total_steps {
            // 模拟算法步骤
            std::thread::sleep(std::time::Duration::from_millis(10));
            
            // 每10步更新一次进度
            if step % 10 == 0 || step == total_steps - 1 {
                self.notify_observers(&AlgorithmEvent::Progress {
                    current_step: step + 1,
                    total_steps,
                });
            }
        }
        
        // 实际执行排序
        self.algorithm.sort(data);
    }
}

// 使用示例
// Usage example
pub fn observer_pattern_example() {
    let algorithm = Box::new(BubbleSortStrategy);
    let mut observable = ObservableAlgorithm::new(algorithm);
    
    // 添加观察者
    observable.add_observer(Box::new(ConsoleLogger));
    observable.add_observer(Box::new(PerformanceMetrics::new()));
    observable.add_observer(Box::new(ProgressBar::new(30)));
    
    let mut data = vec![64, 34, 25, 12, 22, 11, 90];
    println!("Original data: {:?}", data);
    
    observable.execute(&mut data).unwrap();
    
    println!("\nSorted data: {:?}", data);
}
```

## 总结 / Summary

算法设计模式理论为我们提供了构建可复用、可维护算法的强大工具。通过应用这些模式，我们可以创建更加灵活、可扩展的算法解决方案。

Algorithm design pattern theory provides us with powerful tools for building reusable and maintainable algorithms. By applying these patterns, we can create more flexible and extensible algorithmic solutions.

### 关键要点 / Key Points

1. **模式分类** / Pattern Classification
   - 创建型、结构型、行为型、优化型模式
   - 每种模式解决特定类型的问题

2. **经典算法模式** / Classic Algorithm Patterns
   - 分治、动态规划、贪心等基础模式
   - 为算法设计提供指导框架

3. **设计原则** / Design Principles
   - 开闭原则、单一职责原则
   - 提高代码的可维护性和可扩展性

4. **实际应用** / Practical Applications
   - 工厂模式用于算法选择
   - 装饰器模式用于功能增强
   - 策略模式用于算法切换

---

**参考文献 / References**:

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design patterns: elements of reusable object-oriented software. Pearson Education India.
2. Freeman, E., Robson, E., Bates, B., & Sierra, K. (2004). Head first design patterns. O'Reilly Media, Inc.
3. Martin, R. C. (2017). Clean architecture: a craftsman's guide to software structure and design. Prentice Hall.
4. Fowler, M. (2002). Patterns of enterprise application architecture. Addison-Wesley Professional.
5. Alexander, C., Ishikawa, S., & Silverstein, M. (1977). A pattern language: towns, buildings, construction. Oxford university press.
