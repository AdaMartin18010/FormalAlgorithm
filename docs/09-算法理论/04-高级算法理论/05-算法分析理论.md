# 算法分析理论 / Algorithm Analysis Theory

## 概述 / Overview

算法分析理论是研究如何分析算法性能和复杂度的学科。它提供了评估算法效率的数学工具和方法，包括时间复杂度分析、空间复杂度分析、摊还分析、概率分析等多个方面。

Algorithm analysis theory studies how to analyze algorithm performance and complexity. It provides mathematical tools and methods for evaluating algorithm efficiency, including time complexity analysis, space complexity analysis, amortized analysis, probabilistic analysis, and other aspects.

## 基本概念 / Basic Concepts

### 算法分析定义 / Definition of Algorithm Analysis

**定义 1.1** (算法分析 / Algorithm Analysis)
算法分析是评估算法性能的过程，主要关注算法在时间和空间消耗方面的表现，以及算法的正确性和可靠性。

**Definition 1.1** (Algorithm Analysis)
Algorithm analysis is the process of evaluating algorithm performance, primarily focusing on the algorithm's performance in terms of time and space consumption, as well as algorithm correctness and reliability.

### 分析维度 / Analysis Dimensions

1. **时间复杂度** / Time Complexity
   - 算法执行所需的计算步骤数
   - 与输入规模的关系

2. **空间复杂度** / Space Complexity
   - 算法执行所需的内存空间
   - 辅助空间的使用

3. **正确性** / Correctness
   - 算法是否产生正确的输出
   - 满足前置和后置条件

4. **稳定性** / Stability
   - 算法在不同输入下的表现
   - 数值稳定性

## 渐进分析 / Asymptotic Analysis

### 渐进记号 / Asymptotic Notation

```rust
// 渐进分析工具实现
// Asymptotic analysis tools implementation

pub struct AsymptoticAnalyzer {
    name: String,
}

impl AsymptoticAnalyzer {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    /// Big-O 分析
    /// Big-O analysis
    pub fn big_o_analysis(&self, function_values: &[f64], input_sizes: &[usize]) -> String {
        if function_values.len() != input_sizes.len() || function_values.len() < 2 {
            return "Insufficient data for analysis".to_string();
        }
        
        let n = function_values.len();
        let mut growth_ratios = Vec::new();
        
        // 计算增长比率
        // Calculate growth ratios
        for i in 1..n {
            let size_ratio = input_sizes[i] as f64 / input_sizes[i-1] as f64;
            let value_ratio = function_values[i] / function_values[i-1];
            let growth_ratio = value_ratio / size_ratio;
            growth_ratios.push(growth_ratio);
        }
        
        let avg_growth = growth_ratios.iter().sum::<f64>() / growth_ratios.len() as f64;
        
        // 分类复杂度
        // Classify complexity
        if avg_growth < 1.2 {
            "O(1) - Constant".to_string()
        } else if avg_growth < 2.0 {
            "O(log n) - Logarithmic".to_string()
        } else if avg_growth < 3.0 {
            "O(n) - Linear".to_string()
        } else if avg_growth < 4.0 {
            "O(n log n) - Linearithmic".to_string()
        } else if avg_growth < 6.0 {
            "O(n²) - Quadratic".to_string()
        } else {
            "O(n^k) where k > 2 - Polynomial or higher".to_string()
        }
    }
    
    /// Theta 分析（紧确界）
    /// Theta analysis (tight bound)
    pub fn theta_analysis(&self, best_case: &[f64], worst_case: &[f64], input_sizes: &[usize]) -> String {
        let best_complexity = self.big_o_analysis(best_case, input_sizes);
        let worst_complexity = self.big_o_analysis(worst_case, input_sizes);
        
        if best_complexity == worst_complexity {
            format!("Θ({}) - Tight bound", best_complexity.split_whitespace().next().unwrap_or("unknown"))
        } else {
            format!("No tight bound: Best case {}, Worst case {}", best_complexity, worst_complexity)
        }
    }
    
    /// Omega 分析（下界）
    /// Omega analysis (lower bound)
    pub fn omega_analysis(&self, best_case: &[f64], input_sizes: &[usize]) -> String {
        let complexity = self.big_o_analysis(best_case, input_sizes);
        format!("Ω({}) - Lower bound", complexity.split_whitespace().next().unwrap_or("unknown"))
    }
}
```

### 递归关系分析 / Recurrence Relation Analysis

```rust
// 递归关系分析器
// Recurrence relation analyzer

pub struct RecurrenceAnalyzer {
    name: String,
}

impl RecurrenceAnalyzer {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    /// 主定理分析
    /// Master theorem analysis
    pub fn master_theorem(&self, a: f64, b: f64, d: f64) -> String {
        if b <= 1.0 || a <= 0.0 {
            return "Invalid parameters for master theorem".to_string();
        }
        
        let log_b_a = a.log(b);
        
        if d < log_b_a {
            format!("Case 1: T(n) = Θ(n^{:.2})", log_b_a)
        } else if d == log_b_a {
            format!("Case 2: T(n) = Θ(n^{:.2} log n)", d)
        } else {
            format!("Case 3: T(n) = Θ(n^{:.2})", d)
        }
    }
    
    /// 展开法分析
    /// Substitution method analysis
    pub fn substitution_method(&self, recurrence_type: &str, n: usize) -> f64 {
        match recurrence_type {
            "binary_search" => self.binary_search_recurrence(n),
            "merge_sort" => self.merge_sort_recurrence(n),
            "fibonacci" => self.fibonacci_recurrence(n),
            _ => 0.0,
        }
    }
    
    fn binary_search_recurrence(&self, n: usize) -> f64 {
        if n <= 1 {
            1.0
        } else {
            1.0 + self.binary_search_recurrence(n / 2)
        }
    }
    
    fn merge_sort_recurrence(&self, n: usize) -> f64 {
        if n <= 1 {
            1.0
        } else {
            2.0 * self.merge_sort_recurrence(n / 2) + n as f64
        }
    }
    
    fn fibonacci_recurrence(&self, n: usize) -> f64 {
        if n <= 1 {
            1.0
        } else {
            self.fibonacci_recurrence(n - 1) + self.fibonacci_recurrence(n - 2)
        }
    }
    
    /// 递归树分析
    /// Recursion tree analysis
    pub fn recursion_tree_analysis(&self, a: usize, b: usize, depth: usize) -> Vec<f64> {
        let mut tree_levels = Vec::new();
        
        for level in 0..depth {
            let nodes_at_level = a.pow(level as u32) as f64;
            let work_per_node = (1.0 / b as f64).powi(level as i32);
            let total_work = nodes_at_level * work_per_node;
            tree_levels.push(total_work);
        }
        
        tree_levels
    }
}
```

## 摊还分析 / Amortized Analysis

### 聚合分析 / Aggregate Analysis

```rust
// 摊还分析工具
// Amortized analysis tools

pub struct AmortizedAnalyzer {
    name: String,
}

impl AmortizedAnalyzer {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    /// 动态数组的摊还分析
    /// Amortized analysis of dynamic arrays
    pub struct DynamicArray<T> {
        data: Vec<T>,
        size: usize,
        capacity: usize,
        total_operations: usize,
        total_cost: usize,
    }
    
    impl<T: Clone> DynamicArray<T> {
        pub fn new() -> Self {
            Self {
                data: Vec::new(),
                size: 0,
                capacity: 1,
                total_operations: 0,
                total_cost: 0,
            }
        }
        
        pub fn push(&mut self, item: T) {
            self.total_operations += 1;
            
            if self.size >= self.capacity {
                // 需要扩容
                // Need to resize
                self.resize();
                self.total_cost += self.size; // 复制成本
            }
            
            self.data.push(item);
            self.size += 1;
            self.total_cost += 1; // 插入成本
        }
        
        fn resize(&mut self) {
            self.capacity *= 2;
            // 在实际实现中，这里会重新分配内存
            // In actual implementation, memory would be reallocated here
        }
        
        pub fn amortized_cost(&self) -> f64 {
            if self.total_operations == 0 {
                0.0
            } else {
                self.total_cost as f64 / self.total_operations as f64
            }
        }
        
        pub fn size(&self) -> usize {
            self.size
        }
    }
    
    /// 二项堆的摊还分析
    /// Amortized analysis of binomial heaps
    pub struct BinomialHeap {
        min_node: Option<usize>,
        size: usize,
        potential: usize, // 势能函数
    }
    
    impl BinomialHeap {
        pub fn new() -> Self {
            Self {
                min_node: None,
                size: 0,
                potential: 0,
            }
        }
        
        pub fn insert(&mut self, value: i32) -> usize {
            self.size += 1;
            let old_potential = self.potential;
            
            // 更新势能（二项堆中树的数量）
            // Update potential (number of trees in binomial heap)
            self.potential = self.count_trees();
            
            let actual_cost = 1; // 实际插入成本
            let potential_change = self.potential as i32 - old_potential as i32;
            let amortized_cost = actual_cost + potential_change;
            
            amortized_cost as usize
        }
        
        pub fn extract_min(&mut self) -> Option<i32> {
            if self.size == 0 {
                return None;
            }
            
            self.size -= 1;
            let old_potential = self.potential;
            
            // 模拟提取最小值操作
            // Simulate extract minimum operation
            self.potential = self.count_trees();
            
            let actual_cost = self.potential + 1; // 实际提取成本
            let potential_change = self.potential as i32 - old_potential as i32;
            let _amortized_cost = actual_cost as i32 + potential_change;
            
            Some(0) // 简化返回
        }
        
        fn count_trees(&self) -> usize {
            // 计算二项堆中的树数量（简化版本）
            // Count number of trees in binomial heap (simplified)
            self.size.count_ones() as usize
        }
    }
}
```

### 银行家方法 / Banker's Method

```rust
// 银行家方法分析
// Banker's method analysis

pub struct BankersMethodAnalyzer {
    name: String,
}

impl BankersMethodAnalyzer {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    /// 栈的摊还分析（银行家方法）
    /// Amortized analysis of stack (banker's method)
    pub struct AmortizedStack<T> {
        data: Vec<T>,
        credits: usize, // 信用点数
    }
    
    impl<T> AmortizedStack<T> {
        pub fn new() -> Self {
            Self {
                data: Vec::new(),
                credits: 0,
            }
        }
        
        pub fn push(&mut self, item: T) -> usize {
            self.data.push(item);
            self.credits += 2; // 为每个元素分配2个信用点
            1 // 摊还成本为1
        }
        
        pub fn pop(&mut self) -> Option<T> {
            if let Some(item) = self.data.pop() {
                self.credits = self.credits.saturating_sub(2); // 使用2个信用点
                Some(item)
            } else {
                None
            }
        }
        
        pub fn multipop(&mut self, k: usize) -> Vec<T> {
            let mut result = Vec::new();
            let actual_pops = std::cmp::min(k, self.data.len());
            
            for _ in 0..actual_pops {
                if let Some(item) = self.data.pop() {
                    result.push(item);
                    self.credits = self.credits.saturating_sub(2);
                }
            }
            
            result
        }
        
        pub fn size(&self) -> usize {
            self.data.len()
        }
        
        pub fn credits(&self) -> usize {
            self.credits
        }
    }
    
    /// 二进制计数器的摊还分析
    /// Amortized analysis of binary counter
    pub struct BinaryCounter {
        bits: Vec<bool>,
        credits: Vec<usize>, // 每个位的信用点
    }
    
    impl BinaryCounter {
        pub fn new(size: usize) -> Self {
            Self {
                bits: vec![false; size],
                credits: vec![0; size],
            }
        }
        
        pub fn increment(&mut self) -> usize {
            let mut i = 0;
            let mut amortized_cost = 0;
            
            // 找到第一个0位
            // Find first 0 bit
            while i < self.bits.len() && self.bits[i] {
                self.bits[i] = false;
                // 使用信用点支付翻转成本
                // Use credits to pay for flip cost
                if self.credits[i] > 0 {
                    self.credits[i] -= 1;
                } else {
                    amortized_cost += 1;
                }
                i += 1;
            }
            
            // 设置第一个0位为1
            // Set first 0 bit to 1
            if i < self.bits.len() {
                self.bits[i] = true;
                self.credits[i] += 1; // 为这一位分配信用点
                amortized_cost += 2; // 实际成本1 + 信用点1
            }
            
            amortized_cost
        }
        
        pub fn value(&self) -> usize {
            let mut result = 0;
            for (i, &bit) in self.bits.iter().enumerate() {
                if bit {
                    result += 1 << i;
                }
            }
            result
        }
    }
}
```

## 概率分析 / Probabilistic Analysis

### 随机算法分析 / Randomized Algorithm Analysis

```rust
// 概率分析工具
// Probabilistic analysis tools

use rand::{Rng, thread_rng};

pub struct ProbabilisticAnalyzer {
    name: String,
}

impl ProbabilisticAnalyzer {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    /// 快速排序的概率分析
    /// Probabilistic analysis of quicksort
    pub fn analyze_randomized_quicksort(&self, n: usize, trials: usize) -> (f64, f64, f64) {
        let mut times = Vec::new();
        
        for _ in 0..trials {
            let mut arr: Vec<i32> = (0..n as i32).collect();
            self.shuffle(&mut arr);
            
            let start = std::time::Instant::now();
            self.randomized_quicksort(&mut arr);
            let duration = start.elapsed().as_nanos() as f64;
            times.push(duration);
        }
        
        let mean = times.iter().sum::<f64>() / times.len() as f64;
        let variance = times.iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / times.len() as f64;
        let std_dev = variance.sqrt();
        
        (mean, variance, std_dev)
    }
    
    fn randomized_quicksort(&self, arr: &mut [i32]) {
        if arr.len() <= 1 {
            return;
        }
        
        // 随机选择pivot
        // Randomly select pivot
        let mut rng = thread_rng();
        let pivot_index = rng.gen_range(0..arr.len());
        arr.swap(0, pivot_index);
        
        let pivot = self.partition(arr);
        let (left, right) = arr.split_at_mut(pivot);
        
        self.randomized_quicksort(left);
        self.randomized_quicksort(&mut right[1..]);
    }
    
    fn partition(&self, arr: &mut [i32]) -> usize {
        let pivot = arr[0];
        let mut i = 1;
        
        for j in 1..arr.len() {
            if arr[j] <= pivot {
                arr.swap(i, j);
                i += 1;
            }
        }
        
        arr.swap(0, i - 1);
        i - 1
    }
    
    fn shuffle(&self, arr: &mut [i32]) {
        let mut rng = thread_rng();
        for i in (1..arr.len()).rev() {
            let j = rng.gen_range(0..=i);
            arr.swap(i, j);
        }
    }
    
    /// 期望值分析
    /// Expected value analysis
    pub fn expected_value_analysis(&self, outcomes: &[f64], probabilities: &[f64]) -> f64 {
        if outcomes.len() != probabilities.len() {
            return 0.0;
        }
        
        outcomes.iter()
            .zip(probabilities.iter())
            .map(|(&outcome, &prob)| outcome * prob)
            .sum()
    }
    
    /// 方差分析
    /// Variance analysis
    pub fn variance_analysis(&self, outcomes: &[f64], probabilities: &[f64]) -> f64 {
        let expected_value = self.expected_value_analysis(outcomes, probabilities);
        
        outcomes.iter()
            .zip(probabilities.iter())
            .map(|(&outcome, &prob)| (outcome - expected_value).powi(2) * prob)
            .sum()
    }
    
    /// 尾界分析（Chernoff界）
    /// Tail bound analysis (Chernoff bound)
    pub fn chernoff_bound(&self, n: usize, p: f64, delta: f64) -> f64 {
        let mu = n as f64 * p;
        if delta <= 0.0 {
            return 1.0;
        }
        
        // Chernoff界: P(X > (1+δ)μ) ≤ e^(-δ²μ/3)
        // Chernoff bound: P(X > (1+δ)μ) ≤ e^(-δ²μ/3)
        (-delta * delta * mu / 3.0).exp()
    }
}
```

### 马尔可夫链分析 / Markov Chain Analysis

```rust
// 马尔可夫链分析
// Markov chain analysis

pub struct MarkovChainAnalyzer {
    name: String,
}

impl MarkovChainAnalyzer {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    /// 马尔可夫链模拟
    /// Markov chain simulation
    pub struct MarkovChain {
        states: Vec<String>,
        transition_matrix: Vec<Vec<f64>>,
        current_state: usize,
    }
    
    impl MarkovChain {
        pub fn new(states: Vec<String>, transition_matrix: Vec<Vec<f64>>) -> Self {
            Self {
                states,
                transition_matrix,
                current_state: 0,
            }
        }
        
        pub fn next_state(&mut self) -> &str {
            let mut rng = thread_rng();
            let random_value: f64 = rng.gen();
            
            let mut cumulative_prob = 0.0;
            for (next_state, &prob) in self.transition_matrix[self.current_state].iter().enumerate() {
                cumulative_prob += prob;
                if random_value <= cumulative_prob {
                    self.current_state = next_state;
                    break;
                }
            }
            
            &self.states[self.current_state]
        }
        
        pub fn simulate_steps(&mut self, steps: usize) -> Vec<String> {
            let mut path = Vec::new();
            
            for _ in 0..steps {
                path.push(self.next_state().to_string());
            }
            
            path
        }
        
        pub fn steady_state_distribution(&self, iterations: usize) -> Vec<f64> {
            let n = self.states.len();
            let mut distribution = vec![1.0 / n as f64; n];
            
            for _ in 0..iterations {
                let mut new_distribution = vec![0.0; n];
                
                for i in 0..n {
                    for j in 0..n {
                        new_distribution[j] += distribution[i] * self.transition_matrix[i][j];
                    }
                }
                
                distribution = new_distribution;
            }
            
            distribution
        }
    }
    
    /// 随机游走分析
    /// Random walk analysis
    pub fn analyze_random_walk(&self, steps: usize, start_position: i32) -> (f64, f64) {
        let mut positions = Vec::new();
        let mut current_position = start_position;
        
        let mut rng = thread_rng();
        
        for _ in 0..steps {
            if rng.gen::<f64>() < 0.5 {
                current_position += 1;
            } else {
                current_position -= 1;
            }
            positions.push(current_position);
        }
        
        let mean_position = positions.iter().sum::<i32>() as f64 / positions.len() as f64;
        let variance = positions.iter()
            .map(|&pos| (pos as f64 - mean_position).powi(2))
            .sum::<f64>() / positions.len() as f64;
        
        (mean_position, variance)
    }
}
```

## 实验分析 / Experimental Analysis

### 性能测试框架 / Performance Testing Framework

```rust
// 性能测试框架
// Performance testing framework

use std::time::{Duration, Instant};

pub struct PerformanceTester {
    name: String,
}

impl PerformanceTester {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    /// 基准测试
    /// Benchmark testing
    pub fn benchmark<F, T>(&self, name: &str, setup: F, iterations: usize) -> BenchmarkResult
    where F: Fn() -> T {
        let mut times = Vec::new();
        
        for _ in 0..iterations {
            let start = Instant::now();
            let _result = setup();
            let duration = start.elapsed();
            times.push(duration);
        }
        
        BenchmarkResult::new(name.to_string(), times)
    }
    
    /// 可扩展性测试
    /// Scalability testing
    pub fn scalability_test<F, T>(&self, algorithm: F, input_sizes: &[usize]) -> ScalabilityResult
    where F: Fn(usize) -> T {
        let mut results = Vec::new();
        
        for &size in input_sizes {
            let start = Instant::now();
            let _result = algorithm(size);
            let duration = start.elapsed();
            results.push((size, duration));
        }
        
        ScalabilityResult::new(results)
    }
    
    /// 内存使用分析
    /// Memory usage analysis
    pub fn memory_analysis<F, T>(&self, algorithm: F) -> MemoryResult
    where F: FnOnce() -> T {
        let start_memory = self.get_memory_usage();
        let _result = algorithm();
        let end_memory = self.get_memory_usage();
        
        MemoryResult {
            peak_usage: end_memory - start_memory,
            allocations: 0, // 简化版本
        }
    }
    
    fn get_memory_usage(&self) -> usize {
        // 简化的内存使用获取
        // Simplified memory usage retrieval
        0
    }
}

pub struct BenchmarkResult {
    name: String,
    times: Vec<Duration>,
}

impl BenchmarkResult {
    pub fn new(name: String, times: Vec<Duration>) -> Self {
        Self { name, times }
    }
    
    pub fn mean(&self) -> Duration {
        let total: Duration = self.times.iter().sum();
        total / self.times.len() as u32
    }
    
    pub fn median(&self) -> Duration {
        let mut sorted_times = self.times.clone();
        sorted_times.sort();
        sorted_times[sorted_times.len() / 2]
    }
    
    pub fn min(&self) -> Duration {
        *self.times.iter().min().unwrap()
    }
    
    pub fn max(&self) -> Duration {
        *self.times.iter().max().unwrap()
    }
    
    pub fn standard_deviation(&self) -> f64 {
        let mean = self.mean().as_nanos() as f64;
        let variance = self.times.iter()
            .map(|t| (t.as_nanos() as f64 - mean).powi(2))
            .sum::<f64>() / self.times.len() as f64;
        variance.sqrt()
    }
}

pub struct ScalabilityResult {
    data_points: Vec<(usize, Duration)>,
}

impl ScalabilityResult {
    pub fn new(data_points: Vec<(usize, Duration)>) -> Self {
        Self { data_points }
    }
    
    pub fn growth_rate(&self) -> f64 {
        if self.data_points.len() < 2 {
            return 0.0;
        }
        
        let (size1, time1) = self.data_points[0];
        let (size2, time2) = self.data_points[self.data_points.len() - 1];
        
        let size_ratio = size2 as f64 / size1 as f64;
        let time_ratio = time2.as_nanos() as f64 / time1.as_nanos() as f64;
        
        time_ratio.log(size_ratio)
    }
    
    pub fn efficiency(&self) -> Vec<f64> {
        self.data_points.iter()
            .map(|(size, time)| *size as f64 / time.as_nanos() as f64)
            .collect()
    }
}

pub struct MemoryResult {
    peak_usage: usize,
    allocations: usize,
}

impl MemoryResult {
    pub fn peak_usage(&self) -> usize {
        self.peak_usage
    }
    
    pub fn allocations(&self) -> usize {
        self.allocations
    }
}
```

## 应用案例 / Application Cases

### 案例1：排序算法比较分析 / Case 1: Comparative Analysis of Sorting Algorithms

```rust
// 排序算法比较分析
// Comparative analysis of sorting algorithms

pub struct SortingAnalyzer {
    name: String,
}

impl SortingAnalyzer {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    /// 排序算法比较
    /// Sorting algorithm comparison
    pub fn compare_sorting_algorithms(&self, input_sizes: &[usize]) -> ComparisonResult {
        let mut results = ComparisonResult::new();
        
        for &size in input_sizes {
            // 生成测试数据
            // Generate test data
            let random_data: Vec<i32> = (0..size).map(|_| rand::random()).collect();
            let sorted_data: Vec<i32> = (0..size as i32).collect();
            let reverse_sorted_data: Vec<i32> = (0..size as i32).rev().collect();
            
            // 测试不同算法
            // Test different algorithms
            results.add_result("QuickSort", "Random", 
                self.test_quicksort(random_data.clone()));
            results.add_result("QuickSort", "Sorted", 
                self.test_quicksort(sorted_data.clone()));
            results.add_result("QuickSort", "Reverse", 
                self.test_quicksort(reverse_sorted_data.clone()));
            
            results.add_result("MergeSort", "Random", 
                self.test_mergesort(random_data.clone()));
            results.add_result("MergeSort", "Sorted", 
                self.test_mergesort(sorted_data.clone()));
            results.add_result("MergeSort", "Reverse", 
                self.test_mergesort(reverse_sorted_data.clone()));
            
            results.add_result("HeapSort", "Random", 
                self.test_heapsort(random_data.clone()));
            results.add_result("HeapSort", "Sorted", 
                self.test_heapsort(sorted_data.clone()));
            results.add_result("HeapSort", "Reverse", 
                self.test_heapsort(reverse_sorted_data));
        }
        
        results
    }
    
    fn test_quicksort(&self, mut data: Vec<i32>) -> Duration {
        let start = Instant::now();
        self.quicksort(&mut data);
        start.elapsed()
    }
    
    fn test_mergesort(&self, mut data: Vec<i32>) -> Duration {
        let start = Instant::now();
        self.mergesort(&mut data);
        start.elapsed()
    }
    
    fn test_heapsort(&self, mut data: Vec<i32>) -> Duration {
        let start = Instant::now();
        self.heapsort(&mut data);
        start.elapsed()
    }
    
    fn quicksort(&self, arr: &mut [i32]) {
        if arr.len() <= 1 {
            return;
        }
        
        let pivot = self.partition(arr);
        let (left, right) = arr.split_at_mut(pivot);
        
        self.quicksort(left);
        self.quicksort(&mut right[1..]);
    }
    
    fn mergesort(&self, arr: &mut [i32]) {
        if arr.len() <= 1 {
            return;
        }
        
        let mid = arr.len() / 2;
        let (left, right) = arr.split_at_mut(mid);
        
        self.mergesort(left);
        self.mergesort(right);
        
        self.merge(arr, mid);
    }
    
    fn heapsort(&self, arr: &mut [i32]) {
        let n = arr.len();
        
        // 建堆
        // Build heap
        for i in (0..n/2).rev() {
            self.heapify(arr, n, i);
        }
        
        // 排序
        // Sort
        for i in (1..n).rev() {
            arr.swap(0, i);
            self.heapify(arr, i, 0);
        }
    }
    
    fn partition(&self, arr: &mut [i32]) -> usize {
        let pivot = arr[arr.len() - 1];
        let mut i = 0;
        
        for j in 0..arr.len() - 1 {
            if arr[j] <= pivot {
                arr.swap(i, j);
                i += 1;
            }
        }
        
        arr.swap(i, arr.len() - 1);
        i
    }
    
    fn merge(&self, arr: &mut [i32], mid: usize) {
        let left = arr[..mid].to_vec();
        let right = arr[mid..].to_vec();
        
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;
        
        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                arr[k] = left[i];
                i += 1;
            } else {
                arr[k] = right[j];
                j += 1;
            }
            k += 1;
        }
        
        while i < left.len() {
            arr[k] = left[i];
            i += 1;
            k += 1;
        }
        
        while j < right.len() {
            arr[k] = right[j];
            j += 1;
            k += 1;
        }
    }
    
    fn heapify(&self, arr: &mut [i32], n: usize, i: usize) {
        let mut largest = i;
        let left = 2 * i + 1;
        let right = 2 * i + 2;
        
        if left < n && arr[left] > arr[largest] {
            largest = left;
        }
        
        if right < n && arr[right] > arr[largest] {
            largest = right;
        }
        
        if largest != i {
            arr.swap(i, largest);
            self.heapify(arr, n, largest);
        }
    }
}

pub struct ComparisonResult {
    results: std::collections::HashMap<String, Duration>,
}

impl ComparisonResult {
    pub fn new() -> Self {
        Self {
            results: std::collections::HashMap::new(),
        }
    }
    
    pub fn add_result(&mut self, algorithm: &str, input_type: &str, duration: Duration) {
        let key = format!("{}_{}", algorithm, input_type);
        self.results.insert(key, duration);
    }
    
    pub fn get_result(&self, algorithm: &str, input_type: &str) -> Option<&Duration> {
        let key = format!("{}_{}", algorithm, input_type);
        self.results.get(&key)
    }
    
    pub fn print_summary(&self) {
        println!("Algorithm Performance Comparison:");
        println!("================================");
        
        for (key, duration) in &self.results {
            println!("{}: {:?}", key, duration);
        }
    }
}
```

## 总结 / Summary

算法分析理论为我们提供了评估和比较算法性能的强大工具。通过渐进分析、摊还分析、概率分析和实验分析等方法，我们可以深入理解算法的行为特征和性能表现。

Algorithm analysis theory provides us with powerful tools for evaluating and comparing algorithm performance. Through asymptotic analysis, amortized analysis, probabilistic analysis, and experimental analysis, we can deeply understand the behavioral characteristics and performance of algorithms.

### 关键要点 / Key Points

1. **多维度分析** / Multi-dimensional Analysis
   - 时间复杂度、空间复杂度、正确性
   - 理论分析与实验验证相结合

2. **渐进分析** / Asymptotic Analysis
   - Big-O、Theta、Omega记号
   - 递归关系的求解

3. **摊还分析** / Amortized Analysis
   - 聚合分析、银行家方法、势能方法
   - 动态数据结构的性能保证

4. **概率分析** / Probabilistic Analysis
   - 随机算法的期望性能
   - 尾界分析和集中不等式

---

**参考文献 / References**:

1. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to algorithms. MIT press.
2. Knuth, D. E. (1997). The art of computer programming. Addison-Wesley.
3. Sedgewick, R., & Wayne, K. (2011). Algorithms. Addison-Wesley Professional.
4. Kleinberg, J., & Tardos, E. (2005). Algorithm design. Pearson Education India.
5. Motwani, R., & Raghavan, P. (1995). Randomized algorithms. Cambridge university press.
