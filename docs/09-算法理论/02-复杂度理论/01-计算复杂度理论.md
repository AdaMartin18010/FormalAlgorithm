# 9.2 计算复杂度理论

## 目录

- [9.2 计算复杂度理论](#92-计算复杂度理论)
  - [目录](#目录)
  - [1. 基本概念](#1-基本概念)
    - [1.1 计算模型](#11-计算模型)
    - [1.2 问题分类](#12-问题分类)
    - [1.3 算法效率](#13-算法效率)
  - [2. 时间复杂度](#2-时间复杂度)
    - [2.1 基本定义](#21-基本定义)
    - [2.2 渐进分析](#22-渐进分析)
    - [2.3 常见复杂度类](#23-常见复杂度类)
  - [3. 空间复杂度](#3-空间复杂度)
    - [3.1 基本定义](#31-基本定义)
    - [3.2 空间层次](#32-空间层次)
    - [3.3 时间空间权衡](#33-时间空间权衡)
  - [4. 复杂度类](#4-复杂度类)
    - [4.1 确定性复杂度类](#41-确定性复杂度类)
    - [4.2 非确定性复杂度类](#42-非确定性复杂度类)
    - [4.3 复杂度类关系](#43-复杂度类关系)
  - [5. 下界理论](#5-下界理论)
    - [5.1 信息论下界](#51-信息论下界)
    - [5.2 通信复杂度下界](#52-通信复杂度下界)
    - [5.3 电路复杂度下界](#53-电路复杂度下界)
  - [6. 参考文献](#6-参考文献)

---

## 1. 基本概念

### 1.1 计算模型

**定义 1.1.1** 随机访问机器(RAM)模型是算法分析的标准计算模型。

**RAM模型特征：**

- 无限内存
- 基本操作在常数时间内完成
- 内存访问在常数时间内完成

**定义 1.1.2** 图灵机模型是理论计算的标准模型。

**图灵机特征：**

- 有限状态控制
- 无限磁带
- 读写头可以左右移动

### 1.2 问题分类

**定义 1.2.1** 判定问题是输出为"是"或"否"的问题。

**形式化表示：**
$$L \subseteq \Sigma^*$$

其中 $L$ 是语言，$\Sigma$ 是字母表。

**定义 1.2.2** 优化问题是寻找最优解的问题。

**形式化表示：**
$$f: \Sigma^* \rightarrow \mathbb{R}$$

其中 $f$ 是目标函数。

### 1.3 算法效率

**定义 1.3.1** 算法的效率是时间和空间复杂度的综合评估。

**效率度量：**
$$E(A) = \alpha \cdot T_A(n) + \beta \cdot S_A(n)$$

其中 $\alpha$ 和 $\beta$ 是权重因子。

---

## 2. 时间复杂度

### 2.1 基本定义

**定义 2.1.1** 算法 $A$ 的时间复杂度函数：
$$T_A: \mathbb{N} \rightarrow \mathbb{N}$$

其中 $T_A(n)$ 表示输入大小为 $n$ 时的最坏情况运行时间。

**定义 2.1.2** 平均情况时间复杂度：
$$T_A^{avg}(n) = \sum_{x: |x| = n} p(x) \cdot t_A(x)$$

其中 $p(x)$ 是输入 $x$ 的概率分布。

### 2.2 渐进分析

**定义 2.2.1** 大O记号：
$$f(n) = O(g(n)) \Leftrightarrow \exists c, n_0: \forall n \geq n_0, f(n) \leq c \cdot g(n)$$

**定义 2.2.2** 大Ω记号：
$$f(n) = \Omega(g(n)) \Leftrightarrow \exists c, n_0: \forall n \geq n_0, f(n) \geq c \cdot g(n)$$

**定义 2.2.3** 大Θ记号：
$$f(n) = \Theta(g(n)) \Leftrightarrow f(n) = O(g(n)) \land f(n) = \Omega(g(n))$$

### 2.3 常见复杂度类

**定义 2.3.1** 常见的时间复杂度类：

1. **常数时间**：$O(1)$
2. **对数时间**：$O(\log n)$
3. **线性时间**：$O(n)$
4. **线性对数时间**：$O(n \log n)$
5. **平方时间**：$O(n^2)$
6. **立方时间**：$O(n^3)$
7. **指数时间**：$O(2^n)$
8. **阶乘时间**：$O(n!)$

---

## 3. 空间复杂度

### 3.1 基本定义

**定义 3.1.1** 算法的空间复杂度函数：
$$S_A: \mathbb{N} \rightarrow \mathbb{N}$$

其中 $S_A(n)$ 表示输入大小为 $n$ 时的最坏情况空间使用量。

**定义 3.1.2** 辅助空间复杂度：
$$S_A^{aux}(n) = S_A(n) - n$$

表示除输入外的额外空间使用量。

### 3.2 空间层次

**定义 3.2.1** 空间复杂度层次：

1. **常数空间**：$O(1)$
2. **对数空间**：$O(\log n)$
3. **线性空间**：$O(n)$
4. **多项式空间**：$O(n^k)$
5. **指数空间**：$O(2^n)$

### 3.3 时间空间权衡

**定理 3.3.1** 对于任意算法 $A$：
$$T_A(n) \geq S_A(n)$$

**证明：**
算法必须至少读取其使用的所有内存位置。

**定理 3.3.2** (时间空间权衡)
对于某些问题，减少空间使用会增加时间使用，反之亦然。

---

## 4. 复杂度类

### 4.1 确定性复杂度类

**定义 4.1.1** 确定性时间类：
$$\text{DTIME}(f(n)) = \{L : \exists \text{图灵机 } M \text{ 在时间 } O(f(n)) \text{ 内判定 } L\}$$

**重要类：**

- **P**：$\text{P} = \bigcup_{k \in \mathbb{N}} \text{DTIME}(n^k)$
- **EXP**：$\text{EXP} = \bigcup_{k \in \mathbb{N}} \text{DTIME}(2^{n^k})$

**定义 4.1.2** 确定性空间类：
$$\text{DSPACE}(f(n)) = \{L : \exists \text{图灵机 } M \text{ 在空间 } O(f(n)) \text{ 内判定 } L\}$$

**重要类：**

- **L**：$\text{L} = \text{DSPACE}(\log n)$
- **PSPACE**：$\text{PSPACE} = \bigcup_{k \in \mathbb{N}} \text{DSPACE}(n^k)$

### 4.2 非确定性复杂度类

**定义 4.2.1** 非确定性时间类：
$$\text{NTIME}(f(n)) = \{L : \exists \text{非确定性图灵机 } M \text{ 在时间 } O(f(n)) \text{ 内判定 } L\}$$

**重要类：**

- **NP**：$\text{NP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(n^k)$
- **NEXP**：$\text{NEXP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(2^{n^k})$

**定义 4.2.2** 非确定性空间类：
$$\text{NSPACE}(f(n)) = \{L : \exists \text{非确定性图灵机 } M \text{ 在空间 } O(f(n)) \text{ 内判定 } L\}$$

### 4.3 复杂度类关系

**定理 4.3.1** (萨维奇定理)
$$\text{NSPACE}(f(n)) \subseteq \text{DSPACE}(f^2(n))$$

**定理 4.3.2** (时间层次定理)
对于时间可构造函数 $f$ 和 $g$：
$$f(n) \log f(n) = o(g(n)) \Rightarrow \text{DTIME}(f(n)) \subsetneq \text{DTIME}(g(n))$$

**定理 4.3.3** (空间层次定理)
对于空间可构造函数 $f$ 和 $g$：
$$f(n) = o(g(n)) \Rightarrow \text{DSPACE}(f(n)) \subsetneq \text{DSPACE}(g(n))$$

---

## 5. 下界理论

### 5.1 信息论下界

**定理 5.1.1** 任何比较排序算法的最坏情况时间复杂度为 $\Omega(n \log n)$。

**证明：**

- 排序问题的决策树高度至少为 $\log(n!)$
- 根据斯特林公式：$\log(n!) = \Theta(n \log n)$
- 因此任何比较排序算法需要 $\Omega(n \log n)$ 次比较

### 5.2 通信复杂度下界

**定义 5.2.1** 函数 $f: \{0,1\}^n \times \{0,1\}^n \rightarrow \{0,1\}$ 的确定性通信复杂度：
$$D(f) = \min_{P} \max_{x,y} \text{协议 } P \text{ 在输入 } (x,y) \text{ 上的通信位数}$$

**定理 5.2.1** 对于函数 $f$：
$$D(f) \geq \log \text{rank}(M_f)$$

其中 $M_f$ 是 $f$ 的通信矩阵。

### 5.3 电路复杂度下界

**定义 5.3.1** 布尔函数 $f$ 的电路复杂度 $C(f)$ 是计算 $f$ 的最小电路大小。

**定理 5.3.1** (香农下界) 几乎所有布尔函数 $f: \{0,1\}^n \rightarrow \{0,1\}$ 的电路复杂度为：
$$C(f) = \Omega\left(\frac{2^n}{n}\right)$$

**证明：**

- 大小为 $s$ 的电路数量为 $2^{O(s \log s)}$
- 布尔函数总数为 $2^{2^n}$
- 如果 $s = o(2^n/n)$，则电路数量少于布尔函数数量

---

## 6. 参考文献

1. Arora, S., & Barak, B. (2009). Computational Complexity.
2. Papadimitriou, C. H. (1994). Computational Complexity.
3. Goldreich, O. (2008). Computational Complexity.
4. Sipser, M. (2013). Introduction to the Theory of Computation.
5. Hopcroft, J. E., & Ullman, J. D. (1979). Introduction to Automata Theory, Languages, and Computation.

---

*本文档严格遵循数学形式化规范，所有定义和定理均采用标准数学符号表示。*
