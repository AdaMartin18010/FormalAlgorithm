---
title: 9.2.1 è®¡ç®—å¤æ‚åº¦ç†è®º / Computational Complexity Theory
version: 1.0
status: maintained
last_updated: 2025-01-11
owner: ç®—æ³•ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 9.2.1 è®¡ç®—å¤æ‚åº¦ç†è®º / Computational Complexity Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€è®¡ç®—å¤æ‚åº¦ç†è®ºçš„å½¢å¼åŒ–å®šä¹‰ã€æ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ä¸å¤æ‚åº¦ç±»ã€‚
- å»ºç«‹å¤æ‚åº¦ç†è®ºåœ¨ç®—æ³•åˆ†æä¸­çš„æ ¸å¿ƒåœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- è®¡ç®—å¤æ‚åº¦ã€æ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ã€å¤æ‚åº¦ç±»ã€ä¸‹ç•Œç†è®ºã€RAMæ¨¡å‹ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- è®¡ç®—å¤æ‚åº¦ï¼ˆComputational Complexityï¼‰ï¼šç ”ç©¶ç®—æ³•æ‰€éœ€èµ„æºçš„ç†è®ºã€‚
- æ—¶é—´å¤æ‚åº¦ï¼ˆTime Complexityï¼‰ï¼šç®—æ³•æ‰§è¡Œæ‰€éœ€çš„æ—¶é—´èµ„æºã€‚
- ç©ºé—´å¤æ‚åº¦ï¼ˆSpace Complexityï¼‰ï¼šç®—æ³•æ‰§è¡Œæ‰€éœ€çš„ç©ºé—´èµ„æºã€‚
- è®°å·çº¦å®šï¼š`O`ã€`Î©`ã€`Î˜` è¡¨ç¤ºæ¸è¿›å¤æ‚åº¦ï¼Œ`P`ã€`NP` è¡¨ç¤ºå¤æ‚åº¦ç±»ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- ç®—æ³•å¤æ‚åº¦ï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/` ç›¸å…³æ–‡æ¡£ã€‚
- ç®—æ³•è®¾è®¡ï¼šå‚è§ `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/01-ç®—æ³•è®¾è®¡ç†è®º.md`ã€‚
- è®¡ç®—æ¨¡å‹ï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- æ—¶é—´å¤æ‚åº¦
- ç©ºé—´å¤æ‚åº¦
- å¤æ‚åº¦ç±»

## ç›®å½• / Table of Contents

- [9.2.1 è®¡ç®—å¤æ‚åº¦ç†è®º / Computational Complexity Theory](#921-è®¡ç®—å¤æ‚åº¦ç†è®º--computational-complexity-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#1-åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [1.1 è®¡ç®—æ¨¡å‹ / Computational Models](#11-è®¡ç®—æ¨¡å‹--computational-models)
  - [1.2 é—®é¢˜åˆ†ç±» / Problem Classification](#12-é—®é¢˜åˆ†ç±»--problem-classification)
  - [1.3 ç®—æ³•æ•ˆç‡ / Algorithm Efficiency](#13-ç®—æ³•æ•ˆç‡--algorithm-efficiency)
- [2. æ—¶é—´å¤æ‚åº¦ / Time Complexity](#2-æ—¶é—´å¤æ‚åº¦--time-complexity)
  - [2.1 åŸºæœ¬å®šä¹‰ / Basic Definitions](#21-åŸºæœ¬å®šä¹‰--basic-definitions)
  - [2.2 æ¸è¿›åˆ†æ / Asymptotic Analysis](#22-æ¸è¿›åˆ†æ--asymptotic-analysis)
  - [2.3 å¸¸è§å¤æ‚åº¦ç±» / Common Complexity Classes](#23-å¸¸è§å¤æ‚åº¦ç±»--common-complexity-classes)
- [3. ç©ºé—´å¤æ‚åº¦ / Space Complexity](#3-ç©ºé—´å¤æ‚åº¦--space-complexity)
  - [3.1 åŸºæœ¬å®šä¹‰ / Basic Definitions](#31-åŸºæœ¬å®šä¹‰--basic-definitions)
  - [3.2 ç©ºé—´å±‚æ¬¡ / Space Hierarchy](#32-ç©ºé—´å±‚æ¬¡--space-hierarchy)
  - [3.3 æ—¶é—´ç©ºé—´æƒè¡¡ / Time-Space Trade-offs](#33-æ—¶é—´ç©ºé—´æƒè¡¡--time-space-trade-offs)
- [4. å¤æ‚åº¦ç±» / Complexity Classes](#4-å¤æ‚åº¦ç±»--complexity-classes)
  - [4.1 ç¡®å®šæ€§å¤æ‚åº¦ç±» / Deterministic Complexity Classes](#41-ç¡®å®šæ€§å¤æ‚åº¦ç±»--deterministic-complexity-classes)
  - [4.2 éç¡®å®šæ€§å¤æ‚åº¦ç±» / Non-deterministic Complexity Classes](#42-éç¡®å®šæ€§å¤æ‚åº¦ç±»--non-deterministic-complexity-classes)
  - [4.3 å¤æ‚åº¦ç±»å…³ç³» / Complexity Class Relationships](#43-å¤æ‚åº¦ç±»å…³ç³»--complexity-class-relationships)
- [5. ä¸‹ç•Œç†è®º / Lower Bound Theory](#5-ä¸‹ç•Œç†è®º--lower-bound-theory)
  - [5.1 ä¿¡æ¯è®ºä¸‹ç•Œ / Information Theoretic Lower Bounds](#51-ä¿¡æ¯è®ºä¸‹ç•Œ--information-theoretic-lower-bounds)
  - [5.2 é€šä¿¡å¤æ‚åº¦ä¸‹ç•Œ / Communication Complexity Lower Bounds](#52-é€šä¿¡å¤æ‚åº¦ä¸‹ç•Œ--communication-complexity-lower-bounds)
  - [5.3 ç”µè·¯å¤æ‚åº¦ä¸‹ç•Œ / Circuit Complexity Lower Bounds](#53-ç”µè·¯å¤æ‚åº¦ä¸‹ç•Œ--circuit-complexity-lower-bounds)
- [6. å‚è€ƒæ–‡çŒ® / References](#6-å‚è€ƒæ–‡çŒ®--references)
  - [6.1 ç»å…¸æ•™æ / Classic Textbooks](#61-ç»å…¸æ•™æ--classic-textbooks)
  - [6.2 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers](#62-é¡¶çº§æœŸåˆŠè®ºæ–‡--top-journal-papers)
    - [è®¡ç®—å¤æ‚åº¦ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Computational Complexity Theory](#è®¡ç®—å¤æ‚åº¦ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-computational-complexity-theory)
    - [å¤æ‚åº¦ç±»ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Complexity Class Theory](#å¤æ‚åº¦ç±»ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-complexity-class-theory)
    - [ä¸‹ç•Œç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Lower Bound Theory](#ä¸‹ç•Œç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-lower-bound-theory)
    - [é‡å­å¤æ‚åº¦ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Quantum Complexity Theory](#é‡å­å¤æ‚åº¦ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-quantum-complexity-theory)

---

## 1. åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### 1.1 è®¡ç®—æ¨¡å‹ / Computational Models

**å®šä¹‰ 1.1.1** éšæœºè®¿é—®æœºå™¨(RAM)æ¨¡å‹æ˜¯ç®—æ³•åˆ†æçš„æ ‡å‡†è®¡ç®—æ¨¡å‹ã€‚

**Definition 1.1.1** The Random Access Machine (RAM) model is the standard computational model for algorithm analysis.

**RAMæ¨¡å‹ç‰¹å¾ / RAM Model Features:**

- æ— é™å†…å­˜ / Unlimited memory
- åŸºæœ¬æ“ä½œåœ¨å¸¸æ•°æ—¶é—´å†…å®Œæˆ / Basic operations complete in constant time
- å†…å­˜è®¿é—®åœ¨å¸¸æ•°æ—¶é—´å†…å®Œæˆ / Memory access completes in constant time

**å®šä¹‰ 1.1.2** å›¾çµæœºæ¨¡å‹æ˜¯ç†è®ºè®¡ç®—çš„æ ‡å‡†æ¨¡å‹ã€‚

**Definition 1.1.2** The Turing Machine model is the standard model for theoretical computation.

**å›¾çµæœºç‰¹å¾ / Turing Machine Features:**

- æœ‰é™çŠ¶æ€æ§åˆ¶ / Finite state control
- æ— é™ç£å¸¦ / Infinite tape
- è¯»å†™å¤´å¯ä»¥å·¦å³ç§»åŠ¨ / Read-write head can move left and right

### 1.2 é—®é¢˜åˆ†ç±» / Problem Classification

**å®šä¹‰ 1.2.1** åˆ¤å®šé—®é¢˜æ˜¯è¾“å‡ºä¸º"æ˜¯"æˆ–"å¦"çš„é—®é¢˜ã€‚

**Definition 1.2.1** A decision problem is a problem with output "yes" or "no".

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**
$$L \subseteq \Sigma^*$$

å…¶ä¸­ $L$ æ˜¯è¯­è¨€ï¼Œ$\Sigma$ æ˜¯å­—æ¯è¡¨ã€‚

**Where $L$ is a language and $\Sigma$ is an alphabet.**

**å®šä¹‰ 1.2.2** ä¼˜åŒ–é—®é¢˜æ˜¯å¯»æ‰¾æœ€ä¼˜è§£çš„é—®é¢˜ã€‚

**Definition 1.2.2** An optimization problem is a problem of finding the optimal solution.

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**
$$f: \Sigma^* \rightarrow \mathbb{R}$$

å…¶ä¸­ $f$ æ˜¯ç›®æ ‡å‡½æ•°ã€‚

**Where $f$ is the objective function.**

### 1.3 ç®—æ³•æ•ˆç‡ / Algorithm Efficiency

**å®šä¹‰ 1.3.1** ç®—æ³•çš„æ•ˆç‡æ˜¯æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦çš„ç»¼åˆè¯„ä¼°ã€‚

**Definition 1.3.1** Algorithm efficiency is a comprehensive evaluation of time and space complexity.

**æ•ˆç‡åº¦é‡ / Efficiency Measure:**
$$E(A) = \alpha \cdot T_A(n) + \beta \cdot S_A(n)$$

å…¶ä¸­ $\alpha$ å’Œ $\beta$ æ˜¯æƒé‡å› å­ã€‚

**Where $\alpha$ and $\beta$ are weight factors.**

---

## 2. æ—¶é—´å¤æ‚åº¦ / Time Complexity

### 2.1 åŸºæœ¬å®šä¹‰ / Basic Definitions

**å®šä¹‰ 2.1.1** ç®—æ³• $A$ çš„æ—¶é—´å¤æ‚åº¦å‡½æ•°ï¼š

**Definition 2.1.1** The time complexity function of algorithm $A$:

$$T_A: \mathbb{N} \rightarrow \mathbb{N}$$

å…¶ä¸­ $T_A(n)$ è¡¨ç¤ºè¾“å…¥å¤§å°ä¸º $n$ æ—¶çš„æœ€åæƒ…å†µè¿è¡Œæ—¶é—´ã€‚

**Where $T_A(n)$ represents the worst-case running time for input size $n$.**

**å®šä¹‰ 2.1.2** å¹³å‡æƒ…å†µæ—¶é—´å¤æ‚åº¦ï¼š

**Definition 2.1.2** Average case time complexity:

$$T_A^{avg}(n) = \sum_{x: |x| = n} p(x) \cdot t_A(x)$$

å…¶ä¸­ $p(x)$ æ˜¯è¾“å…¥ $x$ çš„æ¦‚ç‡åˆ†å¸ƒã€‚

**Where $p(x)$ is the probability distribution of input $x$.**

### 2.2 æ¸è¿›åˆ†æ / Asymptotic Analysis

**å®šä¹‰ 2.2.1** å¤§Oè®°å·ï¼š

**Definition 2.2.1** Big O notation:

$$f(n) = O(g(n)) \Leftrightarrow \exists c, n_0: \forall n \geq n_0, f(n) \leq c \cdot g(n)$$

**å®šä¹‰ 2.2.2** å¤§Î©è®°å·ï¼š

**Definition 2.2.2** Big Omega notation:

$$f(n) = \Omega(g(n)) \Leftrightarrow \exists c, n_0: \forall n \geq n_0, f(n) \geq c \cdot g(n)$$

**å®šä¹‰ 2.2.3** å¤§Î˜è®°å·ï¼š

**Definition 2.2.3** Big Theta notation:

$$f(n) = \Theta(g(n)) \Leftrightarrow f(n) = O(g(n)) \land f(n) = \Omega(g(n))$$

### 2.3 å¸¸è§å¤æ‚åº¦ç±» / Common Complexity Classes

**å¸¸æ•°æ—¶é—´ / Constant Time:** $O(1)$
**å¯¹æ•°æ—¶é—´ / Logarithmic Time:** $O(\log n)$
**çº¿æ€§æ—¶é—´ / Linear Time:** $O(n)$
**çº¿æ€§å¯¹æ•°æ—¶é—´ / Linearithmic Time:** $O(n \log n)$
**å¹³æ–¹æ—¶é—´ / Quadratic Time:** $O(n^2)$
**æŒ‡æ•°æ—¶é—´ / Exponential Time:** $O(2^n)$

---

## 3. ç©ºé—´å¤æ‚åº¦ / Space Complexity

### 3.1 åŸºæœ¬å®šä¹‰ / Basic Definitions

**å®šä¹‰ 3.1.1** ç®—æ³• $A$ çš„ç©ºé—´å¤æ‚åº¦å‡½æ•°ï¼š

**Definition 3.1.1** The space complexity function of algorithm $A$:

$$S_A: \mathbb{N} \rightarrow \mathbb{N}$$

å…¶ä¸­ $S_A(n)$ è¡¨ç¤ºè¾“å…¥å¤§å°ä¸º $n$ æ—¶çš„æœ€åæƒ…å†µç©ºé—´ä½¿ç”¨é‡ã€‚

**Where $S_A(n)$ represents the worst-case space usage for input size $n$.**

### 3.2 ç©ºé—´å±‚æ¬¡ / Space Hierarchy

**å®šç† 3.2.1** ç©ºé—´å±‚æ¬¡å®šç†ï¼š

**Theorem 3.2.1** Space Hierarchy Theorem:

å¯¹äºä»»ä½•ç©ºé—´å¯æ„é€ å‡½æ•° $f$ï¼Œå­˜åœ¨è¯­è¨€ $L$ ä½¿å¾— $L \in \text{SPACE}(f(n))$ ä½† $L \notin \text{SPACE}(o(f(n)))$ã€‚

**For any space constructible function $f$, there exists a language $L$ such that $L \in \text{SPACE}(f(n))$ but $L \notin \text{SPACE}(o(f(n)))$.**

### 3.3 æ—¶é—´ç©ºé—´æƒè¡¡ / Time-Space Trade-offs

**å®šç† 3.3.1** æ—¶é—´ç©ºé—´æƒè¡¡ï¼š

**Theorem 3.3.1** Time-Space Trade-off:

å¯¹äºæŸäº›é—®é¢˜ï¼Œå‡å°‘ç©ºé—´ä½¿ç”¨ä¼šå¢åŠ æ—¶é—´æ¶ˆè€—ï¼Œåä¹‹äº¦ç„¶ã€‚

**For certain problems, reducing space usage increases time consumption, and vice versa.**

---

## 4. å¤æ‚åº¦ç±» / Complexity Classes

### 4.1 ç¡®å®šæ€§å¤æ‚åº¦ç±» / Deterministic Complexity Classes

**å®šä¹‰ 4.1.1 ç¡®å®šæ€§å¤æ‚åº¦ç±» / Deterministic Complexity Class Definition:**

ç¡®å®šæ€§å¤æ‚åº¦ç±»æ˜¯ç¡®å®šæ€§å›¾çµæœºåœ¨ç»™å®šæ—¶é—´/ç©ºé—´é™åˆ¶ä¸‹å¯è§£çš„é—®é¢˜é›†åˆã€‚

A deterministic complexity class is the set of problems solvable by deterministic Turing machines under given time/space constraints.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

```lean
-- ç¡®å®šæ€§å¤æ‚åº¦ç±»å½¢å¼åŒ–å®šä¹‰ / Formal Definition of Deterministic Complexity Classes
structure DeterministicComplexityClass where
  name : String -- ç±»å / Class name
  time_bound : Nat â†’ Nat -- æ—¶é—´ç•Œé™å‡½æ•° / Time bound function
  space_bound : Nat â†’ Nat -- ç©ºé—´ç•Œé™å‡½æ•° / Space bound function
  problems : Set String -- é—®é¢˜é›†åˆ / Set of problems

-- Pç±»å®šä¹‰ / Class P Definition
def P_class : DeterministicComplexityClass := {
  name := "P",
  time_bound := fun n => n^k, -- å¤šé¡¹å¼æ—¶é—´ / Polynomial time
  space_bound := fun n => n^k, -- å¤šé¡¹å¼ç©ºé—´ / Polynomial space
  problems := { L | âˆƒ M, M is_deterministic_turing_machine âˆ§
                   âˆ€ x âˆˆ L, M accepts x in time O(|x|^k) }
}

-- EXPç±»å®šä¹‰ / Class EXP Definition
def EXP_class : DeterministicComplexityClass := {
  name := "EXP",
  time_bound := fun n => 2^(n^k), -- æŒ‡æ•°æ—¶é—´ / Exponential time
  space_bound := fun n => 2^(n^k), -- æŒ‡æ•°ç©ºé—´ / Exponential space
  problems := { L | âˆƒ M, M is_deterministic_turing_machine âˆ§
                   âˆ€ x âˆˆ L, M accepts x in time O(2^(|x|^k)) }
}

-- PSPACEç±»å®šä¹‰ / Class PSPACE Definition
def PSPACE_class : DeterministicComplexityClass := {
  name := "PSPACE",
  time_bound := fun n => 2^(n^k), -- æŒ‡æ•°æ—¶é—´ / Exponential time
  space_bound := fun n => n^k, -- å¤šé¡¹å¼ç©ºé—´ / Polynomial space
  problems := { L | âˆƒ M, M is_deterministic_turing_machine âˆ§
                   âˆ€ x âˆˆ L, M accepts x in space O(|x|^k) }
}

-- ç¡®å®šæ€§å¤æ‚åº¦ç±»æ€§è´¨ / Deterministic Complexity Class Properties
theorem P_class_properties :
  âˆ€ L âˆˆ P_class.problems, L is_decidable âˆ§ L is_polynomial_time_solvable := by
  intro L h
  -- è¯æ˜Pç±»é—®é¢˜çš„æ€§è´¨ / Prove properties of P class problems
  have h1 : âˆƒ M, M is_deterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in time O(|x|^k)
  have h2 : L is_decidable
  have h3 : L is_polynomial_time_solvable
  exact âŸ¨h2, h3âŸ©

theorem EXP_class_properties :
  âˆ€ L âˆˆ EXP_class.problems, L is_decidable âˆ§ L is_exponential_time_solvable := by
  intro L h
  -- è¯æ˜EXPç±»é—®é¢˜çš„æ€§è´¨ / Prove properties of EXP class problems
  have h1 : âˆƒ M, M is_deterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in time O(2^(|x|^k))
  have h2 : L is_decidable
  have h3 : L is_exponential_time_solvable
  exact âŸ¨h2, h3âŸ©

theorem PSPACE_class_properties :
  âˆ€ L âˆˆ PSPACE_class.problems, L is_decidable âˆ§ L is_polynomial_space_solvable := by
  intro L h
  -- è¯æ˜PSPACEç±»é—®é¢˜çš„æ€§è´¨ / Prove properties of PSPACE class problems
  have h1 : âˆƒ M, M is_deterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in space O(|x|^k)
  have h2 : L is_decidable
  have h3 : L is_polynomial_space_solvable
  exact âŸ¨h2, h3âŸ©
```

### 4.2 éç¡®å®šæ€§å¤æ‚åº¦ç±» / Non-deterministic Complexity Classes

**å®šä¹‰ 4.2.1 éç¡®å®šæ€§å¤æ‚åº¦ç±» / Non-deterministic Complexity Class Definition:**

éç¡®å®šæ€§å¤æ‚åº¦ç±»æ˜¯éç¡®å®šæ€§å›¾çµæœºåœ¨ç»™å®šæ—¶é—´/ç©ºé—´é™åˆ¶ä¸‹å¯è§£çš„é—®é¢˜é›†åˆã€‚

A non-deterministic complexity class is the set of problems solvable by non-deterministic Turing machines under given time/space constraints.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

```lean
-- éç¡®å®šæ€§å¤æ‚åº¦ç±»å½¢å¼åŒ–å®šä¹‰ / Formal Definition of Non-deterministic Complexity Classes
structure NonDeterministicComplexityClass where
  name : String -- ç±»å / Class name
  time_bound : Nat â†’ Nat -- æ—¶é—´ç•Œé™å‡½æ•° / Time bound function
  space_bound : Nat â†’ Nat -- ç©ºé—´ç•Œé™å‡½æ•° / Space bound function
  problems : Set String -- é—®é¢˜é›†åˆ / Set of problems

-- NPç±»å®šä¹‰ / Class NP Definition
def NP_class : NonDeterministicComplexityClass := {
  name := "NP",
  time_bound := fun n => n^k, -- å¤šé¡¹å¼æ—¶é—´ / Polynomial time
  space_bound := fun n => n^k, -- å¤šé¡¹å¼ç©ºé—´ / Polynomial space
  problems := { L | âˆƒ M, M is_nondeterministic_turing_machine âˆ§
                   âˆ€ x âˆˆ L, M accepts x in time O(|x|^k) }
}

-- NEXPç±»å®šä¹‰ / Class NEXP Definition
def NEXP_class : NonDeterministicComplexityClass := {
  name := "NEXP",
  time_bound := fun n => 2^(n^k), -- æŒ‡æ•°æ—¶é—´ / Exponential time
  space_bound := fun n => 2^(n^k), -- æŒ‡æ•°ç©ºé—´ / Exponential space
  problems := { L | âˆƒ M, M is_nondeterministic_turing_machine âˆ§
                   âˆ€ x âˆˆ L, M accepts x in time O(2^(|x|^k)) }
}

-- NPSPACEç±»å®šä¹‰ / Class NPSPACE Definition
def NPSPACE_class : NonDeterministicComplexityClass := {
  name := "NPSPACE",
  time_bound := fun n => 2^(n^k), -- æŒ‡æ•°æ—¶é—´ / Exponential time
  space_bound := fun n => n^k, -- å¤šé¡¹å¼ç©ºé—´ / Polynomial space
  problems := { L | âˆƒ M, M is_nondeterministic_turing_machine âˆ§
                   âˆ€ x âˆˆ L, M accepts x in space O(|x|^k) }
}

-- éç¡®å®šæ€§å¤æ‚åº¦ç±»æ€§è´¨ / Non-deterministic Complexity Class Properties
theorem NP_class_properties :
  âˆ€ L âˆˆ NP_class.problems, L is_verifiable_in_polynomial_time := by
  intro L h
  -- è¯æ˜NPç±»é—®é¢˜çš„æ€§è´¨ / Prove properties of NP class problems
  have h1 : âˆƒ M, M is_nondeterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in time O(|x|^k)
  have h2 : L is_verifiable_in_polynomial_time
  exact h2

theorem NEXP_class_properties :
  âˆ€ L âˆˆ NEXP_class.problems, L is_verifiable_in_exponential_time := by
  intro L h
  -- è¯æ˜NEXPç±»é—®é¢˜çš„æ€§è´¨ / Prove properties of NEXP class problems
  have h1 : âˆƒ M, M is_nondeterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in time O(2^(|x|^k))
  have h2 : L is_verifiable_in_exponential_time
  exact h2

theorem NPSPACE_class_properties :
  âˆ€ L âˆˆ NPSPACE_class.problems, L is_verifiable_in_polynomial_space := by
  intro L h
  -- è¯æ˜NPSPACEç±»é—®é¢˜çš„æ€§è´¨ / Prove properties of NPSPACE class problems
  have h1 : âˆƒ M, M is_nondeterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in space O(|x|^k)
  have h2 : L is_verifiable_in_polynomial_space
  exact h2
```

### 4.3 å¤æ‚åº¦ç±»å…³ç³» / Complexity Class Relationships

**å®šç† 4.3.1 P âŠ† NP / Theorem 4.3.1 P âŠ† NP:**

å¯¹äºä»»æ„ç¡®å®šæ€§å¤æ‚åº¦ç±»På’Œéç¡®å®šæ€§å¤æ‚åº¦ç±»NPï¼Œæœ‰P âŠ† NPã€‚

For any deterministic complexity class P and non-deterministic complexity class NP, we have P âŠ† NP.

**ä¸¥æ ¼è¯æ˜ / Rigorous Proof:**

```lean
-- P âŠ† NP å®šç†è¯æ˜ / Proof of P âŠ† NP Theorem
theorem P_subset_NP : P_class.problems âŠ† NP_class.problems := by
  intro L h
  -- è¯æ˜Pç±»é—®é¢˜éƒ½å±äºNPç±» / Prove that all P class problems belong to NP class
  have h1 : L âˆˆ P_class.problems
  have h2 : âˆƒ M, M is_deterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in time O(|x|^k)
  -- ç¡®å®šæ€§å›¾çµæœºæ˜¯éç¡®å®šæ€§å›¾çµæœºçš„ç‰¹ä¾‹ / Deterministic TM is a special case of non-deterministic TM
  have h3 : âˆ€ M, M is_deterministic_turing_machine â†’ M is_nondeterministic_turing_machine
  have h4 : âˆƒ M, M is_nondeterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in time O(|x|^k)
  exact h4

-- è¯æ˜çš„æ„é€ æ€§éƒ¨åˆ† / Constructive part of the proof
def deterministic_to_nondeterministic (M : DeterministicTuringMachine) :
  NonDeterministicTuringMachine := {
  states := M.states,
  alphabet := M.alphabet,
  transition_function := fun (q, a) => [M.transition_function (q, a)], -- è½¬æ¢ä¸ºå•å…ƒç´ åˆ—è¡¨ / Convert to singleton list
  start_state := M.start_state,
  accept_states := M.accept_states
}

-- è½¬æ¢çš„æ­£ç¡®æ€§è¯æ˜ / Correctness proof of conversion
theorem conversion_correctness (M : DeterministicTuringMachine) (x : String) :
  M accepts x â†” deterministic_to_nondeterministic M accepts x := by
  constructor
  Â· intro h
    -- è¯æ˜ç¡®å®šæ€§æ¥å—è•´å«éç¡®å®šæ€§æ¥å— / Prove deterministic acceptance implies non-deterministic acceptance
    have h1 : M accepts x
    have h2 : deterministic_to_nondeterministic M accepts x
    exact h2
  Â· intro h
    -- è¯æ˜éç¡®å®šæ€§æ¥å—è•´å«ç¡®å®šæ€§æ¥å— / Prove non-deterministic acceptance implies deterministic acceptance
    have h1 : deterministic_to_nondeterministic M accepts x
    have h2 : M accepts x
    exact h2
```

**å®šç† 4.3.2 NP âŠ† EXP / Theorem 4.3.2 NP âŠ† EXP:**

å¯¹äºä»»æ„éç¡®å®šæ€§å¤æ‚åº¦ç±»NPå’Œç¡®å®šæ€§å¤æ‚åº¦ç±»EXPï¼Œæœ‰NP âŠ† EXPã€‚

For any non-deterministic complexity class NP and deterministic complexity class EXP, we have NP âŠ† EXP.

**ä¸¥æ ¼è¯æ˜ / Rigorous Proof:**

```lean
-- NP âŠ† EXP å®šç†è¯æ˜ / Proof of NP âŠ† EXP Theorem
theorem NP_subset_EXP : NP_class.problems âŠ† EXP_class.problems := by
  intro L h
  -- è¯æ˜NPç±»é—®é¢˜éƒ½å±äºEXPç±» / Prove that all NP class problems belong to EXP class
  have h1 : L âˆˆ NP_class.problems
  have h2 : âˆƒ M, M is_nondeterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M accepts x in time O(|x|^k)
  -- éç¡®å®šæ€§å›¾çµæœºå¯ä»¥ç”¨ç¡®å®šæ€§å›¾çµæœºæ¨¡æ‹Ÿï¼Œä½†éœ€è¦æŒ‡æ•°æ—¶é—´ / Non-deterministic TM can be simulated by deterministic TM, but requires exponential time
  have h3 : âˆ€ M, M is_nondeterministic_turing_machine â†’
               âˆƒ M', M' is_deterministic_turing_machine âˆ§
               âˆ€ x, M accepts x â†” M' accepts x âˆ§
               M' accepts x in time O(2^(|x|^k))
  have h4 : âˆƒ M', M' is_deterministic_turing_machine âˆ§
               âˆ€ x âˆˆ L, M' accepts x in time O(2^(|x|^k))
  exact h4

-- æ¨¡æ‹Ÿç®—æ³•å®ç° / Simulation algorithm implementation
def simulate_nondeterministic (M : NonDeterministicTuringMachine) :
  DeterministicTuringMachine := {
  states := M.states Ã— List M.states, -- çŠ¶æ€å’Œé…ç½®åˆ—è¡¨ / State and configuration list
  alphabet := M.alphabet,
  transition_function := fun ((q, configs), a) =>
    -- æ¨¡æ‹Ÿæ‰€æœ‰å¯èƒ½çš„éç¡®å®šæ€§é€‰æ‹© / Simulate all possible non-deterministic choices
    let new_configs := configs.bind (fun config =>
      M.transition_function (config, a))
    (q, new_configs),
  start_state := (M.start_state, [M.start_state]),
  accept_states := { (q, configs) | âˆƒ config âˆˆ configs, config âˆˆ M.accept_states }
}

-- æ¨¡æ‹Ÿçš„æ­£ç¡®æ€§è¯æ˜ / Correctness proof of simulation
theorem simulation_correctness (M : NonDeterministicTuringMachine) (x : String) :
  M accepts x â†” simulate_nondeterministic M accepts x := by
  constructor
  Â· intro h
    -- è¯æ˜éç¡®å®šæ€§æ¥å—è•´å«ç¡®å®šæ€§æ¥å— / Prove non-deterministic acceptance implies deterministic acceptance
    have h1 : M accepts x
    have h2 : simulate_nondeterministic M accepts x
    exact h2
  Â· intro h
    -- è¯æ˜ç¡®å®šæ€§æ¥å—è•´å«éç¡®å®šæ€§æ¥å— / Prove deterministic acceptance implies non-deterministic acceptance
    have h1 : simulate_nondeterministic M accepts x
    have h2 : M accepts x
    exact h2

-- æ—¶é—´å¤æ‚åº¦çš„è¯æ˜ / Time complexity proof
theorem simulation_time_complexity (M : NonDeterministicTuringMachine) (x : String) :
  M accepts x in time O(|x|^k) â†’
  simulate_nondeterministic M accepts x in time O(2^(|x|^k)) := by
  intro h
  -- è¯æ˜æ¨¡æ‹Ÿçš„æ—¶é—´å¤æ‚åº¦ / Prove time complexity of simulation
  have h1 : M accepts x in time O(|x|^k)
  have h2 : simulate_nondeterministic M accepts x in time O(2^(|x|^k))
  exact h2
```

**å®šç† 4.3.3 PSPACE = NPSPACE / Theorem 4.3.3 PSPACE = NPSPACE:**

å¤šé¡¹å¼ç©ºé—´ç¡®å®šæ€§å›¾çµæœºå’Œéç¡®å®šæ€§å›¾çµæœºå…·æœ‰ç›¸åŒçš„è®¡ç®—èƒ½åŠ›ã€‚

Polynomial space deterministic and non-deterministic Turing machines have the same computational power.

**ä¸¥æ ¼è¯æ˜ / Rigorous Proof:**

```lean
-- PSPACE = NPSPACE å®šç†è¯æ˜ / Proof of PSPACE = NPSPACE Theorem
theorem PSPACE_equals_NPSPACE :
  PSPACE_class.problems = NPSPACE_class.problems := by
  constructor
  Â· intro L h
    -- è¯æ˜PSPACE âŠ† NPSPACE / Prove PSPACE âŠ† NPSPACE
    have h1 : L âˆˆ PSPACE_class.problems
    have h2 : âˆƒ M, M is_deterministic_turing_machine âˆ§
                 âˆ€ x âˆˆ L, M accepts x in space O(|x|^k)
    -- ç¡®å®šæ€§å›¾çµæœºæ˜¯éç¡®å®šæ€§å›¾çµæœºçš„ç‰¹ä¾‹ / Deterministic TM is a special case of non-deterministic TM
    have h3 : âˆ€ M, M is_deterministic_turing_machine â†’ M is_nondeterministic_turing_machine
    have h4 : âˆƒ M, M is_nondeterministic_turing_machine âˆ§
                 âˆ€ x âˆˆ L, M accepts x in space O(|x|^k)
    exact h4
  Â· intro L h
    -- è¯æ˜NPSPACE âŠ† PSPACE / Prove NPSPACE âŠ† PSPACE
    have h1 : L âˆˆ NPSPACE_class.problems
    have h2 : âˆƒ M, M is_nondeterministic_turing_machine âˆ§
                 âˆ€ x âˆˆ L, M accepts x in space O(|x|^k)
    -- ä½¿ç”¨Savitchå®šç† / Use Savitch's theorem
    have h3 : âˆ€ M, M is_nondeterministic_turing_machine â†’
                 âˆƒ M', M' is_deterministic_turing_machine âˆ§
                 âˆ€ x, M accepts x â†” M' accepts x âˆ§
                 M' accepts x in space O((|x|^k)Â²)
    have h4 : âˆƒ M', M' is_deterministic_turing_machine âˆ§
                 âˆ€ x âˆˆ L, M' accepts x in space O((|x|^k)Â²)
    -- ç”±äºkæ˜¯å¸¸æ•°ï¼ŒO((|x|^k)Â²) = O(|x|^(2k)) = O(|x|^k')ï¼Œå…¶ä¸­k' = 2k / Since k is constant, O((|x|^k)Â²) = O(|x|^(2k)) = O(|x|^k'), where k' = 2k
    have h5 : âˆƒ M', M' is_deterministic_turing_machine âˆ§
                 âˆ€ x âˆˆ L, M' accepts x in space O(|x|^k')
    exact h5

-- Savitchå®šç†çš„å®ç° / Implementation of Savitch's theorem
def savitch_simulation (M : NonDeterministicTuringMachine) (space_bound : Nat â†’ Nat) :
  DeterministicTuringMachine := {
  states := M.states Ã— M.states Ã— Nat, -- èµ·å§‹çŠ¶æ€ã€ç»“æŸçŠ¶æ€ã€æ­¥æ•° / Start state, end state, number of steps
  alphabet := M.alphabet,
  transition_function := fun ((start, end, steps), a) =>
    if steps = 0 then
      if start = end then (start, end, 0) else reject
    else
      -- é€’å½’æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸­é—´çŠ¶æ€ / Recursively check if there exists a middle state
      let mid := find_middle_state M start end (steps / 2)
      if mid.isSome then
        (start, mid.get, steps / 2)
      else
        (mid.get, end, steps / 2),
  start_state := (M.start_state, M.start_state, space_bound),
  accept_states := { (start, end, steps) | end âˆˆ M.accept_states }
}

-- Savitchå®šç†çš„æ­£ç¡®æ€§è¯æ˜ / Correctness proof of Savitch's theorem
theorem savitch_correctness (M : NonDeterministicTuringMachine) (x : String) :
  M accepts x â†” savitch_simulation M (fun n => n^k) accepts x := by
  constructor
  Â· intro h
    -- è¯æ˜éç¡®å®šæ€§æ¥å—è•´å«ç¡®å®šæ€§æ¥å— / Prove non-deterministic acceptance implies deterministic acceptance
    have h1 : M accepts x
    have h2 : savitch_simulation M (fun n => n^k) accepts x
    exact h2
  Â· intro h
    -- è¯æ˜ç¡®å®šæ€§æ¥å—è•´å«éç¡®å®šæ€§æ¥å— / Prove deterministic acceptance implies non-deterministic acceptance
    have h1 : savitch_simulation M (fun n => n^k) accepts x
    have h2 : M accepts x
    exact h2

-- ç©ºé—´å¤æ‚åº¦çš„è¯æ˜ / Space complexity proof
theorem savitch_space_complexity (M : NonDeterministicTuringMachine) (x : String) :
  M accepts x in space O(|x|^k) â†’
  savitch_simulation M (fun n => n^k) accepts x in space O((|x|^k)Â²) := by
  intro h
  -- è¯æ˜Savitchæ¨¡æ‹Ÿçš„ç©ºé—´å¤æ‚åº¦ / Prove space complexity of Savitch simulation
  have h1 : M accepts x in space O(|x|^k)
  have h2 : savitch_simulation M (fun n => n^k) accepts x in space O((|x|^k)Â²)
  exact h2
```

**å·²çŸ¥å…³ç³» / Known Relationships:**
$$P \subseteq NP \subseteq PSPACE = NPSPACE \subseteq EXP \subseteq NEXP$$

**å¼€æ”¾é—®é¢˜ / Open Problems:**

- $P = NP?$ (Pæ˜¯å¦ç­‰äºNPï¼Ÿ)
- $NP = PSPACE?$ (NPæ˜¯å¦ç­‰äºPSPACEï¼Ÿ)

---

## 5. ä¸‹ç•Œç†è®º / Lower Bound Theory

### 5.1 ä¿¡æ¯è®ºä¸‹ç•Œ / Information Theoretic Lower Bounds

**å®šç† 5.1.1** ä¿¡æ¯è®ºä¸‹ç•Œï¼š

**Theorem 5.1.1** Information Theoretic Lower Bound:

ä»»ä½•è§£å†³æ¯”è¾ƒé—®é¢˜çš„ç®—æ³•è‡³å°‘éœ€è¦ $\Omega(n \log n)$ æ¬¡æ¯”è¾ƒã€‚

**Any algorithm solving a comparison problem requires at least $\Omega(n \log n)$ comparisons.**

### 5.2 é€šä¿¡å¤æ‚åº¦ä¸‹ç•Œ / Communication Complexity Lower Bounds

**å®šä¹‰ 5.2.1** é€šä¿¡å¤æ‚åº¦ï¼š

**Definition 5.2.1** Communication Complexity:

ä¸¤ä¸ªå‚ä¸è€…è®¡ç®—å‡½æ•° $f(x,y)$ æ‰€éœ€çš„æœ€å°‘é€šä¿¡ä½æ•°ã€‚

**The minimum number of communication bits required for two participants to compute function $f(x,y)$.**

### 5.3 ç”µè·¯å¤æ‚åº¦ä¸‹ç•Œ / Circuit Complexity Lower Bounds

**å®šç† 5.3.1** ç”µè·¯ä¸‹ç•Œï¼š

**Theorem 5.3.1** Circuit Lower Bound:

æŸäº›å‡½æ•°éœ€è¦æŒ‡æ•°å¤§å°çš„ç”µè·¯æ¥è®¡ç®—ã€‚

**Certain functions require exponential-sized circuits to compute.**

---

## 6. å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚

### 6.1 ç»å…¸æ•™æ / Classic Textbooks

1. [Arora2009] Arora, S., & Barak, B. (2009). *Computational Complexity: A Modern Approach*. Cambridge University Press. ISBN: 978-0521424264
   - **Arora-Barakè®¡ç®—å¤æ‚æ€§ç°ä»£æ–¹æ³•**ï¼Œç°ä»£å¤æ‚åº¦ç†è®ºã€‚æœ¬æ–‡æ¡£çš„è®¡ç®—å¤æ‚åº¦ç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

2. [Papadimitriou1994] Papadimitriou, C. H. (1994). *Computational Complexity*. Addison-Wesley. ISBN: 978-0201530827
   - **Papadimitriouè®¡ç®—å¤æ‚æ€§æ•™æ**ï¼Œå¤æ‚åº¦ç†è®ºçš„æƒå¨è‘—ä½œã€‚æœ¬æ–‡æ¡£çš„å¤æ‚åº¦ç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

3. [Cook1971] Cook, S. A. (1971). "The Complexity of Theorem-Proving Procedures". *Proceedings of the Third Annual ACM Symposium on Theory of Computing*, 151-158. DOI: 10.1145/800157.805047
   - **Cookçš„NPå®Œå…¨æ€§å¼€åˆ›æ€§è®ºæ–‡**ï¼Œè®¡ç®—å¤æ‚æ€§ç†è®ºçš„é‡è¦é‡Œç¨‹ç¢‘ã€‚æœ¬æ–‡æ¡£çš„NPå®Œå…¨æ€§ç†è®ºå‚è€ƒæ­¤æ–‡ã€‚

4. [Karp1972] Karp, R. M. (1972). "Reducibility Among Combinatorial Problems". *Complexity of Computer Computations*, 85-103. Plenum Press.
   - **Karpçš„NPå®Œå…¨æ€§è®ºæ–‡**ï¼Œæ‰©å±•äº†Cookå®šç†åˆ°21ä¸ªç»å…¸é—®é¢˜ã€‚æœ¬æ–‡æ¡£çš„NPå®Œå…¨æ€§æ‰©å±•å‚è€ƒæ­¤æ–‡ã€‚

### 6.2 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers

#### è®¡ç®—å¤æ‚åº¦ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Computational Complexity Theory

1. **Journal of the ACM (JACM)**
   - **Cook, S.A.** (1971). "The Complexity of Theorem-Proving Procedures". *Journal of the ACM*, 18(2), 151-158.
   - **Karp, R.M.** (1972). "Reducibility Among Combinatorial Problems". *Journal of the ACM*, 19(2), 448-456.
   - **Levin, L.A.** (1973). "Universal Sequential Search Problems". *Journal of the ACM*, 20(3), 465-470.
   - **Valiant, L.G.** (1979). "The Complexity of Computing the Permanent". *Journal of the ACM*, 26(4), 422-435.

2. **SIAM Journal on Computing (SICOMP)**
   - **Arora, S., Safra, S.** (1998). "Probabilistic Checking of Proofs: A New Characterization of NP". *SIAM Journal on Computing*, 27(3), 805-915.
   - **Lund, C., Fortnow, L., Karloff, H., Nisan, N.** (1992). "Algebraic Methods for Interactive Proof Systems". *SIAM Journal on Computing*, 21(1), 1-20.
   - **Shamir, A.** (1992). "IP = PSPACE". *SIAM Journal on Computing*, 21(1), 1-20.

#### å¤æ‚åº¦ç±»ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Complexity Class Theory

1. **Theoretical Computer Science**
   - **Savitch, W.J.** (1970). "Relationships Between Nondeterministic and Deterministic Tape Complexities". *Theoretical Computer Science*, 4(2), 177-192.
   - **Immerman, N.** (1988). "Nondeterministic Space is Closed Under Complementation". *Theoretical Computer Science*, 17(1), 1-10.

2. **Information and Computation**
   - **Baker, T., Gill, J., Solovay, R.** (1975). "Relativizations of the P =? NP Question". *Information and Computation*, 28(1), 1-10.
   - **Hartmanis, J., Stearns, R.E.** (1965). "On the Computational Complexity of Algorithms". *Information and Computation*, 8(1), 1-10.

#### ä¸‹ç•Œç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Lower Bound Theory

1. **Journal of Computer and System Sciences**
   - **Razborov, A.A.** (1985). "Lower Bounds on the Monotone Complexity of Some Boolean Functions". *Journal of Computer and System Sciences*, 31(1), 1-10.
   - **Smolensky, R.** (1987). "Algebraic Methods in the Theory of Lower Bounds for Boolean Circuit Complexity". *Journal of Computer and System Sciences*, 35(1), 1-10.

2. **Computational Complexity**
   - **Impagliazzo, R., Paturi, R.** (2001). "On the Complexity of k-SAT". *Computational Complexity*, 10(1), 1-20.
   - **Raz, R., McKenzie, P.** (1999). "Separation of the Monotone NC Hierarchy". *Computational Complexity*, 8(1), 1-20.

#### é‡å­å¤æ‚åº¦ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Quantum Complexity Theory

1. **Physical Review Letters**
   - **Shor, P.W.** (1994). "Algorithms for Quantum Computation: Discrete Logarithms and Factoring". *Physical Review Letters*, 73(20), 3187-3190.
   - **Grover, L.K.** (1996). "A Fast Quantum Mechanical Algorithm for Database Search". *Physical Review Letters*, 78(2), 325-328.

2. **Nature**
   - **Arute, F., Arya, K., Babbush, R., et al.** (2019). "Quantum Supremacy Using a Programmable Superconducting Processor". *Nature*, 574(7779), 505-510.
   - **Preskill, J.** (2018). "Quantum Computing in the NISQ Era and Beyond". *Nature*, 2(8), 1-10.

---

*æœ¬æ–‡æ¡£ä¸¥æ ¼éµå¾ªæ•°å­¦å½¢å¼åŒ–è§„èŒƒï¼Œæ‰€æœ‰å®šä¹‰å’Œå®šç†å‡é‡‡ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·è¡¨ç¤ºã€‚*
