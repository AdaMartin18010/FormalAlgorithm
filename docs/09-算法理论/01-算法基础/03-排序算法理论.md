---
title: 9.1.3 æ’åºç®—æ³•ç†è®º / Sorting Algorithm Theory
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: ç®—æ³•ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 9.1.3 æ’åºç®—æ³•ç†è®º / Sorting Algorithm Theory

### æ‘˜è¦ / Executive Summary

- å½’çº³æ¯”è¾ƒæ’åºä¸éæ¯”è¾ƒæ’åºçš„å…¸å‹ç®—æ³•ã€ç¨³å®šæ€§ä¸é€‚åº”æ€§åˆ†æï¼Œä»¥åŠä¿¡æ¯è®ºä¸‹ç•Œã€‚
- ç»™å‡ºå®ç°ç¤ºä¾‹ä¸å¯¹æ¯”ç»´åº¦ï¼Œä¾¿äºå·¥ç¨‹é€‰æ‹©ä¸æ•™å­¦å¯¹æ¯”ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ç¨³å®šæ€§/é€‚åº”æ€§ï¼šæ’åºæ€§è´¨ä¸é€‚ç”¨åœºæ™¯ã€‚
- æ¯”è¾ƒæ ‘æ¨¡å‹ï¼šæ¯”è¾ƒæ’åºä¸‹ç•Œåˆ†ææ¡†æ¶ã€‚
- çº¿æ€§æ—¶é—´æ’åºï¼šè®¡æ•°/åŸºæ•°/æ¡¶çš„å‰æä¸é™åˆ¶ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### å¿«é€Ÿå¯¼èˆª / Quick Links

- [ç›®å½•](#ç›®å½•--table-of-contents)
- [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ--basic-concepts)
- [æ¯”è¾ƒæ’åº](#2-æ¯”è¾ƒæ’åº--comparison-sorting)
- [éæ¯”è¾ƒæ’åº](#3-éæ¯”è¾ƒæ’åº--non-comparison-sorting)
- [æ’åºä¸‹ç•Œ](#4-æ’åºä¸‹ç•Œ--sorting-lower-bounds)

## ç›®å½• / Table of Contents

- [9.1.3 æ’åºç®—æ³•ç†è®º / Sorting Algorithm Theory](#913-æ’åºç®—æ³•ç†è®º--sorting-algorithm-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#1-åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [1.1 æ’åºé—®é¢˜å®šä¹‰ / Sorting Problem Definition](#11-æ’åºé—®é¢˜å®šä¹‰--sorting-problem-definition)
  - [1.2 æ’åºç®—æ³•åˆ†ç±» / Sorting Algorithm Classification](#12-æ’åºç®—æ³•åˆ†ç±»--sorting-algorithm-classification)
- [2. æ¯”è¾ƒæ’åº / Comparison Sorting](#2-æ¯”è¾ƒæ’åº--comparison-sorting)
  - [2.1 å†’æ³¡æ’åº / Bubble Sort](#21-å†’æ³¡æ’åº--bubble-sort)
  - [2.2 é€‰æ‹©æ’åº / Selection Sort](#22-é€‰æ‹©æ’åº--selection-sort)
  - [2.3 æ’å…¥æ’åº / Insertion Sort](#23-æ’å…¥æ’åº--insertion-sort)
  - [2.4 å½’å¹¶æ’åº / Merge Sort](#24-å½’å¹¶æ’åº--merge-sort)
  - [2.5 å¿«é€Ÿæ’åº / Quick Sort](#25-å¿«é€Ÿæ’åº--quick-sort)
  - [2.6 å †æ’åº / Heap Sort](#26-å †æ’åº--heap-sort)
- [3. éæ¯”è¾ƒæ’åº / Non-Comparison Sorting](#3-éæ¯”è¾ƒæ’åº--non-comparison-sorting)
  - [3.1 è®¡æ•°æ’åº / Counting Sort](#31-è®¡æ•°æ’åº--counting-sort)
  - [3.2 åŸºæ•°æ’åº / Radix Sort](#32-åŸºæ•°æ’åº--radix-sort)
  - [3.3 æ¡¶æ’åº / Bucket Sort](#33-æ¡¶æ’åº--bucket-sort)
- [4. æ’åºä¸‹ç•Œ / Sorting Lower Bounds](#4-æ’åºä¸‹ç•Œ--sorting-lower-bounds)
  - [4.1 æ¯”è¾ƒæ’åºä¸‹ç•Œ / Comparison Sorting Lower Bound](#41-æ¯”è¾ƒæ’åºä¸‹ç•Œ--comparison-sorting-lower-bound)
  - [4.2 ä¿¡æ¯è®ºä¸‹ç•Œ / Information-Theoretic Lower Bound](#42-ä¿¡æ¯è®ºä¸‹ç•Œ--information-theoretic-lower-bound)
  - [4.3 è‡ªé€‚åº”æ’åº / Adaptive Sorting](#43-è‡ªé€‚åº”æ’åº--adaptive-sorting)
- [5. å¤–éƒ¨æ’åº / External Sorting](#5-å¤–éƒ¨æ’åº--external-sorting)
  - [5.1 å¤–éƒ¨æ’åºæ¨¡å‹ / External Sorting Model](#51-å¤–éƒ¨æ’åºæ¨¡å‹--external-sorting-model)
  - [5.2 å¤šè·¯å½’å¹¶ / Multiway Merge](#52-å¤šè·¯å½’å¹¶--multiway-merge)
  - [5.3 æ›¿æ¢é€‰æ‹© / Replacement Selection](#53-æ›¿æ¢é€‰æ‹©--replacement-selection)
- [6. å®ç°ç¤ºä¾‹](#6-å®ç°ç¤ºä¾‹)
  - [6.1 å¿«é€Ÿæ’åºå®ç°](#61-å¿«é€Ÿæ’åºå®ç°)
  - [6.2 å½’å¹¶æ’åºå®ç°](#62-å½’å¹¶æ’åºå®ç°)
  - [6.3 å †æ’åºå®ç°](#63-å †æ’åºå®ç°)
  - [6.4 è®¡æ•°æ’åºå®ç°](#64-è®¡æ•°æ’åºå®ç°)
  - [6.5 åŸºæ•°æ’åºå®ç°](#65-åŸºæ•°æ’åºå®ç°)
  - [6.6 æ’åºç®—æ³•æ¯”è¾ƒ](#66-æ’åºç®—æ³•æ¯”è¾ƒ)
- [7. å‚è€ƒæ–‡çŒ® / References](#7-å‚è€ƒæ–‡çŒ®--references)
  - [7.1 ç»å…¸æ•™æ / Classic Textbooks](#71-ç»å…¸æ•™æ--classic-textbooks)
  - [7.2 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers](#72-é¡¶çº§æœŸåˆŠè®ºæ–‡--top-journal-papers)
    - [æ’åºç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Sorting Algorithm Theory](#æ’åºç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-sorting-algorithm-theory)
    - [æ¯”è¾ƒæ’åºä¸‹ç•Œç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Comparison Sort Lower Bounds](#æ¯”è¾ƒæ’åºä¸‹ç•Œç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-comparison-sort-lower-bounds)
    - [çº¿æ€§æ—¶é—´æ’åºé¡¶çº§æœŸåˆŠ / Top Journals in Linear Time Sorting](#çº¿æ€§æ—¶é—´æ’åºé¡¶çº§æœŸåˆŠ--top-journals-in-linear-time-sorting)
    - [å¤–éƒ¨æ’åºé¡¶çº§æœŸåˆŠ / Top Journals in External Sorting](#å¤–éƒ¨æ’åºé¡¶çº§æœŸåˆŠ--top-journals-in-external-sorting)
    - [å¹¶è¡Œæ’åºé¡¶çº§æœŸåˆŠ / Top Journals in Parallel Sorting](#å¹¶è¡Œæ’åºé¡¶çº§æœŸåˆŠ--top-journals-in-parallel-sorting)
- [8. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#8-ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
  - [8.1 ç›¸å…³æ–‡æ¡£ / Related Documents](#81-ç›¸å…³æ–‡æ¡£--related-documents)
  - [8.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#82-çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
  - [8.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#83-viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)

---

## 1. åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### 1.1 æ’åºé—®é¢˜å®šä¹‰ / Sorting Problem Definition

**å®šä¹‰ 1.1.1** æ’åºé—®é¢˜æ˜¯å°†åºåˆ— $S = (a_1, a_2, \ldots, a_n)$ é‡æ–°æ’åˆ—ä¸ºæœ‰åºåºåˆ— $S' = (a_{i_1}, a_{i_2}, \ldots, a_{i_n})$ï¼Œä½¿å¾—ï¼š
**Definition 1.1.1** The sorting problem is to rearrange a sequence $S = (a_1, a_2, \ldots, a_n)$ into an ordered sequence $S' = (a_{i_1}, a_{i_2}, \ldots, a_{i_n})$ such that:
$$a_{i_1} \leq a_{i_2} \leq \ldots \leq a_{i_n}$$

**å®šä¹‰ 1.1.2** æ’åºç®—æ³•çš„ç¨³å®šæ€§ï¼š
**Definition 1.1.2** Stability of sorting algorithms:
å¦‚æœå¯¹äºç›¸ç­‰çš„å…ƒç´  $a_i = a_j$ï¼Œæ’åºå $a_i$ ä»ç„¶åœ¨ $a_j$ ä¹‹å‰ï¼Œåˆ™ç§°æ’åºç®—æ³•æ˜¯ç¨³å®šçš„ã€‚
If for equal elements $a_i = a_j$, after sorting $a_i$ still comes before $a_j$, then the sorting algorithm is said to be stable.

**å®šä¹‰ 1.1.3** æ’åºç®—æ³•çš„é€‚åº”æ€§ï¼š
**Definition 1.1.3** Adaptivity of sorting algorithms:
å¦‚æœç®—æ³•å¯¹å·²éƒ¨åˆ†æ’åºçš„è¾“å…¥è¡¨ç°æ›´å¥½ï¼Œåˆ™ç§°ç®—æ³•æ˜¯è‡ªé€‚åº”çš„ã€‚
If an algorithm performs better on partially sorted inputs, then the algorithm is said to be adaptive.

### 1.2 æ’åºç®—æ³•åˆ†ç±» / Sorting Algorithm Classification

**å®šä¹‰ 1.2.1** æŒ‰æ¯”è¾ƒæ–¹å¼åˆ†ç±»ï¼š
**Definition 1.2.1** Classification by comparison method:

1. **æ¯”è¾ƒæ’åº / Comparison Sorting**ï¼šé€šè¿‡æ¯”è¾ƒå…ƒç´ ç¡®å®šç›¸å¯¹é¡ºåº / Determine relative order by comparing elements
2. **éæ¯”è¾ƒæ’åº / Non-Comparison Sorting**ï¼šä¸é€šè¿‡æ¯”è¾ƒç¡®å®šé¡ºåº / Determine order without comparison

**å®šä¹‰ 1.2.2** æŒ‰ç©ºé—´å¤æ‚åº¦åˆ†ç±»ï¼š
**Definition 1.2.2** Classification by space complexity:

1. **åŸåœ°æ’åº / In-Place Sorting**ï¼šç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ / Space complexity is $O(1)$
2. **éåŸåœ°æ’åº / Non-In-Place Sorting**ï¼šéœ€è¦é¢å¤–ç©ºé—´ / Requires additional space

**å®šä¹‰ 1.2.3** æŒ‰æ—¶é—´å¤æ‚åº¦åˆ†ç±»ï¼š
**Definition 1.2.3** Classification by time complexity:

1. **$O(n^2)$ æ’åº**ï¼šå†’æ³¡æ’åºã€é€‰æ‹©æ’åºã€æ’å…¥æ’åº / Bubble sort, selection sort, insertion sort
2. **$O(n \log n)$ æ’åº**ï¼šå½’å¹¶æ’åºã€å¿«é€Ÿæ’åºã€å †æ’åº / Merge sort, quick sort, heap sort
3. **$O(n)$ æ’åº**ï¼šè®¡æ•°æ’åºã€åŸºæ•°æ’åºã€æ¡¶æ’åº / Counting sort, radix sort, bucket sort

---

## 2. æ¯”è¾ƒæ’åº / Comparison Sorting

### 2.1 å†’æ³¡æ’åº / Bubble Sort

**å®šä¹‰ 2.1.1** å†’æ³¡æ’åºé€šè¿‡é‡å¤éå†åºåˆ—ï¼Œæ¯”è¾ƒç›¸é‚»å…ƒç´ å¹¶äº¤æ¢ã€‚
**Definition 2.1.1** Bubble sort repeatedly traverses the sequence, comparing adjacent elements and swapping them.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
BubbleSort(A):
    for i = 1 to n-1:
        for j = 1 to n-i:
            if A[j] > A[j+1]:
                swap(A[j], A[j+1])
```

**å®šç† 2.1.1** å†’æ³¡æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚
**Theorem 2.1.1** The time complexity of bubble sort is $O(n^2)$.

**è¯æ˜ / Proof:**

- å¤–å±‚å¾ªç¯æ‰§è¡Œ $n-1$ æ¬¡ / Outer loop executes $n-1$ times
- å†…å±‚å¾ªç¯æ‰§è¡Œ $n-i$ æ¬¡ / Inner loop executes $n-i$ times
- æ€»æ¯”è¾ƒæ¬¡æ•°ï¼š$\sum_{i=1}^{n-1} (n-i) = \frac{n(n-1)}{2} = O(n^2)$ / Total comparisons: $\sum_{i=1}^{n-1} (n-i) = \frac{n(n-1)}{2} = O(n^2)$

### 2.2 é€‰æ‹©æ’åº / Selection Sort

**å®šä¹‰ 2.2.1** é€‰æ‹©æ’åºæ¯æ¬¡é€‰æ‹©æœªæ’åºéƒ¨åˆ†çš„æœ€å°å…ƒç´ æ”¾åˆ°å·²æ’åºéƒ¨åˆ†çš„æœ«å°¾ã€‚
**Definition 2.2.1** Selection sort selects the minimum element from the unsorted part and places it at the end of the sorted part each time.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
SelectionSort(A):
    for i = 1 to n-1:
        min_idx = i
        for j = i+1 to n:
            if A[j] < A[min_idx]:
                min_idx = j
        swap(A[i], A[min_idx])
```

**å®šç† 2.2.1** é€‰æ‹©æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ã€‚
**Theorem 2.2.1** The time complexity of selection sort is $O(n^2)$ and space complexity is $O(1)$.

### 2.3 æ’å…¥æ’åº / Insertion Sort

**å®šä¹‰ 2.3.1** æ’å…¥æ’åºå°†æ¯ä¸ªå…ƒç´ æ’å…¥åˆ°å·²æ’åºéƒ¨åˆ†çš„æ­£ç¡®ä½ç½®ã€‚
**Definition 2.3.1** Insertion sort inserts each element into the correct position in the sorted part.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
InsertionSort(A):
    for i = 2 to n:
        key = A[i]
        j = i - 1
        while j > 0 and A[j] > key:
            A[j+1] = A[j]
            j = j - 1
        A[j+1] = key
```

**å®šç† 2.3.1** æ’å…¥æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œä½†å¯¹äºå·²æ’åºçš„è¾“å…¥ä¸º $O(n)$ã€‚
**Theorem 2.3.1** The time complexity of insertion sort is $O(n^2)$, but for sorted input it is $O(n)$.

### 2.4 å½’å¹¶æ’åº / Merge Sort

**å®šä¹‰ 2.4.1** å½’å¹¶æ’åºä½¿ç”¨åˆ†æ²»ç­–ç•¥ï¼Œå°†åºåˆ—åˆ†æˆä¸¤åŠï¼Œåˆ†åˆ«æ’åºååˆå¹¶ã€‚
**Definition 2.4.1** Merge sort uses the divide-and-conquer strategy, dividing the sequence into two halves, sorting them separately, and then merging.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
MergeSort(A, left, right):
    if left < right:
        mid = (left + right) / 2
        MergeSort(A, left, mid)
        MergeSort(A, mid+1, right)
        Merge(A, left, mid, right)
```

**å®šç† 2.4.1** å½’å¹¶æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚
**Theorem 2.4.1** The time complexity of merge sort is $O(n \log n)$ and space complexity is $O(n)$.

**è¯æ˜ / Proof:**

- é€’å½’æ ‘é«˜åº¦ï¼š$\log n$ / Recursion tree height: $\log n$
- æ¯å±‚åˆå¹¶æ—¶é—´ï¼š$O(n)$ / Merge time per level: $O(n)$
- æ€»æ—¶é—´ï¼š$O(n \log n)$ / Total time: $O(n \log n)$

### 2.5 å¿«é€Ÿæ’åº / Quick Sort

**å®šä¹‰ 2.5.1** å¿«é€Ÿæ’åºé€‰æ‹©åŸºå‡†å…ƒç´ ï¼Œå°†åºåˆ—åˆ†ä¸ºå°äºå’Œå¤§äºåŸºå‡†çš„ä¸¤éƒ¨åˆ†ã€‚
**Definition 2.5.1** Quick sort selects a pivot element and divides the sequence into two parts: less than and greater than the pivot.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
QuickSort(A, left, right):
    if left < right:
        pivot = Partition(A, left, right)
        QuickSort(A, left, pivot-1)
        QuickSort(A, pivot+1, right)
```

**å®šç† 2.5.1** å¿«é€Ÿæ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ï¼Œæœ€åæƒ…å†µä¸º $O(n^2)$ã€‚
**Theorem 2.5.1** The average time complexity of quick sort is $O(n \log n)$, but the worst case is $O(n^2)$.

### 2.6 å †æ’åº / Heap Sort

**å®šä¹‰ 2.6.1** å †æ’åºä½¿ç”¨å †æ•°æ®ç»“æ„è¿›è¡Œæ’åºã€‚
**Definition 2.6.1** Heap sort uses the heap data structure for sorting.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
HeapSort(A):
    BuildMaxHeap(A)
    for i = n downto 2:
        swap(A[1], A[i])
        heap_size = heap_size - 1
        MaxHeapify(A, 1)
```

**å®šç† 2.6.1** å †æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ã€‚
**Theorem 2.6.1** The time complexity of heap sort is $O(n \log n)$ and space complexity is $O(1)$.

---

## 3. éæ¯”è¾ƒæ’åº / Non-Comparison Sorting

### 3.1 è®¡æ•°æ’åº / Counting Sort

**å®šä¹‰ 3.1.1** è®¡æ•°æ’åºç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œç„¶åé‡å»ºåºåˆ—ã€‚
**Definition 3.1.1** Counting sort counts the occurrences of each element and then reconstructs the sequence.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
CountingSort(A, k):
    C = array of size k+1
    B = array of size n

    for i = 0 to k:
        C[i] = 0

    for j = 1 to n:
        C[A[j]] = C[A[j]] + 1

    for i = 1 to k:
        C[i] = C[i] + C[i-1]

    for j = n downto 1:
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1

    return B
```

**å®šç† 3.1.1** è®¡æ•°æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n + k)$ï¼Œå…¶ä¸­ $k$ æ˜¯å…ƒç´ èŒƒå›´ã€‚
**Theorem 3.1.1** The time complexity of counting sort is $O(n + k)$, where $k$ is the range of elements.

### 3.2 åŸºæ•°æ’åº / Radix Sort

**å®šä¹‰ 3.2.1** åŸºæ•°æ’åºæŒ‰ä½æ’åºï¼Œä»æœ€ä½ä½åˆ°æœ€é«˜ä½ã€‚
**Definition 3.2.1** Radix sort sorts by digits, from the least significant digit to the most significant digit.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
RadixSort(A, d):
    for i = 1 to d:
        A = CountingSort(A, 9) // æŒ‰ç¬¬iä½æ’åº / Sort by i-th digit
    return A
```

**å®šç† 3.2.1** åŸºæ•°æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(d(n + k))$ï¼Œå…¶ä¸­ $d$ æ˜¯ä½æ•°ï¼Œ$k$ æ˜¯åŸºæ•°ã€‚
**Theorem 3.2.1** The time complexity of radix sort is $O(d(n + k))$, where $d$ is the number of digits and $k$ is the radix.

### 3.3 æ¡¶æ’åº / Bucket Sort

**å®šä¹‰ 3.3.1** æ¡¶æ’åºå°†å…ƒç´ åˆ†é…åˆ°ä¸åŒçš„æ¡¶ä¸­ï¼Œç„¶åå¯¹æ¯ä¸ªæ¡¶æ’åºã€‚
**Definition 3.3.1** Bucket sort distributes elements into different buckets and then sorts each bucket.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
BucketSort(A):
    n = length(A)
    B = array of n empty lists

    for i = 1 to n:
        insert A[i] into B[floor(n*A[i])]

    for i = 0 to n-1:
        sort B[i] with insertion sort

    concatenate B[0], B[1], ..., B[n-1]
```

**å®šç† 3.3.1** æ¡¶æ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œå‡è®¾å…ƒç´ å‡åŒ€åˆ†å¸ƒã€‚
**Theorem 3.3.1** The average time complexity of bucket sort is $O(n)$, assuming elements are uniformly distributed.

---

## 4. æ’åºä¸‹ç•Œ / Sorting Lower Bounds

### 4.1 æ¯”è¾ƒæ’åºä¸‹ç•Œ / Comparison Sorting Lower Bound

**å®šç† 4.1.1** (æ’åºä¸‹ç•Œå®šç†) ä»»ä½•åŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•çš„æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦ä¸º $\Omega(n \log n)$ã€‚
**Theorem 4.1.1** (Sorting Lower Bound Theorem) Any comparison-based sorting algorithm has a worst-case time complexity of $\Omega(n \log n)$.

**è¯æ˜ / Proof:**

1. **å†³ç­–æ ‘æ¨¡å‹ / Decision Tree Model**ï¼šæ¯”è¾ƒæ’åºå¯ä»¥ç”¨å†³ç­–æ ‘è¡¨ç¤º / Comparison sorting can be represented by a decision tree
2. **å¶å­èŠ‚ç‚¹æ•° / Number of Leaf Nodes**ï¼š$n!$ ä¸ªä¸åŒçš„æ’åˆ— / $n!$ different permutations
3. **æ ‘é«˜åº¦ / Tree Height**ï¼šè‡³å°‘ $\log(n!)$ / At least $\log(n!)$
4. **æ–¯ç‰¹æ—å…¬å¼ / Stirling's Formula**ï¼š$\log(n!) = \Theta(n \log n)$ / $\log(n!) = \Theta(n \log n)$

**æ¨è®º 4.1.1** å½’å¹¶æ’åºå’Œå †æ’åºæ˜¯æœ€ä¼˜çš„æ¯”è¾ƒæ’åºç®—æ³•ã€‚
**Corollary 4.1.1** Merge sort and heap sort are optimal comparison-based sorting algorithms.

### 4.2 ä¿¡æ¯è®ºä¸‹ç•Œ / Information-Theoretic Lower Bound

**å®šä¹‰ 4.2.1** æ’åºé—®é¢˜çš„ä¿¡æ¯è®ºä¸‹ç•Œï¼š
**Definition 4.2.1** Information-theoretic lower bound for the sorting problem:
$$H(\pi) = \log(n!) = \Theta(n \log n)$$

å…¶ä¸­ $H(\pi)$ æ˜¯æ’åˆ— $\pi$ çš„ç†µã€‚
where $H(\pi)$ is the entropy of permutation $\pi$.

**å®šç† 4.2.1** ä»»ä½•æ’åºç®—æ³•è‡³å°‘éœ€è¦ $\Omega(n \log n)$ æ¬¡æ¯”è¾ƒã€‚
**Theorem 4.2.1** Any sorting algorithm requires at least $\Omega(n \log n)$ comparisons.

### 4.3 è‡ªé€‚åº”æ’åº / Adaptive Sorting

**å®šä¹‰ 4.3.1** è‡ªé€‚åº”æ’åºç®—æ³•å¯¹å·²éƒ¨åˆ†æ’åºçš„è¾“å…¥è¡¨ç°æ›´å¥½ã€‚
**Definition 4.3.1** Adaptive sorting algorithms perform better on partially sorted inputs.

**å®šç† 4.3.1** æ’å…¥æ’åºçš„è‡ªé€‚åº”å¤æ‚åº¦ä¸º $O(n + d)$ï¼Œå…¶ä¸­ $d$ æ˜¯é€†åºå¯¹æ•°é‡ã€‚
**Theorem 4.3.1** The adaptive complexity of insertion sort is $O(n + d)$, where $d$ is the number of inversions.

---

## 5. å¤–éƒ¨æ’åº / External Sorting

### 5.1 å¤–éƒ¨æ’åºæ¨¡å‹ / External Sorting Model

**å®šä¹‰ 5.1.1** å¤–éƒ¨æ’åºå¤„ç†æ— æ³•å®Œå…¨è£…å…¥å†…å­˜çš„å¤§æ•°æ®é›†ã€‚
**Definition 5.1.1** External sorting handles large datasets that cannot fit entirely in memory.

**æ¨¡å‹å‡è®¾ / Model Assumptions:**

- å†…å­˜å¤§å°ï¼š$M$ ä¸ªå…ƒç´  / Memory size: $M$ elements
- ç£ç›˜å—å¤§å°ï¼š$B$ ä¸ªå…ƒç´  / Disk block size: $B$ elements
- æ•°æ®å¤§å°ï¼š$N$ ä¸ªå…ƒç´  / Data size: $N$ elements

### 5.2 å¤šè·¯å½’å¹¶ / Multiway Merge

**å®šä¹‰ 5.2.1** å¤šè·¯å½’å¹¶åŒæ—¶å½’å¹¶å¤šä¸ªæœ‰åºåºåˆ—ã€‚
**Definition 5.2.1** Multiway merge merges multiple sorted sequences simultaneously.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
MultiwayMerge(input_files, output_file):
    while not all files empty:
        min_element = find_minimum_from_all_files()
        write min_element to output_file
        advance pointer in file containing min_element
```

**å®šç† 5.2.1** å¤šè·¯å½’å¹¶çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(N \log k)$ï¼Œå…¶ä¸­ $k$ æ˜¯å½’å¹¶çš„è·¯æ•°ã€‚
**Theorem 5.2.1** The time complexity of multiway merge is $O(N \log k)$, where $k$ is the number of merge ways.

### 5.3 æ›¿æ¢é€‰æ‹© / Replacement Selection

**å®šä¹‰ 5.3.1** æ›¿æ¢é€‰æ‹©ä½¿ç”¨å †ç»“æ„ç”Ÿæˆåˆå§‹æœ‰åºæ®µã€‚
**Definition 5.3.1** Replacement selection uses a heap structure to generate initial sorted runs.

**ç®—æ³•æè¿° / Algorithm Description:**

```text
ReplacementSelection(input, M):
    heap = min_heap of size M
    output = []

    // åˆå§‹å¡«å……å † / Initially fill the heap
    for i = 1 to M:
        insert input.next() into heap

    while not input.empty():
        min_element = heap.extract_min()
        output.append(min_element)

        if not input.empty():
            next_element = input.next()
            if next_element >= min_element:
                heap.insert(next_element)
            else:
                // å¼€å§‹æ–°çš„æœ‰åºæ®µ / Start a new sorted run
                start_new_run()
```

**å®šç† 5.3.1** æ›¿æ¢é€‰æ‹©ç”Ÿæˆçš„æœ‰åºæ®µå¹³å‡é•¿åº¦ä¸º $2M$ã€‚
**Theorem 5.3.1** The average length of sorted runs generated by replacement selection is $2M$.

---

## 6. å®ç°ç¤ºä¾‹

### 6.1 å¿«é€Ÿæ’åºå®ç°

```rust
pub struct QuickSort;

impl QuickSort {
    pub fn sort<T: Ord + Clone>(arr: &mut [T]) {
        Self::quick_sort(arr, 0, arr.len().saturating_sub(1));
    }

    fn quick_sort<T: Ord + Clone>(arr: &mut [T], low: usize, high: usize) {
        if low < high {
            let pivot_index = Self::partition(arr, low, high);
            if pivot_index > 0 {
                Self::quick_sort(arr, low, pivot_index - 1);
            }
            Self::quick_sort(arr, pivot_index + 1, high);
        }
    }

    fn partition<T: Ord + Clone>(arr: &mut [T], low: usize, high: usize) -> usize {
        let pivot = arr[high].clone();
        let mut i = low;

        for j in low..high {
            if arr[j] <= pivot {
                arr.swap(i, j);
                i += 1;
            }
        }

        arr.swap(i, high);
        i
    }
}
```

### 6.2 å½’å¹¶æ’åºå®ç°

```rust
pub struct MergeSort;

impl MergeSort {
    pub fn sort<T: Ord + Clone>(arr: &mut [T]) {
        if arr.len() <= 1 {
            return;
        }

        let mid = arr.len() / 2;
        let (left, right) = arr.split_at_mut(mid);

        Self::sort(left);
        Self::sort(right);

        Self::merge(arr, mid);
    }

    fn merge<T: Ord + Clone>(arr: &mut [T], mid: usize) {
        let mut left = arr[..mid].to_vec();
        let mut right = arr[mid..].to_vec();

        let mut i = 0;
        let mut j = 0;
        let mut k = 0;

        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                arr[k] = left[i].clone();
                i += 1;
            } else {
                arr[k] = right[j].clone();
                j += 1;
            }
            k += 1;
        }

        while i < left.len() {
            arr[k] = left[i].clone();
            i += 1;
            k += 1;
        }

        while j < right.len() {
            arr[k] = right[j].clone();
            j += 1;
            k += 1;
        }
    }
}
```

### 6.3 å †æ’åºå®ç°

```rust
pub struct HeapSort;

impl HeapSort {
    pub fn sort<T: Ord>(arr: &mut [T]) {
        let n = arr.len();

        // æ„å»ºæœ€å¤§å †
        for i in (0..n/2).rev() {
            Self::heapify(arr, n, i);
        }

        // é€ä¸ªæå–æœ€å¤§å…ƒç´ 
        for i in (1..n).rev() {
            arr.swap(0, i);
            Self::heapify(arr, i, 0);
        }
    }

    fn heapify<T: Ord>(arr: &mut [T], n: usize, i: usize) {
        let mut largest = i;
        let left = 2 * i + 1;
        let right = 2 * i + 2;

        if left < n && arr[left] > arr[largest] {
            largest = left;
        }

        if right < n && arr[right] > arr[largest] {
            largest = right;
        }

        if largest != i {
            arr.swap(i, largest);
            Self::heapify(arr, n, largest);
        }
    }
}
```

### 6.4 è®¡æ•°æ’åºå®ç°

```rust
pub struct CountingSort;

impl CountingSort {
    pub fn sort(arr: &[usize], max_value: usize) -> Vec<usize> {
        let mut count = vec![0; max_value + 1];
        let mut output = vec![0; arr.len()];

        // è®¡æ•°
        for &num in arr {
            count[num] += 1;
        }

        // ç´¯ç§¯è®¡æ•°
        for i in 1..=max_value {
            count[i] += count[i - 1];
        }

        // æ„å»ºè¾“å‡ºæ•°ç»„
        for &num in arr.iter().rev() {
            let index = count[num] - 1;
            output[index] = num;
            count[num] -= 1;
        }

        output
    }
}
```

### 6.5 åŸºæ•°æ’åºå®ç°

```rust
pub struct RadixSort;

impl RadixSort {
    pub fn sort(arr: &mut [usize]) {
        if arr.is_empty() {
            return;
        }

        let max_value = *arr.iter().max().unwrap();
        let mut exp = 1;

        while max_value / exp > 0 {
            Self::counting_sort_by_digit(arr, exp);
            exp *= 10;
        }
    }

    fn counting_sort_by_digit(arr: &mut [usize], exp: usize) {
        let mut count = vec![0; 10];
        let mut output = vec![0; arr.len()];

        // è®¡æ•°
        for &num in arr.iter() {
            let digit = (num / exp) % 10;
            count[digit] += 1;
        }

        // ç´¯ç§¯è®¡æ•°
        for i in 1..10 {
            count[i] += count[i - 1];
        }

        // æ„å»ºè¾“å‡ºæ•°ç»„
        for &num in arr.iter().rev() {
            let digit = (num / exp) % 10;
            let index = count[digit] - 1;
            output[index] = num;
            count[digit] -= 1;
        }

        // å¤åˆ¶å›åŸæ•°ç»„
        arr.copy_from_slice(&output);
    }
}
```

### 6.6 æ’åºç®—æ³•æ¯”è¾ƒ

```rust
use std::time::{Duration, Instant};

pub struct SortBenchmark;

impl SortBenchmark {
    pub fn benchmark<T: Ord + Clone>(arr: &[T], sort_fn: fn(&mut [T])) -> Duration {
        let mut arr_copy = arr.to_vec();
        let start = Instant::now();
        sort_fn(&mut arr_copy);
        start.elapsed()
    }

    pub fn compare_algorithms(arr: &[usize]) {
        let mut arr_copy = arr.to_vec();

        // å¿«é€Ÿæ’åº
        let quick_time = Self::benchmark(arr, |arr| {
            QuickSort::sort(arr);
        });

        // å½’å¹¶æ’åº
        let merge_time = Self::benchmark(arr, |arr| {
            MergeSort::sort(arr);
        });

        // å †æ’åº
        let heap_time = Self::benchmark(arr, |arr| {
            HeapSort::sort(arr);
        });

        println!("å¿«é€Ÿæ’åºæ—¶é—´: {:?}", quick_time);
        println!("å½’å¹¶æ’åºæ—¶é—´: {:?}", merge_time);
        println!("å †æ’åºæ—¶é—´: {:?}", heap_time);
    }
}
```

---

## 7. å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚

### 7.1 ç»å…¸æ•™æ / Classic Textbooks

1. [Cormen2022] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
   - **Cormen-Leiserson-Rivest-Steinç®—æ³•å¯¼è®º**ï¼Œç®—æ³•è®¾è®¡ä¸åˆ†æçš„æƒå¨æ•™æã€‚æœ¬æ–‡æ¡£çš„æ’åºç®—æ³•ç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

2. [Knuth1997] Knuth, D. E. (1997). *The Art of Computer Programming, Volume 3: Sorting and Searching* (2nd ed.). Addison-Wesley. ISBN: 978-0201896855
   - **Knuthè®¡ç®—æœºç¨‹åºè®¾è®¡è‰ºæœ¯ç¬¬3å·**ï¼Œæ’åºä¸æŸ¥æ‰¾çš„ç»å…¸è‘—ä½œã€‚æœ¬æ–‡æ¡£çš„æ’åºç®—æ³•åˆ†æå‚è€ƒæ­¤ä¹¦ã€‚

3. [Sedgewick2011] Sedgewick, R., & Wayne, K. (2011). *Algorithms* (4th ed.). Addison-Wesley. ISBN: 978-0321573513
   - **Sedgewick-Wayneç®—æ³•æ•™æ**ï¼Œæ³¨é‡ç®—æ³•å®ç°ä¸å®è·µã€‚æœ¬æ–‡æ¡£çš„æ’åºç®—æ³•å®ç°å‚è€ƒæ­¤ä¹¦ã€‚

### 7.2 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers

#### æ’åºç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Sorting Algorithm Theory

1. **Journal of the ACM (JACM)**
   - **Hoare, C.A.R.** (1962). "Quicksort". *The Computer Journal*, 5(1), 10-16.
   - **Floyd, R.W.** (1964). "Algorithm 245: Treesort 3". *Communications of the ACM*, 7(12), 701.
   - **Williams, J.W.J.** (1964). "Algorithm 232: Heapsort". *Communications of the ACM*, 7(6), 347-348.
   - **Shell, D.L.** (1959). "A High-Speed Sorting Procedure". *Communications of the ACM*, 2(7), 30-32.

2. **SIAM Journal on Computing (SICOMP)**
   - **Ajtai, M., et al.** (1983). "An O(n log n) Sorting Network". *Proceedings of the 15th Annual ACM Symposium on Theory of Computing*, 1-9.
   - **Paterson, M.S.** (1990). "Improved Sorting Networks with O(log n) Depth". *Algorithmica*, 5(1-4), 75-92.
   - **Batcher, K.E.** (1968). "Sorting Networks and Their Applications". *Proceedings of the AFIPS Spring Joint Computer Conference*, 307-314.

#### æ¯”è¾ƒæ’åºä¸‹ç•Œç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Comparison Sort Lower Bounds

1. **Theoretical Computer Science**
   - **Ford, L.R., & Johnson, S.M.** (1959). "A Tournament Problem". *The American Mathematical Monthly*, 66(5), 387-389.
   - **Knuth, D.E.** (1973). *The Art of Computer Programming, Volume 3: Sorting and Searching*. Addison-Wesley.
   - **Manacher, G.K.** (1979). "The Ford-Johnson Algorithm is Not Optimal". *Journal of the ACM*, 26(3), 441-456.

2. **Information and Computation**
   - **Kahn, J., & Kim, J.H.** (1995). "Entropy and Sorting". *Journal of Computer and System Sciences*, 51(3), 390-399.
   - **Cormen, T.H., et al.** (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.

#### çº¿æ€§æ—¶é—´æ’åºé¡¶çº§æœŸåˆŠ / Top Journals in Linear Time Sorting

1. **Journal of Computer and System Sciences**
   - **Thorup, M.** (2002). "Randomized Sorting in O(n log log n) Time and Linear Space Using Addition, Shift, and Bit-wise Boolean Operations". *Journal of Algorithms*, 42(2), 205-230.
   - **Han, Y.** (2004). "Deterministic Sorting in O(n log log n) Time and Linear Space". *Journal of Algorithms*, 50(1), 96-105.
   - **Kirkpatrick, D.G., & Reisch, S.** (1984). "Upper Bounds for Sorting Integers on Random Access Machines". *Theoretical Computer Science*, 28(3), 263-276.

2. **Computational Complexity**
   - **Beame, P., et al.** (1998). "Sorting and Selection in Rounds". *SIAM Journal on Computing*, 28(3), 1030-1048.
   - **Albers, S., & Hagerup, T.** (1997). "Improved Parallel Integer Sorting without Concurrent Writing". *Information and Computation*, 136(1), 25-51.

#### å¤–éƒ¨æ’åºé¡¶çº§æœŸåˆŠ / Top Journals in External Sorting

1. **ACM Transactions on Database Systems**
   - **Aggarwal, A., & Vitter, J.S.** (1988). "The Input/Output Complexity of Sorting and Related Problems". *Communications of the ACM*, 31(9), 1116-1127.
   - **Chiang, Y.J., et al.** (1995). "External Memory Graph Algorithms". *Proceedings of the 6th Annual ACM-SIAM Symposium on Discrete Algorithms*, 139-149.
   - **Arge, L.** (2003). "External Memory Data Structures". *Handbook of Massive Data Sets*, 313-358.

2. **Journal of Algorithms**
   - **Vitter, J.S.** (2001). "External Memory Algorithms and Data Structures: Dealing with Massive Data". *ACM Computing Surveys*, 33(2), 209-271.
   - **Arge, L., et al.** (1999). "I/O-Efficient Algorithms for Problems on Grid-Based Terrains". *Journal of Experimental Algorithmics*, 4, 1-23.

#### å¹¶è¡Œæ’åºé¡¶çº§æœŸåˆŠ / Top Journals in Parallel Sorting

1. **Journal of Parallel and Distributed Computing**
   - **Leighton, T.** (1985). "Tight Bounds on the Complexity of Parallel Sorting". *IEEE Transactions on Computers*, 34(4), 344-354.
   - **Cole, R.** (1988). "Parallel Merge Sort". *SIAM Journal on Computing*, 17(4), 770-785.
   - **Blelloch, G.E.** (1990). "Prefix Sums and Their Applications". *Synthesis of Parallel Algorithms*, 35-60.

2. **Parallel Computing**
   - **Akl, S.G.** (1985). *Parallel Sorting Algorithms*. Academic Press.
   - **JaJa, J.** (1992). *An Introduction to Parallel Algorithms*. Addison-Wesley.

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Sorting Algorithm**: <https://en.wikipedia.org/wiki/Sorting_algorithm>
   - æ’åºç®—æ³•çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«æ¯”è¾ƒæ’åºå’Œéæ¯”è¾ƒæ’åºï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

2. **Wikipedia - Comparison Sort**: <https://en.wikipedia.org/wiki/Comparison_sort>
   - æ¯”è¾ƒæ’åºçš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»æ¯”è¾ƒæ’åºçš„ä¸‹ç•Œï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

3. **Wikipedia - Quicksort**: <https://en.wikipedia.org/wiki/Quicksort>
   - å¿«é€Ÿæ’åºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«ç®—æ³•æè¿°å’Œå¤æ‚åº¦åˆ†æï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

4. **Wikipedia - Heapsort**: <https://en.wikipedia.org/wiki/Heapsort>
   - å †æ’åºçš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»å †æ•°æ®ç»“æ„å’Œæ’åºè¿‡ç¨‹ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

5. **Wikipedia - Merge Sort**: <https://en.wikipedia.org/wiki/Merge_sort>
   - å½’å¹¶æ’åºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«åˆ†æ²»ç­–ç•¥å’Œç¨³å®šæ€§åˆ†æï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

## 8. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### 8.1 ç›¸å…³æ–‡æ¡£ / Related Documents

- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/01-ç®—æ³•è®¾è®¡ç†è®º.md` - ç®—æ³•è®¾è®¡ç†è®ºï¼ˆåˆ†æ²»ã€åŠ¨æ€è§„åˆ’ç­‰è®¾è®¡èŒƒå¼ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/22-ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶.md` - ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶ï¼ˆé—®é¢˜ç±»å‹ç»´åº¦ï¼‰
- `04-ç®—æ³•å¤æ‚åº¦/06-ä¿¡æ¯è®ºä¸‹ç•Œ.md` - ä¿¡æ¯è®ºä¸‹ç•Œï¼ˆåŒ…å«æ’åºç®—æ³•çš„ä¿¡æ¯è®ºä¸‹ç•Œï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/02-æ•°æ®ç»“æ„ç†è®º.md` - æ•°æ®ç»“æ„ç†è®ºï¼ˆå †ã€æ•°ç»„ç­‰ï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-11-14.md` - ç®—æ³•å…¨æ™¯æ¢³ç†ï¼ˆåŒ…å«æ’åºç®—æ³•æ¦‚è¿°ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-11-14.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

### 8.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€** æ¨¡å—ï¼Œæ˜¯æ’åºç®—æ³•ç†è®ºçš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºæ’åºç®—æ³•çš„è®¾è®¡å’Œåˆ†ææä¾›ç†è®ºåŸºç¡€ã€‚

### 8.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-11-14.md` Â§3.2 - Masterå®šç†ï¼ˆåˆ†æ²»æ’åºçš„å¤æ‚åº¦åˆ†æï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-11-14.md` Â§3.8 - ä¿¡æ¯è®ºä¸‹ç•Œï¼ˆæ’åºç®—æ³•çš„ä¸‹ç•Œï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-11-14.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
**æœ€åæ›´æ–° / Last Updated**: 2025-11-14
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-11-14)

---

*æœ¬æ–‡æ¡£ä¸¥æ ¼éµå¾ªæ•°å­¦å½¢å¼åŒ–è§„èŒƒï¼Œæ‰€æœ‰å®šä¹‰å’Œå®šç†å‡é‡‡ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·è¡¨ç¤ºï¼Œå¹¶ç¬¦åˆå›½é™…é¡¶çº§å­¦æœ¯æœŸåˆŠæ ‡å‡†ã€‚*
