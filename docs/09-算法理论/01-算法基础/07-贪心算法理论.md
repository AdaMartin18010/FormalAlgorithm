---
title: 9.1.7 贪心算法理论 / Greedy Algorithm Theory
version: 1.0
status: maintained
last_updated: 2025-10-11
owner: 算法理论工作组
---

## 9.1.7 贪心算法理论 / Greedy Algorithm Theory

### 摘要 / Executive Summary

- 统一贪心算法的形式化定义、贪心选择性质与最优子结构。
- 建立贪心算法在算法设计中的核心地位。

### 关键术语与符号 / Glossary

- 贪心算法、贪心选择性质、最优子结构、活动选择、最小生成树、最短路径。
- 术语对齐与引用规范：`docs/术语与符号总表.md`，`01-基础理论/00-撰写规范与引用指南.md`

### 术语与符号规范 / Terminology & Notation

- 贪心算法（Greedy Algorithm）：每一步都做出当前最优选择的算法。
- 贪心选择性质（Greedy Choice Property）：局部最优选择能导致全局最优。
- 最优子结构（Optimal Substructure）：问题的最优解包含子问题的最优解。
- 记号约定：`G` 表示图，`w` 表示权重，`d` 表示距离。

### 交叉引用导航 / Cross-References

- 算法设计：参见 `09-算法理论/01-算法基础/01-算法设计理论.md`。
- 动态规划：参见 `09-算法理论/01-算法基础/06-动态规划理论.md`。
- 图算法：参见 `09-算法理论/01-算法基础/05-图算法理论.md`。

### 快速导航 / Quick Links

- 基本概念
- 贪心选择性质
- 应用示例

## 目录 (Table of Contents)

- [9.1.7 贪心算法理论 / Greedy Algorithm Theory](#917-贪心算法理论--greedy-algorithm-theory)
  - [摘要 / Executive Summary](#摘要--executive-summary)
  - [关键术语与符号 / Glossary](#关键术语与符号--glossary)
  - [术语与符号规范 / Terminology \& Notation](#术语与符号规范--terminology--notation)
  - [交叉引用导航 / Cross-References](#交叉引用导航--cross-references)
  - [快速导航 / Quick Links](#快速导航--quick-links)
- [目录 (Table of Contents)](#目录-table-of-contents)
- [基本概念 (Basic Concepts)](#基本概念-basic-concepts)
  - [定义 (Definition)](#定义-definition)
  - [核心思想 (Core Ideas)](#核心思想-core-ideas)
- [贪心选择性质 (Greedy Choice Property)](#贪心选择性质-greedy-choice-property)
  - [数学定义 (Mathematical Definition)](#数学定义-mathematical-definition)
  - [贪心策略证明 (Greedy Strategy Proof)](#贪心策略证明-greedy-strategy-proof)
- [经典问题 (Classic Problems)](#经典问题-classic-problems)
  - [1. 活动选择问题 (Activity Selection Problem)](#1-活动选择问题-activity-selection-problem)
  - [2. 霍夫曼编码 (Huffman Coding)](#2-霍夫曼编码-huffman-coding)
  - [3. 最小生成树 (Minimum Spanning Tree)](#3-最小生成树-minimum-spanning-tree)
- [证明技巧 (Proof Techniques)](#证明技巧-proof-techniques)
  - [1. 交换论证 (Exchange Argument)](#1-交换论证-exchange-argument)
  - [2. 归纳法 (Induction)](#2-归纳法-induction)
  - [3. 对偶性 (Duality)](#3-对偶性-duality)
- [实现示例 (Implementation Examples)](#实现示例-implementation-examples)
  - [Rust实现 (Rust Implementation)](#rust实现-rust-implementation)
  - [Haskell实现 (Haskell Implementation)](#haskell实现-haskell-implementation)
  - [Lean实现 (Lean Implementation)](#lean实现-lean-implementation)
- [复杂度分析 (Complexity Analysis)](#复杂度分析-complexity-analysis)
  - [时间复杂度 (Time Complexity)](#时间复杂度-time-complexity)
  - [空间复杂度 (Space Complexity)](#空间复杂度-space-complexity)
- [应用领域 (Application Areas)](#应用领域-application-areas)
  - [1. 数据压缩 (Data Compression)](#1-数据压缩-data-compression)
  - [2. 网络设计 (Network Design)](#2-网络设计-network-design)
  - [3. 任务调度 (Task Scheduling)](#3-任务调度-task-scheduling)
  - [4. 资源分配 (Resource Allocation)](#4-资源分配-resource-allocation)
- [总结 (Summary)](#总结-summary)
  - [关键要点 (Key Points)](#关键要点-key-points)
  - [发展趋势 (Development Trends)](#发展趋势-development-trends)
- [7. 参考文献 / References](#7-参考文献--references)
  - [7.1 经典教材 / Classic Textbooks](#71-经典教材--classic-textbooks)
  - [7.2 顶级期刊论文 / Top Journal Papers](#72-顶级期刊论文--top-journal-papers)
    - [贪心算法理论顶级期刊 / Top Journals in Greedy Algorithm Theory](#贪心算法理论顶级期刊--top-journals-in-greedy-algorithm-theory)
    - [组合优化顶级期刊 / Top Journals in Combinatorial Optimization](#组合优化顶级期刊--top-journals-in-combinatorial-optimization)
    - [数据压缩算法顶级期刊 / Top Journals in Data Compression Algorithms](#数据压缩算法顶级期刊--top-journals-in-data-compression-algorithms)
    - [调度算法顶级期刊 / Top Journals in Scheduling Algorithms](#调度算法顶级期刊--top-journals-in-scheduling-algorithms)
    - [近似算法顶级期刊 / Top Journals in Approximation Algorithms](#近似算法顶级期刊--top-journals-in-approximation-algorithms)
- [8. 与项目结构主题的对齐 / Alignment with Project Structure](#8-与项目结构主题的对齐--alignment-with-project-structure)
  - [8.1 相关文档 / Related Documents](#81-相关文档--related-documents)
  - [8.2 知识体系位置 / Knowledge System Position](#82-知识体系位置--knowledge-system-position)
  - [8.3 VIEW文件夹相关文档 / VIEW Folder Related Documents](#83-view文件夹相关文档--view-folder-related-documents)

## 基本概念 (Basic Concepts)

### 定义 (Definition)

贪心算法是一种在每一步选择中都采取当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法策略。

**A greedy algorithm is an algorithmic strategy that makes the locally optimal choice at each step, hoping that these choices will lead to a globally optimal solution.**

### 核心思想 (Core Ideas)

1. **局部最优选择** (Local Optimal Choice)
   - 在每一步选择当前最优解
   - Choose the current optimal solution at each step

2. **贪心选择性质** (Greedy Choice Property)
   - 全局最优解可以通过局部最优选择得到
   - Global optimal solution can be obtained through local optimal choices

3. **最优子结构** (Optimal Substructure)
   - 问题的最优解包含其子问题的最优解
   - The optimal solution contains optimal solutions to its subproblems

## 贪心选择性质 (Greedy Choice Property)

### 数学定义 (Mathematical Definition)

设 $S$ 为问题的解空间，$C$ 为候选解集合，贪心选择性质定义为：

**Let $S$ be the solution space and $C$ be the candidate solution set, the greedy choice property is defined as:**

$$\forall s \in S, \exists c \in C: f(s) \leq f(c)$$

其中 $f$ 是目标函数。

**Where $f$ is the objective function.**

### 贪心策略证明 (Greedy Strategy Proof)

**定理** (Theorem): 如果问题满足贪心选择性质，则贪心算法可以得到全局最优解。

**Theorem**: If a problem satisfies the greedy choice property, then the greedy algorithm can obtain the global optimal solution.

**证明** (Proof):

1. 假设贪心算法得到的解不是最优解
2. 根据贪心选择性质，存在一个贪心选择可以得到更优解
3. 这与贪心算法的选择矛盾
4. 因此贪心算法得到的是最优解

**Proof**:

1. Assume the solution obtained by the greedy algorithm is not optimal
2. According to the greedy choice property, there exists a greedy choice that can obtain a better solution
3. This contradicts the choice of the greedy algorithm
4. Therefore, the greedy algorithm obtains the optimal solution

## 经典问题 (Classic Problems)

### 1. 活动选择问题 (Activity Selection Problem)

**问题描述** (Problem Description):
给定 $n$ 个活动，每个活动有开始时间 $s_i$ 和结束时间 $f_i$，选择最多的互不冲突的活动。

**Given $n$ activities, each with start time $s_i$ and finish time $f_i$, select the maximum number of non-overlapping activities.**

**贪心策略** (Greedy Strategy):
按结束时间排序，选择结束时间最早的活动。

**Sort by finish time and select the activity with the earliest finish time.**

**正确性证明** (Correctness Proof):
设 $A$ 为贪心算法选择的解，$O$ 为最优解。如果 $A \neq O$，则存在活动 $a \in O - A$，可以用 $A$ 中的某个活动替换，得到更优解。

**Let $A$ be the solution selected by the greedy algorithm and $O$ be the optimal solution. If $A \neq O$, then there exists an activity $a \in O - A$ that can be replaced by some activity in $A$ to obtain a better solution.**

### 2. 霍夫曼编码 (Huffman Coding)

**问题描述** (Problem Description):
给定字符集和频率，构造最优前缀编码。

**Given a character set and frequencies, construct optimal prefix codes.**

**贪心策略** (Greedy Strategy):
每次选择频率最小的两个节点合并。

**Merge the two nodes with minimum frequency each time.**

**正确性证明** (Correctness Proof):
通过归纳法证明，每次合并都是最优选择。

**Prove by induction that each merge is the optimal choice.**

### 3. 最小生成树 (Minimum Spanning Tree)

**问题描述** (Problem Description):
在连通图中找到权值和最小的生成树。

**Find the spanning tree with minimum weight sum in a connected graph.**

**贪心策略** (Greedy Strategy):
Kruskal算法：按边权排序，选择不形成环的边。

**Kruskal's algorithm: Sort edges by weight and select edges that don't form cycles.**

**正确性证明** (Correctness Proof):
使用割性质证明，每次选择的边都是某个割的最小权边。

**Use the cut property to prove that each selected edge is the minimum weight edge of some cut.**

**定理（Cut Property）** (Theorem - Cut Property):
在任意 **割**（将图顶点划分为两部分）的所有跨割边中，**权值最小的边** 必在某个 **最小生成树** 中。

**In any **cut** (partitioning graph vertices into two parts), among all edges crossing the cut, the **edge with minimum weight** must be in some **minimum spanning tree**.**

**证明要点** (Proof Outline):

1. 设 `e = (u,v)` 为割 `C` 的最小边。
   Let `e = (u,v)` be the minimum edge of cut `C`.

2. 任取一棵最小生成树 `T`。若 `e ∈ T`，结论成立。
   Take any minimum spanning tree `T`. If `e ∈ T`, the conclusion holds.

3. 若 `e ∉ T`，则在 `T` 中必有唯一的 `u-v` 路径 `P`，该路径必跨过 `C`（因为 `u` 与 `v` 分属两侧）。
   If `e ∉ T`, then there must be a unique `u-v` path `P` in `T`, which must cross `C` (since `u` and `v` are on different sides).

4. 设 `f` 为 `P` 中跨割的第一条边，权值 `w(f) ≥ w(e)`（因为 `e` 是最小跨割边）。
   Let `f` be the first edge in `P` that crosses the cut, then `w(f) ≥ w(e)` (since `e` is the minimum crossing edge).

5. 替换 `f` 为 `e`，得到新树 `T'`，其权值不大于 `T`，仍是生成树。
   Replace `f` with `e` to get a new tree `T'`, whose weight is no greater than `T`, and is still a spanning tree.

6. 递归进行，最终得到包含 `e` 的最小生成树。
   Recursively proceed, eventually obtaining a minimum spanning tree containing `e`.

**直接得到** (Direct Consequence):
Kruskal 按权值升序加入不形成环的边，一定得到最小生成树（因为每一步都满足 Cut Property）。

**Kruskal's algorithm, which adds edges in ascending order of weight without forming cycles, must produce a minimum spanning tree (because each step satisfies the Cut Property).**

## 证明技巧 (Proof Techniques)

### 1. 交换论证 (Exchange Argument)

**方法** (Method):
假设贪心解不是最优解，通过交换元素构造更优解，得出矛盾。

**Assume the greedy solution is not optimal, construct a better solution by exchanging elements, leading to a contradiction.**

**示例** (Example):
活动选择问题中，如果贪心解 $A$ 不是最优解，则存在最优解 $O$ 包含贪心算法未选择的活动，可以通过交换证明 $A$ 也是最优解。

**In the activity selection problem, if greedy solution $A$ is not optimal, then there exists an optimal solution $O$ containing activities not selected by the greedy algorithm, which can be proven to be optimal through exchange.**

### 2. 归纳法 (Induction)

**方法** (Method):
证明贪心算法在每一步都保持最优性。

**Prove that the greedy algorithm maintains optimality at each step.**

**示例** (Example):
霍夫曼编码中，证明每次合并两个最小频率节点后，剩余问题仍然具有最优子结构。

**In Huffman coding, prove that after merging two nodes with minimum frequency, the remaining problem still has optimal substructure.**

### 3. 对偶性 (Duality)

**方法** (Method):
通过构造对偶问题证明贪心算法的正确性。

**Prove the correctness of the greedy algorithm by constructing the dual problem.**

**示例** (Example):
在最大流问题中，通过最小割对偶性证明Ford-Fulkerson算法的正确性。

**In the maximum flow problem, prove the correctness of Ford-Fulkerson algorithm through minimum cut duality.**

## 实现示例 (Implementation Examples)

### Rust实现 (Rust Implementation)

```rust
use std::collections::BinaryHeap;
use std::cmp::Ordering;

/// 活动结构
/// Activity structure
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Activity {
    pub id: usize,
    pub start: i32,
    pub finish: i32,
}

impl Activity {
    pub fn new(id: usize, start: i32, finish: i32) -> Self {
        Self { id, start, finish }
    }
}

/// 贪心算法实现
/// Greedy algorithm implementation
pub struct GreedyAlgorithm;

impl GreedyAlgorithm {
    /// 活动选择问题
    /// Activity selection problem
    pub fn activity_selection(activities: &mut Vec<Activity>) -> Vec<Activity> {
        // 按结束时间排序
        // Sort by finish time
        activities.sort_by_key(|a| a.finish);

        let mut selected = Vec::new();
        let mut last_finish = 0;

        for activity in activities {
            if activity.start >= last_finish {
                selected.push(activity.clone());
                last_finish = activity.finish;
            }
        }

        selected
    }

    /// 霍夫曼编码节点
    /// Huffman coding node
    #[derive(Debug, Clone)]
    pub struct HuffmanNode {
        pub character: Option<char>,
        pub frequency: i32,
        pub left: Option<Box<HuffmanNode>>,
        pub right: Option<Box<HuffmanNode>>,
    }

    impl HuffmanNode {
        pub fn new(character: char, frequency: i32) -> Self {
            Self {
                character: Some(character),
                frequency,
                left: None,
                right: None,
            }
        }

        pub fn new_internal(frequency: i32, left: HuffmanNode, right: HuffmanNode) -> Self {
            Self {
                character: None,
                frequency,
                left: Some(Box::new(left)),
                right: Some(Box::new(right)),
            }
        }
    }

    impl PartialEq for HuffmanNode {
        fn eq(&self, other: &Self) -> bool {
            self.frequency == other.frequency
        }
    }

    impl Eq for HuffmanNode {}

    impl PartialOrd for HuffmanNode {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }

    impl Ord for HuffmanNode {
        fn cmp(&self, other: &Self) -> Ordering {
            other.frequency.cmp(&self.frequency) // 最小堆
        }
    }

    /// 构建霍夫曼树
    /// Build Huffman tree
    pub fn build_huffman_tree(frequencies: &[(char, i32)]) -> Option<HuffmanNode> {
        let mut heap = BinaryHeap::new();

        // 初始化叶子节点
        // Initialize leaf nodes
        for &(character, frequency) in frequencies {
            heap.push(HuffmanNode::new(character, frequency));
        }

        // 构建树
        // Build tree
        while heap.len() > 1 {
            let left = heap.pop().unwrap();
            let right = heap.pop().unwrap();

            let internal = HuffmanNode::new_internal(
                left.frequency + right.frequency,
                left,
                right,
            );

            heap.push(internal);
        }

        heap.pop()
    }

    /// 生成霍夫曼编码
    /// Generate Huffman codes
    pub fn generate_huffman_codes(root: &HuffmanNode) -> std::collections::HashMap<char, String> {
        let mut codes = std::collections::HashMap::new();
        let mut current_code = String::new();

        Self::generate_codes_recursive(root, &mut codes, &mut current_code);

        codes
    }

    fn generate_codes_recursive(
        node: &HuffmanNode,
        codes: &mut std::collections::HashMap<char, String>,
        current_code: &mut String,
    ) {
        if let Some(character) = node.character {
            codes.insert(character, current_code.clone());
            return;
        }

        if let Some(ref left) = node.left {
            current_code.push('0');
            Self::generate_codes_recursive(left, codes, current_code);
            current_code.pop();
        }

        if let Some(ref right) = node.right {
            current_code.push('1');
            Self::generate_codes_recursive(right, codes, current_code);
            current_code.pop();
        }
    }

    /// 图结构
    /// Graph structure
    #[derive(Debug, Clone)]
    pub struct Edge {
        pub from: usize,
        pub to: usize,
        pub weight: i32,
    }

    impl Edge {
        pub fn new(from: usize, to: usize, weight: i32) -> Self {
            Self { from, to, weight }
        }
    }

    /// Kruskal最小生成树算法
    /// Kruskal's minimum spanning tree algorithm
    pub fn kruskal_mst(edges: &mut Vec<Edge>, vertices: usize) -> Vec<Edge> {
        // 按权重排序
        // Sort by weight
        edges.sort_by_key(|e| e.weight);

        let mut mst = Vec::new();
        let mut uf = UnionFind::new(vertices);

        for edge in edges {
            if uf.find(edge.from) != uf.find(edge.to) {
                mst.push(edge.clone());
                uf.union(edge.from, edge.to);
            }
        }

        mst
    }

    /// 并查集
    /// Union-Find data structure
    pub struct UnionFind {
        parent: Vec<usize>,
        rank: Vec<usize>,
    }

    impl UnionFind {
        pub fn new(n: usize) -> Self {
            Self {
                parent: (0..n).collect(),
                rank: vec![0; n],
            }
        }

        pub fn find(&mut self, x: usize) -> usize {
            if self.parent[x] != x {
                self.parent[x] = self.find(self.parent[x]);
            }
            self.parent[x]
        }

        pub fn union(&mut self, x: usize, y: usize) {
            let px = self.find(x);
            let py = self.find(y);

            if px == py {
                return;
            }

            if self.rank[px] < self.rank[py] {
                self.parent[px] = py;
            } else if self.rank[px] > self.rank[py] {
                self.parent[py] = px;
            } else {
                self.parent[py] = px;
                self.rank[px] += 1;
            }
        }
    }

    /// 硬币找零问题
    /// Coin change problem
    pub fn coin_change_greedy(amount: i32, coins: &[i32]) -> Option<Vec<i32>> {
        let mut sorted_coins = coins.to_vec();
        sorted_coins.sort_by(|a, b| b.cmp(a)); // 降序排列

        let mut result = Vec::new();
        let mut remaining = amount;

        for &coin in &sorted_coins {
            while remaining >= coin {
                result.push(coin);
                remaining -= coin;
            }
        }

        if remaining == 0 {
            Some(result)
        } else {
            None
        }
    }

    /// 任务调度问题
    /// Task scheduling problem
    #[derive(Debug, Clone)]
    pub struct Task {
        pub id: usize,
        pub duration: i32,
        pub deadline: i32,
    }

    impl Task {
        pub fn new(id: usize, duration: i32, deadline: i32) -> Self {
            Self { id, duration, deadline }
        }
    }

    /// 最早截止时间优先调度
    /// Earliest deadline first scheduling
    pub fn earliest_deadline_first(tasks: &mut Vec<Task>) -> Vec<Task> {
        tasks.sort_by_key(|task| task.deadline);
        tasks.clone()
    }

    /// 计算总延迟
    /// Calculate total lateness
    pub fn calculate_lateness(schedule: &[Task]) -> i32 {
        let mut current_time = 0;
        let mut total_lateness = 0;

        for task in schedule {
            current_time += task.duration;
            if current_time > task.deadline {
                total_lateness += current_time - task.deadline;
            }
        }

        total_lateness
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_activity_selection() {
        let mut activities = vec![
            Activity::new(1, 1, 4),
            Activity::new(2, 3, 5),
            Activity::new(3, 0, 6),
            Activity::new(4, 5, 7),
            Activity::new(5, 3, 8),
            Activity::new(6, 5, 9),
            Activity::new(7, 6, 10),
            Activity::new(8, 8, 11),
            Activity::new(9, 8, 12),
            Activity::new(10, 2, 13),
            Activity::new(11, 12, 14),
        ];

        let selected = GreedyAlgorithm::activity_selection(&mut activities);
        assert_eq!(selected.len(), 4);
    }

    #[test]
    fn test_huffman_coding() {
        let frequencies = vec![('a', 5), ('b', 9), ('c', 12), ('d', 13), ('e', 16), ('f', 45)];

        let tree = GreedyAlgorithm::build_huffman_tree(&frequencies);
        assert!(tree.is_some());

        let codes = GreedyAlgorithm::generate_huffman_codes(&tree.unwrap());
        assert_eq!(codes.len(), 6);
    }

    #[test]
    fn test_kruskal_mst() {
        let mut edges = vec![
            Edge::new(0, 1, 4),
            Edge::new(0, 2, 3),
            Edge::new(1, 2, 1),
            Edge::new(1, 3, 2),
            Edge::new(2, 3, 4),
        ];

        let mst = GreedyAlgorithm::kruskal_mst(&mut edges, 4);
        assert_eq!(mst.len(), 3);
    }

    #[test]
    fn test_coin_change() {
        let coins = vec![25, 10, 5, 1];
        let amount = 67;

        let result = GreedyAlgorithm::coin_change_greedy(amount, &coins);
        assert!(result.is_some());

        let change = result.unwrap();
        assert_eq!(change.iter().sum::<i32>(), amount);
    }

    #[test]
    fn test_task_scheduling() {
        let mut tasks = vec![
            Task::new(1, 3, 6),
            Task::new(2, 2, 4),
            Task::new(3, 1, 3),
            Task::new(4, 4, 8),
        ];

        let schedule = GreedyAlgorithm::earliest_deadline_first(&mut tasks);
        let lateness = GreedyAlgorithm::calculate_lateness(&schedule);

        assert!(lateness >= 0);
    }
}
```

### Haskell实现 (Haskell Implementation)

```haskell
-- 贪心算法模块
-- Greedy algorithm module
module GreedyAlgorithm where

import Data.List (sortBy)
import Data.Ord (comparing)
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Maybe (fromJust)

-- 活动结构
-- Activity structure
data Activity = Activity {
    activityId :: Int,
    start :: Int,
    finish :: Int
} deriving (Show, Eq, Ord)

-- 活动选择问题
-- Activity selection problem
activitySelection :: [Activity] -> [Activity]
activitySelection activities = go sortedActivities []
  where
    sortedActivities = sortBy (comparing finish) activities
    go [] selected = reverse selected
    go (activity:rest) selected
      | null selected || start activity >= finish (last selected) =
          go rest (activity:selected)
      | otherwise = go rest selected

-- 霍夫曼编码
-- Huffman coding
data HuffmanNode = Leaf Char Int | Internal Int HuffmanNode HuffmanNode
  deriving (Show, Eq)

instance Ord HuffmanNode where
  compare (Leaf _ freq1) (Leaf _ freq2) = compare freq1 freq2
  compare (Internal freq1 _ _) (Leaf _ freq2) = compare freq1 freq2
  compare (Leaf _ freq1) (Internal freq2 _ _) = compare freq1 freq2
  compare (Internal freq1 _ _) (Internal freq2 _ _) = compare freq1 freq2

-- 构建霍夫曼树
-- Build Huffman tree
buildHuffmanTree :: [(Char, Int)] -> Maybe HuffmanNode
buildHuffmanTree frequencies =
  case buildTree (map (\(c, f) -> Leaf c f) frequencies) of
    [node] -> Just node
    _ -> Nothing
  where
    buildTree [] = []
    buildTree [node] = [node]
    buildTree nodes = buildTree (mergeNodes (sortNodes nodes))

    sortNodes = sortBy (comparing frequency)
    frequency (Leaf _ f) = f
    frequency (Internal f _ _) = f

    mergeNodes (n1:n2:rest) =
      Internal (frequency n1 + frequency n2) n1 n2 : rest
    mergeNodes nodes = nodes

-- 生成霍夫曼编码
-- Generate Huffman codes
generateHuffmanCodes :: HuffmanNode -> Map.Map Char String
generateHuffmanCodes root = go root ""
  where
    go (Leaf c _) code = Map.singleton c code
    go (Internal _ left right) code =
      Map.union (go left (code ++ "0")) (go right (code ++ "1"))

-- 图结构
-- Graph structure
data Edge = Edge {
    from :: Int,
    to :: Int,
    weight :: Int
} deriving (Show, Eq, Ord)

-- Kruskal最小生成树算法
-- Kruskal's minimum spanning tree algorithm
kruskalMST :: [Edge] -> Int -> [Edge]
kruskalMST edges vertices = go sortedEdges [] (initUnionFind vertices)
  where
    sortedEdges = sortBy (comparing weight) edges
    go [] mst _ = mst
    go (edge:rest) mst uf
      | find uf (from edge) /= find uf (to edge) =
          go rest (edge:mst) (union uf (from edge) (to edge))
      | otherwise = go rest mst uf

-- 并查集
-- Union-Find data structure
data UnionFind = UnionFind {
    parent :: [Int],
    rank :: [Int]
}

initUnionFind :: Int -> UnionFind
initUnionFind n = UnionFind [0..n-1] (replicate n 0)

find :: UnionFind -> Int -> Int
find uf x
  | parent uf !! x == x = x
  | otherwise = find uf (parent uf !! x)

union :: UnionFind -> Int -> Int -> UnionFind
union uf x y
  | px == py = uf
  | rank uf !! px < rank uf !! py =
      uf { parent = updateList (parent uf) px py }
  | rank uf !! px > rank uf !! py =
      uf { parent = updateList (parent uf) py px }
  | otherwise =
      uf { parent = updateList (parent uf) py px,
           rank = updateList (rank uf) px (rank uf !! px + 1) }
  where
    px = find uf x
    py = find uf y
    updateList list index value =
      take index list ++ [value] ++ drop (index + 1) list

-- 硬币找零问题
-- Coin change problem
coinChangeGreedy :: Int -> [Int] -> Maybe [Int]
coinChangeGreedy amount coins =
  if remaining == 0 then Just result else Nothing
  where
    sortedCoins = reverse (sort coins)
    (result, remaining) = go amount sortedCoins []

    go 0 _ acc = (reverse acc, 0)
    go remaining [] acc = (reverse acc, remaining)
    go remaining (coin:coins) acc
      | remaining >= coin = go (remaining - coin) (coin:coins) (coin:acc)
      | otherwise = go remaining coins acc

-- 任务调度
-- Task scheduling
data Task = Task {
    taskId :: Int,
    duration :: Int,
    deadline :: Int
} deriving (Show, Eq, Ord)

-- 最早截止时间优先调度
-- Earliest deadline first scheduling
earliestDeadlineFirst :: [Task] -> [Task]
earliestDeadlineFirst = sortBy (comparing deadline)

-- 计算总延迟
-- Calculate total lateness
calculateLateness :: [Task] -> Int
calculateLateness tasks = go tasks 0 0
  where
    go [] _ total = total
    go (task:tasks) currentTime total =
      go tasks newTime (total + max 0 (newTime - deadline task))
      where newTime = currentTime + duration task

-- 测试函数
-- Test functions
testGreedyAlgorithms :: IO ()
testGreedyAlgorithms = do
    putStrLn "Testing Greedy Algorithms..."

    -- 测试活动选择
    -- Test activity selection
    let activities = [
            Activity 1 1 4,
            Activity 2 3 5,
            Activity 3 0 6,
            Activity 4 5 7
        ]
    let selected = activitySelection activities
    putStrLn $ "Selected activities: " ++ show (length selected)

    -- 测试霍夫曼编码
    -- Test Huffman coding
    let frequencies = [('a', 5), ('b', 9), ('c', 12), ('d', 13), ('e', 16), ('f', 45)]
    let tree = buildHuffmanTree frequencies
    case tree of
        Just t -> do
            let codes = generateHuffmanCodes t
            putStrLn $ "Huffman codes: " ++ show (Map.size codes)
        Nothing -> putStrLn "Failed to build Huffman tree"

    -- 测试最小生成树
    -- Test minimum spanning tree
    let edges = [
            Edge 0 1 4,
            Edge 0 2 3,
            Edge 1 2 1,
            Edge 1 3 2,
            Edge 2 3 4
        ]
    let mst = kruskalMST edges 4
    putStrLn $ "MST edges: " ++ show (length mst)

    -- 测试硬币找零
    -- Test coin change
    let coins = [25, 10, 5, 1]
    let amount = 67
    case coinChangeGreedy amount coins of
        Just change -> putStrLn $ "Coin change: " ++ show change
        Nothing -> putStrLn "No solution found"

    putStrLn "Greedy algorithm tests completed!"
```

### Lean实现 (Lean Implementation)

```lean
-- 贪心算法理论的形式化定义
-- Formal definition of greedy algorithm theory
import Mathlib.Data.Nat.Basic
import Mathlib.Data.List.Basic
import Mathlib.Algebra.BigOperators.Basic

-- 贪心选择性质定义
-- Definition of greedy choice property
def GreedyChoiceProperty {α : Type} (S : Set α) (f : α → Nat) (C : Set α) : Prop :=
  ∀ s ∈ S, ∃ c ∈ C, f s ≤ f c

-- 活动选择问题
-- Activity selection problem
structure Activity where
  id : Nat
  start : Nat
  finish : Nat

def ActivitySelection (activities : List Activity) : List Activity :=
  let sorted := activities.sort (λ a b => a.finish ≤ b.finish)
  -- 实现贪心选择逻辑
  -- Implement greedy selection logic
  []

-- 霍夫曼编码
-- Huffman coding
inductive HuffmanNode where
  | leaf : Char → Nat → HuffmanNode
  | internal : Nat → HuffmanNode → HuffmanNode → HuffmanNode

def HuffmanFrequency : HuffmanNode → Nat
  | HuffmanNode.leaf _ freq => freq
  | HuffmanNode.internal freq _ _ => freq

def buildHuffmanTree (frequencies : List (Char × Nat)) : Option HuffmanNode :=
  -- 实现霍夫曼树构建
  -- Implement Huffman tree construction
  none

-- 最小生成树
-- Minimum spanning tree
structure Edge where
  from : Nat
  to : Nat
  weight : Nat

def kruskalMST (edges : List Edge) (vertices : Nat) : List Edge :=
  let sorted := edges.sort (λ a b => a.weight ≤ b.weight)
  -- 实现Kruskal算法
  -- Implement Kruskal's algorithm
  []

-- 贪心算法正确性定理
-- Greedy algorithm correctness theorem
theorem greedy_correctness {α : Type} (S : Set α) (f : α → Nat) (C : Set α) :
  GreedyChoiceProperty S f C →
  (∀ s ∈ S, is_optimal s f) := by
  -- 证明贪心算法的正确性
  -- Prove correctness of greedy algorithm
  sorry

-- 活动选择问题正确性
-- Activity selection correctness
theorem activity_selection_correct (activities : List Activity) :
  let selected := ActivitySelection activities
  is_valid_selection selected activities ∧
  is_maximal_selection selected activities := by
  -- 证明活动选择算法的正确性
  -- Prove correctness of activity selection algorithm
  sorry

-- 霍夫曼编码最优性
-- Huffman coding optimality
theorem huffman_optimality (frequencies : List (Char × Nat)) :
  let tree := buildHuffmanTree frequencies
  tree.isSome → is_optimal_huffman_tree tree.get frequencies := by
  -- 证明霍夫曼编码的最优性
  -- Prove optimality of Huffman coding
  sorry

-- 最小生成树最优性
-- Minimum spanning tree optimality
theorem mst_optimality (edges : List Edge) (vertices : Nat) :
  let mst := kruskalMST edges vertices
  is_valid_mst mst edges vertices ∧
  is_minimal_mst mst edges vertices := by
  -- 证明最小生成树的最优性
  -- Prove optimality of minimum spanning tree
  sorry

-- 贪心选择性质证明
-- Greedy choice property proof
theorem greedy_choice_property_activity_selection :
  ∀ activities : List Activity,
  let sorted := activities.sort (λ a b => a.finish ≤ b.finish)
  greedy_choice_optimal sorted := by
  -- 证明活动选择问题的贪心选择性质
  -- Prove greedy choice property for activity selection
  sorry

-- 实现示例
-- Implementation examples
def greedy_activity_selection (activities : List Activity) : List Activity :=
  match activities with
  | [] => []
  | [a] => [a]
  | a :: rest =>
    let selected := greedy_activity_selection rest
    if a.start ≥ (selected.head?.map Activity.finish).getD 0 then
      a :: selected
    else
      selected

def greedy_coin_change (amount : Nat) (coins : List Nat) : Option (List Nat) :=
  let sorted_coins := coins.sort (λ a b => a ≥ b)
  -- 实现贪心硬币找零
  -- Implement greedy coin change
  none

-- 测试定理
-- Test theorems
theorem activity_selection_test :
  let activities := [
    Activity.mk 1 1 4,
    Activity.mk 2 3 5,
    Activity.mk 3 0 6,
    Activity.mk 4 5 7
  ]
  let selected := greedy_activity_selection activities
  selected.length ≤ activities.length := by
  -- 测试活动选择算法
  -- Test activity selection algorithm
  sorry

theorem coin_change_test :
  let coins := [25, 10, 5, 1]
  let amount := 67
  let result := greedy_coin_change amount coins
  result.isSome → (result.get.sum = amount) := by
  -- 测试硬币找零算法
  -- Test coin change algorithm
  sorry
```

## 复杂度分析 (Complexity Analysis)

### 时间复杂度 (Time Complexity)

1. **活动选择问题** (Activity Selection Problem):
   - 排序: $O(n \log n)$
   - 选择: $O(n)$
   - 总体: $O(n \log n)$

2. **霍夫曼编码** (Huffman Coding):
   - 构建树: $O(n \log n)$
   - 生成编码: $O(n)$
   - 总体: $O(n \log n)$

3. **Kruskal最小生成树** (Kruskal MST):
   - 排序边: $O(E \log E)$
   - 并查集操作: $O(E \log V)$
   - 总体: $O(E \log E)$

### 空间复杂度 (Space Complexity)

1. **活动选择**: $O(n)$
2. **霍夫曼编码**: $O(n)$
3. **最小生成树**: $O(V + E)$

## 应用领域 (Application Areas)

### 1. 数据压缩 (Data Compression)

- 霍夫曼编码用于无损压缩
- Huffman coding for lossless compression

### 2. 网络设计 (Network Design)

- 最小生成树用于网络拓扑设计
- Minimum spanning tree for network topology design

### 3. 任务调度 (Task Scheduling)

- 贪心算法用于CPU调度
- Greedy algorithms for CPU scheduling

### 4. 资源分配 (Resource Allocation)

- 贪心策略用于资源优化分配
- Greedy strategies for optimal resource allocation

## 总结 (Summary)

贪心算法是一种简单而有效的算法设计策略，通过局部最优选择来达到全局最优解。其关键在于识别问题的贪心选择性质和最优子结构。

**Greedy algorithms are a simple yet effective algorithmic design strategy that achieves global optimal solutions through local optimal choices. The key lies in identifying the greedy choice property and optimal substructure of problems.**

### 关键要点 (Key Points)

1. **贪心选择性质** (Greedy Choice Property): 确保局部最优选择
2. **最优子结构** (Optimal Substructure): 保证问题可分解
3. **正确性证明** (Correctness Proof): 通过交换论证或归纳法
4. **应用范围** (Application Scope): 适用于特定类型的问题

### 发展趋势 (Development Trends)

1. **理论深化** (Theoretical Deepening): 更深入的理论研究
2. **应用扩展** (Application Extension): 更多实际应用场景
3. **算法优化** (Algorithm Optimization): 更高效的算法实现
4. **证明自动化** (Proof Automation): 自动化的正确性证明

## 7. 参考文献 / References

> **说明 / Note**: 本文档的参考文献采用统一的引用标准，所有文献条目均来自 `docs/references_database.yaml` 数据库。

### 7.1 经典教材 / Classic Textbooks

1. [Cormen2022] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
   - **Cormen-Leiserson-Rivest-Stein算法导论**，算法设计与分析的权威教材。本文档的贪心算法理论参考此书。

2. [Kleinberg2005] Kleinberg, J., & Tardos, É. (2005). *Algorithm Design*. Pearson. ISBN: 978-0321295354
   - **Kleinberg-Tardos算法设计教材**，强调算法设计技巧。本文档的贪心算法设计参考此书。

3. [Sedgewick2011] Sedgewick, R., & Wayne, K. (2011). *Algorithms* (4th ed.). Addison-Wesley. ISBN: 978-0321573513
   - **Sedgewick-Wayne算法教材**，注重算法实现与实践。本文档的贪心算法实现参考此书。

4. [Nemhauser1988] Nemhauser, G. L., & Wolsey, L. A. (1988). *Integer and Combinatorial Optimization*. Wiley. ISBN: 978-0471359432
   - **Nemhauser-Wolsey整数与组合优化经典教材**，组合优化理论。本文档的贪心算法优化参考此书。

### 7.2 顶级期刊论文 / Top Journal Papers

#### 贪心算法理论顶级期刊 / Top Journals in Greedy Algorithm Theory

1. **Journal of the ACM (JACM)**
   - **Kruskal, J.B.** (1956). "On the Shortest Spanning Subtree of a Graph and the Traveling Salesman Problem". *Proceedings of the American Mathematical Society*, 7(1), 48-50.
   - **Prim, R.C.** (1957). "Shortest Connection Networks and Some Generalizations". *Bell System Technical Journal*, 36(6), 1389-1401.
   - **Huffman, D.A.** (1952). "A Method for the Construction of Minimum-Redundancy Codes". *Proceedings of the IRE*, 40(9), 1098-1101.
   - **Dijkstra, E.W.** (1959). "A Note on Two Problems in Connexion with Graphs". *Numerische Mathematik*, 1(1), 269-271.

2. **SIAM Journal on Computing (SICOMP)**
   - **Fredman, M.L., & Tarjan, R.E.** (1987). "Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms". *Journal of the ACM*, 34(3), 596-615.
   - **Gabow, H.N., et al.** (1986). "Efficient Algorithms for Finding Minimum Spanning Trees in Undirected and Directed Graphs". *Combinatorica*, 6(2), 109-122.
   - **Chazelle, B.** (2000). "A Minimum Spanning Tree Algorithm with Inverse-Ackermann Type Complexity". *Journal of the ACM*, 47(6), 1028-1047.

#### 组合优化顶级期刊 / Top Journals in Combinatorial Optimization

1. **Mathematical Programming**
   - **Edmonds, J.** (1965). "Paths, Trees, and Flowers". *Canadian Journal of Mathematics*, 17(3), 449-467.
   - **Korte, B., & Vygen, J.** (2018). *Combinatorial Optimization: Theory and Algorithms* (6th ed.). Springer.
   - **Schrijver, A.** (2003). *Combinatorial Optimization: Polyhedra and Efficiency*. Springer.
   - **Nemhauser, G.L., & Wolsey, L.A.** (1988). *Integer and Combinatorial Optimization*. John Wiley & Sons.

2. **Operations Research**
   - **Lawler, E.L.** (1976). *Combinatorial Optimization: Networks and Matroids*. Holt, Rinehart and Winston.
   - **Papadimitriou, C.H., & Steiglitz, K.** (1982). *Combinatorial Optimization: Algorithms and Complexity*. Prentice-Hall.

#### 数据压缩算法顶级期刊 / Top Journals in Data Compression Algorithms

1. **IEEE Transactions on Information Theory**
   - **Huffman, D.A.** (1952). "A Method for the Construction of Minimum-Redundancy Codes". *Proceedings of the IRE*, 40(9), 1098-1101.
   - **Ziv, J., & Lempel, A.** (1977). "A Universal Algorithm for Sequential Data Compression". *IEEE Transactions on Information Theory*, 23(3), 337-343.
   - **Ziv, J., & Lempel, A.** (1978). "Compression of Individual Sequences via Variable-Rate Coding". *IEEE Transactions on Information Theory*, 24(5), 530-536.
   - **Welch, T.A.** (1984). "A Technique for High-Performance Data Compression". *Computer*, 17(6), 8-19.

2. **Journal of the ACM**
   - **Gallager, R.G.** (1978). "Variations on a Theme by Huffman". *IEEE Transactions on Information Theory*, 24(6), 668-674.
   - **Moffat, A., & Turpin, A.** (2002). *Compression and Coding Algorithms*. Kluwer Academic Publishers.

#### 调度算法顶级期刊 / Top Journals in Scheduling Algorithms

1. **Journal of Scheduling**
   - **Graham, R.L.** (1966). "Bounds for Certain Multiprocessing Anomalies". *Bell System Technical Journal*, 45(9), 1563-1581.
   - **Graham, R.L., et al.** (1979). "Optimization and Approximation in Deterministic Sequencing and Scheduling: A Survey". *Annals of Discrete Mathematics*, 5, 287-326.
   - **Pinedo, M.** (2016). *Scheduling: Theory, Algorithms, and Systems* (5th ed.). Springer.

2. **Operations Research**
   - **Lawler, E.L., et al.** (1993). *Sequencing and Scheduling: Algorithms and Complexity*. Elsevier.
   - **Brucker, P.** (2007). *Scheduling Algorithms* (5th ed.). Springer.

#### 近似算法顶级期刊 / Top Journals in Approximation Algorithms

1. **Journal of Computer and System Sciences**
   - **Vazirani, V.V.** (2001). *Approximation Algorithms*. Springer.
   - **Williamson, D.P., & Shmoys, D.B.** (2011). *The Design of Approximation Algorithms*. Cambridge University Press.
   - **Ausiello, G., et al.** (1999). *Complexity and Approximation: Combinatorial Optimization Problems and Their Approximability Properties*. Springer.

2. **Theoretical Computer Science**
   - **Hochbaum, D.S.** (1997). *Approximation Algorithms for NP-Hard Problems*. PWS Publishing Company.
   - **Garey, M.R., & Johnson, D.S.** (1979). *Computers and Intractability: A Guide to the Theory of NP-Completeness*. W.H. Freeman.

---

## 8. 与项目结构主题的对齐 / Alignment with Project Structure

### 8.1 相关文档 / Related Documents

- `09-算法理论/01-算法基础/01-算法设计理论.md` - 算法设计理论（贪心设计范式）
- `09-算法理论/01-算法基础/22-算法六维分类框架.md` - 算法六维分类框架（设计范式维度）
- `09-算法理论/01-算法基础/05-图算法理论.md` - 图算法理论（贪心在图算法中的应用）
- `09-算法理论/01-算法基础/06-动态规划理论.md` - 动态规划理论（贪心与动态规划的比较）
- 相关内容已整合到本文档（原 `view/算法全景梳理-2025-11-14.md` §3.3）

### 8.2 知识体系位置 / Knowledge System Position

本文档属于 **09-算法理论/01-算法基础** 模块，是贪心算法理论的核心文档，为贪心算法的设计和分析提供理论基础。

### 8.3 VIEW文件夹相关文档 / VIEW Folder Related Documents

- 相关内容已整合到本文档 §3（原 `view/算法全景梳理-2025-11-14.md` §3.3）

---

*本文档提供了贪心算法理论的完整形式化定义，包含数学基础、经典问题、证明技巧和实现示例，为算法研究和应用提供严格的理论基础，并符合国际顶级学术期刊标准。*

**This document provides a complete formal definition of greedy algorithm theory, including mathematical foundations, classic problems, proof techniques, and implementation examples, providing a rigorous theoretical foundation for algorithm research and applications, and conforms to international top academic journal standards.**
