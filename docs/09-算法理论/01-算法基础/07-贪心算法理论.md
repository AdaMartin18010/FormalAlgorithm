---
title: 9.1.7 è´ªå¿ƒç®—æ³•ç†è®º / Greedy Algorithm Theory
version: 1.1
status: maintained
last_updated: 2025-01-12
owner: ç®—æ³•ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 9.1.7 è´ªå¿ƒç®—æ³•ç†è®º / Greedy Algorithm Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€è´ªå¿ƒç®—æ³•çš„å½¢å¼åŒ–å®šä¹‰ã€è´ªå¿ƒé€‰æ‹©æ€§è´¨ä¸æœ€ä¼˜å­ç»“æ„ã€‚
- å»ºç«‹è´ªå¿ƒç®—æ³•åœ¨ç®—æ³•è®¾è®¡ä¸­çš„æ ¸å¿ƒåœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- è´ªå¿ƒç®—æ³•ã€è´ªå¿ƒé€‰æ‹©æ€§è´¨ã€æœ€ä¼˜å­ç»“æ„ã€æ´»åŠ¨é€‰æ‹©ã€æœ€å°ç”Ÿæˆæ ‘ã€æœ€çŸ­è·¯å¾„ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- è´ªå¿ƒç®—æ³•ï¼ˆGreedy Algorithmï¼‰ï¼šæ¯ä¸€æ­¥éƒ½åšå‡ºå½“å‰æœ€ä¼˜é€‰æ‹©çš„ç®—æ³•ã€‚
- è´ªå¿ƒé€‰æ‹©æ€§è´¨ï¼ˆGreedy Choice Propertyï¼‰ï¼šå±€éƒ¨æœ€ä¼˜é€‰æ‹©èƒ½å¯¼è‡´å…¨å±€æœ€ä¼˜ã€‚
- æœ€ä¼˜å­ç»“æ„ï¼ˆOptimal Substructureï¼‰ï¼šé—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å­é—®é¢˜çš„æœ€ä¼˜è§£ã€‚
- è®°å·çº¦å®šï¼š`G` è¡¨ç¤ºå›¾ï¼Œ`w` è¡¨ç¤ºæƒé‡ï¼Œ`d` è¡¨ç¤ºè·ç¦»ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- ç®—æ³•è®¾è®¡ï¼šå‚è§ `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/01-ç®—æ³•è®¾è®¡ç†è®º.md`ã€‚
- åŠ¨æ€è§„åˆ’ï¼šå‚è§ `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/06-åŠ¨æ€è§„åˆ’ç†è®º.md`ã€‚
- å›¾ç®—æ³•ï¼šå‚è§ `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/05-å›¾ç®—æ³•ç†è®º.md`ã€‚

### æ•°å­¦å‰ç½® / Mathematical Prerequisites

å»ºè®®å…·å¤‡ï¼š**åºè®º**ï¼ˆååºã€å…¨åºã€æ‹Ÿé˜µï¼‰ã€**ç»„åˆä¸å›¾è®º**ï¼ˆæœ€å°ç”Ÿæˆæ ‘ã€æœ€çŸ­è·¯å¾„ï¼‰ï¼›ä¸**ä¼˜åŒ–**è¡”æ¥æ—¶éœ€**çº¿æ€§ä»£æ•°**ä¸**å‡¸ä¼˜åŒ–**åŸºç¡€ã€‚è¯¦è§ `01-åŸºç¡€ç†è®º/02-æ•°å­¦åŸºç¡€.md`ã€`01-åŸºç¡€ç†è®º/09-åºè®ºåŸºç¡€.md`ï¼›é¢å‘ ML çš„æ•°å­¦å¯¼è¯»è§ [AIä¸ç®—æ³•æ•°å­¦å‚è€ƒ](../../AIä¸ç®—æ³•æ•°å­¦å‚è€ƒ.md)ã€‚

### å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References

è´ªå¿ƒç®—æ³•å¯ä¸ **MIT 6.006/6.046**ã€**CMU 15-451**ã€**Stanford CS 161**ã€**Berkeley CS 170** ç­‰è¯¾ç¨‹å¯¹æ ‡ã€‚è¯¾ç¨‹ä¸æ¨¡å—æ˜ å°„è§ [å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- è´ªå¿ƒé€‰æ‹©æ€§è´¨
- åº”ç”¨ç¤ºä¾‹

## ç›®å½• (Table of Contents)

- [9.1.7 è´ªå¿ƒç®—æ³•ç†è®º / Greedy Algorithm Theory](#917-è´ªå¿ƒç®—æ³•ç†è®º--greedy-algorithm-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [æ•°å­¦å‰ç½® / Mathematical Prerequisites](#æ•°å­¦å‰ç½®--mathematical-prerequisites)
  - [å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References](#å›½é™…è¯¾ç¨‹å‚è€ƒ--international-course-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [æ¦‚è¿° / Overview](#æ¦‚è¿°--overview)
- [åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [å®šä¹‰ (Definition)](#å®šä¹‰-definition)
  - [æ ¸å¿ƒæ€æƒ³ (Core Ideas)](#æ ¸å¿ƒæ€æƒ³-core-ideas)
  - [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
    - [è§£é‡Šä¸ç›´è§‚ / Explanation and Intuition](#è§£é‡Šä¸ç›´è§‚--explanation-and-intuition)
    - [æ¦‚å¿µå±æ€§è¡¨ / Concept Attribute Table](#æ¦‚å¿µå±æ€§è¡¨--concept-attribute-table)
    - [æ¦‚å¿µå…³ç³» / Concept Relations](#æ¦‚å¿µå…³ç³»--concept-relations)
    - [æ¦‚å¿µä¾èµ–å›¾ / Concept Dependency Graph](#æ¦‚å¿µä¾èµ–å›¾--concept-dependency-graph)
    - [è®ºè¯ä¸è¯æ˜è¡”æ¥ / Argumentation and Proof Link](#è®ºè¯ä¸è¯æ˜è¡”æ¥--argumentation-and-proof-link)
    - [æ€ç»´å¯¼å›¾ï¼šæœ¬ç« æ¦‚å¿µç»“æ„ / Mind Map](#æ€ç»´å¯¼å›¾æœ¬ç« æ¦‚å¿µç»“æ„--mind-map)
    - [å¤šç»´çŸ©é˜µï¼šè´ªå¿ƒé—®é¢˜ä¸èŒƒå¼å¯¹æ¯” / Multi-Dimensional Comparison](#å¤šç»´çŸ©é˜µè´ªå¿ƒé—®é¢˜ä¸èŒƒå¼å¯¹æ¯”--multi-dimensional-comparison)
    - [å†³ç­–æ ‘ï¼šè´ªå¿ƒ vs DP / Decision Tree](#å†³ç­–æ ‘è´ªå¿ƒ-vs-dp--decision-tree)
    - [å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘ / Axiom-Theorem-Proof Tree](#å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘--axiom-theorem-proof-tree)
    - [åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘ / Application Decision Modeling Tree](#åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘--application-decision-modeling-tree)
- [è´ªå¿ƒé€‰æ‹©æ€§è´¨ (Greedy Choice Property)](#è´ªå¿ƒé€‰æ‹©æ€§è´¨-greedy-choice-property)
  - [æ•°å­¦å®šä¹‰ (Mathematical Definition)](#æ•°å­¦å®šä¹‰-mathematical-definition)
  - [è´ªå¿ƒç­–ç•¥è¯æ˜ (Greedy Strategy Proof)](#è´ªå¿ƒç­–ç•¥è¯æ˜-greedy-strategy-proof)
    - [1.1.1 æ‹Ÿé˜µç†è®ºåŸºç¡€ / Matroid Foundation](#111-æ‹Ÿé˜µç†è®ºåŸºç¡€--matroid-foundation)
    - [1.1.2 è´ªå¿ƒç®—æ³•åœ¨æ‹Ÿé˜µä¸Šçš„æ­£ç¡®æ€§ / Greedy Algorithm Correctness on Matroids](#112-è´ªå¿ƒç®—æ³•åœ¨æ‹Ÿé˜µä¸Šçš„æ­£ç¡®æ€§--greedy-algorithm-correctness-on-matroids)
    - [1.1.3 æ´»åŠ¨é€‰æ‹©é—®é¢˜çš„ä¸¥æ ¼è¯æ˜ / Rigorous Proof for Activity Selection](#113-æ´»åŠ¨é€‰æ‹©é—®é¢˜çš„ä¸¥æ ¼è¯æ˜--rigorous-proof-for-activity-selection)
- [ç»å…¸é—®é¢˜ (Classic Problems)](#ç»å…¸é—®é¢˜-classic-problems)
  - [1. æ´»åŠ¨é€‰æ‹©é—®é¢˜ (Activity Selection Problem)](#1-æ´»åŠ¨é€‰æ‹©é—®é¢˜-activity-selection-problem)
  - [2. éœå¤«æ›¼ç¼–ç  (Huffman Coding)](#2-éœå¤«æ›¼ç¼–ç -huffman-coding)
  - [3. æœ€å°ç”Ÿæˆæ ‘ (Minimum Spanning Tree)](#3-æœ€å°ç”Ÿæˆæ ‘-minimum-spanning-tree)
- [è¯æ˜æŠ€å·§ (Proof Techniques)](#è¯æ˜æŠ€å·§-proof-techniques)
  - [1. äº¤æ¢è®ºè¯ (Exchange Argument)](#1-äº¤æ¢è®ºè¯-exchange-argument)
  - [2. å½’çº³æ³• (Induction)](#2-å½’çº³æ³•-induction)
  - [3. å¯¹å¶æ€§ (Duality)](#3-å¯¹å¶æ€§-duality)
- [å®ç°ç¤ºä¾‹ (Implementation Examples)](#å®ç°ç¤ºä¾‹-implementation-examples)
  - [Rustå®ç° (Rust Implementation)](#rustå®ç°-rust-implementation)
  - [Haskellå®ç° (Haskell Implementation)](#haskellå®ç°-haskell-implementation)
  - [Leanå®ç° (Lean Implementation)](#leanå®ç°-lean-implementation)
- [å¤æ‚åº¦åˆ†æ (Complexity Analysis)](#å¤æ‚åº¦åˆ†æ-complexity-analysis)
  - [æ—¶é—´å¤æ‚åº¦ (Time Complexity)](#æ—¶é—´å¤æ‚åº¦-time-complexity)
  - [ç©ºé—´å¤æ‚åº¦ (Space Complexity)](#ç©ºé—´å¤æ‚åº¦-space-complexity)
- [åº”ç”¨é¢†åŸŸ (Application Areas)](#åº”ç”¨é¢†åŸŸ-application-areas)
  - [1. æ•°æ®å‹ç¼© (Data Compression)](#1-æ•°æ®å‹ç¼©-data-compression)
  - [2. ç½‘ç»œè®¾è®¡ (Network Design)](#2-ç½‘ç»œè®¾è®¡-network-design)
  - [3. ä»»åŠ¡è°ƒåº¦ (Task Scheduling)](#3-ä»»åŠ¡è°ƒåº¦-task-scheduling)
  - [4. èµ„æºåˆ†é… (Resource Allocation)](#4-èµ„æºåˆ†é…-resource-allocation)
- [æ€»ç»“ (Summary)](#æ€»ç»“-summary)
  - [å…³é”®è¦ç‚¹ (Key Points)](#å…³é”®è¦ç‚¹-key-points)
  - [å‘å±•è¶‹åŠ¿ (Development Trends)](#å‘å±•è¶‹åŠ¿-development-trends)
- [7. å‚è€ƒæ–‡çŒ® / References](#7-å‚è€ƒæ–‡çŒ®--references)
  - [7.1 ç»å…¸æ•™æ / Classic Textbooks](#71-ç»å…¸æ•™æ--classic-textbooks)
  - [7.2 Wikiæ¦‚å¿µå‚è€ƒ / Wiki Concept References](#72-wikiæ¦‚å¿µå‚è€ƒ--wiki-concept-references)
  - [7.3 å¤§å­¦è¯¾ç¨‹å‚è€ƒ / University Course References](#73-å¤§å­¦è¯¾ç¨‹å‚è€ƒ--university-course-references)
  - [7.4 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers](#74-é¡¶çº§æœŸåˆŠè®ºæ–‡--top-journal-papers)
    - [è´ªå¿ƒç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Greedy Algorithm Theory](#è´ªå¿ƒç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-greedy-algorithm-theory)
    - [ç»„åˆä¼˜åŒ–é¡¶çº§æœŸåˆŠ / Top Journals in Combinatorial Optimization](#ç»„åˆä¼˜åŒ–é¡¶çº§æœŸåˆŠ--top-journals-in-combinatorial-optimization)
    - [æ•°æ®å‹ç¼©ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Data Compression Algorithms](#æ•°æ®å‹ç¼©ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-data-compression-algorithms)
    - [è°ƒåº¦ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Scheduling Algorithms](#è°ƒåº¦ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-scheduling-algorithms)
    - [è¿‘ä¼¼ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Approximation Algorithms](#è¿‘ä¼¼ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-approximation-algorithms)
- [8. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#8-ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
  - [8.1 ç›¸å…³æ–‡æ¡£ / Related Documents](#81-ç›¸å…³æ–‡æ¡£--related-documents)
  - [8.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#82-çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
  - [8.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#83-viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)

## æ¦‚è¿° / Overview

è´ªå¿ƒç®—æ³•æ˜¯ä¸€ç§åœ¨æ¯ä¸€æ­¥é€‰æ‹©ä¸­éƒ½é‡‡å–å½“å‰çŠ¶æ€ä¸‹æœ€å¥½æˆ–æœ€ä¼˜çš„é€‰æ‹©ï¼Œä»è€Œå¸Œæœ›å¯¼è‡´ç»“æœæ˜¯æœ€å¥½æˆ–æœ€ä¼˜çš„ç®—æ³•ç­–ç•¥ã€‚æ ¹æ®[Cormen 2022]çš„å®šä¹‰ï¼Œè´ªå¿ƒç®—æ³•é€šè¿‡å±€éƒ¨æœ€ä¼˜é€‰æ‹©æ¥æ„å»ºå…¨å±€æœ€ä¼˜è§£ã€‚æ ¹æ®[Kleinberg 2005]çš„ç ”ç©¶ï¼Œè´ªå¿ƒç®—æ³•çš„æœ‰æ•ˆæ€§ä¾èµ–äºè´ªå¿ƒé€‰æ‹©æ€§è´¨å’Œæœ€ä¼˜å­ç»“æ„ã€‚æœ¬æ–‡æ¡£æ¶µç›–è´ªå¿ƒç®—æ³•çš„ç†è®ºåŸºç¡€ã€ç»å…¸é—®é¢˜ã€è¯æ˜æŠ€å·§å’Œåº”ç”¨é¢†åŸŸã€‚

A greedy algorithm is an algorithmic strategy that makes the locally optimal choice at each step, hoping that these choices will lead to a globally optimal solution. According to [Cormen 2022], greedy algorithms construct a globally optimal solution by making locally optimal choices. According to [Kleinberg 2005], the effectiveness of greedy algorithms depends on the greedy choice property and optimal substructure. This document covers the theoretical foundations, classic problems, proof techniques, and application areas of greedy algorithms.

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**

- [Cormen 2022]: Cormen, T. H., et al. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
- [Kleinberg 2005]: Kleinberg, J., & Tardos, Ã‰. (2005). *Algorithm Design*. Pearson. ISBN: 978-0321295354
- [Edmonds 1965]: Edmonds, J. (1965). "Paths, Trees, and Flowers". *Canadian Journal of Mathematics*, 17(3), 449-467. DOI: 10.4153/CJM-1965-045-4

**Wikiæ¦‚å¿µå¯¹é½ / Wiki Concept Alignment:**

- [Greedy Algorithm](https://en.wikipedia.org/wiki/Greedy_algorithm) - è´ªå¿ƒç®—æ³•çš„æ ‡å‡†å®šä¹‰
- [Greedy Choice Property](https://en.wikipedia.org/wiki/Greedy_algorithm#Greedy_choice_property) - è´ªå¿ƒé€‰æ‹©æ€§è´¨
- [Matroid](https://en.wikipedia.org/wiki/Matroid) - æ‹Ÿé˜µç†è®º
- [Huffman Coding](https://en.wikipedia.org/wiki/Huffman_coding) - éœå¤«æ›¼ç¼–ç 

**å¤§å­¦è¯¾ç¨‹å¯¹æ ‡ / University Course Alignment:**

- MIT 6.006: Introduction to Algorithms - è´ªå¿ƒç®—æ³•åŸºç¡€
- Stanford CS161: Design and Analysis of Algorithms - è´ªå¿ƒç®—æ³•è®¾è®¡ä¸è¯æ˜
- CMU 15-451: Algorithm Design and Analysis - é«˜çº§è´ªå¿ƒç®—æ³•æŠ€æœ¯

## åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### å®šä¹‰ (Definition)

**å®šä¹‰ 1.1** (è´ªå¿ƒç®—æ³•) [Cormen 2022, Kleinberg 2005, Wikipedia Greedy Algorithm]
è´ªå¿ƒç®—æ³•æ˜¯ä¸€ç§åœ¨æ¯ä¸€æ­¥é€‰æ‹©ä¸­éƒ½é‡‡å–å½“å‰çŠ¶æ€ä¸‹æœ€å¥½æˆ–æœ€ä¼˜çš„é€‰æ‹©ï¼Œä»è€Œå¸Œæœ›å¯¼è‡´ç»“æœæ˜¯æœ€å¥½æˆ–æœ€ä¼˜çš„ç®—æ³•ç­–ç•¥ã€‚æ ¹æ®[Cormen 2022]çš„å®šä¹‰ï¼Œè´ªå¿ƒç®—æ³•é€šè¿‡å±€éƒ¨æœ€ä¼˜é€‰æ‹©æ¥æ„å»ºå…¨å±€æœ€ä¼˜è§£ã€‚

**A greedy algorithm is an algorithmic strategy that makes the locally optimal choice at each step, hoping that these choices will lead to a globally optimal solution. According to [Cormen 2022], greedy algorithms construct a globally optimal solution by making locally optimal choices.**

**Wikiæ¦‚å¿µå¯¹é½ / Wiki Concept Alignment:**

| é¡¹ç›®æ¦‚å¿µ | Wikiæ¡ç›® | æ ‡å‡†å®šä¹‰ | å¯¹é½çŠ¶æ€ |
|---------|---------|---------|---------|
| è´ªå¿ƒç®—æ³• | [Greedy Algorithm](https://en.wikipedia.org/wiki/Greedy_algorithm) | æ¯æ­¥é€‰æ‹©å±€éƒ¨æœ€ä¼˜çš„ç®—æ³• | âœ… å·²å¯¹é½ |
| è´ªå¿ƒé€‰æ‹©æ€§è´¨ | [Greedy Choice Property](https://en.wikipedia.org/wiki/Greedy_algorithm#Greedy_choice_property) | å±€éƒ¨æœ€ä¼˜å¯¼è‡´å…¨å±€æœ€ä¼˜ | âœ… å·²å¯¹é½ |
| æœ€ä¼˜å­ç»“æ„ | [Optimal Substructure](https://en.wikipedia.org/wiki/Optimal_substructure) | æœ€ä¼˜è§£åŒ…å«å­é—®é¢˜æœ€ä¼˜è§£ | âœ… å·²å¯¹é½ |
| æ‹Ÿé˜µ | [Matroid](https://en.wikipedia.org/wiki/Matroid) | è´ªå¿ƒç®—æ³•çš„ç†è®ºåŸºç¡€ | âœ… å·²å¯¹é½ |

**è´ªå¿ƒç®—æ³•çŸ¥è¯†ä½“ç³» / Greedy Algorithm Knowledge System:**

```mermaid
mindmap
  root((è´ªå¿ƒç®—æ³•<br/>Greedy Algorithm))
    æ ¸å¿ƒæ¦‚å¿µ
      è´ªå¿ƒé€‰æ‹©æ€§è´¨
        å±€éƒ¨æœ€ä¼˜
        å…¨å±€æœ€ä¼˜
        è¯æ˜æ–¹æ³•
      æœ€ä¼˜å­ç»“æ„
        é—®é¢˜åˆ†è§£
        æœ€ä¼˜è§£æ€§è´¨
        è¯æ˜æŠ€å·§
      æ‹Ÿé˜µç†è®º
        ç‹¬ç«‹é›†
        åŸº
        ç§©å‡½æ•°
    ç»å…¸é—®é¢˜
      æ´»åŠ¨é€‰æ‹©
        åŒºé—´è°ƒåº¦
        èµ„æºåˆ†é…
        è¯æ˜æ–¹æ³•
      éœå¤«æ›¼ç¼–ç 
        å‰ç¼€ç 
        æœ€ä¼˜ç¼–ç 
        æ ‘æ„å»º
      æœ€å°ç”Ÿæˆæ ‘
        Kruskalç®—æ³•
        Primç®—æ³•
        è¯æ˜æ–¹æ³•
      æœ€çŸ­è·¯å¾„
        Dijkstraç®—æ³•
        å•æºæœ€çŸ­è·¯å¾„
        è¯æ˜æ–¹æ³•
    è¯æ˜æŠ€å·§
      äº¤æ¢è®ºè¯
        æ›¿æ¢ç­–ç•¥
        æœ€ä¼˜æ€§è¯æ˜
      å½’çº³æ³•
        åŸºç¡€æƒ…å†µ
        å½’çº³æ­¥éª¤
      å¯¹å¶æ€§
        çº¿æ€§è§„åˆ’
        å¯¹å¶é—®é¢˜
    åº”ç”¨é¢†åŸŸ
      æ•°æ®å‹ç¼©
        éœå¤«æ›¼ç¼–ç 
        LZç¼–ç 
      ç½‘ç»œè®¾è®¡
        æœ€å°ç”Ÿæˆæ ‘
        æœ€çŸ­è·¯å¾„
      ä»»åŠ¡è°ƒåº¦
        æ´»åŠ¨é€‰æ‹©
        ä½œä¸šè°ƒåº¦
      èµ„æºåˆ†é…
        èƒŒåŒ…é—®é¢˜
        åŒºé—´è°ƒåº¦
```

**è´ªå¿ƒç®—æ³•ä¸å…¶ä»–ç®—æ³•èŒƒå¼å¯¹æ¯” / Greedy Algorithm vs Other Algorithm Paradigms:**

| ç®—æ³•èŒƒå¼ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | éš¾åº¦ | å…¸å‹ç®—æ³• | å‚è€ƒæ–‡çŒ® |
|---------|-----------|-----------|---------|------|---------|---------|
| è´ªå¿ƒç®—æ³• | $O(n \log n)$ | $O(1)$ | å±€éƒ¨æœ€ä¼˜ | ä½ | æœ€å°ç”Ÿæˆæ ‘ | [Cormen 2022] |
| åŠ¨æ€è§„åˆ’ | $O(n^2)$ | $O(n)$ | é‡å å­é—®é¢˜ | é«˜ | æœ€é•¿å…¬å…±å­åºåˆ— | [Cormen 2022] |
| åˆ†æ²»æ³• | $O(n \log n)$ | $O(\log n)$ | å­é—®é¢˜ç‹¬ç«‹ | ä¸­ | å½’å¹¶æ’åº | [Cormen 2022] |
| å›æº¯ç®—æ³• | $O(2^n)$ | $O(n)$ | çº¦æŸæ»¡è¶³ | ä¸­ | Nçš‡åé—®é¢˜ | [Cormen 2022] |

### æ ¸å¿ƒæ€æƒ³ (Core Ideas)

1. **å±€éƒ¨æœ€ä¼˜é€‰æ‹©** (Local Optimal Choice)
   - åœ¨æ¯ä¸€æ­¥é€‰æ‹©å½“å‰æœ€ä¼˜è§£
   - Choose the current optimal solution at each step

2. **è´ªå¿ƒé€‰æ‹©æ€§è´¨** (Greedy Choice Property)
   - å…¨å±€æœ€ä¼˜è§£å¯ä»¥é€šè¿‡å±€éƒ¨æœ€ä¼˜é€‰æ‹©å¾—åˆ°
   - Global optimal solution can be obtained through local optimal choices

3. **æœ€ä¼˜å­ç»“æ„** (Optimal Substructure)
   - é—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å…¶å­é—®é¢˜çš„æœ€ä¼˜è§£
   - The optimal solution contains optimal solutions to its subproblems

### å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

#### è§£é‡Šä¸ç›´è§‚ / Explanation and Intuition

è´ªå¿ƒç®—æ³•æ¯æ­¥åšå±€éƒ¨æœ€ä¼˜é€‰æ‹©ï¼Œåœ¨è´ªå¿ƒé€‰æ‹©æ€§è´¨ä¸æœ€ä¼˜å­ç»“æ„æˆç«‹æ—¶å¾—åˆ°å…¨å±€æœ€ä¼˜ã€‚äº¤æ¢è®ºè¯ä¸å½’çº³æ˜¯ä¸»è¦è¯æ˜å·¥å…·ï¼›ä¸ DPã€åˆ†æ²»å½¢æˆèŒƒå¼å¯¹æ¯”ã€‚æ‹Ÿé˜µä¸Šçš„è´ªå¿ƒæœ‰ç»Ÿä¸€æ­£ç¡®æ€§å®šç†ã€‚

#### æ¦‚å¿µå±æ€§è¡¨ / Concept Attribute Table

| å±æ€§å | ç±»å‹/èŒƒå›´ | å«ä¹‰ | å¤‡æ³¨ |
|--------|-----------|------|------|
| è´ªå¿ƒç®—æ³• | ç®—æ³•èŒƒå¼ | å®šä¹‰ 1.1 | æ¯æ­¥å±€éƒ¨æœ€ä¼˜ |
| è´ªå¿ƒé€‰æ‹©æ€§è´¨ | æ€§è´¨ | Â§åŸºæœ¬æ¦‚å¿µ | å­˜åœ¨æŸå±€éƒ¨æœ€ä¼˜åœ¨å…¨å±€æœ€ä¼˜ä¸­ |
| æœ€ä¼˜å­ç»“æ„ | æ€§è´¨ | Â§åŸºæœ¬æ¦‚å¿µ | ä¸ DP å…±ç”¨ |
| æ‹Ÿé˜µ | ç»“æ„ | å®šä¹‰ 1.1.1 | é—ä¼ +äº¤æ¢ â†’ è´ªå¿ƒæ­£ç¡® |
| æ´»åŠ¨é€‰æ‹©/éœå¤«æ›¼/MST/Dijkstra | ç»å…¸é—®é¢˜ | è§æœ¬æ–‡ | è´ªå¿ƒé€‰æ‹©ä¸è¯æ˜ |

#### æ¦‚å¿µå…³ç³» / Concept Relations

| æºæ¦‚å¿µ | ç›®æ ‡æ¦‚å¿µ | å…³ç³»ç±»å‹ | è¯´æ˜ |
|--------|----------|----------|------|
| è´ªå¿ƒç†è®º | 09-01-01 ç®—æ³•è®¾è®¡ | depends_on | é€‰æ‹©ä¸åº |
| è´ªå¿ƒç†è®º | 04-å¤æ‚åº¦ | depends_on | æ’åº+å•æ¬¡é€‰æ‹©ä»£ä»· |
| è´ªå¿ƒç†è®º | 09-01-06 DPã€09-01-08 åˆ†æ²» | èŒƒå¼å¯¹æ¯” | å±€éƒ¨ vs å…¨å±€ã€é‡å  vs ç‹¬ç«‹ |
| è´ªå¿ƒç†è®º | 09-03-04 å¯å‘å¼ | applies_to | å¯å‘å¼ä¸ºå¹¿ä¹‰è´ªå¿ƒ |

#### æ¦‚å¿µä¾èµ–å›¾ / Concept Dependency Graph

```mermaid
graph LR
  G[è´ªå¿ƒå®šä¹‰]
  GP[è´ªå¿ƒé€‰æ‹©æ€§è´¨]
  OS[æœ€ä¼˜å­ç»“æ„]
  M[æ‹Ÿé˜µå¯é€‰]
  Proof[äº¤æ¢è®ºè¯/å½’çº³]
  G --> GP
  G --> OS
  GP --> Proof
  OS --> Proof
  M --> Proof
```

#### è®ºè¯ä¸è¯æ˜è¡”æ¥ / Argumentation and Proof Link

å®šä¹‰ 1.1 ä¸è´ªå¿ƒé€‰æ‹©æ€§è´¨ã€æœ€ä¼˜å­ç»“æ„å½¢å¼åŒ–ï¼›äº¤æ¢è®ºè¯ã€å½’çº³ã€å¯¹å¶æ€§è§è¯æ˜æŠ€å·§ï¼›æ‹Ÿé˜µä¸è´ªå¿ƒæ­£ç¡®æ€§è§å®šç† 1.2 åŠæ–‡çŒ®ã€‚

#### æ€ç»´å¯¼å›¾ï¼šæœ¬ç« æ¦‚å¿µç»“æ„ / Mind Map

```mermaid
graph TD
  Greedy[è´ªå¿ƒç†è®º]
  Greedy --> Core[æ ¸å¿ƒæ¦‚å¿µ]
  Greedy --> Classic[ç»å…¸é—®é¢˜]
  Greedy --> Proof[è¯æ˜æŠ€å·§]
  Classic --> Act[æ´»åŠ¨é€‰æ‹©]
  Classic --> Huff[éœå¤«æ›¼]
  Classic --> MST[MST]
  Classic --> SP[æœ€çŸ­è·¯å¾„]
```

#### å¤šç»´çŸ©é˜µï¼šè´ªå¿ƒé—®é¢˜ä¸èŒƒå¼å¯¹æ¯” / Multi-Dimensional Comparison

| é—®é¢˜/èŒƒå¼ | è´ªå¿ƒé€‰æ‹© | è¯æ˜æ–¹æ³• | å¤æ‚åº¦ |
|-----------|----------|----------|--------|
| æ´»åŠ¨é€‰æ‹© | æœ€æ—©ç»“æŸ | äº¤æ¢è®ºè¯ | $O(n\log n)$ |
| éœå¤«æ›¼ | æœ€å°é¢‘ç‡ | å½’çº³ | $O(n\log n)$ |
| MST (Kruskal/Prim) | æœ€å°è¾¹/æœ€è¿‘ç‚¹ | å‰²æ€§è´¨ | $O(E\log V)$ |
| Dijkstra | å½“å‰æœ€è¿‘ | æ¾å¼› | $O((V+E)\log V)$ |
| DP | â€” | æœ€ä¼˜å­ç»“æ„ | çŠ¶æ€Ã—è½¬ç§» |
| åˆ†æ²» | â€” | ä¸»å®šç† | $T(n)=aT(n/b)+f(n)$ |

#### å†³ç­–æ ‘ï¼šè´ªå¿ƒ vs DP / Decision Tree

```mermaid
flowchart TD
  S([é—®é¢˜])
  S --> GreedyProp{è´ªå¿ƒé€‰æ‹©æ€§è´¨?}
  GreedyProp -->|æ˜¯| OS{æœ€ä¼˜å­ç»“æ„?}
  GreedyProp -->|å¦| DP[åŠ¨æ€è§„åˆ’]
  OS -->|æ˜¯| G[è´ªå¿ƒç®—æ³•]
  OS -->|å¦| DP
  G --> Method[äº¤æ¢è®ºè¯/å½’çº³]
```

#### å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘ / Axiom-Theorem-Proof Tree

```mermaid
graph LR
  GP[è´ªå¿ƒé€‰æ‹©æ€§è´¨]
  OS[æœ€ä¼˜å­ç»“æ„]
  T[å±€éƒ¨æœ€ä¼˜å³å…¨å±€æœ€ä¼˜]
  Ex[äº¤æ¢è®ºè¯/å½’çº³]
  GP --> T
  OS --> T
  Ex --> T
```

#### åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘ / Application Decision Modeling Tree

```mermaid
flowchart TD
  Need([éœ€æ±‚])
  Need --> Schedule[æ´»åŠ¨è°ƒåº¦]
  Need --> Code[ç¼–ç ]
  Need --> MST[æœ€å°ç”Ÿæˆæ ‘]
  Need --> SP[æœ€çŸ­è·¯å¾„]
  Schedule --> Act[æ´»åŠ¨é€‰æ‹©]
  Code --> Huff[éœå¤«æ›¼]
  MST --> Kruskal[Kruskal/Prim]
  SP --> Dij[Dijkstra]
```

## è´ªå¿ƒé€‰æ‹©æ€§è´¨ (Greedy Choice Property)

### æ•°å­¦å®šä¹‰ (Mathematical Definition)

è®¾ $S$ ä¸ºé—®é¢˜çš„è§£ç©ºé—´ï¼Œ$C$ ä¸ºå€™é€‰è§£é›†åˆï¼Œè´ªå¿ƒé€‰æ‹©æ€§è´¨å®šä¹‰ä¸ºï¼š

**Let $S$ be the solution space and $C$ be the candidate solution set, the greedy choice property is defined as:**

$$\forall s \in S, \exists c \in C: f(s) \leq f(c)$$

å…¶ä¸­ $f$ æ˜¯ç›®æ ‡å‡½æ•°ã€‚

**Where $f$ is the objective function.**

### è´ªå¿ƒç­–ç•¥è¯æ˜ (Greedy Strategy Proof)

**å®šç† 1.1** (è´ªå¿ƒç®—æ³•æ­£ç¡®æ€§å®šç†) å¦‚æœé—®é¢˜æ»¡è¶³è´ªå¿ƒé€‰æ‹©æ€§è´¨å’Œæœ€ä¼˜å­ç»“æ„ï¼Œåˆ™è´ªå¿ƒç®—æ³•å¯ä»¥å¾—åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚
**Theorem 1.1** (Greedy Algorithm Correctness Theorem) If a problem satisfies the greedy choice property and optimal substructure, then the greedy algorithm can obtain the global optimal solution.

**ä¸¥æ ¼æ•°å­¦æ¨å¯¼ / Rigorous Mathematical Derivation:**

#### 1.1.1 æ‹Ÿé˜µç†è®ºåŸºç¡€ / Matroid Foundation

**å®šä¹‰ 1.1.1** (æ‹Ÿé˜µ) æ‹Ÿé˜µ $M = (E, \mathcal{I})$ ç”±æœ‰é™é›†åˆ $E$ å’Œç‹¬ç«‹é›†æ— $\mathcal{I} \subseteq 2^E$ ç»„æˆï¼Œæ»¡è¶³ï¼š
**Definition 1.1.1** (Matroid) A matroid $M = (E, \mathcal{I})$ consists of a finite set $E$ and a family of independent sets $\mathcal{I} \subseteq 2^E$ satisfying:

1. **é—ä¼ æ€§è´¨ / Hereditary Property**: å¦‚æœ $A \in \mathcal{I}$ ä¸” $B \subseteq A$ï¼Œåˆ™ $B \in \mathcal{I}$
   If $A \in \mathcal{I}$ and $B \subseteq A$, then $B \in \mathcal{I}$

2. **äº¤æ¢æ€§è´¨ / Exchange Property**: å¦‚æœ $A, B \in \mathcal{I}$ ä¸” $|B| > |A|$ï¼Œåˆ™å­˜åœ¨ $x \in B \setminus A$ ä½¿å¾— $A \cup \{x\} \in \mathcal{I}$
   If $A, B \in \mathcal{I}$ and $|B| > |A|$, then there exists $x \in B \setminus A$ such that $A \cup \{x\} \in \mathcal{I}$

**å®šä¹‰ 1.1.2** (åŸº) æ‹Ÿé˜µçš„åŸºæ˜¯æå¤§ç‹¬ç«‹é›†ï¼Œæ‰€æœ‰åŸºå…·æœ‰ç›¸åŒåŸºæ•°ã€‚
**Definition 1.1.2** (Basis) A basis of a matroid is a maximal independent set, and all bases have the same cardinality.

#### 1.1.2 è´ªå¿ƒç®—æ³•åœ¨æ‹Ÿé˜µä¸Šçš„æ­£ç¡®æ€§ / Greedy Algorithm Correctness on Matroids

**å®šç† 1.2** (æ‹Ÿé˜µè´ªå¿ƒç®—æ³•æ­£ç¡®æ€§) è®¾ $M = (E, \mathcal{I})$ ä¸ºæ‹Ÿé˜µï¼Œ$w: E \to \mathbb{R}^+$ ä¸ºæƒé‡å‡½æ•°ã€‚è´ªå¿ƒç®—æ³•ï¼ˆæŒ‰æƒé‡é™åºé€‰æ‹©å…ƒç´ ï¼Œä»…å½“ä¿æŒç‹¬ç«‹æ€§æ—¶æ·»åŠ ï¼‰äº§ç”Ÿæœ€å¤§æƒé‡åŸºã€‚
**Theorem 1.2** (Matroid Greedy Algorithm Correctness) Let $M = (E, \mathcal{I})$ be a matroid and $w: E \to \mathbb{R}^+$ be a weight function. The greedy algorithm (selecting elements in decreasing order of weight, adding only when maintaining independence) produces a maximum-weight basis.

**è¯æ˜ / Proof:**

**ç¬¬ä¸€éƒ¨åˆ†ï¼šè¾“å‡ºæ˜¯åŸº / Part 1: Output is a Basis**

è®¾ $A$ ä¸ºè´ªå¿ƒç®—æ³•äº§ç”Ÿçš„é›†åˆã€‚
Let $A$ be the set produced by the greedy algorithm.

- æ ¹æ®æ„é€ ï¼Œ$A$ æ˜¯ç‹¬ç«‹é›†ï¼ˆå…ƒç´ ä»…åœ¨ä¿æŒç‹¬ç«‹æ€§æ—¶æ·»åŠ ï¼‰
- By construction, $A$ is an independent set (elements added only when maintaining independence)

å‡è®¾ $A$ ä¸æ˜¯åŸºï¼Œå³å­˜åœ¨åŸº $B$ ä½¿å¾— $|B| > |A|$ã€‚
Assume $A$ is not a basis, i.e., there exists a basis $B$ such that $|B| > |A|$.

æ ¹æ®äº¤æ¢æ€§è´¨ï¼Œå­˜åœ¨ $x \in B \setminus A$ ä½¿å¾— $A \cup \{x\} \in \mathcal{I}$ã€‚
By the exchange property, there exists $x \in B \setminus A$ such that $A \cup \{x\} \in \mathcal{I}$.

ä½†è´ªå¿ƒç®—æ³•æœªæ·»åŠ  $x$ï¼Œè¿™æ„å‘³ç€å­˜åœ¨ $y \in A$ ä½¿å¾— $w(y) \geq w(x)$ ä¸” $A \setminus \{y\} \cup \{x\} \notin \mathcal{I}$ã€‚
But the greedy algorithm did not add $x$, meaning there exists $y \in A$ such that $w(y) \geq w(x)$ and $A \setminus \{y\} \cup \{x\} \notin \mathcal{I}$.

è¿™ä¸é—ä¼ æ€§è´¨çŸ›ç›¾ï¼ˆå› ä¸º $A \cup \{x\} \in \mathcal{I}$ ä¸” $A \setminus \{y\} \subseteq A \cup \{x\}$ï¼‰ã€‚
This contradicts the hereditary property (since $A \cup \{x\} \in \mathcal{I}$ and $A \setminus \{y\} \subseteq A \cup \{x\}$).

å› æ­¤ $A$ æ˜¯åŸºã€‚
Therefore $A$ is a basis.

**ç¬¬äºŒéƒ¨åˆ†ï¼šè´ªå¿ƒè¾“å‡ºæ˜¯æœ€å¤§æƒé‡ / Part 2: Greedy Output is Maximum Weight**

è®¾ $A = \{a_1, a_2, \ldots, a_k\}$ ä¸ºè´ªå¿ƒç®—æ³•äº§ç”Ÿçš„åŸºï¼ˆæŒ‰æƒé‡é™åºï¼‰ï¼Œ$B = \{b_1, b_2, \ldots, b_k\}$ ä¸ºæœ€ä¼˜åŸºï¼ˆæŒ‰æƒé‡é™åºï¼‰ã€‚
Let $A = \{a_1, a_2, \ldots, a_k\}$ be the basis produced by the greedy algorithm (in decreasing weight order), $B = \{b_1, b_2, \ldots, b_k\}$ be the optimal basis (in decreasing weight order).

å‡è®¾ $w(A) \neq w(B)$ï¼Œè®¾ $i$ ä¸ºæœ€å°ç´¢å¼•ä½¿å¾— $w(a_i) \neq w(b_i)$ã€‚
Assume $w(A) \neq w(B)$, let $i$ be the minimum index such that $w(a_i) \neq w(b_i)$.

æ ¹æ®è´ªå¿ƒæ„é€ ï¼Œ$w(a_i) > w(b_i)$ï¼ˆå¦åˆ™è´ªå¿ƒç®—æ³•ä¼šé€‰æ‹© $b_i$ï¼‰ã€‚
By greedy construction, $w(a_i) > w(b_i)$ (otherwise the greedy algorithm would have chosen $b_i$).

åº”ç”¨äº¤æ¢æ€§è´¨ï¼šå­˜åœ¨ $b_j \in B \setminus \{a_1, \ldots, a_i\}$ ä½¿å¾— $\{a_1, \ldots, a_i\} \cup \{b_j\} \in \mathcal{I}$ã€‚
Apply exchange property: there exists $b_j \in B \setminus \{a_1, \ldots, a_i\}$ such that $\{a_1, \ldots, a_i\} \cup \{b_j\} \in \mathcal{I}$.

ç”±äº $j > i$ï¼Œ$w(b_j) \leq w(b_i) < w(a_i)$ã€‚
Since $j > i$, $w(b_j) \leq w(b_i) < w(a_i)$.

é€šè¿‡é‡å¤åº”ç”¨äº¤æ¢æ€§è´¨ï¼Œå¯ä»¥æ„é€ åŸº $C$ åŒ…å« $\{a_1, \ldots, a_i\}$ å’Œ $B$ çš„å‰©ä½™å…ƒç´ ã€‚
By repeatedly applying the exchange property, we can construct a basis $C$ containing $\{a_1, \ldots, a_i\}$ and the remaining elements of $B$.

ç”±äº $w(a_i) > w(b_i)$ ä¸” $w(a_j) \geq w(b_j)$ å¯¹æ‰€æœ‰ $j > i$ï¼Œæˆ‘ä»¬æœ‰ $w(C) > w(B)$ã€‚
Since $w(a_i) > w(b_i)$ and $w(a_j) \geq w(b_j)$ for all $j > i$, we have $w(C) > w(B)$.

è¿™ä¸ $B$ æ˜¯æœ€ä¼˜åŸºçŸ›ç›¾ã€‚
This contradicts that $B$ is an optimal basis.

å› æ­¤ $w(A) = w(B)$ã€‚
Therefore $w(A) = w(B)$.

#### 1.1.3 æ´»åŠ¨é€‰æ‹©é—®é¢˜çš„ä¸¥æ ¼è¯æ˜ / Rigorous Proof for Activity Selection

**å®šç† 1.3** (æ´»åŠ¨é€‰æ‹©è´ªå¿ƒç®—æ³•æ­£ç¡®æ€§) æŒ‰ç»“æŸæ—¶é—´æ’åºåé€‰æ‹©æœ€æ—©ç»“æŸæ´»åŠ¨çš„è´ªå¿ƒç®—æ³•äº§ç”Ÿæœ€å¤§æ´»åŠ¨é›†åˆã€‚
**Theorem 1.3** (Activity Selection Greedy Algorithm Correctness) The greedy algorithm that selects activities in order of earliest finish time produces a maximum activity set.

**è¯æ˜ / Proof:**

è®¾ $A = \{a_1, a_2, \ldots, a_k\}$ ä¸ºè´ªå¿ƒè§£ï¼ˆæŒ‰ç»“æŸæ—¶é—´æ’åºï¼‰ï¼Œ$O = \{o_1, o_2, \ldots, o_m\}$ ä¸ºæœ€ä¼˜è§£ï¼ˆæŒ‰ç»“æŸæ—¶é—´æ’åºï¼‰ã€‚
Let $A = \{a_1, a_2, \ldots, a_k\}$ be the greedy solution (sorted by finish time), $O = \{o_1, o_2, \ldots, o_m\}$ be the optimal solution (sorted by finish time).

ä½¿ç”¨å½’çº³æ³•è¯æ˜ï¼šå¯¹äºæ‰€æœ‰ $i$ï¼Œå­˜åœ¨æœ€ä¼˜è§£ $O_i$ ä½¿å¾— $O_i$ çš„å‰ $i$ ä¸ªæ´»åŠ¨ä¸ $A$ çš„å‰ $i$ ä¸ªæ´»åŠ¨ç›¸åŒã€‚
Use induction to prove: for all $i$, there exists an optimal solution $O_i$ such that the first $i$ activities of $O_i$ match the first $i$ activities of $A$.

**åŸºç¡€æƒ…å†µ**: $i = 0$ï¼Œæ˜¾ç„¶æˆç«‹ã€‚
**Base case**: $i = 0$, obviously holds.

**å½’çº³æ­¥éª¤**: å‡è®¾å¯¹ $i-1$ æˆç«‹ï¼Œè¯æ˜å¯¹ $i$ æˆç«‹ã€‚
**Inductive step**: Assume holds for $i-1$, prove for $i$.

è®¾ $O_{i-1}$ ä¸ºåŒ…å« $\{a_1, \ldots, a_{i-1}\}$ çš„æœ€ä¼˜è§£ã€‚
Let $O_{i-1}$ be an optimal solution containing $\{a_1, \ldots, a_{i-1}\}$.

å¦‚æœ $a_i \in O_{i-1}$ï¼Œåˆ™ $O_i = O_{i-1}$ï¼Œç»“è®ºæˆç«‹ã€‚
If $a_i \in O_{i-1}$, then $O_i = O_{i-1}$, conclusion holds.

å¦‚æœ $a_i \notin O_{i-1}$ï¼Œè®¾ $o_j$ ä¸º $O_{i-1}$ ä¸­ç¬¬ä¸€ä¸ªä¸ $a_i$ å†²çªçš„æ´»åŠ¨ã€‚
If $a_i \notin O_{i-1}$, let $o_j$ be the first activity in $O_{i-1}$ that conflicts with $a_i$.

ç”±äºè´ªå¿ƒé€‰æ‹©ï¼Œ$a_i$ çš„ç»“æŸæ—¶é—´ $\leq o_j$ çš„ç»“æŸæ—¶é—´ã€‚
By greedy choice, finish time of $a_i \leq$ finish time of $o_j$.

æ„é€  $O_i = O_{i-1} \setminus \{o_j\} \cup \{a_i\}$ã€‚
Construct $O_i = O_{i-1} \setminus \{o_j\} \cup \{a_i\}$.

ç”±äº $a_i$ çš„ç»“æŸæ—¶é—´æ›´æ—©ï¼Œ$O_i$ æ˜¯æœ‰æ•ˆçš„ï¼Œä¸” $|O_i| = |O_{i-1}|$ï¼Œå› æ­¤ $O_i$ ä¹Ÿæ˜¯æœ€ä¼˜è§£ã€‚
Since $a_i$ finishes earlier, $O_i$ is valid, and $|O_i| = |O_{i-1}|$, so $O_i$ is also optimal.

**æ—¶é—´å¤æ‚åº¦åˆ†æ / Time Complexity Analysis:**

- **æ’åº**: $O(n \log n)$
- **é€‰æ‹©**: $O(n)$
- **æ€»æ—¶é—´å¤æ‚åº¦**: $O(n \log n)$
- **Sorting**: $O(n \log n)$
- **Selection**: $O(n)$
- **Total time complexity**: $O(n \log n)$

**ç©ºé—´å¤æ‚åº¦åˆ†æ / Space Complexity Analysis:**

- **ç©ºé—´å¤æ‚åº¦**: $O(1)$ï¼ˆä¸åŒ…æ‹¬è¾“å…¥å’Œè¾“å‡ºï¼‰
- **Space complexity**: $O(1)$ (excluding input and output)

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**

- [Cormen 2022]: Cormen, T. H., et al. (2022). *Introduction to Algorithms* (4th ed.). MIT Press.
- [Edmonds 1965]: Edmonds, J. (1965). "Paths, Trees, and Flowers." *Canadian Journal of Mathematics*, 17(3), 449-467.
- [Korte 2011]: Korte, B., & Vygen, J. (2011). *Combinatorial Optimization: Theory and Algorithms* (5th ed.). Springer.

## ç»å…¸é—®é¢˜ (Classic Problems)

### 1. æ´»åŠ¨é€‰æ‹©é—®é¢˜ (Activity Selection Problem)

**é—®é¢˜æè¿°** (Problem Description):
ç»™å®š $n$ ä¸ªæ´»åŠ¨ï¼Œæ¯ä¸ªæ´»åŠ¨æœ‰å¼€å§‹æ—¶é—´ $s_i$ å’Œç»“æŸæ—¶é—´ $f_i$ï¼Œé€‰æ‹©æœ€å¤šçš„äº’ä¸å†²çªçš„æ´»åŠ¨ã€‚

**Given $n$ activities, each with start time $s_i$ and finish time $f_i$, select the maximum number of non-overlapping activities.**

**è´ªå¿ƒç­–ç•¥** (Greedy Strategy):
æŒ‰ç»“æŸæ—¶é—´æ’åºï¼Œé€‰æ‹©ç»“æŸæ—¶é—´æœ€æ—©çš„æ´»åŠ¨ã€‚

**Sort by finish time and select the activity with the earliest finish time.**

**æ­£ç¡®æ€§è¯æ˜** (Correctness Proof):
è®¾ $A$ ä¸ºè´ªå¿ƒç®—æ³•é€‰æ‹©çš„è§£ï¼Œ$O$ ä¸ºæœ€ä¼˜è§£ã€‚å¦‚æœ $A \neq O$ï¼Œåˆ™å­˜åœ¨æ´»åŠ¨ $a \in O - A$ï¼Œå¯ä»¥ç”¨ $A$ ä¸­çš„æŸä¸ªæ´»åŠ¨æ›¿æ¢ï¼Œå¾—åˆ°æ›´ä¼˜è§£ã€‚

**Let $A$ be the solution selected by the greedy algorithm and $O$ be the optimal solution. If $A \neq O$, then there exists an activity $a \in O - A$ that can be replaced by some activity in $A$ to obtain a better solution.**

### 2. éœå¤«æ›¼ç¼–ç  (Huffman Coding)

**é—®é¢˜æè¿°** (Problem Description):
ç»™å®šå­—ç¬¦é›†å’Œé¢‘ç‡ï¼Œæ„é€ æœ€ä¼˜å‰ç¼€ç¼–ç ã€‚

**Given a character set and frequencies, construct optimal prefix codes.**

**è´ªå¿ƒç­–ç•¥** (Greedy Strategy):
æ¯æ¬¡é€‰æ‹©é¢‘ç‡æœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹åˆå¹¶ã€‚

**Merge the two nodes with minimum frequency each time.**

**æ­£ç¡®æ€§è¯æ˜** (Correctness Proof):
é€šè¿‡å½’çº³æ³•è¯æ˜ï¼Œæ¯æ¬¡åˆå¹¶éƒ½æ˜¯æœ€ä¼˜é€‰æ‹©ã€‚

**Prove by induction that each merge is the optimal choice.**

### 3. æœ€å°ç”Ÿæˆæ ‘ (Minimum Spanning Tree)

**é—®é¢˜æè¿°** (Problem Description):
åœ¨è¿é€šå›¾ä¸­æ‰¾åˆ°æƒå€¼å’Œæœ€å°çš„ç”Ÿæˆæ ‘ã€‚

**Find the spanning tree with minimum weight sum in a connected graph.**

**è´ªå¿ƒç­–ç•¥** (Greedy Strategy):
Kruskalç®—æ³•ï¼šæŒ‰è¾¹æƒæ’åºï¼Œé€‰æ‹©ä¸å½¢æˆç¯çš„è¾¹ã€‚

**Kruskal's algorithm: Sort edges by weight and select edges that don't form cycles.**

**æ­£ç¡®æ€§è¯æ˜** (Correctness Proof):
ä½¿ç”¨å‰²æ€§è´¨è¯æ˜ï¼Œæ¯æ¬¡é€‰æ‹©çš„è¾¹éƒ½æ˜¯æŸä¸ªå‰²çš„æœ€å°æƒè¾¹ã€‚

**Use the cut property to prove that each selected edge is the minimum weight edge of some cut.**

**å®šç†ï¼ˆCut Propertyï¼‰** (Theorem - Cut Property):
åœ¨ä»»æ„ **å‰²**ï¼ˆå°†å›¾é¡¶ç‚¹åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼‰çš„æ‰€æœ‰è·¨å‰²è¾¹ä¸­ï¼Œ**æƒå€¼æœ€å°çš„è¾¹** å¿…åœ¨æŸä¸ª **æœ€å°ç”Ÿæˆæ ‘** ä¸­ã€‚

**In any **cut** (partitioning graph vertices into two parts), among all edges crossing the cut, the **edge with minimum weight** must be in some **minimum spanning tree**.**

**è¯æ˜è¦ç‚¹** (Proof Outline):

1. è®¾ `e = (u,v)` ä¸ºå‰² `C` çš„æœ€å°è¾¹ã€‚
   Let `e = (u,v)` be the minimum edge of cut `C`.

2. ä»»å–ä¸€æ£µæœ€å°ç”Ÿæˆæ ‘ `T`ã€‚è‹¥ `e âˆˆ T`ï¼Œç»“è®ºæˆç«‹ã€‚
   Take any minimum spanning tree `T`. If `e âˆˆ T`, the conclusion holds.

3. è‹¥ `e âˆ‰ T`ï¼Œåˆ™åœ¨ `T` ä¸­å¿…æœ‰å”¯ä¸€çš„ `u-v` è·¯å¾„ `P`ï¼Œè¯¥è·¯å¾„å¿…è·¨è¿‡ `C`ï¼ˆå› ä¸º `u` ä¸ `v` åˆ†å±ä¸¤ä¾§ï¼‰ã€‚
   If `e âˆ‰ T`, then there must be a unique `u-v` path `P` in `T`, which must cross `C` (since `u` and `v` are on different sides).

4. è®¾ `f` ä¸º `P` ä¸­è·¨å‰²çš„ç¬¬ä¸€æ¡è¾¹ï¼Œæƒå€¼ `w(f) â‰¥ w(e)`ï¼ˆå› ä¸º `e` æ˜¯æœ€å°è·¨å‰²è¾¹ï¼‰ã€‚
   Let `f` be the first edge in `P` that crosses the cut, then `w(f) â‰¥ w(e)` (since `e` is the minimum crossing edge).

5. æ›¿æ¢ `f` ä¸º `e`ï¼Œå¾—åˆ°æ–°æ ‘ `T'`ï¼Œå…¶æƒå€¼ä¸å¤§äº `T`ï¼Œä»æ˜¯ç”Ÿæˆæ ‘ã€‚
   Replace `f` with `e` to get a new tree `T'`, whose weight is no greater than `T`, and is still a spanning tree.

6. é€’å½’è¿›è¡Œï¼Œæœ€ç»ˆå¾—åˆ°åŒ…å« `e` çš„æœ€å°ç”Ÿæˆæ ‘ã€‚
   Recursively proceed, eventually obtaining a minimum spanning tree containing `e`.

**ç›´æ¥å¾—åˆ°** (Direct Consequence):
Kruskal æŒ‰æƒå€¼å‡åºåŠ å…¥ä¸å½¢æˆç¯çš„è¾¹ï¼Œä¸€å®šå¾—åˆ°æœ€å°ç”Ÿæˆæ ‘ï¼ˆå› ä¸ºæ¯ä¸€æ­¥éƒ½æ»¡è¶³ Cut Propertyï¼‰ã€‚

**Kruskal's algorithm, which adds edges in ascending order of weight without forming cycles, must produce a minimum spanning tree (because each step satisfies the Cut Property).**

## è¯æ˜æŠ€å·§ (Proof Techniques)

### 1. äº¤æ¢è®ºè¯ (Exchange Argument)

**æ–¹æ³•** (Method):
å‡è®¾è´ªå¿ƒè§£ä¸æ˜¯æœ€ä¼˜è§£ï¼Œé€šè¿‡äº¤æ¢å…ƒç´ æ„é€ æ›´ä¼˜è§£ï¼Œå¾—å‡ºçŸ›ç›¾ã€‚

**Assume the greedy solution is not optimal, construct a better solution by exchanging elements, leading to a contradiction.**

**ç¤ºä¾‹** (Example):
æ´»åŠ¨é€‰æ‹©é—®é¢˜ä¸­ï¼Œå¦‚æœè´ªå¿ƒè§£ $A$ ä¸æ˜¯æœ€ä¼˜è§£ï¼Œåˆ™å­˜åœ¨æœ€ä¼˜è§£ $O$ åŒ…å«è´ªå¿ƒç®—æ³•æœªé€‰æ‹©çš„æ´»åŠ¨ï¼Œå¯ä»¥é€šè¿‡äº¤æ¢è¯æ˜ $A$ ä¹Ÿæ˜¯æœ€ä¼˜è§£ã€‚

**In the activity selection problem, if greedy solution $A$ is not optimal, then there exists an optimal solution $O$ containing activities not selected by the greedy algorithm, which can be proven to be optimal through exchange.**

### 2. å½’çº³æ³• (Induction)

**æ–¹æ³•** (Method):
è¯æ˜è´ªå¿ƒç®—æ³•åœ¨æ¯ä¸€æ­¥éƒ½ä¿æŒæœ€ä¼˜æ€§ã€‚

**Prove that the greedy algorithm maintains optimality at each step.**

**ç¤ºä¾‹** (Example):
éœå¤«æ›¼ç¼–ç ä¸­ï¼Œè¯æ˜æ¯æ¬¡åˆå¹¶ä¸¤ä¸ªæœ€å°é¢‘ç‡èŠ‚ç‚¹åï¼Œå‰©ä½™é—®é¢˜ä»ç„¶å…·æœ‰æœ€ä¼˜å­ç»“æ„ã€‚

**In Huffman coding, prove that after merging two nodes with minimum frequency, the remaining problem still has optimal substructure.**

### 3. å¯¹å¶æ€§ (Duality)

**æ–¹æ³•** (Method):
é€šè¿‡æ„é€ å¯¹å¶é—®é¢˜è¯æ˜è´ªå¿ƒç®—æ³•çš„æ­£ç¡®æ€§ã€‚

**Prove the correctness of the greedy algorithm by constructing the dual problem.**

**ç¤ºä¾‹** (Example):
åœ¨æœ€å¤§æµé—®é¢˜ä¸­ï¼Œé€šè¿‡æœ€å°å‰²å¯¹å¶æ€§è¯æ˜Ford-Fulkersonç®—æ³•çš„æ­£ç¡®æ€§ã€‚

**In the maximum flow problem, prove the correctness of Ford-Fulkerson algorithm through minimum cut duality.**

## å®ç°ç¤ºä¾‹ (Implementation Examples)

### Rustå®ç° (Rust Implementation)

```rust
use std::collections::BinaryHeap;
use std::cmp::Ordering;

/// æ´»åŠ¨ç»“æ„
/// Activity structure
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Activity {
    pub id: usize,
    pub start: i32,
    pub finish: i32,
}

impl Activity {
    pub fn new(id: usize, start: i32, finish: i32) -> Self {
        Self { id, start, finish }
    }
}

/// è´ªå¿ƒç®—æ³•å®ç°
/// Greedy algorithm implementation
pub struct GreedyAlgorithm;

impl GreedyAlgorithm {
    /// æ´»åŠ¨é€‰æ‹©é—®é¢˜
    /// Activity selection problem
    pub fn activity_selection(activities: &mut Vec<Activity>) -> Vec<Activity> {
        // æŒ‰ç»“æŸæ—¶é—´æ’åº
        // Sort by finish time
        activities.sort_by_key(|a| a.finish);

        let mut selected = Vec::new();
        let mut last_finish = 0;

        for activity in activities {
            if activity.start >= last_finish {
                selected.push(activity.clone());
                last_finish = activity.finish;
            }
        }

        selected
    }

    /// éœå¤«æ›¼ç¼–ç èŠ‚ç‚¹
    /// Huffman coding node
    #[derive(Debug, Clone)]
    pub struct HuffmanNode {
        pub character: Option<char>,
        pub frequency: i32,
        pub left: Option<Box<HuffmanNode>>,
        pub right: Option<Box<HuffmanNode>>,
    }

    impl HuffmanNode {
        pub fn new(character: char, frequency: i32) -> Self {
            Self {
                character: Some(character),
                frequency,
                left: None,
                right: None,
            }
        }

        pub fn new_internal(frequency: i32, left: HuffmanNode, right: HuffmanNode) -> Self {
            Self {
                character: None,
                frequency,
                left: Some(Box::new(left)),
                right: Some(Box::new(right)),
            }
        }
    }

    impl PartialEq for HuffmanNode {
        fn eq(&self, other: &Self) -> bool {
            self.frequency == other.frequency
        }
    }

    impl Eq for HuffmanNode {}

    impl PartialOrd for HuffmanNode {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }

    impl Ord for HuffmanNode {
        fn cmp(&self, other: &Self) -> Ordering {
            other.frequency.cmp(&self.frequency) // æœ€å°å †
        }
    }

    /// æ„å»ºéœå¤«æ›¼æ ‘
    /// Build Huffman tree
    pub fn build_huffman_tree(frequencies: &[(char, i32)]) -> Option<HuffmanNode> {
        let mut heap = BinaryHeap::new();

        // åˆå§‹åŒ–å¶å­èŠ‚ç‚¹
        // Initialize leaf nodes
        for &(character, frequency) in frequencies {
            heap.push(HuffmanNode::new(character, frequency));
        }

        // æ„å»ºæ ‘
        // Build tree
        while heap.len() > 1 {
            let left = heap.pop().unwrap();
            let right = heap.pop().unwrap();

            let internal = HuffmanNode::new_internal(
                left.frequency + right.frequency,
                left,
                right,
            );

            heap.push(internal);
        }

        heap.pop()
    }

    /// ç”Ÿæˆéœå¤«æ›¼ç¼–ç 
    /// Generate Huffman codes
    pub fn generate_huffman_codes(root: &HuffmanNode) -> std::collections::HashMap<char, String> {
        let mut codes = std::collections::HashMap::new();
        let mut current_code = String::new();

        Self::generate_codes_recursive(root, &mut codes, &mut current_code);

        codes
    }

    fn generate_codes_recursive(
        node: &HuffmanNode,
        codes: &mut std::collections::HashMap<char, String>,
        current_code: &mut String,
    ) {
        if let Some(character) = node.character {
            codes.insert(character, current_code.clone());
            return;
        }

        if let Some(ref left) = node.left {
            current_code.push('0');
            Self::generate_codes_recursive(left, codes, current_code);
            current_code.pop();
        }

        if let Some(ref right) = node.right {
            current_code.push('1');
            Self::generate_codes_recursive(right, codes, current_code);
            current_code.pop();
        }
    }

    /// å›¾ç»“æ„
    /// Graph structure
    #[derive(Debug, Clone)]
    pub struct Edge {
        pub from: usize,
        pub to: usize,
        pub weight: i32,
    }

    impl Edge {
        pub fn new(from: usize, to: usize, weight: i32) -> Self {
            Self { from, to, weight }
        }
    }

    /// Kruskalæœ€å°ç”Ÿæˆæ ‘ç®—æ³•
    /// Kruskal's minimum spanning tree algorithm
    pub fn kruskal_mst(edges: &mut Vec<Edge>, vertices: usize) -> Vec<Edge> {
        // æŒ‰æƒé‡æ’åº
        // Sort by weight
        edges.sort_by_key(|e| e.weight);

        let mut mst = Vec::new();
        let mut uf = UnionFind::new(vertices);

        for edge in edges {
            if uf.find(edge.from) != uf.find(edge.to) {
                mst.push(edge.clone());
                uf.union(edge.from, edge.to);
            }
        }

        mst
    }

    /// å¹¶æŸ¥é›†
    /// Union-Find data structure
    pub struct UnionFind {
        parent: Vec<usize>,
        rank: Vec<usize>,
    }

    impl UnionFind {
        pub fn new(n: usize) -> Self {
            Self {
                parent: (0..n).collect(),
                rank: vec![0; n],
            }
        }

        pub fn find(&mut self, x: usize) -> usize {
            if self.parent[x] != x {
                self.parent[x] = self.find(self.parent[x]);
            }
            self.parent[x]
        }

        pub fn union(&mut self, x: usize, y: usize) {
            let px = self.find(x);
            let py = self.find(y);

            if px == py {
                return;
            }

            if self.rank[px] < self.rank[py] {
                self.parent[px] = py;
            } else if self.rank[px] > self.rank[py] {
                self.parent[py] = px;
            } else {
                self.parent[py] = px;
                self.rank[px] += 1;
            }
        }
    }

    /// ç¡¬å¸æ‰¾é›¶é—®é¢˜
    /// Coin change problem
    pub fn coin_change_greedy(amount: i32, coins: &[i32]) -> Option<Vec<i32>> {
        let mut sorted_coins = coins.to_vec();
        sorted_coins.sort_by(|a, b| b.cmp(a)); // é™åºæ’åˆ—

        let mut result = Vec::new();
        let mut remaining = amount;

        for &coin in &sorted_coins {
            while remaining >= coin {
                result.push(coin);
                remaining -= coin;
            }
        }

        if remaining == 0 {
            Some(result)
        } else {
            None
        }
    }

    /// ä»»åŠ¡è°ƒåº¦é—®é¢˜
    /// Task scheduling problem
    #[derive(Debug, Clone)]
    pub struct Task {
        pub id: usize,
        pub duration: i32,
        pub deadline: i32,
    }

    impl Task {
        pub fn new(id: usize, duration: i32, deadline: i32) -> Self {
            Self { id, duration, deadline }
        }
    }

    /// æœ€æ—©æˆªæ­¢æ—¶é—´ä¼˜å…ˆè°ƒåº¦
    /// Earliest deadline first scheduling
    pub fn earliest_deadline_first(tasks: &mut Vec<Task>) -> Vec<Task> {
        tasks.sort_by_key(|task| task.deadline);
        tasks.clone()
    }

    /// è®¡ç®—æ€»å»¶è¿Ÿ
    /// Calculate total lateness
    pub fn calculate_lateness(schedule: &[Task]) -> i32 {
        let mut current_time = 0;
        let mut total_lateness = 0;

        for task in schedule {
            current_time += task.duration;
            if current_time > task.deadline {
                total_lateness += current_time - task.deadline;
            }
        }

        total_lateness
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_activity_selection() {
        let mut activities = vec![
            Activity::new(1, 1, 4),
            Activity::new(2, 3, 5),
            Activity::new(3, 0, 6),
            Activity::new(4, 5, 7),
            Activity::new(5, 3, 8),
            Activity::new(6, 5, 9),
            Activity::new(7, 6, 10),
            Activity::new(8, 8, 11),
            Activity::new(9, 8, 12),
            Activity::new(10, 2, 13),
            Activity::new(11, 12, 14),
        ];

        let selected = GreedyAlgorithm::activity_selection(&mut activities);
        assert_eq!(selected.len(), 4);
    }

    #[test]
    fn test_huffman_coding() {
        let frequencies = vec![('a', 5), ('b', 9), ('c', 12), ('d', 13), ('e', 16), ('f', 45)];

        let tree = GreedyAlgorithm::build_huffman_tree(&frequencies);
        assert!(tree.is_some());

        let codes = GreedyAlgorithm::generate_huffman_codes(&tree.unwrap());
        assert_eq!(codes.len(), 6);
    }

    #[test]
    fn test_kruskal_mst() {
        let mut edges = vec![
            Edge::new(0, 1, 4),
            Edge::new(0, 2, 3),
            Edge::new(1, 2, 1),
            Edge::new(1, 3, 2),
            Edge::new(2, 3, 4),
        ];

        let mst = GreedyAlgorithm::kruskal_mst(&mut edges, 4);
        assert_eq!(mst.len(), 3);
    }

    #[test]
    fn test_coin_change() {
        let coins = vec![25, 10, 5, 1];
        let amount = 67;

        let result = GreedyAlgorithm::coin_change_greedy(amount, &coins);
        assert!(result.is_some());

        let change = result.unwrap();
        assert_eq!(change.iter().sum::<i32>(), amount);
    }

    #[test]
    fn test_task_scheduling() {
        let mut tasks = vec![
            Task::new(1, 3, 6),
            Task::new(2, 2, 4),
            Task::new(3, 1, 3),
            Task::new(4, 4, 8),
        ];

        let schedule = GreedyAlgorithm::earliest_deadline_first(&mut tasks);
        let lateness = GreedyAlgorithm::calculate_lateness(&schedule);

        assert!(lateness >= 0);
    }
}
```

### Haskellå®ç° (Haskell Implementation)

```haskell
-- è´ªå¿ƒç®—æ³•æ¨¡å—
-- Greedy algorithm module
module GreedyAlgorithm where

import Data.List (sortBy)
import Data.Ord (comparing)
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Maybe (fromJust)

-- æ´»åŠ¨ç»“æ„
-- Activity structure
data Activity = Activity {
    activityId :: Int,
    start :: Int,
    finish :: Int
} deriving (Show, Eq, Ord)

-- æ´»åŠ¨é€‰æ‹©é—®é¢˜
-- Activity selection problem
activitySelection :: [Activity] -> [Activity]
activitySelection activities = go sortedActivities []
  where
    sortedActivities = sortBy (comparing finish) activities
    go [] selected = reverse selected
    go (activity:rest) selected
      | null selected || start activity >= finish (last selected) =
          go rest (activity:selected)
      | otherwise = go rest selected

-- éœå¤«æ›¼ç¼–ç 
-- Huffman coding
data HuffmanNode = Leaf Char Int | Internal Int HuffmanNode HuffmanNode
  deriving (Show, Eq)

instance Ord HuffmanNode where
  compare (Leaf _ freq1) (Leaf _ freq2) = compare freq1 freq2
  compare (Internal freq1 _ _) (Leaf _ freq2) = compare freq1 freq2
  compare (Leaf _ freq1) (Internal freq2 _ _) = compare freq1 freq2
  compare (Internal freq1 _ _) (Internal freq2 _ _) = compare freq1 freq2

-- æ„å»ºéœå¤«æ›¼æ ‘
-- Build Huffman tree
buildHuffmanTree :: [(Char, Int)] -> Maybe HuffmanNode
buildHuffmanTree frequencies =
  case buildTree (map (\(c, f) -> Leaf c f) frequencies) of
    [node] -> Just node
    _ -> Nothing
  where
    buildTree [] = []
    buildTree [node] = [node]
    buildTree nodes = buildTree (mergeNodes (sortNodes nodes))

    sortNodes = sortBy (comparing frequency)
    frequency (Leaf _ f) = f
    frequency (Internal f _ _) = f

    mergeNodes (n1:n2:rest) =
      Internal (frequency n1 + frequency n2) n1 n2 : rest
    mergeNodes nodes = nodes

-- ç”Ÿæˆéœå¤«æ›¼ç¼–ç 
-- Generate Huffman codes
generateHuffmanCodes :: HuffmanNode -> Map.Map Char String
generateHuffmanCodes root = go root ""
  where
    go (Leaf c _) code = Map.singleton c code
    go (Internal _ left right) code =
      Map.union (go left (code ++ "0")) (go right (code ++ "1"))

-- å›¾ç»“æ„
-- Graph structure
data Edge = Edge {
    from :: Int,
    to :: Int,
    weight :: Int
} deriving (Show, Eq, Ord)

-- Kruskalæœ€å°ç”Ÿæˆæ ‘ç®—æ³•
-- Kruskal's minimum spanning tree algorithm
kruskalMST :: [Edge] -> Int -> [Edge]
kruskalMST edges vertices = go sortedEdges [] (initUnionFind vertices)
  where
    sortedEdges = sortBy (comparing weight) edges
    go [] mst _ = mst
    go (edge:rest) mst uf
      | find uf (from edge) /= find uf (to edge) =
          go rest (edge:mst) (union uf (from edge) (to edge))
      | otherwise = go rest mst uf

-- å¹¶æŸ¥é›†
-- Union-Find data structure
data UnionFind = UnionFind {
    parent :: [Int],
    rank :: [Int]
}

initUnionFind :: Int -> UnionFind
initUnionFind n = UnionFind [0..n-1] (replicate n 0)

find :: UnionFind -> Int -> Int
find uf x
  | parent uf !! x == x = x
  | otherwise = find uf (parent uf !! x)

union :: UnionFind -> Int -> Int -> UnionFind
union uf x y
  | px == py = uf
  | rank uf !! px < rank uf !! py =
      uf { parent = updateList (parent uf) px py }
  | rank uf !! px > rank uf !! py =
      uf { parent = updateList (parent uf) py px }
  | otherwise =
      uf { parent = updateList (parent uf) py px,
           rank = updateList (rank uf) px (rank uf !! px + 1) }
  where
    px = find uf x
    py = find uf y
    updateList list index value =
      take index list ++ [value] ++ drop (index + 1) list

-- ç¡¬å¸æ‰¾é›¶é—®é¢˜
-- Coin change problem
coinChangeGreedy :: Int -> [Int] -> Maybe [Int]
coinChangeGreedy amount coins =
  if remaining == 0 then Just result else Nothing
  where
    sortedCoins = reverse (sort coins)
    (result, remaining) = go amount sortedCoins []

    go 0 _ acc = (reverse acc, 0)
    go remaining [] acc = (reverse acc, remaining)
    go remaining (coin:coins) acc
      | remaining >= coin = go (remaining - coin) (coin:coins) (coin:acc)
      | otherwise = go remaining coins acc

-- ä»»åŠ¡è°ƒåº¦
-- Task scheduling
data Task = Task {
    taskId :: Int,
    duration :: Int,
    deadline :: Int
} deriving (Show, Eq, Ord)

-- æœ€æ—©æˆªæ­¢æ—¶é—´ä¼˜å…ˆè°ƒåº¦
-- Earliest deadline first scheduling
earliestDeadlineFirst :: [Task] -> [Task]
earliestDeadlineFirst = sortBy (comparing deadline)

-- è®¡ç®—æ€»å»¶è¿Ÿ
-- Calculate total lateness
calculateLateness :: [Task] -> Int
calculateLateness tasks = go tasks 0 0
  where
    go [] _ total = total
    go (task:tasks) currentTime total =
      go tasks newTime (total + max 0 (newTime - deadline task))
      where newTime = currentTime + duration task

-- æµ‹è¯•å‡½æ•°
-- Test functions
testGreedyAlgorithms :: IO ()
testGreedyAlgorithms = do
    putStrLn "Testing Greedy Algorithms..."

    -- æµ‹è¯•æ´»åŠ¨é€‰æ‹©
    -- Test activity selection
    let activities = [
            Activity 1 1 4,
            Activity 2 3 5,
            Activity 3 0 6,
            Activity 4 5 7
        ]
    let selected = activitySelection activities
    putStrLn $ "Selected activities: " ++ show (length selected)

    -- æµ‹è¯•éœå¤«æ›¼ç¼–ç 
    -- Test Huffman coding
    let frequencies = [('a', 5), ('b', 9), ('c', 12), ('d', 13), ('e', 16), ('f', 45)]
    let tree = buildHuffmanTree frequencies
    case tree of
        Just t -> do
            let codes = generateHuffmanCodes t
            putStrLn $ "Huffman codes: " ++ show (Map.size codes)
        Nothing -> putStrLn "Failed to build Huffman tree"

    -- æµ‹è¯•æœ€å°ç”Ÿæˆæ ‘
    -- Test minimum spanning tree
    let edges = [
            Edge 0 1 4,
            Edge 0 2 3,
            Edge 1 2 1,
            Edge 1 3 2,
            Edge 2 3 4
        ]
    let mst = kruskalMST edges 4
    putStrLn $ "MST edges: " ++ show (length mst)

    -- æµ‹è¯•ç¡¬å¸æ‰¾é›¶
    -- Test coin change
    let coins = [25, 10, 5, 1]
    let amount = 67
    case coinChangeGreedy amount coins of
        Just change -> putStrLn $ "Coin change: " ++ show change
        Nothing -> putStrLn "No solution found"

    putStrLn "Greedy algorithm tests completed!"
```

### Leanå®ç° (Lean Implementation)

```lean
-- è´ªå¿ƒç®—æ³•ç†è®ºçš„å½¢å¼åŒ–å®šä¹‰
-- Formal definition of greedy algorithm theory
import Mathlib.Data.Nat.Basic
import Mathlib.Data.List.Basic
import Mathlib.Algebra.BigOperators.Basic

-- è´ªå¿ƒé€‰æ‹©æ€§è´¨å®šä¹‰
-- Definition of greedy choice property
def GreedyChoiceProperty {Î± : Type} (S : Set Î±) (f : Î± â†’ Nat) (C : Set Î±) : Prop :=
  âˆ€ s âˆˆ S, âˆƒ c âˆˆ C, f s â‰¤ f c

-- æ´»åŠ¨é€‰æ‹©é—®é¢˜
-- Activity selection problem
structure Activity where
  id : Nat
  start : Nat
  finish : Nat

def ActivitySelection (activities : List Activity) : List Activity :=
  let sorted := activities.sort (Î» a b => a.finish â‰¤ b.finish)
  -- å®ç°è´ªå¿ƒé€‰æ‹©é€»è¾‘
  -- Implement greedy selection logic
  []

-- éœå¤«æ›¼ç¼–ç 
-- Huffman coding
inductive HuffmanNode where
  | leaf : Char â†’ Nat â†’ HuffmanNode
  | internal : Nat â†’ HuffmanNode â†’ HuffmanNode â†’ HuffmanNode

def HuffmanFrequency : HuffmanNode â†’ Nat
  | HuffmanNode.leaf _ freq => freq
  | HuffmanNode.internal freq _ _ => freq

def buildHuffmanTree (frequencies : List (Char Ã— Nat)) : Option HuffmanNode :=
  -- å®ç°éœå¤«æ›¼æ ‘æ„å»º
  -- Implement Huffman tree construction
  none

-- æœ€å°ç”Ÿæˆæ ‘
-- Minimum spanning tree
structure Edge where
  from : Nat
  to : Nat
  weight : Nat

def kruskalMST (edges : List Edge) (vertices : Nat) : List Edge :=
  let sorted := edges.sort (Î» a b => a.weight â‰¤ b.weight)
  -- å®ç°Kruskalç®—æ³•
  -- Implement Kruskal's algorithm
  []

-- è´ªå¿ƒç®—æ³•æ­£ç¡®æ€§å®šç†
-- Greedy algorithm correctness theorem
theorem greedy_correctness {Î± : Type} (S : Set Î±) (f : Î± â†’ Nat) (C : Set Î±) :
  GreedyChoiceProperty S f C â†’
  (âˆ€ s âˆˆ S, is_optimal s f) := by
  -- è¯æ˜è´ªå¿ƒç®—æ³•çš„æ­£ç¡®æ€§
  -- Prove correctness of greedy algorithm
  sorry

-- æ´»åŠ¨é€‰æ‹©é—®é¢˜æ­£ç¡®æ€§
-- Activity selection correctness
theorem activity_selection_correct (activities : List Activity) :
  let selected := ActivitySelection activities
  is_valid_selection selected activities âˆ§
  is_maximal_selection selected activities := by
  -- è¯æ˜æ´»åŠ¨é€‰æ‹©ç®—æ³•çš„æ­£ç¡®æ€§
  -- Prove correctness of activity selection algorithm
  sorry

-- éœå¤«æ›¼ç¼–ç æœ€ä¼˜æ€§
-- Huffman coding optimality
theorem huffman_optimality (frequencies : List (Char Ã— Nat)) :
  let tree := buildHuffmanTree frequencies
  tree.isSome â†’ is_optimal_huffman_tree tree.get frequencies := by
  -- è¯æ˜éœå¤«æ›¼ç¼–ç çš„æœ€ä¼˜æ€§
  -- Prove optimality of Huffman coding
  sorry

-- æœ€å°ç”Ÿæˆæ ‘æœ€ä¼˜æ€§
-- Minimum spanning tree optimality
theorem mst_optimality (edges : List Edge) (vertices : Nat) :
  let mst := kruskalMST edges vertices
  is_valid_mst mst edges vertices âˆ§
  is_minimal_mst mst edges vertices := by
  -- è¯æ˜æœ€å°ç”Ÿæˆæ ‘çš„æœ€ä¼˜æ€§
  -- Prove optimality of minimum spanning tree
  sorry

-- è´ªå¿ƒé€‰æ‹©æ€§è´¨è¯æ˜
-- Greedy choice property proof
theorem greedy_choice_property_activity_selection :
  âˆ€ activities : List Activity,
  let sorted := activities.sort (Î» a b => a.finish â‰¤ b.finish)
  greedy_choice_optimal sorted := by
  -- è¯æ˜æ´»åŠ¨é€‰æ‹©é—®é¢˜çš„è´ªå¿ƒé€‰æ‹©æ€§è´¨
  -- Prove greedy choice property for activity selection
  sorry

-- å®ç°ç¤ºä¾‹
-- Implementation examples
def greedy_activity_selection (activities : List Activity) : List Activity :=
  match activities with
  | [] => []
  | [a] => [a]
  | a :: rest =>
    let selected := greedy_activity_selection rest
    if a.start â‰¥ (selected.head?.map Activity.finish).getD 0 then
      a :: selected
    else
      selected

def greedy_coin_change (amount : Nat) (coins : List Nat) : Option (List Nat) :=
  let sorted_coins := coins.sort (Î» a b => a â‰¥ b)
  -- å®ç°è´ªå¿ƒç¡¬å¸æ‰¾é›¶
  -- Implement greedy coin change
  none

-- æµ‹è¯•å®šç†
-- Test theorems
theorem activity_selection_test :
  let activities := [
    Activity.mk 1 1 4,
    Activity.mk 2 3 5,
    Activity.mk 3 0 6,
    Activity.mk 4 5 7
  ]
  let selected := greedy_activity_selection activities
  selected.length â‰¤ activities.length := by
  -- æµ‹è¯•æ´»åŠ¨é€‰æ‹©ç®—æ³•
  -- Test activity selection algorithm
  sorry

theorem coin_change_test :
  let coins := [25, 10, 5, 1]
  let amount := 67
  let result := greedy_coin_change amount coins
  result.isSome â†’ (result.get.sum = amount) := by
  -- æµ‹è¯•ç¡¬å¸æ‰¾é›¶ç®—æ³•
  -- Test coin change algorithm
  sorry
```

## å¤æ‚åº¦åˆ†æ (Complexity Analysis)

### æ—¶é—´å¤æ‚åº¦ (Time Complexity)

1. **æ´»åŠ¨é€‰æ‹©é—®é¢˜** (Activity Selection Problem):
   - æ’åº: $O(n \log n)$
   - é€‰æ‹©: $O(n)$
   - æ€»ä½“: $O(n \log n)$

2. **éœå¤«æ›¼ç¼–ç ** (Huffman Coding):
   - æ„å»ºæ ‘: $O(n \log n)$
   - ç”Ÿæˆç¼–ç : $O(n)$
   - æ€»ä½“: $O(n \log n)$

3. **Kruskalæœ€å°ç”Ÿæˆæ ‘** (Kruskal MST):
   - æ’åºè¾¹: $O(E \log E)$
   - å¹¶æŸ¥é›†æ“ä½œ: $O(E \log V)$
   - æ€»ä½“: $O(E \log E)$

### ç©ºé—´å¤æ‚åº¦ (Space Complexity)

1. **æ´»åŠ¨é€‰æ‹©**: $O(n)$
2. **éœå¤«æ›¼ç¼–ç **: $O(n)$
3. **æœ€å°ç”Ÿæˆæ ‘**: $O(V + E)$

## åº”ç”¨é¢†åŸŸ (Application Areas)

### 1. æ•°æ®å‹ç¼© (Data Compression)

- éœå¤«æ›¼ç¼–ç ç”¨äºæ— æŸå‹ç¼©
- Huffman coding for lossless compression

### 2. ç½‘ç»œè®¾è®¡ (Network Design)

- æœ€å°ç”Ÿæˆæ ‘ç”¨äºç½‘ç»œæ‹“æ‰‘è®¾è®¡
- Minimum spanning tree for network topology design

### 3. ä»»åŠ¡è°ƒåº¦ (Task Scheduling)

- è´ªå¿ƒç®—æ³•ç”¨äºCPUè°ƒåº¦
- Greedy algorithms for CPU scheduling

### 4. èµ„æºåˆ†é… (Resource Allocation)

- è´ªå¿ƒç­–ç•¥ç”¨äºèµ„æºä¼˜åŒ–åˆ†é…
- Greedy strategies for optimal resource allocation

## æ€»ç»“ (Summary)

è´ªå¿ƒç®—æ³•æ˜¯ä¸€ç§ç®€å•è€Œæœ‰æ•ˆçš„ç®—æ³•è®¾è®¡ç­–ç•¥ï¼Œé€šè¿‡å±€éƒ¨æœ€ä¼˜é€‰æ‹©æ¥è¾¾åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚å…¶å…³é”®åœ¨äºè¯†åˆ«é—®é¢˜çš„è´ªå¿ƒé€‰æ‹©æ€§è´¨å’Œæœ€ä¼˜å­ç»“æ„ã€‚

**Greedy algorithms are a simple yet effective algorithmic design strategy that achieves global optimal solutions through local optimal choices. The key lies in identifying the greedy choice property and optimal substructure of problems.**

### å…³é”®è¦ç‚¹ (Key Points)

1. **è´ªå¿ƒé€‰æ‹©æ€§è´¨** (Greedy Choice Property): ç¡®ä¿å±€éƒ¨æœ€ä¼˜é€‰æ‹©
2. **æœ€ä¼˜å­ç»“æ„** (Optimal Substructure): ä¿è¯é—®é¢˜å¯åˆ†è§£
3. **æ­£ç¡®æ€§è¯æ˜** (Correctness Proof): é€šè¿‡äº¤æ¢è®ºè¯æˆ–å½’çº³æ³•
4. **åº”ç”¨èŒƒå›´** (Application Scope): é€‚ç”¨äºç‰¹å®šç±»å‹çš„é—®é¢˜

### å‘å±•è¶‹åŠ¿ (Development Trends)

1. **ç†è®ºæ·±åŒ–** (Theoretical Deepening): æ›´æ·±å…¥çš„ç†è®ºç ”ç©¶
2. **åº”ç”¨æ‰©å±•** (Application Extension): æ›´å¤šå®é™…åº”ç”¨åœºæ™¯
3. **ç®—æ³•ä¼˜åŒ–** (Algorithm Optimization): æ›´é«˜æ•ˆçš„ç®—æ³•å®ç°
4. **è¯æ˜è‡ªåŠ¨åŒ–** (Proof Automation): è‡ªåŠ¨åŒ–çš„æ­£ç¡®æ€§è¯æ˜

## 7. å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚

### 7.1 ç»å…¸æ•™æ / Classic Textbooks

1. [Cormen2022] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
   - **Cormen-Leiserson-Rivest-Steinç®—æ³•å¯¼è®º**ï¼Œç®—æ³•è®¾è®¡ä¸åˆ†æçš„æƒå¨æ•™æã€‚æœ¬æ–‡æ¡£çš„è´ªå¿ƒç®—æ³•ç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

2. [Kleinberg2005] Kleinberg, J., & Tardos, Ã‰. (2005). *Algorithm Design*. Pearson. ISBN: 978-0321295354
   - **Kleinberg-Tardosç®—æ³•è®¾è®¡æ•™æ**ï¼Œå¼ºè°ƒç®—æ³•è®¾è®¡æŠ€å·§ã€‚æœ¬æ–‡æ¡£çš„è´ªå¿ƒç®—æ³•è®¾è®¡å‚è€ƒæ­¤ä¹¦ã€‚

3. [Sedgewick2011] Sedgewick, R., & Wayne, K. (2011). *Algorithms* (4th ed.). Addison-Wesley. ISBN: 978-0321573513
   - **Sedgewick-Wayneç®—æ³•æ•™æ**ï¼Œæ³¨é‡ç®—æ³•å®ç°ä¸å®è·µã€‚æœ¬æ–‡æ¡£çš„è´ªå¿ƒç®—æ³•å®ç°å‚è€ƒæ­¤ä¹¦ã€‚

4. [Nemhauser1988] Nemhauser, G. L., & Wolsey, L. A. (1988). *Integer and Combinatorial Optimization*. Wiley. ISBN: 978-0471359432
   - **Nemhauser-Wolseyæ•´æ•°ä¸ç»„åˆä¼˜åŒ–ç»å…¸æ•™æ**ï¼Œç»„åˆä¼˜åŒ–ç†è®ºã€‚æœ¬æ–‡æ¡£çš„è´ªå¿ƒç®—æ³•ä¼˜åŒ–å‚è€ƒæ­¤ä¹¦ã€‚

### 7.2 Wikiæ¦‚å¿µå‚è€ƒ / Wiki Concept References

- [Greedy Algorithm](https://en.wikipedia.org/wiki/Greedy_algorithm) - è´ªå¿ƒç®—æ³•çš„æ ‡å‡†å®šä¹‰
- [Greedy Choice Property](https://en.wikipedia.org/wiki/Greedy_algorithm#Greedy_choice_property) - è´ªå¿ƒé€‰æ‹©æ€§è´¨
- [Matroid](https://en.wikipedia.org/wiki/Matroid) - æ‹Ÿé˜µç†è®º
- [Huffman Coding](https://en.wikipedia.org/wiki/Huffman_coding) - éœå¤«æ›¼ç¼–ç 
- [Minimum Spanning Tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree) - æœ€å°ç”Ÿæˆæ ‘
- [Dijkstra's Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) - è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•

### 7.3 å¤§å­¦è¯¾ç¨‹å‚è€ƒ / University Course References

- **MIT 6.006**: Introduction to Algorithms. MIT OpenCourseWare. URL: <https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/>
- **Stanford CS161**: Design and Analysis of Algorithms. Stanford University. URL: <https://web.stanford.edu/class/cs161/>
- **CMU 15-451**: Algorithm Design and Analysis. Carnegie Mellon University. URL: <https://www.cs.cmu.edu/~15451/>

### 7.4 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers

#### è´ªå¿ƒç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Greedy Algorithm Theory

1. **Journal of the ACM (JACM)**
   - **Kruskal, J.B.** (1956). "On the Shortest Spanning Subtree of a Graph and the Traveling Salesman Problem". *Proceedings of the American Mathematical Society*, 7(1), 48-50.
   - **Prim, R.C.** (1957). "Shortest Connection Networks and Some Generalizations". *Bell System Technical Journal*, 36(6), 1389-1401.
   - **Huffman, D.A.** (1952). "A Method for the Construction of Minimum-Redundancy Codes". *Proceedings of the IRE*, 40(9), 1098-1101.
   - **Dijkstra, E.W.** (1959). "A Note on Two Problems in Connexion with Graphs". *Numerische Mathematik*, 1(1), 269-271.

2. **SIAM Journal on Computing (SICOMP)**
   - **Fredman, M.L., & Tarjan, R.E.** (1987). "Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms". *Journal of the ACM*, 34(3), 596-615.
   - **Gabow, H.N., et al.** (1986). "Efficient Algorithms for Finding Minimum Spanning Trees in Undirected and Directed Graphs". *Combinatorica*, 6(2), 109-122.
   - **Chazelle, B.** (2000). "A Minimum Spanning Tree Algorithm with Inverse-Ackermann Type Complexity". *Journal of the ACM*, 47(6), 1028-1047.

#### ç»„åˆä¼˜åŒ–é¡¶çº§æœŸåˆŠ / Top Journals in Combinatorial Optimization

1. **Mathematical Programming**
   - **Edmonds, J.** (1965). "Paths, Trees, and Flowers". *Canadian Journal of Mathematics*, 17(3), 449-467.
   - **Korte, B., & Vygen, J.** (2018). *Combinatorial Optimization: Theory and Algorithms* (6th ed.). Springer.
   - **Schrijver, A.** (2003). *Combinatorial Optimization: Polyhedra and Efficiency*. Springer.
   - **Nemhauser, G.L., & Wolsey, L.A.** (1988). *Integer and Combinatorial Optimization*. John Wiley & Sons.

2. **Operations Research**
   - **Lawler, E.L.** (1976). *Combinatorial Optimization: Networks and Matroids*. Holt, Rinehart and Winston.
   - **Papadimitriou, C.H., & Steiglitz, K.** (1982). *Combinatorial Optimization: Algorithms and Complexity*. Prentice-Hall.

#### æ•°æ®å‹ç¼©ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Data Compression Algorithms

1. **IEEE Transactions on Information Theory**
   - **Huffman, D.A.** (1952). "A Method for the Construction of Minimum-Redundancy Codes". *Proceedings of the IRE*, 40(9), 1098-1101.
   - **Ziv, J., & Lempel, A.** (1977). "A Universal Algorithm for Sequential Data Compression". *IEEE Transactions on Information Theory*, 23(3), 337-343.
   - **Ziv, J., & Lempel, A.** (1978). "Compression of Individual Sequences via Variable-Rate Coding". *IEEE Transactions on Information Theory*, 24(5), 530-536.
   - **Welch, T.A.** (1984). "A Technique for High-Performance Data Compression". *Computer*, 17(6), 8-19.

2. **Journal of the ACM**
   - **Gallager, R.G.** (1978). "Variations on a Theme by Huffman". *IEEE Transactions on Information Theory*, 24(6), 668-674.
   - **Moffat, A., & Turpin, A.** (2002). *Compression and Coding Algorithms*. Kluwer Academic Publishers.

#### è°ƒåº¦ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Scheduling Algorithms

1. **Journal of Scheduling**
   - **Graham, R.L.** (1966). "Bounds for Certain Multiprocessing Anomalies". *Bell System Technical Journal*, 45(9), 1563-1581.
   - **Graham, R.L., et al.** (1979). "Optimization and Approximation in Deterministic Sequencing and Scheduling: A Survey". *Annals of Discrete Mathematics*, 5, 287-326.
   - **Pinedo, M.** (2016). *Scheduling: Theory, Algorithms, and Systems* (5th ed.). Springer.

2. **Operations Research**
   - **Lawler, E.L., et al.** (1993). *Sequencing and Scheduling: Algorithms and Complexity*. Elsevier.
   - **Brucker, P.** (2007). *Scheduling Algorithms* (5th ed.). Springer.

#### è¿‘ä¼¼ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Approximation Algorithms

1. **Journal of Computer and System Sciences**
   - **Vazirani, V.V.** (2001). *Approximation Algorithms*. Springer.
   - **Williamson, D.P., & Shmoys, D.B.** (2011). *The Design of Approximation Algorithms*. Cambridge University Press.
   - **Ausiello, G., et al.** (1999). *Complexity and Approximation: Combinatorial Optimization Problems and Their Approximability Properties*. Springer.

2. **Theoretical Computer Science**
   - **Hochbaum, D.S.** (1997). *Approximation Algorithms for NP-Hard Problems*. PWS Publishing Company.
   - **Garey, M.R., & Johnson, D.S.** (1979). *Computers and Intractability: A Guide to the Theory of NP-Completeness*. W.H. Freeman.

---

## 8. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### 8.1 ç›¸å…³æ–‡æ¡£ / Related Documents

- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/01-ç®—æ³•è®¾è®¡ç†è®º.md` - ç®—æ³•è®¾è®¡ç†è®ºï¼ˆè´ªå¿ƒè®¾è®¡èŒƒå¼ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/22-ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶.md` - ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶ï¼ˆè®¾è®¡èŒƒå¼ç»´åº¦ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/05-å›¾ç®—æ³•ç†è®º.md` - å›¾ç®—æ³•ç†è®ºï¼ˆè´ªå¿ƒåœ¨å›¾ç®—æ³•ä¸­çš„åº”ç”¨ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/06-åŠ¨æ€è§„åˆ’ç†è®º.md` - åŠ¨æ€è§„åˆ’ç†è®ºï¼ˆè´ªå¿ƒä¸åŠ¨æ€è§„åˆ’çš„æ¯”è¾ƒï¼‰
- ç›¸å…³å†…å®¹å·²æ•´åˆåˆ°æœ¬æ–‡æ¡£ï¼ˆåŸ `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§3.3ï¼‰

### 8.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€** æ¨¡å—ï¼Œæ˜¯è´ªå¿ƒç®—æ³•ç†è®ºçš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºè´ªå¿ƒç®—æ³•çš„è®¾è®¡å’Œåˆ†ææä¾›ç†è®ºåŸºç¡€ã€‚

### 8.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- ç›¸å…³å†…å®¹å·²æ•´åˆåˆ°æœ¬æ–‡æ¡£ Â§3ï¼ˆåŸ `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§3.3ï¼‰

---

*æœ¬æ–‡æ¡£æä¾›äº†è´ªå¿ƒç®—æ³•ç†è®ºçš„å®Œæ•´å½¢å¼åŒ–å®šä¹‰ï¼ŒåŒ…å«æ•°å­¦åŸºç¡€ã€ç»å…¸é—®é¢˜ã€è¯æ˜æŠ€å·§å’Œå®ç°ç¤ºä¾‹ï¼Œä¸ºç®—æ³•ç ”ç©¶å’Œåº”ç”¨æä¾›ä¸¥æ ¼çš„ç†è®ºåŸºç¡€ï¼Œå¹¶ç¬¦åˆå›½é™…é¡¶çº§å­¦æœ¯æœŸåˆŠæ ‡å‡†ã€‚*

**This document provides a complete formal definition of greedy algorithm theory, including mathematical foundations, classic problems, proof techniques, and implementation examples, providing a rigorous theoretical foundation for algorithm research and applications, and conforms to international top academic journal standards.**
