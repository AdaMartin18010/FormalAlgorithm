---
title: 9.1.4 æœç´¢ç®—æ³•ç†è®º / Search Algorithm Theory
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: ç®—æ³•ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 9.1.4 æœç´¢ç®—æ³•ç†è®º / Search Algorithm Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€çº¿æ€§/äºŒåˆ†/æ ‘/å›¾ä¸å¯å‘å¼æœç´¢çš„ç†è®ºä¸å®è·µè¦ç‚¹ï¼Œæ˜ç¡®å¤æ‚åº¦ä¸é€‚ç”¨åœºæ™¯ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- å¯åˆ¤å®šæ€§ä¸å®Œå¤‡æ€§ï¼šæœç´¢æ˜¯å¦æ€»èƒ½ç»™å‡ºè§£åŠå…¶æ¡ä»¶ã€‚
- å¯å‘å¼å‡½æ•°ï¼ˆHeuristicï¼‰ï¼šä¼°ä»·å‡½æ•°çš„ä¸€è‡´æ€§ä¸å¯é‡‡çº³æ€§ã€‚
- æœç´¢å¤æ‚åº¦ï¼šæ—¶é—´/ç©ºé—´/åˆ†æ”¯å› å­ä¸æ·±åº¦çš„å…³ç³»ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### å¿«é€Ÿå¯¼èˆª / Quick Links

- [ç›®å½•](#ç›®å½•--table-of-contents)
- [çº¿æ€§æœç´¢](#2-çº¿æ€§æœç´¢)
- [äºŒåˆ†æœç´¢](#3-äºŒåˆ†æœç´¢)
- [æ ‘æœç´¢](#4-æ ‘æœç´¢)
- [å¯å‘å¼æœç´¢](#5-å¯å‘å¼æœç´¢)
- [å›¾æœç´¢](#6-å›¾æœç´¢)

## ç›®å½• / Table of Contents

- [9.1.4 æœç´¢ç®—æ³•ç†è®º / Search Algorithm Theory](#914-æœç´¢ç®—æ³•ç†è®º--search-algorithm-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
  - [1.1 æœç´¢é—®é¢˜å®šä¹‰](#11-æœç´¢é—®é¢˜å®šä¹‰)
  - [1.2 æœç´¢å¤æ‚åº¦](#12-æœç´¢å¤æ‚åº¦)
  - [1.3 æœç´¢ç­–ç•¥](#13-æœç´¢ç­–ç•¥)
- [2. çº¿æ€§æœç´¢](#2-çº¿æ€§æœç´¢)
  - [2.1 åŸºæœ¬çº¿æ€§æœç´¢](#21-åŸºæœ¬çº¿æ€§æœç´¢)
  - [2.2 æ”¹è¿›çº¿æ€§æœç´¢](#22-æ”¹è¿›çº¿æ€§æœç´¢)
  - [2.3 æ¦‚ç‡çº¿æ€§æœç´¢](#23-æ¦‚ç‡çº¿æ€§æœç´¢)
- [3. äºŒåˆ†æœç´¢](#3-äºŒåˆ†æœç´¢)
  - [3.1 åŸºæœ¬äºŒåˆ†æœç´¢](#31-åŸºæœ¬äºŒåˆ†æœç´¢)
  - [3.2 äºŒåˆ†æœç´¢å˜ç§](#32-äºŒåˆ†æœç´¢å˜ç§)
  - [3.3 ä¸‰åˆ†æœç´¢](#33-ä¸‰åˆ†æœç´¢)
- [4. æ ‘æœç´¢](#4-æ ‘æœç´¢)
  - [4.1 äºŒå‰æœç´¢æ ‘æœç´¢](#41-äºŒå‰æœç´¢æ ‘æœç´¢)
  - [4.2 å¹³è¡¡æ ‘æœç´¢](#42-å¹³è¡¡æ ‘æœç´¢)
  - [4.3 Bæ ‘æœç´¢](#43-bæ ‘æœç´¢)
- [5. å¯å‘å¼æœç´¢](#5-å¯å‘å¼æœç´¢)
  - [5.1 A\*ç®—æ³•](#51-aç®—æ³•)
  - [5.2 è´ªå¿ƒæœç´¢](#52-è´ªå¿ƒæœç´¢)
  - [5.3 æ¨¡æ‹Ÿé€€ç«æœç´¢](#53-æ¨¡æ‹Ÿé€€ç«æœç´¢)
- [6. å›¾æœç´¢](#6-å›¾æœç´¢)
  - [6.1 æ·±åº¦ä¼˜å…ˆæœç´¢](#61-æ·±åº¦ä¼˜å…ˆæœç´¢)
  - [6.2 å¹¿åº¦ä¼˜å…ˆæœç´¢](#62-å¹¿åº¦ä¼˜å…ˆæœç´¢)
  - [6.3 åŒå‘æœç´¢](#63-åŒå‘æœç´¢)
- [7. å®ç°ç¤ºä¾‹](#7-å®ç°ç¤ºä¾‹)
  - [7.1 çº¿æ€§æœç´¢å®ç°](#71-çº¿æ€§æœç´¢å®ç°)
  - [7.2 äºŒåˆ†æœç´¢å®ç°](#72-äºŒåˆ†æœç´¢å®ç°)
  - [7.3 A\*ç®—æ³•å®ç°](#73-aç®—æ³•å®ç°)
  - [7.4 å›¾æœç´¢å®ç°](#74-å›¾æœç´¢å®ç°)
- [8. å‚è€ƒæ–‡çŒ® / References](#8-å‚è€ƒæ–‡çŒ®--references)
  - [8.1 ç»å…¸æ•™æ / Classic Textbooks](#81-ç»å…¸æ•™æ--classic-textbooks)
  - [8.2 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers](#82-é¡¶çº§æœŸåˆŠè®ºæ–‡--top-journal-papers)
    - [æœç´¢ç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Search Algorithm Theory](#æœç´¢ç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-search-algorithm-theory)
    - [å¯å‘å¼æœç´¢é¡¶çº§æœŸåˆŠ / Top Journals in Heuristic Search](#å¯å‘å¼æœç´¢é¡¶çº§æœŸåˆŠ--top-journals-in-heuristic-search)
    - [å›¾æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Graph Search Algorithms](#å›¾æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-graph-search-algorithms)
    - [å¹¶è¡Œæœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Parallel Search Algorithms](#å¹¶è¡Œæœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-parallel-search-algorithms)
    - [é‡å­æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Quantum Search Algorithms](#é‡å­æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-quantum-search-algorithms)
- [9. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#9-ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
  - [9.1 ç›¸å…³æ–‡æ¡£ / Related Documents](#91-ç›¸å…³æ–‡æ¡£--related-documents)
  - [9.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#92-çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
  - [9.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#93-viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)

---

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æœç´¢é—®é¢˜å®šä¹‰

**å®šä¹‰ 1.1.1** æœç´¢é—®é¢˜æ˜¯åœ¨æ•°æ®é›†åˆ $S$ ä¸­æŸ¥æ‰¾ç›®æ ‡å…ƒç´  $x$ çš„é—®é¢˜ã€‚

**å½¢å¼åŒ–è¡¨ç¤ºï¼š**
$$
\text{Search}(S, x) = \begin{cases}
i & \text{if } x \in S \text{ and } x = S[i] \\
-1 & \text{if } x \notin S
\end{cases}
$$

**å®šä¹‰ 1.1.2** æœç´¢ç®—æ³•çš„åˆ†ç±»ï¼š

1. **ç¡®å®šæ€§æœç´¢**ï¼šæ¯æ¬¡æœç´¢è·¯å¾„ç¡®å®š
2. **éšæœºæœç´¢**ï¼šä½¿ç”¨éšæœºæ€§æŒ‡å¯¼æœç´¢
3. **å¯å‘å¼æœç´¢**ï¼šä½¿ç”¨å¯å‘å‡½æ•°æŒ‡å¯¼æœç´¢

### 1.2 æœç´¢å¤æ‚åº¦

**å®šä¹‰ 1.2.1** æœç´¢ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼š

- **æœ€åæƒ…å†µ**ï¼š$T_{worst}(n) = \max_{x} T(n, x)$
- **å¹³å‡æƒ…å†µ**ï¼š$T_{avg}(n) = \sum_{x} p(x) \cdot T(n, x)$
- **æœ€å¥½æƒ…å†µ**ï¼š$T_{best}(n) = \min_{x} T(n, x)$

**å®šä¹‰ 1.2.2** æœç´¢ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦ï¼š
$$S(n) = \max_{x} S(n, x)$$

### 1.3 æœç´¢ç­–ç•¥

**å®šä¹‰ 1.3.1** æœç´¢ç­–ç•¥åˆ†ç±»ï¼š

1. **ç©·ä¸¾æœç´¢**ï¼šæ£€æŸ¥æ‰€æœ‰å¯èƒ½è§£
2. **åˆ†æ²»æœç´¢**ï¼šå°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜
3. **å¯å‘å¼æœç´¢**ï¼šä½¿ç”¨å¯å‘ä¿¡æ¯æŒ‡å¯¼æœç´¢
4. **éšæœºæœç´¢**ï¼šä½¿ç”¨éšæœºæ€§é¿å…å±€éƒ¨æœ€ä¼˜

---

## 2. çº¿æ€§æœç´¢

### 2.1 åŸºæœ¬çº¿æ€§æœç´¢

**å®šä¹‰ 2.1.1** çº¿æ€§æœç´¢æŒ‰é¡ºåºæ£€æŸ¥æ¯ä¸ªå…ƒç´ ï¼Œç›´åˆ°æ‰¾åˆ°ç›®æ ‡æˆ–æ£€æŸ¥å®Œæ‰€æœ‰å…ƒç´ ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
LinearSearch(A, x):
    for i = 1 to n:
        if A[i] == x:
            return i
    return -1
```

**å®šç† 2.1.1** çº¿æ€§æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

**è¯æ˜ï¼š**

- æœ€åæƒ…å†µï¼šæ£€æŸ¥æ‰€æœ‰ $n$ ä¸ªå…ƒç´ 
- å¹³å‡æƒ…å†µï¼šæ£€æŸ¥ $\frac{n+1}{2}$ ä¸ªå…ƒç´ 
- æœ€å¥½æƒ…å†µï¼šç¬¬ä¸€ä¸ªå…ƒç´ å°±æ˜¯ç›®æ ‡

### 2.2 æ”¹è¿›çº¿æ€§æœç´¢

**å®šä¹‰ 2.2.1** å“¨å…µçº¿æ€§æœç´¢ä½¿ç”¨å“¨å…µå…ƒç´ é¿å…è¾¹ç•Œæ£€æŸ¥ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
SentinelLinearSearch(A, x):
    A[n+1] = x  // å“¨å…µ
    i = 1
    while A[i] != x:
        i = i + 1
    if i <= n:
        return i
    else:
        return -1
```

**å®šç† 2.2.1** å“¨å…µçº¿æ€§æœç´¢å‡å°‘äº†è¾¹ç•Œæ£€æŸ¥ï¼Œä½†æ—¶é—´å¤æ‚åº¦ä»ä¸º $O(n)$ã€‚

### 2.3 æ¦‚ç‡çº¿æ€§æœç´¢

**å®šä¹‰ 2.3.1** æ¦‚ç‡çº¿æ€§æœç´¢ä½¿ç”¨éšæœºåŒ–ç­–ç•¥ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
RandomizedLinearSearch(A, x):
    n = length(A)
    for t = 1 to c * log n:  // cæ˜¯å¸¸æ•°
        i = random(1, n)
        if A[i] == x:
            return i
    return LinearSearch(A, x)  // å›é€€åˆ°ç¡®å®šæ€§æœç´¢
```

**å®šç† 2.3.1** æ¦‚ç‡çº¿æ€§æœç´¢çš„æœŸæœ›æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ï¼Œå¦‚æœç›®æ ‡å…ƒç´ å­˜åœ¨ã€‚

---

## 3. äºŒåˆ†æœç´¢

### 3.1 åŸºæœ¬äºŒåˆ†æœç´¢

**å®šä¹‰ 3.1.1** äºŒåˆ†æœç´¢åœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å…ƒç´ ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BinarySearch(A, x):
    left = 1
    right = n
    while left <= right:
        mid = (left + right) / 2
        if A[mid] == x:
            return mid
        elif A[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**å®šç† 3.1.1** äºŒåˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ã€‚

**è¯æ˜ï¼š**

- æ¯æ¬¡è¿­ä»£å°†æœç´¢ç©ºé—´å‡åŠ
- æœ€å¤šéœ€è¦ $\log_2 n$ æ¬¡è¿­ä»£
- æ¯æ¬¡è¿­ä»£çš„æ“ä½œä¸ºå¸¸æ•°æ—¶é—´

### 3.2 äºŒåˆ†æœç´¢å˜ç§

**å®šä¹‰ 3.2.1** æŸ¥æ‰¾ç¬¬ä¸€ä¸ªç­‰äºç›®æ ‡çš„ä½ç½®ï¼š

```text
BinarySearchFirst(A, x):
    left = 1
    right = n
    result = -1
    while left <= right:
        mid = (left + right) / 2
        if A[mid] == x:
            result = mid
            right = mid - 1
        elif A[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

**å®šä¹‰ 3.2.2** æŸ¥æ‰¾æœ€åä¸€ä¸ªç­‰äºç›®æ ‡çš„ä½ç½®ï¼š

```text
BinarySearchLast(A, x):
    left = 1
    right = n
    result = -1
    while left <= right:
        mid = (left + right) / 2
        if A[mid] == x:
            result = mid
            left = mid + 1
        elif A[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

### 3.3 ä¸‰åˆ†æœç´¢

**å®šä¹‰ 3.3.1** ä¸‰åˆ†æœç´¢ç”¨äºåœ¨å•å³°å‡½æ•°ä¸­æŸ¥æ‰¾æœ€å¤§å€¼ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
TernarySearch(f, left, right, epsilon):
    while right - left > epsilon:
        mid1 = left + (right - left) / 3
        mid2 = right - (right - left) / 3
        if f(mid1) < f(mid2):
            left = mid1
        else:
            right = mid2
    return (left + right) / 2
```

**å®šç† 3.3.1** ä¸‰åˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log \frac{b-a}{\epsilon})$ã€‚

---

## 4. æ ‘æœç´¢

### 4.1 äºŒå‰æœç´¢æ ‘æœç´¢

**å®šä¹‰ 4.1.1** åœ¨äºŒå‰æœç´¢æ ‘ä¸­æœç´¢ç›®æ ‡å€¼ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BSTSearch(root, x):
    if root == null or root.key == x:
        return root
    if x < root.key:
        return BSTSearch(root.left, x)
    else:
        return BSTSearch(root.right, x)
```

**å®šç† 4.1.1** äºŒå‰æœç´¢æ ‘æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(h)$ï¼Œå…¶ä¸­ $h$ æ˜¯æ ‘é«˜ã€‚

### 4.2 å¹³è¡¡æ ‘æœç´¢

**å®šä¹‰ 4.2.1** åœ¨AVLæ ‘ä¸­æœç´¢ï¼š

```rust
fn avl_search<T: Ord>(root: &Option<Box<AVLNode<T>>>, key: &T) -> Option<&T> {
    match root {
        None => None,
        Some(node) => {
            if key == &node.data {
                Some(&node.data)
            } else if key < &node.data {
                Self::avl_search(&node.left, key)
            } else {
                Self::avl_search(&node.right, key)
            }
        }
    }
}
```

**å®šç† 4.2.1** AVLæ ‘æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ã€‚

### 4.3 Bæ ‘æœç´¢

**å®šä¹‰ 4.3.1** Bæ ‘æœç´¢åœ¨Bæ ‘ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BTreeSearch(node, x):
    i = 1
    while i <= node.n and x > node.key[i]:
        i = i + 1
    if i <= node.n and x == node.key[i]:
        return (node, i)
    elif node.leaf:
        return null
    else:
        return BTreeSearch(node.child[i], x)
```

**å®šç† 4.3.1** Bæ ‘æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log_t n)$ï¼Œå…¶ä¸­ $t$ æ˜¯Bæ ‘çš„æœ€å°åº¦æ•°ã€‚

---

## 5. å¯å‘å¼æœç´¢

### 5.1 A*ç®—æ³•

**å®šä¹‰ 5.1.1** A*ç®—æ³•ä½¿ç”¨å¯å‘å‡½æ•° $h(n)$ ä¼°è®¡ä»èŠ‚ç‚¹ $n$ åˆ°ç›®æ ‡çš„è·ç¦»ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
AStar(start, goal, h):
    open_set = {start}
    came_from = {}
    g_score = {start: 0}
    f_score = {start: h(start)}

    while open_set is not empty:
        current = node in open_set with lowest f_score
        if current == goal:
            return reconstruct_path(came_from, current)

        open_set.remove(current)
        for each neighbor of current:
            tentative_g_score = g_score[current] + d(current, neighbor)
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + h(neighbor)
                if neighbor not in open_set:
                    open_set.add(neighbor)

    return failure
```

**å®šç† 5.1.1** å¦‚æœå¯å‘å‡½æ•° $h$ æ˜¯å¯æ¥å—çš„ï¼ˆä¸é«˜ä¼°ï¼‰ï¼Œåˆ™A*ç®—æ³•æ‰¾åˆ°æœ€ä¼˜è§£ã€‚

### 5.2 è´ªå¿ƒæœç´¢

**å®šä¹‰ 5.2.1** è´ªå¿ƒæœç´¢åªä½¿ç”¨å¯å‘å‡½æ•°ï¼Œä¸è€ƒè™‘å·²èµ°è¿‡çš„è·¯å¾„ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
GreedySearch(start, goal, h):
    current = start
    path = [start]

    while current != goal:
        neighbors = get_neighbors(current)
        if neighbors is empty:
            return failure

        current = argmin_{n in neighbors} h(n)
        path.append(current)

    return path
```

**å®šç† 5.2.1** è´ªå¿ƒæœç´¢ä¸ä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£ï¼Œä½†é€šå¸¸å¾ˆå¿«ã€‚

### 5.3 æ¨¡æ‹Ÿé€€ç«æœç´¢

**å®šä¹‰ 5.3.1** æ¨¡æ‹Ÿé€€ç«æœç´¢ä½¿ç”¨æ¦‚ç‡æ¥å—åŠ£è§£æ¥é¿å…å±€éƒ¨æœ€ä¼˜ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
SimulatedAnnealing(initial_state, temperature, cooling_rate):
    current = initial_state
    best = current

    while temperature > min_temperature:
        for i = 1 to iterations_per_temp:
            neighbor = generate_neighbor(current)
            delta_e = cost(neighbor) - cost(current)

            if delta_e < 0 or random() < exp(-delta_e / temperature):
                current = neighbor
                if cost(current) < cost(best):
                    best = current

        temperature *= cooling_rate

    return best
```

---

## 6. å›¾æœç´¢

### 6.1 æ·±åº¦ä¼˜å…ˆæœç´¢

**å®šä¹‰ 6.1.1** æ·±åº¦ä¼˜å…ˆæœç´¢(DFS)ä¼˜å…ˆæ¢ç´¢æ·±å±‚èŠ‚ç‚¹ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
DFS(graph, start):
    visited = set()
    stack = [start]

    while stack is not empty:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            process(vertex)

            for neighbor in graph.neighbors(vertex):
                if neighbor not in visited:
                    stack.push(neighbor)
```

**å®šç† 6.1.1** DFSçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(V + E)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(V)$ã€‚

### 6.2 å¹¿åº¦ä¼˜å…ˆæœç´¢

**å®šä¹‰ 6.2.1** å¹¿åº¦ä¼˜å…ˆæœç´¢(BFS)ä¼˜å…ˆæ¢ç´¢è¿‘é‚»èŠ‚ç‚¹ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BFS(graph, start):
    visited = set()
    queue = [start]
    visited.add(start)

    while queue is not empty:
        vertex = queue.pop(0)
        process(vertex)

        for neighbor in graph.neighbors(vertex):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

**å®šç† 6.2.1** BFSæ‰¾åˆ°ä»èµ·ç‚¹åˆ°ç›®æ ‡çš„æœ€çŸ­è·¯å¾„ï¼ˆå¦‚æœè¾¹æƒé‡ç›¸ç­‰ï¼‰ã€‚

### 6.3 åŒå‘æœç´¢

**å®šä¹‰ 6.3.1** åŒå‘æœç´¢åŒæ—¶ä»èµ·ç‚¹å’Œç›®æ ‡å¼€å§‹æœç´¢ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BidirectionalSearch(graph, start, goal):
    forward_queue = [start]
    backward_queue = [goal]
    forward_visited = {start}
    backward_visited = {goal}

    while forward_queue and backward_queue:
        // å‰å‘æœç´¢
        if forward_queue:
            current = forward_queue.pop(0)
            if current in backward_visited:
                return reconstruct_path(current)
            for neighbor in graph.neighbors(current):
                if neighbor not in forward_visited:
                    forward_visited.add(neighbor)
                    forward_queue.append(neighbor)

        // åå‘æœç´¢
        if backward_queue:
            current = backward_queue.pop(0)
            if current in forward_visited:
                return reconstruct_path(current)
            for neighbor in graph.neighbors(current):
                if neighbor not in backward_visited:
                    backward_visited.add(neighbor)
                    backward_queue.append(neighbor)

    return failure
```

**å®šç† 6.3.1** åŒå‘æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(b^{d/2})$ï¼Œå…¶ä¸­ $b$ æ˜¯åˆ†æ”¯å› å­ï¼Œ$d$ æ˜¯è§£æ·±åº¦ã€‚

---

## 7. å®ç°ç¤ºä¾‹

### 7.1 çº¿æ€§æœç´¢å®ç°

```rust
pub struct LinearSearch;

impl LinearSearch {
    pub fn search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
        for (i, element) in arr.iter().enumerate() {
            if element == target {
                return Some(i);
            }
        }
        None
    }

    pub fn search_with_sentinel<T: PartialEq + Clone>(arr: &mut [T], target: &T) -> Option<usize> {
        let n = arr.len();
        if n == 0 {
            return None;
        }

        // æ·»åŠ å“¨å…µ
        arr.push(target.clone());

        let mut i = 0;
        while arr[i] != *target {
            i += 1;
        }

        // ç§»é™¤å“¨å…µ
        arr.pop();

        if i < n {
            Some(i)
        } else {
            None
        }
    }
}
```

### 7.2 äºŒåˆ†æœç´¢å®ç°

```rust
pub struct BinarySearch;

impl BinarySearch {
    pub fn search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();

        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => return Some(mid),
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }

        None
    }

    pub fn search_first<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();
        let mut result = None;

        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => {
                    result = Some(mid);
                    right = mid;
                }
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }

        result
    }

    pub fn search_last<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();
        let mut result = None;

        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => {
                    result = Some(mid);
                    left = mid + 1;
                }
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }

        result
    }
}
```

### 7.3 A*ç®—æ³•å®ç°

```rust
use std::collections::{BinaryHeap, HashMap};
use std::cmp::Ordering;

# [derive(Debug, Clone, PartialEq, Eq)]
pub struct Node {
    pub id: usize,
    pub g_score: f64,
    pub f_score: f64,
}

impl PartialOrd for Node {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        other.f_score.partial_cmp(&self.f_score)
    }
}

impl Ord for Node {
    fn cmp(&self, other: &Self) -> Ordering {
        other.f_score.partial_cmp(&self.f_score).unwrap()
    }
}

pub struct AStar;

impl AStar {
    pub fn search<F>(
        graph: &Graph,
        start: usize,
        goal: usize,
        heuristic: F,
    ) -> Option<Vec<usize>>
    where
        F: Fn(usize, usize) -> f64,
    {
        let mut open_set = BinaryHeap::new();
        let mut came_from = HashMap::new();
        let mut g_score = HashMap::new();
        let mut f_score = HashMap::new();

        g_score.insert(start, 0.0);
        f_score.insert(start, heuristic(start, goal));
        open_set.push(Node {
            id: start,
            g_score: 0.0,
            f_score: heuristic(start, goal),
        });

        while let Some(current) = open_set.pop() {
            if current.id == goal {
                return Some(Self::reconstruct_path(&came_from, current.id));
            }

            for &neighbor in graph.neighbors(current.id) {
                let tentative_g_score = g_score[&current.id] + graph.distance(current.id, neighbor);

                if tentative_g_score < *g_score.get(&neighbor).unwrap_or(&f64::INFINITY) {
                    came_from.insert(neighbor, current.id);
                    g_score.insert(neighbor, tentative_g_score);
                    let f = tentative_g_score + heuristic(neighbor, goal);
                    f_score.insert(neighbor, f);

                    open_set.push(Node {
                        id: neighbor,
                        g_score: tentative_g_score,
                        f_score: f,
                    });
                }
            }
        }

        None
    }

    fn reconstruct_path(came_from: &HashMap<usize, usize>, current: usize) -> Vec<usize> {
        let mut path = vec![current];
        let mut current = current;

        while let Some(&previous) = came_from.get(&current) {
            path.push(previous);
            current = previous;
        }

        path.reverse();
        path
    }
}
```

### 7.4 å›¾æœç´¢å®ç°

```rust
use std::collections::{HashSet, VecDeque};

pub struct GraphSearch;

impl GraphSearch {
    pub fn dfs(graph: &Graph, start: usize) -> Vec<usize> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        let mut stack = vec![start];

        while let Some(vertex) = stack.pop() {
            if !visited.contains(&vertex) {
                visited.insert(vertex);
                result.push(vertex);

                for &neighbor in graph.neighbors(vertex) {
                    if !visited.contains(&neighbor) {
                        stack.push(neighbor);
                    }
                }
            }
        }

        result
    }

    pub fn bfs(graph: &Graph, start: usize) -> Vec<usize> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        let mut queue = VecDeque::new();

        visited.insert(start);
        queue.push_back(start);

        while let Some(vertex) = queue.pop_front() {
            result.push(vertex);

            for &neighbor in graph.neighbors(vertex) {
                if !visited.contains(&neighbor) {
                    visited.insert(neighbor);
                    queue.push_back(neighbor);
                }
            }
        }

        result
    }

    pub fn bidirectional_search(graph: &Graph, start: usize, goal: usize) -> Option<Vec<usize>> {
        let mut forward_queue = VecDeque::new();
        let mut backward_queue = VecDeque::new();
        let mut forward_visited = HashSet::new();
        let mut backward_visited = HashSet::new();
        let mut forward_parent = HashMap::new();
        let mut backward_parent = HashMap::new();

        forward_queue.push_back(start);
        backward_queue.push_back(goal);
        forward_visited.insert(start);
        backward_visited.insert(goal);

        while !forward_queue.is_empty() && !backward_queue.is_empty() {
            // å‰å‘æœç´¢
            if let Some(current) = forward_queue.pop_front() {
                if backward_visited.contains(&current) {
                    return Some(Self::merge_paths(
                        &forward_parent,
                        &backward_parent,
                        current,
                        start,
                        goal,
                    ));
                }

                for &neighbor in graph.neighbors(current) {
                    if !forward_visited.contains(&neighbor) {
                        forward_visited.insert(neighbor);
                        forward_parent.insert(neighbor, current);
                        forward_queue.push_back(neighbor);
                    }
                }
            }

            // åå‘æœç´¢
            if let Some(current) = backward_queue.pop_front() {
                if forward_visited.contains(&current) {
                    return Some(Self::merge_paths(
                        &forward_parent,
                        &backward_parent,
                        current,
                        start,
                        goal,
                    ));
                }

                for &neighbor in graph.neighbors(current) {
                    if !backward_visited.contains(&neighbor) {
                        backward_visited.insert(neighbor);
                        backward_parent.insert(neighbor, current);
                        backward_queue.push_back(neighbor);
                    }
                }
            }
        }

        None
    }

    fn merge_paths(
        forward_parent: &HashMap<usize, usize>,
        backward_parent: &HashMap<usize, usize>,
        meeting_point: usize,
        start: usize,
        goal: usize,
    ) -> Vec<usize> {
        let mut path = Vec::new();

        // ä»ä¼šåˆç‚¹å‘å‰åˆ°èµ·ç‚¹
        let mut current = meeting_point;
        while current != start {
            path.push(current);
            current = forward_parent[&current];
        }
        path.push(start);
        path.reverse();

        // ä»ä¼šåˆç‚¹å‘ååˆ°ç›®æ ‡
        current = meeting_point;
        while current != goal {
            current = backward_parent[&current];
            path.push(current);
        }

        path
    }
}
```

---

## 8. å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚

### 8.1 ç»å…¸æ•™æ / Classic Textbooks

1. [Cormen2022] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
   - **Cormen-Leiserson-Rivest-Steinç®—æ³•å¯¼è®º**ï¼Œç®—æ³•è®¾è®¡ä¸åˆ†æçš„æƒå¨æ•™æã€‚æœ¬æ–‡æ¡£çš„æœç´¢ç®—æ³•ç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

2. [Knuth1997] Knuth, D. E. (1997). *The Art of Computer Programming, Volume 3: Sorting and Searching* (2nd ed.). Addison-Wesley. ISBN: 978-0201896855
   - **Knuthè®¡ç®—æœºç¨‹åºè®¾è®¡è‰ºæœ¯ç¬¬3å·**ï¼Œæ’åºä¸æŸ¥æ‰¾çš„ç»å…¸è‘—ä½œã€‚æœ¬æ–‡æ¡£çš„æœç´¢ç®—æ³•åˆ†æå‚è€ƒæ­¤ä¹¦ã€‚

3. [Sedgewick2011] Sedgewick, R., & Wayne, K. (2011). *Algorithms* (4th ed.). Addison-Wesley. ISBN: 978-0321573513
   - **Sedgewick-Wayneç®—æ³•æ•™æ**ï¼Œæ³¨é‡ç®—æ³•å®ç°ä¸å®è·µã€‚æœ¬æ–‡æ¡£çš„æœç´¢ç®—æ³•å®ç°å‚è€ƒæ­¤ä¹¦ã€‚

4. **Russell, S., & Norvig, P.** (2010). *Artificial Intelligence: A Modern Approach* (3rd ed.). Prentice Hall.
   - Russell-Norvigäººå·¥æ™ºèƒ½ç°ä»£æ–¹æ³•ï¼Œå¯å‘å¼æœç´¢çš„é‡è¦å‚è€ƒã€‚

5. **Pearl, J.** (1984). *Heuristics: Intelligent Search Strategies for Computer Problem Solving*. Addison-Wesley.
   - Pearlå¯å‘å¼æœç´¢ç­–ç•¥ä¸“è‘—ï¼Œå¯å‘å¼æœç´¢çš„ç†è®ºåŸºç¡€ã€‚

### 8.2 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers

#### æœç´¢ç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Search Algorithm Theory

1. **Journal of the ACM (JACM)**
   - **Dijkstra, E.W.** (1959). "A Note on Two Problems in Connexion with Graphs". *Numerische Mathematik*, 1(1), 269-271.
   - **Bellman, R.** (1958). "On a Routing Problem". *Quarterly of Applied Mathematics*, 16(1), 87-90.
   - **Floyd, R.W.** (1962). "Algorithm 97: Shortest Path". *Communications of the ACM*, 5(6), 345.
   - **Warshall, S.** (1962). "A Theorem on Boolean Matrices". *Journal of the ACM*, 9(1), 11-12.

2. **SIAM Journal on Computing (SICOMP)**
   - **Fredman, M.L., & Tarjan, R.E.** (1987). "Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms". *Journal of the ACM*, 34(3), 596-615.
   - **Thorup, M.** (1999). "Undirected Single-Source Shortest Paths with Positive Integer Weights in Linear Time". *Journal of the ACM*, 46(3), 362-394.
   - **Pettie, S.** (2004). "A New Approach to All-Pairs Shortest Paths on Real-Weighted Graphs". *Theoretical Computer Science*, 312(1), 47-74.

#### å¯å‘å¼æœç´¢é¡¶çº§æœŸåˆŠ / Top Journals in Heuristic Search

1. **Artificial Intelligence**
   - **Hart, P.E., et al.** (1968). "A Formal Basis for the Heuristic Determination of Minimum Cost Paths". *IEEE Transactions on Systems Science and Cybernetics*, 4(2), 100-107.
   - **Pearl, J.** (1984). *Heuristics: Intelligent Search Strategies for Computer Problem Solving*. Addison-Wesley.
   - **Korf, R.E.** (1985). "Depth-First Iterative-Deepening: An Optimal Admissible Tree Search". *Artificial Intelligence*, 27(1), 97-109.
   - **Hansen, E.A., & Zilberstein, S.** (2001). "LAO*: A Heuristic Search Algorithm That Finds Solutions with Loops". *Artificial Intelligence*, 129(1-2), 35-62.

2. **Journal of Artificial Intelligence Research**
   - **Burns, E., et al.** (2012). "Best-First Search for Treewidth". *Proceedings of the 26th AAAI Conference on Artificial Intelligence*, 510-516.
   - **Richter, S., & Westphal, M.** (2010). "The LAMA Planner: Guiding Cost-Based Anytime Planning with Landmarks". *Journal of Artificial Intelligence Research*, 39, 127-177.

#### å›¾æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Graph Search Algorithms

1. **Theoretical Computer Science**
   - **Hopcroft, J.E., & Tarjan, R.E.** (1973). "Algorithm 447: Efficient Algorithms for Graph Manipulation". *Communications of the ACM*, 16(6), 372-378.
   - **Tarjan, R.E.** (1972). "Depth-First Search and Linear Graph Algorithms". *SIAM Journal on Computing*, 1(2), 146-160.
   - **Gabow, H.N.** (1976). "An Efficient Implementation of Edmonds' Algorithm for Maximum Matching on Graphs". *Journal of the ACM*, 23(2), 221-234.

2. **Information and Computation**
   - **Even, S.** (1979). *Graph Algorithms*. Computer Science Press.
   - **West, D.B.** (2001). *Introduction to Graph Theory* (2nd ed.). Prentice Hall.

#### å¹¶è¡Œæœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Parallel Search Algorithms

1. **Journal of Parallel and Distributed Computing**
   - **Karp, R.M., & Zhang, Y.** (1988). "A Randomized Parallel Algorithm for Backtrack Search". *Proceedings of the 20th Annual ACM Symposium on Theory of Computing*, 330-339.
   - **Reif, J.H.** (1985). "Depth-First Search is Inherently Sequential". *Information Processing Letters*, 20(5), 229-234.
   - **Aggarwal, A., et al.** (1990). "Parallel Depth-First Search in General Directed Graphs". *SIAM Journal on Computing*, 19(2), 397-409.

2. **Parallel Computing**
   - **Blelloch, G.E.** (1990). "Prefix Sums and Their Applications". *Synthesis of Parallel Algorithms*, 35-60.
   - **JaJa, J.** (1992). *An Introduction to Parallel Algorithms*. Addison-Wesley.

#### é‡å­æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Quantum Search Algorithms

1. **Physical Review Letters**
   - **Grover, L.K.** (1996). "A Fast Quantum Mechanical Algorithm for Database Search". *Proceedings of the 28th Annual ACM Symposium on Theory of Computing*, 212-219.
   - **Bennett, C.H., et al.** (1997). "Strengths and Weaknesses of Quantum Computing". *SIAM Journal on Computing*, 26(5), 1510-1523.
   - **Farhi, E., et al.** (2000). "Quantum Computation by Adiabatic Evolution". *arXiv preprint quant-ph/0001106*.

2. **Quantum Information Processing**
   - **Ambainis, A.** (2007). "Quantum Walk Algorithm for Element Distinctness". *SIAM Journal on Computing*, 37(1), 210-239.
   - **Magniez, F., et al.** (2007). "Quantum Algorithms for the Triangle Problem". *SIAM Journal on Computing*, 37(2), 413-424.

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Search Algorithm**: <https://en.wikipedia.org/wiki/Search_algorithm>
   - æœç´¢ç®—æ³•çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«çº¿æ€§æœç´¢ã€äºŒåˆ†æœç´¢ç­‰ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Binary Search Algorithm**: <https://en.wikipedia.org/wiki/Binary_search_algorithm>
   - äºŒåˆ†æœç´¢ç®—æ³•çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»åˆ†æ²»ç­–ç•¥å’Œå¤æ‚åº¦åˆ†æï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Breadth-First Search**: <https://en.wikipedia.org/wiki/Breadth-first_search>
   - å¹¿åº¦ä¼˜å…ˆæœç´¢çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«BFSç®—æ³•å’Œé˜Ÿåˆ—å®ç°ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

4. **Wikipedia - Depth-First Search**: <https://en.wikipedia.org/wiki/Depth-first_search>
   - æ·±åº¦ä¼˜å…ˆæœç´¢çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»DFSç®—æ³•å’Œé€’å½’å®ç°ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

5. **Wikipedia - A* Search Algorithm**: <https://en.wikipedia.org/wiki/A*_search_algorithm>
   - A*æœç´¢ç®—æ³•çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«å¯å‘å¼å‡½æ•°å’Œæœ€ä¼˜æ€§è¯æ˜ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

## 9. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### 9.1 ç›¸å…³æ–‡æ¡£ / Related Documents

- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/01-ç®—æ³•è®¾è®¡ç†è®º.md` - ç®—æ³•è®¾è®¡ç†è®ºï¼ˆåˆ†æ²»ã€è´ªå¿ƒç­‰è®¾è®¡èŒƒå¼ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/22-ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶.md` - ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶ï¼ˆé—®é¢˜ç±»å‹ç»´åº¦ï¼‰
- `04-ç®—æ³•å¤æ‚åº¦/06-ä¿¡æ¯è®ºä¸‹ç•Œ.md` - ä¿¡æ¯è®ºä¸‹ç•Œï¼ˆåŒ…å«æœç´¢ç®—æ³•çš„ä¿¡æ¯è®ºä¸‹ç•Œï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/05-å›¾ç®—æ³•ç†è®º.md` - å›¾ç®—æ³•ç†è®ºï¼ˆBFSã€DFSç­‰å›¾æœç´¢ï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` - ç®—æ³•å…¨æ™¯æ¢³ç†ï¼ˆåŒ…å«æœç´¢ç®—æ³•æ¦‚è¿°ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

### 9.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€** æ¨¡å—ï¼Œæ˜¯æœç´¢ç®—æ³•ç†è®ºçš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºæœç´¢ç®—æ³•çš„è®¾è®¡å’Œåˆ†ææä¾›ç†è®ºåŸºç¡€ã€‚

### 9.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§3.2 - Masterå®šç†ï¼ˆäºŒåˆ†æœç´¢çš„å¤æ‚åº¦åˆ†æï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§3.8 - ä¿¡æ¯è®ºä¸‹ç•Œï¼ˆæœç´¢ç®—æ³•çš„ä¸‹ç•Œï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£ä¸¥æ ¼éµå¾ªæ•°å­¦å½¢å¼åŒ–è§„èŒƒï¼Œæ‰€æœ‰å®šä¹‰å’Œå®šç†å‡é‡‡ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·è¡¨ç¤ºï¼Œå¹¶ç¬¦åˆå›½é™…é¡¶çº§å­¦æœ¯æœŸåˆŠæ ‡å‡†ã€‚*
