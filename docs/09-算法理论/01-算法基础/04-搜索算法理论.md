---
title: 9.1.4 æœç´¢ç®—æ³•ç†è®º / Search Algorithm Theory
version: 1.2
status: maintained
last_updated: 2025-01-12
owner: ç®—æ³•ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 9.1.4 æœç´¢ç®—æ³•ç†è®º / Search Algorithm Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€çº¿æ€§/äºŒåˆ†/æ ‘/å›¾ä¸å¯å‘å¼æœç´¢çš„ç†è®ºä¸å®è·µè¦ç‚¹ï¼Œæ˜ç¡®å¤æ‚åº¦ä¸é€‚ç”¨åœºæ™¯ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- å¯åˆ¤å®šæ€§ä¸å®Œå¤‡æ€§ï¼šæœç´¢æ˜¯å¦æ€»èƒ½ç»™å‡ºè§£åŠå…¶æ¡ä»¶ã€‚
- å¯å‘å¼å‡½æ•°ï¼ˆHeuristicï¼‰ï¼šä¼°ä»·å‡½æ•°çš„ä¸€è‡´æ€§ä¸å¯é‡‡çº³æ€§ã€‚
- æœç´¢å¤æ‚åº¦ï¼šæ—¶é—´/ç©ºé—´/åˆ†æ”¯å› å­ä¸æ·±åº¦çš„å…³ç³»ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### å¿«é€Ÿå¯¼èˆª / Quick Links

- [ç›®å½•](#ç›®å½•--table-of-contents)
- [çº¿æ€§æœç´¢](#2-çº¿æ€§æœç´¢)
- [äºŒåˆ†æœç´¢](#3-äºŒåˆ†æœç´¢)
- [æ ‘æœç´¢](#4-æ ‘æœç´¢)
- [å¯å‘å¼æœç´¢](#5-å¯å‘å¼æœç´¢)
- [å›¾æœç´¢](#6-å›¾æœç´¢)

## ç›®å½• / Table of Contents

- [9.1.4 æœç´¢ç®—æ³•ç†è®º / Search Algorithm Theory](#914-æœç´¢ç®—æ³•ç†è®º--search-algorithm-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)
- [æ¦‚è¿° / Overview](#æ¦‚è¿°--overview)
- [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
  - [1.1 æœç´¢é—®é¢˜å®šä¹‰](#11-æœç´¢é—®é¢˜å®šä¹‰)
  - [1.2 æœç´¢å¤æ‚åº¦](#12-æœç´¢å¤æ‚åº¦)
  - [1.3 æœç´¢ç­–ç•¥](#13-æœç´¢ç­–ç•¥)
- [2. çº¿æ€§æœç´¢](#2-çº¿æ€§æœç´¢)
  - [2.1 åŸºæœ¬çº¿æ€§æœç´¢](#21-åŸºæœ¬çº¿æ€§æœç´¢)
  - [2.2 æ”¹è¿›çº¿æ€§æœç´¢](#22-æ”¹è¿›çº¿æ€§æœç´¢)
  - [2.3 æ¦‚ç‡çº¿æ€§æœç´¢](#23-æ¦‚ç‡çº¿æ€§æœç´¢)
- [3. äºŒåˆ†æœç´¢](#3-äºŒåˆ†æœç´¢)
  - [3.1 åŸºæœ¬äºŒåˆ†æœç´¢](#31-åŸºæœ¬äºŒåˆ†æœç´¢)
  - [3.2 äºŒåˆ†æœç´¢å˜ç§](#32-äºŒåˆ†æœç´¢å˜ç§)
  - [3.3 ä¸‰åˆ†æœç´¢](#33-ä¸‰åˆ†æœç´¢)
- [4. æ ‘æœç´¢](#4-æ ‘æœç´¢)
  - [4.1 äºŒå‰æœç´¢æ ‘æœç´¢](#41-äºŒå‰æœç´¢æ ‘æœç´¢)
  - [4.2 å¹³è¡¡æ ‘æœç´¢](#42-å¹³è¡¡æ ‘æœç´¢)
  - [4.3 Bæ ‘æœç´¢](#43-bæ ‘æœç´¢)
- [5. å¯å‘å¼æœç´¢](#5-å¯å‘å¼æœç´¢)
  - [5.1 A\*ç®—æ³•](#51-aç®—æ³•)
  - [5.2 è´ªå¿ƒæœç´¢](#52-è´ªå¿ƒæœç´¢)
  - [5.3 æ¨¡æ‹Ÿé€€ç«æœç´¢](#53-æ¨¡æ‹Ÿé€€ç«æœç´¢)
- [6. å›¾æœç´¢](#6-å›¾æœç´¢)
  - [6.1 æ·±åº¦ä¼˜å…ˆæœç´¢](#61-æ·±åº¦ä¼˜å…ˆæœç´¢)
  - [6.2 å¹¿åº¦ä¼˜å…ˆæœç´¢](#62-å¹¿åº¦ä¼˜å…ˆæœç´¢)
  - [6.3 åŒå‘æœç´¢](#63-åŒå‘æœç´¢)
- [7. å®ç°ç¤ºä¾‹](#7-å®ç°ç¤ºä¾‹)
  - [7.1 çº¿æ€§æœç´¢å®ç°](#71-çº¿æ€§æœç´¢å®ç°)
  - [7.2 äºŒåˆ†æœç´¢å®ç°](#72-äºŒåˆ†æœç´¢å®ç°)
  - [7.3 A\*ç®—æ³•å®ç°](#73-aç®—æ³•å®ç°)
  - [7.4 å›¾æœç´¢å®ç°](#74-å›¾æœç´¢å®ç°)
- [8. å‚è€ƒæ–‡çŒ® / References](#8-å‚è€ƒæ–‡çŒ®--references)
  - [8.1 ç»å…¸æ•™æ / Classic Textbooks](#81-ç»å…¸æ•™æ--classic-textbooks)
  - [8.2 Wikiæ¦‚å¿µå‚è€ƒ / Wiki Concept References](#82-wikiæ¦‚å¿µå‚è€ƒ--wiki-concept-references)
  - [8.3 å¤§å­¦è¯¾ç¨‹å‚è€ƒ / University Course References](#83-å¤§å­¦è¯¾ç¨‹å‚è€ƒ--university-course-references)
  - [8.4 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers](#84-é¡¶çº§æœŸåˆŠè®ºæ–‡--top-journal-papers)
    - [æœç´¢ç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Search Algorithm Theory](#æœç´¢ç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-search-algorithm-theory)
    - [å¯å‘å¼æœç´¢é¡¶çº§æœŸåˆŠ / Top Journals in Heuristic Search](#å¯å‘å¼æœç´¢é¡¶çº§æœŸåˆŠ--top-journals-in-heuristic-search)
    - [å›¾æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Graph Search Algorithms](#å›¾æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-graph-search-algorithms)
    - [å¹¶è¡Œæœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Parallel Search Algorithms](#å¹¶è¡Œæœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-parallel-search-algorithms)
    - [é‡å­æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Quantum Search Algorithms](#é‡å­æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ--top-journals-in-quantum-search-algorithms)
- [9. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#9-ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
  - [9.1 ç›¸å…³æ–‡æ¡£ / Related Documents](#91-ç›¸å…³æ–‡æ¡£--related-documents)
  - [9.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#92-çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
  - [9.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#93-viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)

---

## æ¦‚è¿° / Overview

æœç´¢ç®—æ³•æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­ç”¨äºåœ¨æ•°æ®é›†åˆä¸­æŸ¥æ‰¾ç›®æ ‡å…ƒç´ çš„æ ¸å¿ƒç®—æ³•ã€‚æ ¹æ®[Cormen 2022]çš„å®šä¹‰ï¼Œæœç´¢é—®é¢˜æ˜¯åœ¨æ•°æ®é›†åˆä¸­æŸ¥æ‰¾ç›®æ ‡å…ƒç´ çš„é—®é¢˜ã€‚æ ¹æ®[Russell 2010]çš„ç ”ç©¶ï¼Œæœç´¢ç®—æ³•å¯ä»¥åˆ†ä¸ºç¡®å®šæ€§æœç´¢å’Œå¯å‘å¼æœç´¢ä¸¤å¤§ç±»ï¼Œæ¯ç±»éƒ½æœ‰å…¶ç‰¹å®šçš„åº”ç”¨åœºæ™¯å’Œå¤æ‚åº¦ç‰¹å¾ã€‚æœ¬æ–‡æ¡£æ¶µç›–æœç´¢ç®—æ³•çš„ç†è®ºåŸºç¡€ã€ç»å…¸ç®—æ³•ã€å¤æ‚åº¦åˆ†æå’Œåº”ç”¨é¢†åŸŸã€‚

Search algorithms are core algorithms in computer science for finding target elements in data collections. According to [Cormen 2022], the search problem is to find a target element in a data collection. According to [Russell 2010], search algorithms can be divided into two major categories: deterministic search and heuristic search, each with its specific application scenarios and complexity characteristics. This document covers the theoretical foundations, classic algorithms, complexity analysis, and application areas of search algorithms.

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**

- [Cormen 2022]: Cormen, T. H., et al. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
- [Russell 2010]: Russell, S., & Norvig, P. (2010). *Artificial Intelligence: A Modern Approach* (3rd ed.). Prentice Hall. ISBN: 978-0136042594
- [Knuth 1998]: Knuth, D. E. (1998). *The Art of Computer Programming, Volume 3: Sorting and Searching* (2nd ed.). Addison-Wesley. ISBN: 978-0201896855

**Wikiæ¦‚å¿µå¯¹é½ / Wiki Concept Alignment:**

- [Search Algorithm](https://en.wikipedia.org/wiki/Search_algorithm) - æœç´¢ç®—æ³•çš„æ ‡å‡†å®šä¹‰
- [Binary Search](https://en.wikipedia.org/wiki/Binary_search_algorithm) - äºŒåˆ†æœç´¢
- [A* Search Algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm) - A*æœç´¢ç®—æ³•
- [Depth-First Search](https://en.wikipedia.org/wiki/Depth-first_search) - æ·±åº¦ä¼˜å…ˆæœç´¢

**å¤§å­¦è¯¾ç¨‹å¯¹æ ‡ / University Course Alignment:**

- MIT 6.006: Introduction to Algorithms - æœç´¢ç®—æ³•åŸºç¡€
- Stanford CS161: Design and Analysis of Algorithms - æœç´¢ç®—æ³•è®¾è®¡ä¸åˆ†æ
- CMU 15-451: Algorithm Design and Analysis - é«˜çº§æœç´¢ç®—æ³•æŠ€æœ¯

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æœç´¢é—®é¢˜å®šä¹‰

**å®šä¹‰ 1.1.1** (æœç´¢é—®é¢˜) [Cormen 2022, Wikipedia Search Algorithm]
æœç´¢é—®é¢˜æ˜¯åœ¨æ•°æ®é›†åˆ $S$ ä¸­æŸ¥æ‰¾ç›®æ ‡å…ƒç´  $x$ çš„é—®é¢˜ã€‚

**å½¢å¼åŒ–è¡¨ç¤ºï¼š**
$$
\text{Search}(S, x) = \begin{cases}
i & \text{if } x \in S \text{ and } x = S[i] \\
-1 & \text{if } x \notin S
\end{cases}
$$

**Wikiæ¦‚å¿µå¯¹é½ / Wiki Concept Alignment:**

| é¡¹ç›®æ¦‚å¿µ | Wikiæ¡ç›® | æ ‡å‡†å®šä¹‰ | å¯¹é½çŠ¶æ€ |
|---------|---------|---------|---------|
| æœç´¢ç®—æ³• | [Search Algorithm](https://en.wikipedia.org/wiki/Search_algorithm) | åœ¨æ•°æ®é›†åˆä¸­æŸ¥æ‰¾å…ƒç´ çš„ç®—æ³• | âœ… å·²å¯¹é½ |
| äºŒåˆ†æœç´¢ | [Binary Search](https://en.wikipedia.org/wiki/Binary_search_algorithm) | åœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾çš„ç®—æ³• | âœ… å·²å¯¹é½ |
| çº¿æ€§æœç´¢ | [Linear Search](https://en.wikipedia.org/wiki/Linear_search) | é¡ºåºéå†æŸ¥æ‰¾çš„ç®—æ³• | âœ… å·²å¯¹é½ |
| A*æœç´¢ | [A* Search Algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm) | å¯å‘å¼å›¾æœç´¢ç®—æ³• | âœ… å·²å¯¹é½ |

**æœç´¢ç®—æ³•çŸ¥è¯†ä½“ç³» / Search Algorithm Knowledge System:**

```mermaid
mindmap
  root((æœç´¢ç®—æ³•<br/>Search Algorithm))
    åŸºæœ¬æ¦‚å¿µ
      æœç´¢é—®é¢˜å®šä¹‰
        è¾“å…¥è¾“å‡º
        ç›®æ ‡å…ƒç´ 
      æœç´¢å¤æ‚åº¦
        æ—¶é—´å¤æ‚åº¦
        ç©ºé—´å¤æ‚åº¦
      æœç´¢ç­–ç•¥
        ç¡®å®šæ€§æœç´¢
        å¯å‘å¼æœç´¢
    çº¿æ€§æœç´¢
      åŸºæœ¬çº¿æ€§æœç´¢
        é¡ºåºéå†
        O(n)å¤æ‚åº¦
      æ”¹è¿›çº¿æ€§æœç´¢
        å“¨å…µä¼˜åŒ–
        æ¦‚ç‡ä¼˜åŒ–
    äºŒåˆ†æœç´¢
      åŸºæœ¬äºŒåˆ†æœç´¢
        æœ‰åºæ•°ç»„
        O(log n)å¤æ‚åº¦
      äºŒåˆ†æœç´¢å˜ç§
        æŸ¥æ‰¾æ’å…¥ä½ç½®
        æŸ¥æ‰¾è¾¹ç•Œ
      ä¸‰åˆ†æœç´¢
        å•å³°å‡½æ•°
        ä¼˜åŒ–æœç´¢
    æ ‘æœç´¢
      äºŒå‰æœç´¢æ ‘
        BSTæœç´¢
        å¹³è¡¡æ€§
      å¹³è¡¡æ ‘æœç´¢
        AVLæ ‘
        çº¢é»‘æ ‘
      Bæ ‘æœç´¢
        å¤šè·¯æœç´¢
        æ•°æ®åº“åº”ç”¨
    å¯å‘å¼æœç´¢
      A*ç®—æ³•
        ä¼°ä»·å‡½æ•°
        æœ€ä¼˜æ€§
      è´ªå¿ƒæœç´¢
        å±€éƒ¨æœ€ä¼˜
        å¿«é€Ÿæœç´¢
      æ¨¡æ‹Ÿé€€ç«
        æ¦‚ç‡æ¥å—
        å…¨å±€ä¼˜åŒ–
    å›¾æœç´¢
      æ·±åº¦ä¼˜å…ˆæœç´¢
        DFSç®—æ³•
        å›æº¯æœç´¢
      å¹¿åº¦ä¼˜å…ˆæœç´¢
        BFSç®—æ³•
        æœ€çŸ­è·¯å¾„
      åŒå‘æœç´¢
        åŒå‘BFS
        æ•ˆç‡æå‡
    åº”ç”¨é¢†åŸŸ
      æ•°æ®åº“
        ç´¢å¼•æœç´¢
        æŸ¥è¯¢ä¼˜åŒ–
      äººå·¥æ™ºèƒ½
        è·¯å¾„è§„åˆ’
        çŠ¶æ€æœç´¢
      ç®—æ³•åŸºç¡€
        å…¶ä»–ç®—æ³•
        æ•°æ®ç»“æ„
```

**æœç´¢ç®—æ³•å¤æ‚åº¦å¯¹æ¯” / Search Algorithm Complexity Comparison:**

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | æœ€ä¼˜æ€§ | å‚è€ƒæ–‡çŒ® |
|------|-----------|-----------|---------|--------|---------|
| çº¿æ€§æœç´¢ | $O(n)$ | $O(1)$ | æ— åºæ•°ç»„ | âœ… | [Cormen 2022] |
| äºŒåˆ†æœç´¢ | $O(\log n)$ | $O(1)$ | æœ‰åºæ•°ç»„ | âœ… | [Cormen 2022] |
| äºŒå‰æœç´¢æ ‘ | $O(\log n)$ | $O(n)$ | åŠ¨æ€é›†åˆ | âœ… | [Cormen 2022] |
| AVLæ ‘æœç´¢ | $O(\log n)$ | $O(n)$ | å¹³è¡¡æ ‘ | âœ… | [Cormen 2022] |
| Bæ ‘æœç´¢ | $O(\log n)$ | $O(n)$ | æ•°æ®åº“ç´¢å¼• | âœ… | [Cormen 2022] |
| DFS | $O(V + E)$ | $O(V)$ | å›¾éå† | âœ… | [Cormen 2022] |
| BFS | $O(V + E)$ | $O(V)$ | æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰ | âœ… | [Cormen 2022] |
| A*æœç´¢ | $O(b^d)$ | $O(b^d)$ | å¯å‘å¼æœç´¢ | âœ… | [Russell 2010] |
| è´ªå¿ƒæœç´¢ | $O(b^m)$ | $O(bm)$ | å¿«é€Ÿæœç´¢ | âŒ | [Russell 2010] |

*æ³¨ï¼š$b$ ä¸ºåˆ†æ”¯å› å­ï¼Œ$d$ ä¸ºè§£çš„æ·±åº¦ï¼Œ$m$ ä¸ºæœ€å¤§æ·±åº¦*

**å®šä¹‰ 1.1.2** æœç´¢ç®—æ³•çš„åˆ†ç±»ï¼š

1. **ç¡®å®šæ€§æœç´¢**ï¼šæ¯æ¬¡æœç´¢è·¯å¾„ç¡®å®š
2. **éšæœºæœç´¢**ï¼šä½¿ç”¨éšæœºæ€§æŒ‡å¯¼æœç´¢
3. **å¯å‘å¼æœç´¢**ï¼šä½¿ç”¨å¯å‘å‡½æ•°æŒ‡å¯¼æœç´¢

### 1.2 æœç´¢å¤æ‚åº¦

**å®šä¹‰ 1.2.1** æœç´¢ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼š

- **æœ€åæƒ…å†µ**ï¼š$T_{worst}(n) = \max_{x} T(n, x)$
- **å¹³å‡æƒ…å†µ**ï¼š$T_{avg}(n) = \sum_{x} p(x) \cdot T(n, x)$
- **æœ€å¥½æƒ…å†µ**ï¼š$T_{best}(n) = \min_{x} T(n, x)$

**å®šä¹‰ 1.2.2** æœç´¢ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦ï¼š
$$S(n) = \max_{x} S(n, x)$$

### 1.3 æœç´¢ç­–ç•¥

**å®šä¹‰ 1.3.1** æœç´¢ç­–ç•¥åˆ†ç±»ï¼š

1. **ç©·ä¸¾æœç´¢**ï¼šæ£€æŸ¥æ‰€æœ‰å¯èƒ½è§£
2. **åˆ†æ²»æœç´¢**ï¼šå°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜
3. **å¯å‘å¼æœç´¢**ï¼šä½¿ç”¨å¯å‘ä¿¡æ¯æŒ‡å¯¼æœç´¢
4. **éšæœºæœç´¢**ï¼šä½¿ç”¨éšæœºæ€§é¿å…å±€éƒ¨æœ€ä¼˜

---

## 2. çº¿æ€§æœç´¢

### 2.1 åŸºæœ¬çº¿æ€§æœç´¢

**å®šä¹‰ 2.1.1** çº¿æ€§æœç´¢æŒ‰é¡ºåºæ£€æŸ¥æ¯ä¸ªå…ƒç´ ï¼Œç›´åˆ°æ‰¾åˆ°ç›®æ ‡æˆ–æ£€æŸ¥å®Œæ‰€æœ‰å…ƒç´ ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
LinearSearch(A, x):
    for i = 1 to n:
        if A[i] == x:
            return i
    return -1
```

**å®šç† 2.1.1** çº¿æ€§æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

**è¯æ˜ï¼š**

- æœ€åæƒ…å†µï¼šæ£€æŸ¥æ‰€æœ‰ $n$ ä¸ªå…ƒç´ 
- å¹³å‡æƒ…å†µï¼šæ£€æŸ¥ $\frac{n+1}{2}$ ä¸ªå…ƒç´ 
- æœ€å¥½æƒ…å†µï¼šç¬¬ä¸€ä¸ªå…ƒç´ å°±æ˜¯ç›®æ ‡

### 2.2 æ”¹è¿›çº¿æ€§æœç´¢

**å®šä¹‰ 2.2.1** å“¨å…µçº¿æ€§æœç´¢ä½¿ç”¨å“¨å…µå…ƒç´ é¿å…è¾¹ç•Œæ£€æŸ¥ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
SentinelLinearSearch(A, x):
    A[n+1] = x  // å“¨å…µ
    i = 1
    while A[i] != x:
        i = i + 1
    if i <= n:
        return i
    else:
        return -1
```

**å®šç† 2.2.1** å“¨å…µçº¿æ€§æœç´¢å‡å°‘äº†è¾¹ç•Œæ£€æŸ¥ï¼Œä½†æ—¶é—´å¤æ‚åº¦ä»ä¸º $O(n)$ã€‚

### 2.3 æ¦‚ç‡çº¿æ€§æœç´¢

**å®šä¹‰ 2.3.1** æ¦‚ç‡çº¿æ€§æœç´¢ä½¿ç”¨éšæœºåŒ–ç­–ç•¥ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
RandomizedLinearSearch(A, x):
    n = length(A)
    for t = 1 to c * log n:  // cæ˜¯å¸¸æ•°
        i = random(1, n)
        if A[i] == x:
            return i
    return LinearSearch(A, x)  // å›é€€åˆ°ç¡®å®šæ€§æœç´¢
```

**å®šç† 2.3.1** æ¦‚ç‡çº¿æ€§æœç´¢çš„æœŸæœ›æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ï¼Œå¦‚æœç›®æ ‡å…ƒç´ å­˜åœ¨ã€‚

---

## 3. äºŒåˆ†æœç´¢

### 3.1 åŸºæœ¬äºŒåˆ†æœç´¢

**å®šä¹‰ 3.1.1** äºŒåˆ†æœç´¢åœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å…ƒç´ ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BinarySearch(A, x):
    left = 1
    right = n
    while left <= right:
        mid = (left + right) / 2
        if A[mid] == x:
            return mid
        elif A[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**å®šç† 3.1.1** äºŒåˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ã€‚
**Theorem 3.1.1** The time complexity of binary search is $O(\log n)$.

**ä¸¥æ ¼æ•°å­¦æ¨å¯¼ / Rigorous Mathematical Derivation:**

è®¾ $T(n)$ ä¸ºäºŒåˆ†æœç´¢é•¿åº¦ä¸º $n$ çš„æ•°ç»„çš„æ—¶é—´å¤æ‚åº¦ã€‚
Let $T(n)$ be the time complexity of binary search for an array of length $n$.

**é€’å½’å…³ç³» / Recurrence Relation:**
$$
T(n) = \begin{cases}
\Theta(1) & \text{if } n \leq 1 \\
T(n/2) + \Theta(1) & \text{if } n > 1
\end{cases}
$$

**æ–¹æ³•1ï¼šå±•å¼€æ³• / Method 1: Substitution Method**

å‡è®¾ $T(n) = c \log n$ï¼ˆå…¶ä¸­ $c$ ä¸ºå¸¸æ•°ï¼‰ã€‚
Assume $T(n) = c \log n$ (where $c$ is a constant).

**å½’çº³è¯æ˜ / Inductive Proof:**

**åŸºç¡€æƒ…å†µ / Base Case**: $T(1) = c \log 1 = 0 = \Theta(1)$ âœ“

**å½’çº³å‡è®¾ / Inductive Hypothesis**: å‡è®¾å¯¹äºæ‰€æœ‰ $k < n$ï¼Œ$T(k) \leq c \log k$
Assume for all $k < n$, $T(k) \leq c \log k$

**å½’çº³æ­¥éª¤ / Inductive Step**:
$$T(n) = T(n/2) + d$$
$$\leq c \log(n/2) + d$$
$$= c(\log n - 1) + d$$
$$= c \log n - c + d$$

é€‰æ‹© $c \geq d$ï¼Œåˆ™ $T(n) \leq c \log n$ã€‚
Choose $c \geq d$, then $T(n) \leq c \log n$.

å› æ­¤ $T(n) = O(\log n)$ã€‚ç±»ä¼¼å¯è¯ $T(n) = \Omega(\log n)$ã€‚
Therefore $T(n) = O(\log n)$. Similarly, we can prove $T(n) = \Omega(\log n)$.

**æ–¹æ³•2ï¼šä¸»å®šç†æ³• / Method 2: Master Theorem**

å¯¹äºé€’å½’å…³ç³» $T(n) = aT(n/b) + f(n)$ï¼Œå…¶ä¸­ï¼š
For the recurrence $T(n) = aT(n/b) + f(n)$, where:

- $a = 1$ï¼ˆå­é—®é¢˜æ•°é‡ / number of subproblemsï¼‰
- $b = 2$ï¼ˆå­é—®é¢˜å¤§å°æ¯”ä¾‹ / subproblem size ratioï¼‰
- $f(n) = \Theta(1)$ï¼ˆæ¯æ¬¡æ“ä½œæ—¶é—´ / operation time per stepï¼‰

è®¡ç®— $n^{\log_b a} = n^{\log_2 1} = n^0 = 1$
Compute $n^{\log_b a} = n^{\log_2 1} = n^0 = 1$

ç”±äº $f(n) = \Theta(1) = \Theta(n^{\log_b a})$ï¼Œå±äºä¸»å®šç†æƒ…å†µ2ã€‚
Since $f(n) = \Theta(1) = \Theta(n^{\log_b a})$, this is case 2 of the master theorem.

å› æ­¤ï¼š$T(n) = \Theta(n^{\log_b a} \log n) = \Theta(\log n)$
Therefore: $T(n) = \Theta(n^{\log_b a} \log n) = \Theta(\log n)$

**æ–¹æ³•3ï¼šè¿­ä»£æ³• / Method 3: Iteration Method**

$$T(n) = T(n/2) + 1$$
$$= T(n/4) + 1 + 1 = T(n/4) + 2$$
$$= T(n/8) + 3$$
$$= \ldots$$
$$= T(n/2^k) + k$$

å½“ $n/2^k = 1$ æ—¶ï¼Œ$k = \log_2 n$ã€‚
When $n/2^k = 1$, $k = \log_2 n$.

å› æ­¤ï¼š$T(n) = T(1) + \log_2 n = \Theta(\log n)$
Therefore: $T(n) = T(1) + \log_2 n = \Theta(\log n)$

**å®šç† 3.1.2** (äºŒåˆ†æœç´¢æ­£ç¡®æ€§å®šç†) äºŒåˆ†æœç´¢ç®—æ³•èƒ½å¤Ÿæ­£ç¡®æŸ¥æ‰¾æœ‰åºæ•°ç»„ä¸­çš„ç›®æ ‡å…ƒç´ ã€‚
**Theorem 3.1.2** (Binary Search Correctness Theorem) The binary search algorithm correctly finds the target element in a sorted array.

**å½¢å¼åŒ–æ­£ç¡®æ€§è¯æ˜ / Formal Correctness Proof:**

**å‰ç½®æ¡ä»¶ / Precondition**:

- è¾“å…¥æ•°ç»„ $A[1..n]$ å·²æŒ‰å‡åºæ’åº
- ç›®æ ‡å…ƒç´  $x$
**Input array**: $A[1..n]$ is sorted in ascending order
**Target element**: $x$

**åç½®æ¡ä»¶ / Postcondition**:

- å¦‚æœ $x \in A$ï¼Œè¿”å› $x$ çš„ç´¢å¼•
- å¦‚æœ $x \notin A$ï¼Œè¿”å› $-1$
**If $x \in A$**, return the index of $x$
**If $x \notin A$**, return $-1$

**å¾ªç¯ä¸å˜å¼ / Loop Invariant:**

åœ¨æ¯æ¬¡å¾ªç¯è¿­ä»£å¼€å§‹æ—¶ï¼Œä»¥ä¸‹æ¡ä»¶æˆç«‹ï¼š
At the start of each loop iteration, the following conditions hold:

1. **æ•°ç»„æœ‰åºæ€§ / Array Ordering**: $A[1..n]$ å·²æ’åº
   $A[1..n]$ is sorted

2. **æœç´¢èŒƒå›´æœ‰æ•ˆæ€§ / Search Range Validity**: $0 \leq left \leq right \leq n$
   $0 \leq left \leq right \leq n$

3. **ç›®æ ‡å…ƒç´ åŒ…å«æ€§ / Target Element Containment**:
   å¦‚æœ $x \in A$ï¼Œåˆ™ $x \in A[left..right]$
   If $x \in A$, then $x \in A[left..right]$

**è¯æ˜å¾ªç¯ä¸å˜å¼ / Prove Loop Invariant:**

**åˆå§‹åŒ– / Initialization**:

- $left = 1$, $right = n$
- å¦‚æœ $x \in A$ï¼Œåˆ™ $x \in A[1..n]$ï¼Œä¸å˜å¼æˆç«‹ã€‚
- If $x \in A$, then $x \in A[1..n]$, invariant holds.

**ä¿æŒ / Maintenance**:
å‡è®¾ä¸å˜å¼åœ¨è¿­ä»£ $i$ å¼€å§‹æ—¶æˆç«‹ã€‚
Assume the invariant holds at the start of iteration $i$.

è®¾ $mid = \lfloor (left + right) / 2 \rfloor$ã€‚
Let $mid = \lfloor (left + right) / 2 \rfloor$.

- **æƒ…å†µ1**: $A[mid] = x$
  - ç®—æ³•è¿”å› $mid$ï¼Œæ­£ç¡®æ€§æ˜¾ç„¶ã€‚
  - Algorithm returns $mid$, correctness is obvious.

- **æƒ…å†µ2**: $A[mid] < x$
  - ç”±äºæ•°ç»„æœ‰åºï¼Œ$x$ ä¸å¯èƒ½åœ¨ $A[1..mid]$ ä¸­
  - è®¾ç½® $left = mid + 1$ï¼Œæœç´¢èŒƒå›´å˜ä¸º $A[mid+1..right]$
  - å¦‚æœ $x \in A$ï¼Œåˆ™ $x \in A[mid+1..right]$ï¼Œä¸å˜å¼ä¿æŒ
  - Since array is sorted, $x$ cannot be in $A[1..mid]$
  - Set $left = mid + 1$, search range becomes $A[mid+1..right]$
  - If $x \in A$, then $x \in A[mid+1..right]$, invariant maintained

- **æƒ…å†µ3**: $A[mid] > x$
  - ç”±äºæ•°ç»„æœ‰åºï¼Œ$x$ ä¸å¯èƒ½åœ¨ $A[mid..n]$ ä¸­
  - è®¾ç½® $right = mid - 1$ï¼Œæœç´¢èŒƒå›´å˜ä¸º $A[left..mid-1]$
  - å¦‚æœ $x \in A$ï¼Œåˆ™ $x \in A[left..mid-1]$ï¼Œä¸å˜å¼ä¿æŒ
  - Since array is sorted, $x$ cannot be in $A[mid..n]$
  - Set $right = mid - 1$, search range becomes $A[left..mid-1]$
  - If $x \in A$, then $x \in A[left..mid-1]$, invariant maintained

**ç»ˆæ­¢ / Termination**:
å½“ $left > right$ æ—¶å¾ªç¯ç»ˆæ­¢ã€‚
Loop terminates when $left > right$.

æ­¤æ—¶æœç´¢èŒƒå›´ä¸ºç©ºï¼Œæ ¹æ®ä¸å˜å¼ï¼Œå¦‚æœ $x \in A$ï¼Œåˆ™ $x \in A[left..right]$ï¼Œä½† $A[left..right]$ ä¸ºç©ºï¼ŒçŸ›ç›¾ã€‚
At this point, the search range is empty. By the invariant, if $x \in A$, then $x \in A[left..right]$, but $A[left..right]$ is empty, a contradiction.

å› æ­¤ $x \notin A$ï¼Œç®—æ³•è¿”å› $-1$ï¼Œæ­£ç¡®ã€‚
Therefore $x \notin A$, algorithm returns $-1$, correct.

**ç»ˆæ­¢æ€§è¯æ˜ / Termination Proof:**

æœç´¢ç©ºé—´å¤§å° $size = right - left + 1$ åœ¨æ¯æ¬¡è¿­ä»£ä¸­ä¸¥æ ¼é€’å‡ï¼š
Search space size $size = right - left + 1$ strictly decreases in each iteration:

- å¦‚æœ $A[mid] < x$ï¼š$size_{new} = right - (mid + 1) + 1 = right - mid < right - left + 1 = size_{old}$
- å¦‚æœ $A[mid] > x$ï¼š$size_{new} = (mid - 1) - left + 1 = mid - left < right - left + 1 = size_{old}$

ç”±äº $size \geq 0$ ä¸”æ¯æ¬¡ä¸¥æ ¼é€’å‡ï¼Œç®—æ³•å¿…ç„¶åœ¨æœ‰é™æ­¥å†…ç»ˆæ­¢ã€‚
Since $size \geq 0$ and strictly decreases each time, the algorithm must terminate in finite steps.

**ç©ºé—´å¤æ‚åº¦åˆ†æ / Space Complexity Analysis:**

äºŒåˆ†æœç´¢æ˜¯åŸåœ°ç®—æ³•ï¼Œåªéœ€è¦å¸¸æ•°ä¸ªé¢å¤–å˜é‡ã€‚
Binary search is an in-place algorithm, requiring only a constant number of extra variables.

- **ç©ºé—´å¤æ‚åº¦**: $O(1)$
- **Space Complexity**: $O(1)$

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**

- [Cormen 2022]: Cormen, T. H., et al. (2022). *Introduction to Algorithms* (4th ed.). MIT Press.
- [Knuth 1998]: Knuth, D. E. (1998). *The Art of Computer Programming, Volume 3: Sorting and Searching* (2nd ed.). Addison-Wesley.

### 3.2 äºŒåˆ†æœç´¢å˜ç§

**å®šä¹‰ 3.2.1** æŸ¥æ‰¾ç¬¬ä¸€ä¸ªç­‰äºç›®æ ‡çš„ä½ç½®ï¼š

```text
BinarySearchFirst(A, x):
    left = 1
    right = n
    result = -1
    while left <= right:
        mid = (left + right) / 2
        if A[mid] == x:
            result = mid
            right = mid - 1
        elif A[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

**å®šä¹‰ 3.2.2** æŸ¥æ‰¾æœ€åä¸€ä¸ªç­‰äºç›®æ ‡çš„ä½ç½®ï¼š

```text
BinarySearchLast(A, x):
    left = 1
    right = n
    result = -1
    while left <= right:
        mid = (left + right) / 2
        if A[mid] == x:
            result = mid
            left = mid + 1
        elif A[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

### 3.3 ä¸‰åˆ†æœç´¢

**å®šä¹‰ 3.3.1** ä¸‰åˆ†æœç´¢ç”¨äºåœ¨å•å³°å‡½æ•°ä¸­æŸ¥æ‰¾æœ€å¤§å€¼ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
TernarySearch(f, left, right, epsilon):
    while right - left > epsilon:
        mid1 = left + (right - left) / 3
        mid2 = right - (right - left) / 3
        if f(mid1) < f(mid2):
            left = mid1
        else:
            right = mid2
    return (left + right) / 2
```

**å®šç† 3.3.1** ä¸‰åˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log \frac{b-a}{\epsilon})$ã€‚

---

## 4. æ ‘æœç´¢

### 4.1 äºŒå‰æœç´¢æ ‘æœç´¢

**å®šä¹‰ 4.1.1** åœ¨äºŒå‰æœç´¢æ ‘ä¸­æœç´¢ç›®æ ‡å€¼ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BSTSearch(root, x):
    if root == null or root.key == x:
        return root
    if x < root.key:
        return BSTSearch(root.left, x)
    else:
        return BSTSearch(root.right, x)
```

**å®šç† 4.1.1** äºŒå‰æœç´¢æ ‘æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(h)$ï¼Œå…¶ä¸­ $h$ æ˜¯æ ‘é«˜ã€‚

### 4.2 å¹³è¡¡æ ‘æœç´¢

**å®šä¹‰ 4.2.1** åœ¨AVLæ ‘ä¸­æœç´¢ï¼š

```rust
fn avl_search<T: Ord>(root: &Option<Box<AVLNode<T>>>, key: &T) -> Option<&T> {
    match root {
        None => None,
        Some(node) => {
            if key == &node.data {
                Some(&node.data)
            } else if key < &node.data {
                Self::avl_search(&node.left, key)
            } else {
                Self::avl_search(&node.right, key)
            }
        }
    }
}
```

**å®šç† 4.2.1** AVLæ ‘æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ã€‚

### 4.3 Bæ ‘æœç´¢

**å®šä¹‰ 4.3.1** Bæ ‘æœç´¢åœ¨Bæ ‘ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BTreeSearch(node, x):
    i = 1
    while i <= node.n and x > node.key[i]:
        i = i + 1
    if i <= node.n and x == node.key[i]:
        return (node, i)
    elif node.leaf:
        return null
    else:
        return BTreeSearch(node.child[i], x)
```

**å®šç† 4.3.1** Bæ ‘æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log_t n)$ï¼Œå…¶ä¸­ $t$ æ˜¯Bæ ‘çš„æœ€å°åº¦æ•°ã€‚

---

## 5. å¯å‘å¼æœç´¢

### 5.1 A*ç®—æ³•

**å®šä¹‰ 5.1.1** A*ç®—æ³•ä½¿ç”¨å¯å‘å‡½æ•° $h(n)$ ä¼°è®¡ä»èŠ‚ç‚¹ $n$ åˆ°ç›®æ ‡çš„è·ç¦»ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
AStar(start, goal, h):
    open_set = {start}
    came_from = {}
    g_score = {start: 0}
    f_score = {start: h(start)}

    while open_set is not empty:
        current = node in open_set with lowest f_score
        if current == goal:
            return reconstruct_path(came_from, current)

        open_set.remove(current)
        for each neighbor of current:
            tentative_g_score = g_score[current] + d(current, neighbor)
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + h(neighbor)
                if neighbor not in open_set:
                    open_set.add(neighbor)

    return failure
```

**å®šç† 5.1.1** å¦‚æœå¯å‘å‡½æ•° $h$ æ˜¯å¯æ¥å—çš„ï¼ˆä¸é«˜ä¼°ï¼‰ï¼Œåˆ™A*ç®—æ³•æ‰¾åˆ°æœ€ä¼˜è§£ã€‚

### 5.2 è´ªå¿ƒæœç´¢

**å®šä¹‰ 5.2.1** è´ªå¿ƒæœç´¢åªä½¿ç”¨å¯å‘å‡½æ•°ï¼Œä¸è€ƒè™‘å·²èµ°è¿‡çš„è·¯å¾„ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
GreedySearch(start, goal, h):
    current = start
    path = [start]

    while current != goal:
        neighbors = get_neighbors(current)
        if neighbors is empty:
            return failure

        current = argmin_{n in neighbors} h(n)
        path.append(current)

    return path
```

**å®šç† 5.2.1** è´ªå¿ƒæœç´¢ä¸ä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£ï¼Œä½†é€šå¸¸å¾ˆå¿«ã€‚

### 5.3 æ¨¡æ‹Ÿé€€ç«æœç´¢

**å®šä¹‰ 5.3.1** æ¨¡æ‹Ÿé€€ç«æœç´¢ä½¿ç”¨æ¦‚ç‡æ¥å—åŠ£è§£æ¥é¿å…å±€éƒ¨æœ€ä¼˜ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
SimulatedAnnealing(initial_state, temperature, cooling_rate):
    current = initial_state
    best = current

    while temperature > min_temperature:
        for i = 1 to iterations_per_temp:
            neighbor = generate_neighbor(current)
            delta_e = cost(neighbor) - cost(current)

            if delta_e < 0 or random() < exp(-delta_e / temperature):
                current = neighbor
                if cost(current) < cost(best):
                    best = current

        temperature *= cooling_rate

    return best
```

---

## 6. å›¾æœç´¢

### 6.1 æ·±åº¦ä¼˜å…ˆæœç´¢

**å®šä¹‰ 6.1.1** æ·±åº¦ä¼˜å…ˆæœç´¢(DFS)ä¼˜å…ˆæ¢ç´¢æ·±å±‚èŠ‚ç‚¹ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
DFS(graph, start):
    visited = set()
    stack = [start]

    while stack is not empty:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            process(vertex)

            for neighbor in graph.neighbors(vertex):
                if neighbor not in visited:
                    stack.push(neighbor)
```

**å®šç† 6.1.1** DFSçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(V + E)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(V)$ã€‚

### 6.2 å¹¿åº¦ä¼˜å…ˆæœç´¢

**å®šä¹‰ 6.2.1** å¹¿åº¦ä¼˜å…ˆæœç´¢(BFS)ä¼˜å…ˆæ¢ç´¢è¿‘é‚»èŠ‚ç‚¹ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BFS(graph, start):
    visited = set()
    queue = [start]
    visited.add(start)

    while queue is not empty:
        vertex = queue.pop(0)
        process(vertex)

        for neighbor in graph.neighbors(vertex):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

**å®šç† 6.2.1** BFSæ‰¾åˆ°ä»èµ·ç‚¹åˆ°ç›®æ ‡çš„æœ€çŸ­è·¯å¾„ï¼ˆå¦‚æœè¾¹æƒé‡ç›¸ç­‰ï¼‰ã€‚

### 6.3 åŒå‘æœç´¢

**å®šä¹‰ 6.3.1** åŒå‘æœç´¢åŒæ—¶ä»èµ·ç‚¹å’Œç›®æ ‡å¼€å§‹æœç´¢ã€‚

**ç®—æ³•æè¿°ï¼š**

```text
BidirectionalSearch(graph, start, goal):
    forward_queue = [start]
    backward_queue = [goal]
    forward_visited = {start}
    backward_visited = {goal}

    while forward_queue and backward_queue:
        // å‰å‘æœç´¢
        if forward_queue:
            current = forward_queue.pop(0)
            if current in backward_visited:
                return reconstruct_path(current)
            for neighbor in graph.neighbors(current):
                if neighbor not in forward_visited:
                    forward_visited.add(neighbor)
                    forward_queue.append(neighbor)

        // åå‘æœç´¢
        if backward_queue:
            current = backward_queue.pop(0)
            if current in forward_visited:
                return reconstruct_path(current)
            for neighbor in graph.neighbors(current):
                if neighbor not in backward_visited:
                    backward_visited.add(neighbor)
                    backward_queue.append(neighbor)

    return failure
```

**å®šç† 6.3.1** åŒå‘æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(b^{d/2})$ï¼Œå…¶ä¸­ $b$ æ˜¯åˆ†æ”¯å› å­ï¼Œ$d$ æ˜¯è§£æ·±åº¦ã€‚

---

## 7. å®ç°ç¤ºä¾‹

### 7.1 çº¿æ€§æœç´¢å®ç°

```rust
pub struct LinearSearch;

impl LinearSearch {
    pub fn search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
        for (i, element) in arr.iter().enumerate() {
            if element == target {
                return Some(i);
            }
        }
        None
    }

    pub fn search_with_sentinel<T: PartialEq + Clone>(arr: &mut [T], target: &T) -> Option<usize> {
        let n = arr.len();
        if n == 0 {
            return None;
        }

        // æ·»åŠ å“¨å…µ
        arr.push(target.clone());

        let mut i = 0;
        while arr[i] != *target {
            i += 1;
        }

        // ç§»é™¤å“¨å…µ
        arr.pop();

        if i < n {
            Some(i)
        } else {
            None
        }
    }
}
```

### 7.2 äºŒåˆ†æœç´¢å®ç°

```rust
pub struct BinarySearch;

impl BinarySearch {
    pub fn search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();

        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => return Some(mid),
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }

        None
    }

    pub fn search_first<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();
        let mut result = None;

        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => {
                    result = Some(mid);
                    right = mid;
                }
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }

        result
    }

    pub fn search_last<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();
        let mut result = None;

        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => {
                    result = Some(mid);
                    left = mid + 1;
                }
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }

        result
    }
}
```

### 7.3 A*ç®—æ³•å®ç°

```rust
use std::collections::{BinaryHeap, HashMap};
use std::cmp::Ordering;

# [derive(Debug, Clone, PartialEq, Eq)]
pub struct Node {
    pub id: usize,
    pub g_score: f64,
    pub f_score: f64,
}

impl PartialOrd for Node {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        other.f_score.partial_cmp(&self.f_score)
    }
}

impl Ord for Node {
    fn cmp(&self, other: &Self) -> Ordering {
        other.f_score.partial_cmp(&self.f_score).unwrap()
    }
}

pub struct AStar;

impl AStar {
    pub fn search<F>(
        graph: &Graph,
        start: usize,
        goal: usize,
        heuristic: F,
    ) -> Option<Vec<usize>>
    where
        F: Fn(usize, usize) -> f64,
    {
        let mut open_set = BinaryHeap::new();
        let mut came_from = HashMap::new();
        let mut g_score = HashMap::new();
        let mut f_score = HashMap::new();

        g_score.insert(start, 0.0);
        f_score.insert(start, heuristic(start, goal));
        open_set.push(Node {
            id: start,
            g_score: 0.0,
            f_score: heuristic(start, goal),
        });

        while let Some(current) = open_set.pop() {
            if current.id == goal {
                return Some(Self::reconstruct_path(&came_from, current.id));
            }

            for &neighbor in graph.neighbors(current.id) {
                let tentative_g_score = g_score[&current.id] + graph.distance(current.id, neighbor);

                if tentative_g_score < *g_score.get(&neighbor).unwrap_or(&f64::INFINITY) {
                    came_from.insert(neighbor, current.id);
                    g_score.insert(neighbor, tentative_g_score);
                    let f = tentative_g_score + heuristic(neighbor, goal);
                    f_score.insert(neighbor, f);

                    open_set.push(Node {
                        id: neighbor,
                        g_score: tentative_g_score,
                        f_score: f,
                    });
                }
            }
        }

        None
    }

    fn reconstruct_path(came_from: &HashMap<usize, usize>, current: usize) -> Vec<usize> {
        let mut path = vec![current];
        let mut current = current;

        while let Some(&previous) = came_from.get(&current) {
            path.push(previous);
            current = previous;
        }

        path.reverse();
        path
    }
}
```

### 7.4 å›¾æœç´¢å®ç°

```rust
use std::collections::{HashSet, VecDeque};

pub struct GraphSearch;

impl GraphSearch {
    pub fn dfs(graph: &Graph, start: usize) -> Vec<usize> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        let mut stack = vec![start];

        while let Some(vertex) = stack.pop() {
            if !visited.contains(&vertex) {
                visited.insert(vertex);
                result.push(vertex);

                for &neighbor in graph.neighbors(vertex) {
                    if !visited.contains(&neighbor) {
                        stack.push(neighbor);
                    }
                }
            }
        }

        result
    }

    pub fn bfs(graph: &Graph, start: usize) -> Vec<usize> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        let mut queue = VecDeque::new();

        visited.insert(start);
        queue.push_back(start);

        while let Some(vertex) = queue.pop_front() {
            result.push(vertex);

            for &neighbor in graph.neighbors(vertex) {
                if !visited.contains(&neighbor) {
                    visited.insert(neighbor);
                    queue.push_back(neighbor);
                }
            }
        }

        result
    }

    pub fn bidirectional_search(graph: &Graph, start: usize, goal: usize) -> Option<Vec<usize>> {
        let mut forward_queue = VecDeque::new();
        let mut backward_queue = VecDeque::new();
        let mut forward_visited = HashSet::new();
        let mut backward_visited = HashSet::new();
        let mut forward_parent = HashMap::new();
        let mut backward_parent = HashMap::new();

        forward_queue.push_back(start);
        backward_queue.push_back(goal);
        forward_visited.insert(start);
        backward_visited.insert(goal);

        while !forward_queue.is_empty() && !backward_queue.is_empty() {
            // å‰å‘æœç´¢
            if let Some(current) = forward_queue.pop_front() {
                if backward_visited.contains(&current) {
                    return Some(Self::merge_paths(
                        &forward_parent,
                        &backward_parent,
                        current,
                        start,
                        goal,
                    ));
                }

                for &neighbor in graph.neighbors(current) {
                    if !forward_visited.contains(&neighbor) {
                        forward_visited.insert(neighbor);
                        forward_parent.insert(neighbor, current);
                        forward_queue.push_back(neighbor);
                    }
                }
            }

            // åå‘æœç´¢
            if let Some(current) = backward_queue.pop_front() {
                if forward_visited.contains(&current) {
                    return Some(Self::merge_paths(
                        &forward_parent,
                        &backward_parent,
                        current,
                        start,
                        goal,
                    ));
                }

                for &neighbor in graph.neighbors(current) {
                    if !backward_visited.contains(&neighbor) {
                        backward_visited.insert(neighbor);
                        backward_parent.insert(neighbor, current);
                        backward_queue.push_back(neighbor);
                    }
                }
            }
        }

        None
    }

    fn merge_paths(
        forward_parent: &HashMap<usize, usize>,
        backward_parent: &HashMap<usize, usize>,
        meeting_point: usize,
        start: usize,
        goal: usize,
    ) -> Vec<usize> {
        let mut path = Vec::new();

        // ä»ä¼šåˆç‚¹å‘å‰åˆ°èµ·ç‚¹
        let mut current = meeting_point;
        while current != start {
            path.push(current);
            current = forward_parent[&current];
        }
        path.push(start);
        path.reverse();

        // ä»ä¼šåˆç‚¹å‘ååˆ°ç›®æ ‡
        current = meeting_point;
        while current != goal {
            current = backward_parent[&current];
            path.push(current);
        }

        path
    }
}
```

---

## 8. å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚

### 8.1 ç»å…¸æ•™æ / Classic Textbooks

1. [Cormen2022] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
   - **Cormen-Leiserson-Rivest-Steinç®—æ³•å¯¼è®º**ï¼Œç®—æ³•è®¾è®¡ä¸åˆ†æçš„æƒå¨æ•™æã€‚æœ¬æ–‡æ¡£çš„æœç´¢ç®—æ³•ç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

2. [Knuth1997] Knuth, D. E. (1997). *The Art of Computer Programming, Volume 3: Sorting and Searching* (2nd ed.). Addison-Wesley. ISBN: 978-0201896855
   - **Knuthè®¡ç®—æœºç¨‹åºè®¾è®¡è‰ºæœ¯ç¬¬3å·**ï¼Œæ’åºä¸æŸ¥æ‰¾çš„ç»å…¸è‘—ä½œã€‚æœ¬æ–‡æ¡£çš„æœç´¢ç®—æ³•åˆ†æå‚è€ƒæ­¤ä¹¦ã€‚

3. [Sedgewick2011] Sedgewick, R., & Wayne, K. (2011). *Algorithms* (4th ed.). Addison-Wesley. ISBN: 978-0321573513
   - **Sedgewick-Wayneç®—æ³•æ•™æ**ï¼Œæ³¨é‡ç®—æ³•å®ç°ä¸å®è·µã€‚æœ¬æ–‡æ¡£çš„æœç´¢ç®—æ³•å®ç°å‚è€ƒæ­¤ä¹¦ã€‚

4. **Russell, S., & Norvig, P.** (2010). *Artificial Intelligence: A Modern Approach* (3rd ed.). Prentice Hall.
   - Russell-Norvigäººå·¥æ™ºèƒ½ç°ä»£æ–¹æ³•ï¼Œå¯å‘å¼æœç´¢çš„é‡è¦å‚è€ƒã€‚

5. **Pearl, J.** (1984). *Heuristics: Intelligent Search Strategies for Computer Problem Solving*. Addison-Wesley.
   - Pearlå¯å‘å¼æœç´¢ç­–ç•¥ä¸“è‘—ï¼Œå¯å‘å¼æœç´¢çš„ç†è®ºåŸºç¡€ã€‚

### 8.2 Wikiæ¦‚å¿µå‚è€ƒ / Wiki Concept References

- [Search Algorithm](https://en.wikipedia.org/wiki/Search_algorithm) - æœç´¢ç®—æ³•çš„æ ‡å‡†å®šä¹‰
- [Binary Search](https://en.wikipedia.org/wiki/Binary_search_algorithm) - äºŒåˆ†æœç´¢
- [Linear Search](https://en.wikipedia.org/wiki/Linear_search) - çº¿æ€§æœç´¢
- [A* Search Algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm) - A*æœç´¢ç®—æ³•
- [Depth-First Search](https://en.wikipedia.org/wiki/Depth-first_search) - æ·±åº¦ä¼˜å…ˆæœç´¢
- [Breadth-First Search](https://en.wikipedia.org/wiki/Breadth-first_search) - å¹¿åº¦ä¼˜å…ˆæœç´¢
- [Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree) - äºŒå‰æœç´¢æ ‘
- [AVL Tree](https://en.wikipedia.org/wiki/AVL_tree) - AVLæ ‘
- [B-tree](https://en.wikipedia.org/wiki/B-tree) - Bæ ‘
- [Heuristic](https://en.wikipedia.org/wiki/Heuristic_(computer_science)) - å¯å‘å¼å‡½æ•°

### 8.3 å¤§å­¦è¯¾ç¨‹å‚è€ƒ / University Course References

- **MIT 6.006**: Introduction to Algorithms. MIT OpenCourseWare. URL: <https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/>
- **Stanford CS161**: Design and Analysis of Algorithms. Stanford University. URL: <https://web.stanford.edu/class/cs161/>
- **CMU 15-451**: Algorithm Design and Analysis. Carnegie Mellon University. URL: <https://www.cs.cmu.edu/~15451/>

### 8.4 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers

#### æœç´¢ç®—æ³•ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Search Algorithm Theory

1. **Journal of the ACM (JACM)**
   - **Dijkstra, E.W.** (1959). "A Note on Two Problems in Connexion with Graphs". *Numerische Mathematik*, 1(1), 269-271.
   - **Bellman, R.** (1958). "On a Routing Problem". *Quarterly of Applied Mathematics*, 16(1), 87-90.
   - **Floyd, R.W.** (1962). "Algorithm 97: Shortest Path". *Communications of the ACM*, 5(6), 345.
   - **Warshall, S.** (1962). "A Theorem on Boolean Matrices". *Journal of the ACM*, 9(1), 11-12.

2. **SIAM Journal on Computing (SICOMP)**
   - **Fredman, M.L., & Tarjan, R.E.** (1987). "Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms". *Journal of the ACM*, 34(3), 596-615.
   - **Thorup, M.** (1999). "Undirected Single-Source Shortest Paths with Positive Integer Weights in Linear Time". *Journal of the ACM*, 46(3), 362-394.
   - **Pettie, S.** (2004). "A New Approach to All-Pairs Shortest Paths on Real-Weighted Graphs". *Theoretical Computer Science*, 312(1), 47-74.

#### å¯å‘å¼æœç´¢é¡¶çº§æœŸåˆŠ / Top Journals in Heuristic Search

1. **Artificial Intelligence**
   - **Hart, P.E., et al.** (1968). "A Formal Basis for the Heuristic Determination of Minimum Cost Paths". *IEEE Transactions on Systems Science and Cybernetics*, 4(2), 100-107.
   - **Pearl, J.** (1984). *Heuristics: Intelligent Search Strategies for Computer Problem Solving*. Addison-Wesley.
   - **Korf, R.E.** (1985). "Depth-First Iterative-Deepening: An Optimal Admissible Tree Search". *Artificial Intelligence*, 27(1), 97-109.
   - **Hansen, E.A., & Zilberstein, S.** (2001). "LAO*: A Heuristic Search Algorithm That Finds Solutions with Loops". *Artificial Intelligence*, 129(1-2), 35-62.

2. **Journal of Artificial Intelligence Research**
   - **Burns, E., et al.** (2012). "Best-First Search for Treewidth". *Proceedings of the 26th AAAI Conference on Artificial Intelligence*, 510-516.
   - **Richter, S., & Westphal, M.** (2010). "The LAMA Planner: Guiding Cost-Based Anytime Planning with Landmarks". *Journal of Artificial Intelligence Research*, 39, 127-177.

#### å›¾æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Graph Search Algorithms

1. **Theoretical Computer Science**
   - **Hopcroft, J.E., & Tarjan, R.E.** (1973). "Algorithm 447: Efficient Algorithms for Graph Manipulation". *Communications of the ACM*, 16(6), 372-378.
   - **Tarjan, R.E.** (1972). "Depth-First Search and Linear Graph Algorithms". *SIAM Journal on Computing*, 1(2), 146-160.
   - **Gabow, H.N.** (1976). "An Efficient Implementation of Edmonds' Algorithm for Maximum Matching on Graphs". *Journal of the ACM*, 23(2), 221-234.

2. **Information and Computation**
   - **Even, S.** (1979). *Graph Algorithms*. Computer Science Press.
   - **West, D.B.** (2001). *Introduction to Graph Theory* (2nd ed.). Prentice Hall.

#### å¹¶è¡Œæœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Parallel Search Algorithms

1. **Journal of Parallel and Distributed Computing**
   - **Karp, R.M., & Zhang, Y.** (1988). "A Randomized Parallel Algorithm for Backtrack Search". *Proceedings of the 20th Annual ACM Symposium on Theory of Computing*, 330-339.
   - **Reif, J.H.** (1985). "Depth-First Search is Inherently Sequential". *Information Processing Letters*, 20(5), 229-234.
   - **Aggarwal, A., et al.** (1990). "Parallel Depth-First Search in General Directed Graphs". *SIAM Journal on Computing*, 19(2), 397-409.

2. **Parallel Computing**
   - **Blelloch, G.E.** (1990). "Prefix Sums and Their Applications". *Synthesis of Parallel Algorithms*, 35-60.
   - **JaJa, J.** (1992). *An Introduction to Parallel Algorithms*. Addison-Wesley.

#### é‡å­æœç´¢ç®—æ³•é¡¶çº§æœŸåˆŠ / Top Journals in Quantum Search Algorithms

1. **Physical Review Letters**
   - **Grover, L.K.** (1996). "A Fast Quantum Mechanical Algorithm for Database Search". *Proceedings of the 28th Annual ACM Symposium on Theory of Computing*, 212-219.
   - **Bennett, C.H., et al.** (1997). "Strengths and Weaknesses of Quantum Computing". *SIAM Journal on Computing*, 26(5), 1510-1523.
   - **Farhi, E., et al.** (2000). "Quantum Computation by Adiabatic Evolution". *arXiv preprint quant-ph/0001106*.

2. **Quantum Information Processing**
   - **Ambainis, A.** (2007). "Quantum Walk Algorithm for Element Distinctness". *SIAM Journal on Computing*, 37(1), 210-239.
   - **Magniez, F., et al.** (2007). "Quantum Algorithms for the Triangle Problem". *SIAM Journal on Computing*, 37(2), 413-424.

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Search Algorithm**: <https://en.wikipedia.org/wiki/Search_algorithm>
   - æœç´¢ç®—æ³•çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«çº¿æ€§æœç´¢ã€äºŒåˆ†æœç´¢ç­‰ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Binary Search Algorithm**: <https://en.wikipedia.org/wiki/Binary_search_algorithm>
   - äºŒåˆ†æœç´¢ç®—æ³•çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»åˆ†æ²»ç­–ç•¥å’Œå¤æ‚åº¦åˆ†æï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Breadth-First Search**: <https://en.wikipedia.org/wiki/Breadth-first_search>
   - å¹¿åº¦ä¼˜å…ˆæœç´¢çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«BFSç®—æ³•å’Œé˜Ÿåˆ—å®ç°ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

4. **Wikipedia - Depth-First Search**: <https://en.wikipedia.org/wiki/Depth-first_search>
   - æ·±åº¦ä¼˜å…ˆæœç´¢çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»DFSç®—æ³•å’Œé€’å½’å®ç°ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

5. **Wikipedia - A* Search Algorithm**: <https://en.wikipedia.org/wiki/A*_search_algorithm>
   - A*æœç´¢ç®—æ³•çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«å¯å‘å¼å‡½æ•°å’Œæœ€ä¼˜æ€§è¯æ˜ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

## 9. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### 9.1 ç›¸å…³æ–‡æ¡£ / Related Documents

- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/01-ç®—æ³•è®¾è®¡ç†è®º.md` - ç®—æ³•è®¾è®¡ç†è®ºï¼ˆåˆ†æ²»ã€è´ªå¿ƒç­‰è®¾è®¡èŒƒå¼ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/22-ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶.md` - ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶ï¼ˆé—®é¢˜ç±»å‹ç»´åº¦ï¼‰
- `04-ç®—æ³•å¤æ‚åº¦/06-ä¿¡æ¯è®ºä¸‹ç•Œ.md` - ä¿¡æ¯è®ºä¸‹ç•Œï¼ˆåŒ…å«æœç´¢ç®—æ³•çš„ä¿¡æ¯è®ºä¸‹ç•Œï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/05-å›¾ç®—æ³•ç†è®º.md` - å›¾ç®—æ³•ç†è®ºï¼ˆBFSã€DFSç­‰å›¾æœç´¢ï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` - ç®—æ³•å…¨æ™¯æ¢³ç†ï¼ˆåŒ…å«æœç´¢ç®—æ³•æ¦‚è¿°ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

### 9.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€** æ¨¡å—ï¼Œæ˜¯æœç´¢ç®—æ³•ç†è®ºçš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºæœç´¢ç®—æ³•çš„è®¾è®¡å’Œåˆ†ææä¾›ç†è®ºåŸºç¡€ã€‚

### 9.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§3.2 - Masterå®šç†ï¼ˆäºŒåˆ†æœç´¢çš„å¤æ‚åº¦åˆ†æï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§3.8 - ä¿¡æ¯è®ºä¸‹ç•Œï¼ˆæœç´¢ç®—æ³•çš„ä¸‹ç•Œï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£ä¸¥æ ¼éµå¾ªæ•°å­¦å½¢å¼åŒ–è§„èŒƒï¼Œæ‰€æœ‰å®šä¹‰å’Œå®šç†å‡é‡‡ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·è¡¨ç¤ºï¼Œå¹¶ç¬¦åˆå›½é™…é¡¶çº§å­¦æœ¯æœŸåˆŠæ ‡å‡†ã€‚*
