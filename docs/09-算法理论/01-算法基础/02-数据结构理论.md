---
title: 9.1.2 æ•°æ®ç»“æ„ç†è®º / Data Structure Theory
version: 1.2
status: maintained
last_updated: 2025-01-12
owner: ç®—æ³•ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 9.1.2 æ•°æ®ç»“æ„ç†è®º / Data Structure Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€çº¿æ€§ç»“æ„ã€æ ‘ç»“æ„ã€å›¾ç»“æ„ä¸æ•£åˆ—ç»“æ„çš„å½¢å¼åŒ–æè¿°ä¸æ€§èƒ½åˆ†æè§†è§’ã€‚
- æä¾›å®ç°ç¤ºä¾‹å…¥å£ä¸è·¨æ–‡æ¡£é”šç‚¹ï¼Œä¾¿äºä¸ç®—æ³•è®¾è®¡ä¸å¤æ‚åº¦åˆ†æè”åŠ¨ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ADTï¼šæŠ½è±¡æ•°æ®ç±»å‹ä¸æ¥å£ä¸å˜å¼ã€‚
- ç»“æ„ä¸å˜å¼ï¼šé“¾è¡¨/æ ‘/å›¾çš„ç»“æ„æ€§çº¦æŸä¸éªŒè¯ã€‚
- æ€§èƒ½åº¦é‡ï¼šæ‘Šè¿˜/æœ€å/å¹³å‡å¤æ‚åº¦ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### å¿«é€Ÿå¯¼èˆª / Quick Links

- [ç›®å½•](#ç›®å½•--table-of-contents)
- [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ--basic-concepts)
- [çº¿æ€§ç»“æ„](#2-çº¿æ€§ç»“æ„--linear-structures)
- [æ ‘å½¢ç»“æ„](#3-æ ‘å½¢ç»“æ„--tree-structures)
- [å›¾ç»“æ„](#4-å›¾ç»“æ„--graph-structures)
- [æ•£åˆ—ç»“æ„](#5-æ•£åˆ—ç»“æ„--hash-structures)

## ç›®å½• / Table of Contents

- [9.1.2 æ•°æ®ç»“æ„ç†è®º / Data Structure Theory](#912-æ•°æ®ç»“æ„ç†è®º--data-structure-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)
- [æ¦‚è¿° / Overview](#æ¦‚è¿°--overview)
- [1. åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#1-åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [1.1 æ•°æ®ç»“æ„å®šä¹‰ / Data Structure Definition](#11-æ•°æ®ç»“æ„å®šä¹‰--data-structure-definition)
  - [1.2 æŠ½è±¡æ•°æ®ç±»å‹ / Abstract Data Types](#12-æŠ½è±¡æ•°æ®ç±»å‹--abstract-data-types)
  - [1.3 æ•°æ®ç»“æ„åˆ†ç±» / Data Structure Classification](#13-æ•°æ®ç»“æ„åˆ†ç±»--data-structure-classification)
- [2. çº¿æ€§ç»“æ„ / Linear Structures](#2-çº¿æ€§ç»“æ„--linear-structures)
  - [2.1 çº¿æ€§è¡¨ / Linear List](#21-çº¿æ€§è¡¨--linear-list)
  - [2.2 æ ˆ / Stack](#22-æ ˆ--stack)
  - [2.3 é˜Ÿåˆ— / Queue](#23-é˜Ÿåˆ—--queue)
  - [2.4 é“¾è¡¨ / Linked List](#24-é“¾è¡¨--linked-list)
- [3. æ ‘å½¢ç»“æ„ / Tree Structures](#3-æ ‘å½¢ç»“æ„--tree-structures)
  - [3.1 æ ‘çš„åŸºæœ¬æ¦‚å¿µ / Basic Tree Concepts](#31-æ ‘çš„åŸºæœ¬æ¦‚å¿µ--basic-tree-concepts)
  - [3.2 äºŒå‰æ ‘ / Binary Tree](#32-äºŒå‰æ ‘--binary-tree)
  - [3.3 äºŒå‰æœç´¢æ ‘ / Binary Search Tree](#33-äºŒå‰æœç´¢æ ‘--binary-search-tree)
  - [3.4 å¹³è¡¡æ ‘ / Balanced Tree](#34-å¹³è¡¡æ ‘--balanced-tree)
- [4. å›¾ç»“æ„ / Graph Structures](#4-å›¾ç»“æ„--graph-structures)
  - [4.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ / Basic Graph Concepts](#41-å›¾çš„åŸºæœ¬æ¦‚å¿µ--basic-graph-concepts)
  - [4.2 å›¾çš„éå† / Graph Traversal](#42-å›¾çš„éå†--graph-traversal)
  - [4.3 æœ€çŸ­è·¯å¾„ / Shortest Path](#43-æœ€çŸ­è·¯å¾„--shortest-path)
- [5. æ•£åˆ—ç»“æ„ / Hash Structures](#5-æ•£åˆ—ç»“æ„--hash-structures)
  - [5.1 æ•£åˆ—å‡½æ•° / Hash Function](#51-æ•£åˆ—å‡½æ•°--hash-function)
  - [5.2 å†²çªå¤„ç† / Collision Resolution](#52-å†²çªå¤„ç†--collision-resolution)
  - [5.3 æ•£åˆ—è¡¨æ€§èƒ½ / Hash Table Performance](#53-æ•£åˆ—è¡¨æ€§èƒ½--hash-table-performance)
- [6. å®ç°ç¤ºä¾‹ / Implementation Examples](#6-å®ç°ç¤ºä¾‹--implementation-examples)
  - [6.1 çº¿æ€§è¡¨å®ç° / Linear List Implementation](#61-çº¿æ€§è¡¨å®ç°--linear-list-implementation)
  - [6.2 æ ˆå®ç° / Stack Implementation](#62-æ ˆå®ç°--stack-implementation)
  - [6.3 é˜Ÿåˆ—å®ç° / Queue Implementation](#63-é˜Ÿåˆ—å®ç°--queue-implementation)
  - [6.4 äºŒå‰æ ‘å®ç° / Binary Tree Implementation](#64-äºŒå‰æ ‘å®ç°--binary-tree-implementation)
  - [6.5 æ•£åˆ—è¡¨å®ç° / Hash Table Implementation](#65-æ•£åˆ—è¡¨å®ç°--hash-table-implementation)
- [7. å‚è€ƒæ–‡çŒ® / References](#7-å‚è€ƒæ–‡çŒ®--references)
  - [7.1 ç»å…¸æ•™æ / Classic Textbooks](#71-ç»å…¸æ•™æ--classic-textbooks)
  - [7.2 Wikiæ¦‚å¿µå‚è€ƒ / Wiki Concept References](#72-wikiæ¦‚å¿µå‚è€ƒ--wiki-concept-references)
  - [7.3 å¤§å­¦è¯¾ç¨‹å‚è€ƒ / University Course References](#73-å¤§å­¦è¯¾ç¨‹å‚è€ƒ--university-course-references)
  - [7.4 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers](#74-é¡¶çº§æœŸåˆŠè®ºæ–‡--top-journal-papers)
    - [æ•°æ®ç»“æ„ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Data Structure Theory](#æ•°æ®ç»“æ„ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-data-structure-theory)
    - [æŠ½è±¡æ•°æ®ç±»å‹é¡¶çº§æœŸåˆŠ / Top Journals in Abstract Data Types](#æŠ½è±¡æ•°æ®ç±»å‹é¡¶çº§æœŸåˆŠ--top-journals-in-abstract-data-types)
    - [æ•°æ®ç»“æ„ä¼˜åŒ–é¡¶çº§æœŸåˆŠ / Top Journals in Data Structure Optimization](#æ•°æ®ç»“æ„ä¼˜åŒ–é¡¶çº§æœŸåˆŠ--top-journals-in-data-structure-optimization)
    - [æ•£åˆ—ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Hashing Theory](#æ•£åˆ—ç†è®ºé¡¶çº§æœŸåˆŠ--top-journals-in-hashing-theory)
    - [å›¾æ•°æ®ç»“æ„é¡¶çº§æœŸåˆŠ / Top Journals in Graph Data Structures](#å›¾æ•°æ®ç»“æ„é¡¶çº§æœŸåˆŠ--top-journals-in-graph-data-structures)
- [8. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#8-ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
  - [8.1 ç›¸å…³æ–‡æ¡£ / Related Documents](#81-ç›¸å…³æ–‡æ¡£--related-documents)
  - [8.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#82-çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
  - [8.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#83-viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)

---

## æ¦‚è¿° / Overview

æ•°æ®ç»“æ„æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­ç»„ç»‡å’Œå­˜å‚¨æ•°æ®çš„åŸºç¡€ç†è®ºã€‚æ ¹æ®[Cormen 2022]çš„å®šä¹‰ï¼Œæ•°æ®ç»“æ„æ˜¯ç»„ç»‡å’Œå­˜å‚¨æ•°æ®çš„æ–¹å¼ï¼ŒåŒ…å«æ•°æ®å…ƒç´ ä¹‹é—´çš„å…³ç³»å’Œæ“ä½œã€‚æ ¹æ®[Weiss 2011]çš„ç ”ç©¶ï¼Œæ•°æ®ç»“æ„å¯ä»¥åˆ†ä¸ºçº¿æ€§ç»“æ„ã€æ ‘å½¢ç»“æ„ã€å›¾ç»“æ„å’Œæ•£åˆ—ç»“æ„ç­‰ä¸»è¦ç±»å‹ï¼Œæ¯ç§ç±»å‹éƒ½æœ‰å…¶ç‰¹å®šçš„åº”ç”¨åœºæ™¯å’Œæ€§èƒ½ç‰¹å¾ã€‚æœ¬æ–‡æ¡£æ¶µç›–æ•°æ®ç»“æ„çš„ç†è®ºåŸºç¡€ã€ä¸»è¦ç±»å‹ã€å¤æ‚åº¦åˆ†æå’Œåº”ç”¨é¢†åŸŸã€‚

Data structures are fundamental theories in computer science for organizing and storing data. According to [Cormen 2022], a data structure is a way of organizing and storing data, including the relationships between data elements and operations. According to [Weiss 2011], data structures can be divided into major types such as linear structures, tree structures, graph structures, and hash structures, each with its specific application scenarios and performance characteristics. This document covers the theoretical foundations, major types, complexity analysis, and application areas of data structures.

**å­¦æœ¯å¼•ç”¨ / Academic Citations:**

- [Cormen 2022]: Cormen, T. H., et al. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
- [Weiss 2011]: Weiss, M. A. (2011). *Data Structures and Algorithm Analysis in C++* (4th ed.). Pearson. ISBN: 978-0132847377
- [Knuth 1997]: Knuth, D. E. (1997). *The Art of Computer Programming, Volume 1: Fundamental Algorithms* (3rd ed.). Addison-Wesley. ISBN: 978-0201896831

**Wikiæ¦‚å¿µå¯¹é½ / Wiki Concept Alignment:**

- [Data Structure](https://en.wikipedia.org/wiki/Data_structure) - æ•°æ®ç»“æ„çš„æ ‡å‡†å®šä¹‰
- [Abstract Data Type](https://en.wikipedia.org/wiki/Abstract_data_type) - æŠ½è±¡æ•°æ®ç±»å‹
- [Array](https://en.wikipedia.org/wiki/Array_data_structure) - æ•°ç»„
- [Linked List](https://en.wikipedia.org/wiki/Linked_list) - é“¾è¡¨

**å¤§å­¦è¯¾ç¨‹å¯¹æ ‡ / University Course Alignment:**

- MIT 6.006: Introduction to Algorithms - æ•°æ®ç»“æ„åŸºç¡€
- Stanford CS161: Design and Analysis of Algorithms - æ•°æ®ç»“æ„è®¾è®¡ä¸åˆ†æ
- CMU 15-451: Algorithm Design and Analysis - é«˜çº§æ•°æ®ç»“æ„æŠ€æœ¯

## 1. åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### 1.1 æ•°æ®ç»“æ„å®šä¹‰ / Data Structure Definition

**å®šä¹‰ 1.1.1** (æ•°æ®ç»“æ„) [Cormen 2022, Wikipedia Data Structure]
æ•°æ®ç»“æ„æ˜¯ç»„ç»‡å’Œå­˜å‚¨æ•°æ®çš„æ–¹å¼ï¼ŒåŒ…å«æ•°æ®å…ƒç´ ä¹‹é—´çš„å…³ç³»å’Œæ“ä½œã€‚
**Definition 1.1.1** (Data Structure) [Cormen 2022, Wikipedia Data Structure]
A data structure is a way of organizing and storing data, including the relationships between data elements and operations.

**Wikiæ¦‚å¿µå¯¹é½ / Wiki Concept Alignment:**

| é¡¹ç›®æ¦‚å¿µ | Wikiæ¡ç›® | æ ‡å‡†å®šä¹‰ | å¯¹é½çŠ¶æ€ |
|---------|---------|---------|---------|
| æ•°æ®ç»“æ„ | [Data Structure](https://en.wikipedia.org/wiki/Data_structure) | ç»„ç»‡å’Œå­˜å‚¨æ•°æ®çš„æ–¹å¼ | âœ… å·²å¯¹é½ |
| æŠ½è±¡æ•°æ®ç±»å‹ | [Abstract Data Type](https://en.wikipedia.org/wiki/Abstract_data_type) | æ•°æ®ç±»å‹çš„æ•°å­¦æ¨¡å‹ | âœ… å·²å¯¹é½ |
| æ•°ç»„ | [Array](https://en.wikipedia.org/wiki/Array_data_structure) | è¿ç»­å†…å­˜å­˜å‚¨çš„æ•°æ®ç»“æ„ | âœ… å·²å¯¹é½ |
| é“¾è¡¨ | [Linked List](https://en.wikipedia.org/wiki/Linked_list) | é€šè¿‡æŒ‡é’ˆè¿æ¥çš„æ•°æ®ç»“æ„ | âœ… å·²å¯¹é½ |

**æ•°æ®ç»“æ„çŸ¥è¯†ä½“ç³» / Data Structure Knowledge System:**

```mermaid
mindmap
  root((æ•°æ®ç»“æ„<br/>Data Structure))
    åŸºæœ¬æ¦‚å¿µ
      æ•°æ®ç»“æ„å®šä¹‰
        æ•°æ®å…ƒç´ 
        å…³ç³»
        æ“ä½œ
      æŠ½è±¡æ•°æ®ç±»å‹
        ADTå®šä¹‰
        æ¥å£è§„èŒƒ
        å®ç°åˆ†ç¦»
      æ•°æ®ç»“æ„åˆ†ç±»
        çº¿æ€§ç»“æ„
        æ ‘å½¢ç»“æ„
        å›¾ç»“æ„
        æ•£åˆ—ç»“æ„
    çº¿æ€§ç»“æ„
      æ•°ç»„
        è¿ç»­å­˜å‚¨
        éšæœºè®¿é—®
      é“¾è¡¨
        åŠ¨æ€åˆ†é…
        é¡ºåºè®¿é—®
      æ ˆ
        LIFO
        é€’å½’å®ç°
      é˜Ÿåˆ—
        FIFO
        å¹¿åº¦ä¼˜å…ˆ
    æ ‘å½¢ç»“æ„
      äºŒå‰æ ‘
        é€’å½’ç»“æ„
        éå†ç®—æ³•
      äºŒå‰æœç´¢æ ‘
        æœ‰åºæ€§
        æœç´¢æ•ˆç‡
      å¹³è¡¡æ ‘
        AVLæ ‘
        çº¢é»‘æ ‘
      Bæ ‘
        å¤šè·¯æœç´¢
        æ•°æ®åº“ç´¢å¼•
    å›¾ç»“æ„
      å›¾çš„è¡¨ç¤º
        é‚»æ¥çŸ©é˜µ
        é‚»æ¥è¡¨
      å›¾çš„éå†
        DFS
        BFS
      æœ€çŸ­è·¯å¾„
        Dijkstra
        Floyd
    æ•£åˆ—ç»“æ„
      æ•£åˆ—å‡½æ•°
        é™¤ç•™ä½™æ•°æ³•
        ä¹˜æ³•æ•£åˆ—
      å†²çªå¤„ç†
        é“¾åœ°å€æ³•
        å¼€æ”¾åœ°å€æ³•
      æ•£åˆ—è¡¨æ€§èƒ½
        è´Ÿè½½å› å­
        å†æ•£åˆ—
    åº”ç”¨é¢†åŸŸ
      æ•°æ®åº“
        ç´¢å¼•ç»“æ„
        æŸ¥è¯¢ä¼˜åŒ–
      æ“ä½œç³»ç»Ÿ
        å†…å­˜ç®¡ç†
        æ–‡ä»¶ç³»ç»Ÿ
      ç®—æ³•åŸºç¡€
        å…¶ä»–ç®—æ³•
        å¤æ‚åº¦åˆ†æ
```

**æ•°æ®ç»“æ„æ“ä½œå¤æ‚åº¦å¯¹æ¯” / Data Structure Operation Complexity Comparison:**

| æ•°æ®ç»“æ„ | è®¿é—® | æœç´¢ | æ’å…¥ | åˆ é™¤ | ç©ºé—´å¤æ‚åº¦ | å‚è€ƒæ–‡çŒ® |
|---------|------|------|------|------|-----------|---------|
| æ•°ç»„ | $O(1)$ | $O(n)$ | $O(n)$ | $O(n)$ | $O(n)$ | [Cormen 2022] |
| é“¾è¡¨ | $O(n)$ | $O(n)$ | $O(1)$ | $O(1)$ | $O(n)$ | [Cormen 2022] |
| æ ˆ | $O(1)$ | - | $O(1)$ | $O(1)$ | $O(n)$ | [Cormen 2022] |
| é˜Ÿåˆ— | $O(1)$ | - | $O(1)$ | $O(1)$ | $O(n)$ | [Cormen 2022] |
| äºŒå‰æœç´¢æ ‘ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(n)$ | [Cormen 2022] |
| AVLæ ‘ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(n)$ | [Cormen 2022] |
| çº¢é»‘æ ‘ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(n)$ | [Cormen 2022] |
| æ•£åˆ—è¡¨ | $O(1)$ | $O(1)$ | $O(1)$ | $O(1)$ | $O(n)$ | [Cormen 2022] |
| Bæ ‘ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(n)$ | [Cormen 2022] |

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**
æ•°æ®ç»“æ„ $DS$ å¯ä»¥è¡¨ç¤ºä¸ºå››å…ƒç»„ï¼š
Data structure $DS$ can be represented as a quadruple:
$$DS = (D, R, O, C)$$

å…¶ä¸­ / where:

- $D$ æ˜¯æ•°æ®å…ƒç´ çš„é›†åˆ / is the set of data elements
- $R$ æ˜¯æ•°æ®å…ƒç´ é—´å…³ç³»çš„é›†åˆ / is the set of relationships between data elements
- $O$ æ˜¯æ“ä½œçš„é›†åˆ / is the set of operations
- $C$ æ˜¯çº¦æŸæ¡ä»¶çš„é›†åˆ / is the set of constraints

### 1.2 æŠ½è±¡æ•°æ®ç±»å‹ / Abstract Data Types

**å®šä¹‰ 1.2.1** æŠ½è±¡æ•°æ®ç±»å‹(ADT)æ˜¯æ•°æ®ç±»å‹çš„æ•°å­¦æ¨¡å‹ï¼ŒåŒ…å«ï¼š
**Definition 1.2.1** An Abstract Data Type (ADT) is a mathematical model of a data type, including:

- æ•°æ®å¯¹è±¡é›†åˆ / Set of data objects
- æ•°æ®å¯¹è±¡ä¸Šçš„æ“ä½œé›†åˆ / Set of operations on data objects
- æ“ä½œçš„è¯­ä¹‰æè¿° / Semantic description of operations

**å®šä¹‰ 1.2.2** ADTçš„ä»£æ•°è§„èŒƒï¼š
**Definition 1.2.2** Algebraic specification of ADT:
$$\text{ADT} = (\Sigma, E)$$

å…¶ä¸­ $\Sigma$ æ˜¯ç­¾åï¼Œ$E$ æ˜¯ç­‰å¼é›†åˆã€‚
where $\Sigma$ is the signature and $E$ is the set of equations.

### 1.3 æ•°æ®ç»“æ„åˆ†ç±» / Data Structure Classification

**å®šä¹‰ 1.3.1** æŒ‰é€»è¾‘ç»“æ„åˆ†ç±»ï¼š
**Definition 1.3.1** Classification by logical structure:

1. **çº¿æ€§ç»“æ„ / Linear Structure**: å…ƒç´ é—´æ˜¯ä¸€å¯¹ä¸€å…³ç³» / Elements have one-to-one relationships
2. **æ ‘å½¢ç»“æ„ / Tree Structure**: å…ƒç´ é—´æ˜¯ä¸€å¯¹å¤šå…³ç³» / Elements have one-to-many relationships
3. **å›¾ç»“æ„ / Graph Structure**: å…ƒç´ é—´æ˜¯å¤šå¯¹å¤šå…³ç³» / Elements have many-to-many relationships
4. **æ•£åˆ—ç»“æ„ / Hash Structure**: é€šè¿‡æ•£åˆ—å‡½æ•°ç»„ç»‡æ•°æ® / Organize data through hash functions

**å®šä¹‰ 1.3.2** æŒ‰å­˜å‚¨ç»“æ„åˆ†ç±»ï¼š
**Definition 1.3.2** Classification by storage structure:

1. **é¡ºåºå­˜å‚¨ / Sequential Storage**: ç”¨è¿ç»­çš„å­˜å‚¨å•å…ƒå­˜å‚¨ / Store in contiguous storage units
2. **é“¾å¼å­˜å‚¨ / Linked Storage**: ç”¨æŒ‡é’ˆé“¾æ¥çš„å­˜å‚¨å•å…ƒ / Store in pointer-linked storage units
3. **ç´¢å¼•å­˜å‚¨ / Indexed Storage**: å»ºç«‹ç´¢å¼•è¡¨ / Establish index tables
4. **æ•£åˆ—å­˜å‚¨ / Hash Storage**: é€šè¿‡æ•£åˆ—å‡½æ•°ç›´æ¥å®šä½ / Directly locate through hash functions

---

## 2. çº¿æ€§ç»“æ„ / Linear Structures

### 2.1 çº¿æ€§è¡¨ / Linear List

**å®šä¹‰ 2.1.1** çº¿æ€§è¡¨æ˜¯å…·æœ‰ç›¸åŒæ•°æ®ç±»å‹çš„ $n$ ä¸ªæ•°æ®å…ƒç´ çš„æœ‰é™åºåˆ—ï¼š
**Definition 2.1.1** A linear list is a finite sequence of $n$ data elements of the same data type:
$$L = (a_1, a_2, \ldots, a_n)$$

å…¶ä¸­ $a_i$ æ˜¯æ•°æ®å…ƒç´ ï¼Œ$n$ æ˜¯è¡¨é•¿ã€‚
where $a_i$ are data elements and $n$ is the length of the list.

**å®šä¹‰ 2.1.2** çº¿æ€§è¡¨çš„åŸºæœ¬æ“ä½œï¼š
**Definition 2.1.2** Basic operations of linear list:

- **æ’å…¥ / Insert**: $Insert(L, i, e)$
- **åˆ é™¤ / Delete**: $Delete(L, i)$
- **æŸ¥æ‰¾ / Search**: $Search(L, e)$
- **è®¿é—® / Access**: $Access(L, i)$

### 2.2 æ ˆ / Stack

**å®šä¹‰ 2.2.1** æ ˆæ˜¯åè¿›å…ˆå‡º(LIFO)çš„çº¿æ€§è¡¨ã€‚
**Definition 2.2.1** A stack is a linear list with last-in-first-out (LIFO) order.

**æ ˆæ“ä½œï¼š**
**Stack operations:**

- **å…¥æ ˆ / Push**: $Push(S, e)$
- **å‡ºæ ˆ / Pop**: $Pop(S)$
- **å–æ ˆé¡¶ / Top**: $Top(S)$
- **åˆ¤ç©º / IsEmpty**: $IsEmpty(S)$

**å®šç† 2.2.1** æ ˆçš„æ·±åº¦ä¼˜å…ˆæ€§è´¨ï¼š
**Theorem 2.2.1** Stack's depth-first property:
å¯¹äºä»»æ„æ ˆ $S$ å’Œå…ƒç´  $e$ï¼Œå¦‚æœ $Push(S, e)$ åç«‹å³ $Pop(S)$ï¼Œåˆ™è¿”å› $e$ã€‚
For any stack $S$ and element $e$, if $Push(S, e)$ is immediately followed by $Pop(S)$, it returns $e$.

### 2.3 é˜Ÿåˆ— / Queue

**å®šä¹‰ 2.3.1** é˜Ÿåˆ—æ˜¯å…ˆè¿›å…ˆå‡º(FIFO)çš„çº¿æ€§è¡¨ã€‚
**Definition 2.3.1** A queue is a linear list with first-in-first-out (FIFO) order.

**é˜Ÿåˆ—æ“ä½œï¼š**
**Queue operations:**

- **å…¥é˜Ÿ / Enqueue**: $Enqueue(Q, e)$
- **å‡ºé˜Ÿ / Dequeue**: $Dequeue(Q)$
- **å–é˜Ÿé¦– / Front**: $Front(Q)$
- **åˆ¤ç©º / IsEmpty**: $IsEmpty(Q)$

**å®šç† 2.3.1** é˜Ÿåˆ—çš„å¹¿åº¦ä¼˜å…ˆæ€§è´¨ï¼š
**Theorem 2.3.1** Queue's breadth-first property:
å¯¹äºä»»æ„é˜Ÿåˆ— $Q$ å’Œå…ƒç´  $e_1, e_2$ï¼Œå¦‚æœ $Enqueue(Q, e_1)$ å $Enqueue(Q, e_2)$ï¼Œåˆ™ $Dequeue(Q)$ è¿”å› $e_1$ã€‚
For any queue $Q$ and elements $e_1, e_2$, if $Enqueue(Q, e_1)$ is followed by $Enqueue(Q, e_2)$, then $Dequeue(Q)$ returns $e_1$.

### 2.4 é“¾è¡¨ / Linked List

**å®šä¹‰ 2.4.1** é“¾è¡¨æ˜¯ç”±èŠ‚ç‚¹ç»„æˆçš„çº¿æ€§ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«æ•°æ®å’ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
**Definition 2.4.1** A linked list is a linear structure composed of nodes, each containing data and a pointer to the next node.

**å•é“¾è¡¨èŠ‚ç‚¹ï¼š**
**Single linked list node:**

```rust
#[derive(Debug, Clone)]
pub struct Node<T> {
    pub data: T,
    pub next: Option<Box<Node<T>>>,
}
```

**å®šä¹‰ 2.4.2** é“¾è¡¨çš„æ“ä½œå¤æ‚åº¦ï¼š
**Definition 2.4.2** Complexity of linked list operations:

- **æ’å…¥ / Insert**: $O(1)$ (å·²çŸ¥ä½ç½®) / $O(1)$ (known position)
- **åˆ é™¤ / Delete**: $O(1)$ (å·²çŸ¥ä½ç½®) / $O(1)$ (known position)
- **æŸ¥æ‰¾ / Search**: $O(n)$ / $O(n)$
- **è®¿é—® / Access**: $O(n)$ / $O(n)$

---

## 3. æ ‘å½¢ç»“æ„ / Tree Structures

### 3.1 æ ‘çš„åŸºæœ¬æ¦‚å¿µ / Basic Tree Concepts

**å®šä¹‰ 3.1.1** æ ‘æ˜¯ $n$ ä¸ªèŠ‚ç‚¹çš„æœ‰é™é›†åˆï¼Œå…¶ä¸­ï¼š
**Definition 3.1.1** A tree is a finite set of $n$ nodes, where:

- æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ / There is exactly one root node
- å…¶ä½™èŠ‚ç‚¹åˆ†ä¸º $m$ ä¸ªäº’ä¸ç›¸äº¤çš„å­æ ‘ / The remaining nodes are divided into $m$ disjoint subtrees

**å®šä¹‰ 3.1.2** æ ‘çš„é«˜åº¦ï¼š
**Definition 3.1.2** Tree height:
$$h(T) = \max_{v \in T} \text{depth}(v)$$

å…¶ä¸­ $\text{depth}(v)$ æ˜¯èŠ‚ç‚¹ $v$ çš„æ·±åº¦ã€‚
where $\text{depth}(v)$ is the depth of node $v$.

**å®šç† 3.1.1** å¯¹äºæœ‰ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼š
**Theorem 3.1.1** For a tree with $n$ nodes:
$$h(T) \leq n-1$$

### 3.2 äºŒå‰æ ‘ / Binary Tree

**å®šä¹‰ 3.2.1** äºŒå‰æ ‘æ˜¯æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„æ ‘ã€‚
**Definition 3.2.1** A binary tree is a tree where each node has at most two children.

**äºŒå‰æ ‘æ€§è´¨ï¼š**
**Binary tree properties:**

1. **ç¬¬ $i$ å±‚æœ€å¤šèŠ‚ç‚¹æ•° / Number of nodes in level $i$**: $2^{i-1}$
2. **æ·±åº¦ä¸º $h$ çš„æ ‘æœ€å¤šèŠ‚ç‚¹æ•° / Maximum number of nodes in a tree of depth $h$**: $2^h - 1$
3. **$n$ ä¸ªèŠ‚ç‚¹çš„äºŒå‰æ ‘é«˜åº¦ / Height of a binary tree with $n$ nodes**: $\lceil \log_2(n+1) \rceil$

**å®šä¹‰ 3.2.2** å®Œå…¨äºŒå‰æ ‘ï¼š
**Definition 3.2.2** A complete binary tree:
é™¤æœ€åä¸€å±‚å¤–ï¼Œå…¶ä»–å±‚çš„èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ã€‚
Except for the last level, the number of nodes in other levels reaches the maximum.

### 3.3 äºŒå‰æœç´¢æ ‘ / Binary Search Tree

**å®šä¹‰ 3.3.1** äºŒå‰æœç´¢æ ‘(BST)æ˜¯æ»¡è¶³ä»¥ä¸‹æ€§è´¨çš„äºŒå‰æ ‘ï¼š
**Definition 3.3.1** A binary search tree (BST) is a binary tree that satisfies the following properties:

- å·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼å°äºæ ¹èŠ‚ç‚¹ / All node values in the left subtree are less than the root node
- å³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼å¤§äºæ ¹èŠ‚ç‚¹ / All node values in the right subtree are greater than the root node
- å·¦å³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘ / Both left and right subtrees are binary search trees

**å®šç† 3.3.1** BSTçš„ä¸­åºéå†äº§ç”Ÿæœ‰åºåºåˆ—ã€‚
**Theorem 3.3.1** In-order traversal of a BST produces an ordered sequence.

**å®šä¹‰ 3.3.2** BSTæ“ä½œå¤æ‚åº¦ï¼š
**Definition 3.3.2** Complexity of BST operations:

- **æŸ¥æ‰¾ / Search**: $O(h)$ï¼Œå…¶ä¸­ $h$ æ˜¯æ ‘é«˜ / $O(h)$, where $h$ is the tree height
- **æ’å…¥ / Insert**: $O(h)$ / $O(h)$
- **åˆ é™¤ / Delete**: $O(h)$ / $O(h)$

### 3.4 å¹³è¡¡æ ‘ / Balanced Tree

**å®šä¹‰ 3.4.1** AVLæ ‘æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„äºŒå‰æœç´¢æ ‘ï¼š
**Definition 3.4.1** An AVL tree is a binary search tree that satisfies the following conditions:
å¯¹äºä»»æ„èŠ‚ç‚¹ï¼Œå·¦å³å­æ ‘é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ã€‚
For any node, the absolute difference in height between the left and right subtrees is not more than 1.

**å®šä¹‰ 3.4.2** çº¢é»‘æ ‘æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„äºŒå‰æœç´¢æ ‘ï¼š
**Definition 3.4.2** A red-black tree is a binary search tree that satisfies the following conditions:

1. æ¯ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰² / Each node is either red or black
2. æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰² / The root node is black
3. çº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰² / The children of red nodes are black
4. ä»æ ¹åˆ°å¶å­çš„æ‰€æœ‰è·¯å¾„åŒ…å«ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹ / All paths from the root to the leaves contain the same number of black nodes

**å®šç† 3.4.1** çº¢é»‘æ ‘çš„é«˜åº¦ä¸º $O(\log n)$ã€‚
**Theorem 3.4.1** The height of a red-black tree is $O(\log n)$.

---

## 4. å›¾ç»“æ„ / Graph Structures

### 4.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ / Basic Graph Concepts

**å®šä¹‰ 4.1.1** å›¾ $G = (V, E)$ ç”±é¡¶ç‚¹é›† $V$ å’Œè¾¹é›† $E$ ç»„æˆã€‚
**Definition 4.1.1** A graph $G = (V, E)$ consists of a vertex set $V$ and an edge set $E$.

**å®šä¹‰ 4.1.2** å›¾çš„ç±»å‹ï¼š
**Definition 4.1.2** Types of graphs:

- **æ— å‘å›¾ / Undirected Graph**: è¾¹æ²¡æœ‰æ–¹å‘ / Edges have no direction
- **æœ‰å‘å›¾ / Directed Graph**: è¾¹æœ‰æ–¹å‘ / Edges have direction
- **åŠ æƒå›¾ / Weighted Graph**: è¾¹æœ‰æƒé‡ / Edges have weights
- **å¤šé‡å›¾ / Multigraph**: å…è®¸é‡è¾¹ / Allow multiple edges

**å®šä¹‰ 4.1.3** å›¾çš„è¡¨ç¤ºï¼š
**Definition 4.1.3** Graph representation:

1. **é‚»æ¥çŸ©é˜µ / Adjacency Matrix**: $A[i][j] = 1$ è¡¨ç¤ºé¡¶ç‚¹ $i$ å’Œ $j$ ç›¸é‚» / $A[i][j] = 1$ indicates that vertex $i$ and $j$ are adjacent
2. **é‚»æ¥è¡¨ / Adjacency List**: æ¯ä¸ªé¡¶ç‚¹ç»´æŠ¤å…¶é‚»æ¥é¡¶ç‚¹åˆ—è¡¨ / Each vertex maintains a list of its adjacent vertices

### 4.2 å›¾çš„éå† / Graph Traversal

**å®šä¹‰ 4.2.1** æ·±åº¦ä¼˜å…ˆæœç´¢(DFS)ï¼š
**Definition 4.2.1** Depth-first search (DFS):

```rust
fn dfs(graph: &Graph, start: usize, visited: &mut Vec<bool>) {
    visited[start] = true;
    println!("è®¿é—®èŠ‚ç‚¹: {}", start);

    for &neighbor in &graph.adjacency_list[start] {
        if !visited[neighbor] {
            dfs(graph, neighbor, visited);
        }
    }
}
```

**å®šä¹‰ 4.2.2** å¹¿åº¦ä¼˜å…ˆæœç´¢(BFS)ï¼š
**Definition 4.2.2** Breadth-first search (BFS):

```rust
fn bfs(graph: &Graph, start: usize) {
    let mut queue = VecDeque::new();
    let mut visited = vec![false; graph.vertex_count];

    queue.push_back(start);
    visited[start] = true;

    while let Some(vertex) = queue.pop_front() {
        println!("è®¿é—®èŠ‚ç‚¹: {}", vertex);

        for &neighbor in &graph.adjacency_list[vertex] {
            if !visited[neighbor] {
                visited[neighbor] = true;
                queue.push_back(neighbor);
            }
        }
    }
}
```

### 4.3 æœ€çŸ­è·¯å¾„ / Shortest Path

**å®šä¹‰ 4.3.1** Dijkstraç®—æ³•ï¼š
**Definition 4.3.1** Dijkstra's algorithm:

```rust
fn dijkstra(graph: &Graph, start: usize) -> Vec<usize> {
    let mut distances = vec![usize::MAX; graph.vertex_count];
    let mut visited = vec![false; graph.vertex_count];

    distances[start] = 0;

    for _ in 0..graph.vertex_count {
        let u = min_distance_vertex(&distances, &visited);
        visited[u] = true;

        for v in 0..graph.vertex_count {
            if !visited[v] && graph.adjacency_matrix[u][v] != 0 {
                let new_distance = distances[u] + graph.adjacency_matrix[u][v];
                if new_distance < distances[v] {
                    distances[v] = new_distance;
                }
            }
        }
    }

    distances
}
```

**å®šç† 4.3.1** Dijkstraç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(V^2)$ï¼Œå…¶ä¸­ $V$ æ˜¯é¡¶ç‚¹æ•°ã€‚
**Theorem 4.3.1** The time complexity of Dijkstra's algorithm is $O(V^2)$, where $V$ is the number of vertices.

---

## 5. æ•£åˆ—ç»“æ„ / Hash Structures

### 5.1 æ•£åˆ—å‡½æ•° / Hash Function

**å®šä¹‰ 5.1.1** æ•£åˆ—å‡½æ•°æ˜¯å°†å…³é”®å­—æ˜ å°„åˆ°åœ°å€çš„å‡½æ•°ï¼š
**Definition 5.1.1** A hash function is a function that maps keys to addresses:
$$h: K \rightarrow A$$

å…¶ä¸­ $K$ æ˜¯å…³é”®å­—é›†åˆï¼Œ$A$ æ˜¯åœ°å€é›†åˆã€‚
where $K$ is the set of keys and $A$ is the set of addresses.

**å®šä¹‰ 5.1.2** ç†æƒ³æ•£åˆ—å‡½æ•°åº”æ»¡è¶³ï¼š
**Definition 5.1.2** An ideal hash function should satisfy:

1. **å‡åŒ€æ€§ / Uniformity**: å…³é”®å­—å‡åŒ€åˆ†å¸ƒ / Keys are uniformly distributed
2. **éšæœºæ€§ / Randomness**: æ•£åˆ—å€¼éšæœºåˆ†å¸ƒ / Hash values are randomly distributed
3. **é«˜æ•ˆæ€§ / Efficiency**: è®¡ç®—é€Ÿåº¦å¿« / Calculation speed is fast

### 5.2 å†²çªå¤„ç† / Collision Resolution

**å®šä¹‰ 5.2.1** å¼€æ”¾å¯»å€æ³•ï¼š
**Definition 5.2.1** Open addressing:
å½“å‘ç”Ÿå†²çªæ—¶ï¼Œåœ¨æ•£åˆ—è¡¨ä¸­å¯»æ‰¾ä¸‹ä¸€ä¸ªç©ºä½ç½®ã€‚
When a collision occurs, find the next empty position in the hash table.

**çº¿æ€§æ¢æµ‹ / Linear probing**:
**Linear probing**:
$$h_i(k) = (h(k) + i) \bmod m$$

**äºŒæ¬¡æ¢æµ‹ / Quadratic probing**:
**Quadratic probing**:
$$h_i(k) = (h(k) + i^2) \bmod m$$

**å®šä¹‰ 5.2.2** é“¾åœ°å€æ³•ï¼š
**Definition 5.2.2** Chaining:
å°†å†²çªçš„å…ƒç´ å­˜å‚¨åœ¨é“¾è¡¨ä¸­ã€‚
Store collision elements in a linked list.

### 5.3 æ•£åˆ—è¡¨æ€§èƒ½ / Hash Table Performance

**å®šä¹‰ 5.3.1** è£…å¡«å› å­ï¼š
**Definition 5.3.1** Load factor:
$$\alpha = \frac{n}{m}$$

å…¶ä¸­ $n$ æ˜¯å…ƒç´ ä¸ªæ•°ï¼Œ$m$ æ˜¯æ•£åˆ—è¡¨å¤§å°ã€‚
where $n$ is the number of elements and $m$ is the hash table size.

**å®šç† 5.3.1** å¯¹äºå¼€æ”¾å¯»å€æ³•ï¼Œå¹³å‡æŸ¥æ‰¾é•¿åº¦ï¼š
**Theorem 5.3.1** For open addressing, average search length:
$$ASL = \frac{1}{2}\left(1 + \frac{1}{1-\alpha}\right)$$

---

## 6. å®ç°ç¤ºä¾‹ / Implementation Examples

### 6.1 çº¿æ€§è¡¨å®ç° / Linear List Implementation

```rust
use std::fmt::Debug;

/// çº¿æ€§è¡¨ç‰¹å¾ / Linear List Trait
pub trait LinearList<T> {
    fn insert(&mut self, index: usize, element: T) -> Result<(), String>;
    fn delete(&mut self, index: usize) -> Result<T, String>;
    fn get(&self, index: usize) -> Result<&T, String>;
    fn set(&mut self, index: usize, element: T) -> Result<(), String>;
    fn length(&self) -> usize;
    fn is_empty(&self) -> bool;
}

/// é¡ºåºè¡¨å®ç° / Sequential List Implementation
pub struct ArrayList<T> {
    data: Vec<T>,
}

impl<T: Clone + Debug> ArrayList<T> {
    pub fn new() -> Self {
        ArrayList { data: Vec::new() }
    }

    pub fn with_capacity(capacity: usize) -> Self {
        ArrayList {
            data: Vec::with_capacity(capacity)
        }
    }
}

impl<T: Clone + Debug> LinearList<T> for ArrayList<T> {
    fn insert(&mut self, index: usize, element: T) -> Result<(), String> {
        if index > self.data.len() {
            return Err("ç´¢å¼•è¶…å‡ºèŒƒå›´".to_string());
        }

        self.data.insert(index, element);
        Ok(())
    }

    fn delete(&mut self, index: usize) -> Result<T, String> {
        if index >= self.data.len() {
            return Err("ç´¢å¼•è¶…å‡ºèŒƒå›´".to_string());
        }

        Ok(self.data.remove(index))
    }

    fn get(&self, index: usize) -> Result<&T, String> {
        self.data.get(index).ok_or("ç´¢å¼•è¶…å‡ºèŒƒå›´".to_string())
    }

    fn set(&mut self, index: usize, element: T) -> Result<(), String> {
        if index >= self.data.len() {
            return Err("ç´¢å¼•è¶…å‡ºèŒƒå›´".to_string());
        }

        self.data[index] = element;
        Ok(())
    }

    fn length(&self) -> usize {
        self.data.len()
    }

    fn is_empty(&self) -> bool {
        self.data.is_empty()
    }
}
```

### 6.2 æ ˆå®ç° / Stack Implementation

```rust
/// æ ˆç‰¹å¾ / Stack Trait
pub trait Stack<T> {
    fn push(&mut self, element: T);
    fn pop(&mut self) -> Option<T>;
    fn peek(&self) -> Option<&T>;
    fn is_empty(&self) -> bool;
    fn size(&self) -> usize;
}

/// é¡ºåºæ ˆå®ç° / Sequential Stack Implementation
pub struct ArrayStack<T> {
    data: Vec<T>,
}

impl<T> ArrayStack<T> {
    pub fn new() -> Self {
        ArrayStack { data: Vec::new() }
    }

    pub fn with_capacity(capacity: usize) -> Self {
        ArrayStack {
            data: Vec::with_capacity(capacity)
        }
    }
}

impl<T> Stack<T> for ArrayStack<T> {
    fn push(&mut self, element: T) {
        self.data.push(element);
    }

    fn pop(&mut self) -> Option<T> {
        self.data.pop()
    }

    fn peek(&self) -> Option<&T> {
        self.data.last()
    }

    fn is_empty(&self) -> bool {
        self.data.is_empty()
    }

    fn size(&self) -> usize {
        self.data.len()
    }
}
```

### 6.3 é˜Ÿåˆ—å®ç° / Queue Implementation

```rust
use std::collections::VecDeque;

/// é˜Ÿåˆ—ç‰¹å¾ / Queue Trait
pub trait Queue<T> {
    fn enqueue(&mut self, element: T);
    fn dequeue(&mut self) -> Option<T>;
    fn front(&self) -> Option<&T>;
    fn is_empty(&self) -> bool;
    fn size(&self) -> usize;
}

/// é¡ºåºé˜Ÿåˆ—å®ç° / Sequential Queue Implementation
pub struct ArrayQueue<T> {
    data: VecDeque<T>,
}

impl<T> ArrayQueue<T> {
    pub fn new() -> Self {
        ArrayQueue {
            data: VecDeque::new()
        }
    }

    pub fn with_capacity(capacity: usize) -> Self {
        ArrayQueue {
            data: VecDeque::with_capacity(capacity)
        }
    }
}

impl<T> Queue<T> for ArrayQueue<T> {
    fn enqueue(&mut self, element: T) {
        self.data.push_back(element);
    }

    fn dequeue(&mut self) -> Option<T> {
        self.data.pop_front()
    }

    fn front(&self) -> Option<&T> {
        self.data.front()
    }

    fn is_empty(&self) -> bool {
        self.data.is_empty()
    }

    fn size(&self) -> usize {
        self.data.len()
    }
}
```

### 6.4 äºŒå‰æ ‘å®ç° / Binary Tree Implementation

```rust
use std::fmt::Debug;

#[derive(Debug, Clone)]
pub struct TreeNode<T> {
    pub data: T,
    pub left: Option<Box<TreeNode<T>>>,
    pub right: Option<Box<TreeNode<T>>>,
}

impl<T> TreeNode<T> {
    pub fn new(data: T) -> Self {
        TreeNode {
            data,
            left: None,
            right: None,
        }
    }
}

/// äºŒå‰æ ‘ç‰¹å¾ / Binary Tree Trait
pub trait BinaryTree<T> {
    fn insert(&mut self, data: T);
    fn delete(&mut self, data: &T) -> bool;
    fn search(&self, data: &T) -> bool;
    fn inorder_traversal(&self) -> Vec<&T>;
    fn preorder_traversal(&self) -> Vec<&T>;
    fn postorder_traversal(&self) -> Vec<&T>;
}

/// äºŒå‰æœç´¢æ ‘å®ç° / Binary Search Tree Implementation
pub struct BinarySearchTree<T> {
    root: Option<Box<TreeNode<T>>>,
}

impl<T: Ord + Debug> BinarySearchTree<T> {
    pub fn new() -> Self {
        BinarySearchTree { root: None }
    }

    fn insert_recursive(node: &mut Option<Box<TreeNode<T>>>, data: T) {
        match node {
            None => {
                *node = Some(Box::new(TreeNode::new(data)));
            }
            Some(ref mut current) => {
                if data < current.data {
                    Self::insert_recursive(&mut current.left, data);
                } else if data > current.data {
                    Self::insert_recursive(&mut current.right, data);
                }
            }
        }
    }

    fn search_recursive(node: &Option<Box<TreeNode<T>>>, data: &T) -> bool {
        match node {
            None => false,
            Some(current) => {
                if data == &current.data {
                    true
                } else if data < &current.data {
                    Self::search_recursive(&current.left, data)
                } else {
                    Self::search_recursive(&current.right, data)
                }
            }
        }
    }

    fn inorder_recursive(node: &Option<Box<TreeNode<T>>>, result: &mut Vec<&T>) {
        if let Some(current) = node {
            Self::inorder_recursive(&current.left, result);
            result.push(&current.data);
            Self::inorder_recursive(&current.right, result);
        }
    }
}

impl<T: Ord + Debug> BinaryTree<T> for BinarySearchTree<T> {
    fn insert(&mut self, data: T) {
        Self::insert_recursive(&mut self.root, data);
    }

    fn delete(&mut self, data: &T) -> bool {
        // å®ç°åˆ é™¤é€»è¾‘
        false
    }

    fn search(&self, data: &T) -> bool {
        Self::search_recursive(&self.root, data)
    }

    fn inorder_traversal(&self) -> Vec<&T> {
        let mut result = Vec::new();
        Self::inorder_recursive(&self.root, &mut result);
        result
    }

    fn preorder_traversal(&self) -> Vec<&T> {
        // å®ç°å‰åºéå†
        Vec::new()
    }

    fn postorder_traversal(&self) -> Vec<&T> {
        // å®ç°ååºéå†
        Vec::new()
    }
}
```

### 6.5 æ•£åˆ—è¡¨å®ç° / Hash Table Implementation

```rust
use std::collections::HashMap;
use std::hash::Hash;

/// æ•£åˆ—è¡¨ç‰¹å¾ / Hash Table Trait
pub trait HashTable<K, V> {
    fn insert(&mut self, key: K, value: V) -> Option<V>;
    fn get(&self, key: &K) -> Option<&V>;
    fn remove(&mut self, key: &K) -> Option<V>;
    fn contains_key(&self, key: &K) -> bool;
    fn size(&self) -> usize;
    fn is_empty(&self) -> bool;
}

/// é“¾åœ°å€æ³•æ•£åˆ—è¡¨å®ç° / Chained Hash Table Implementation
pub struct ChainedHashTable<K, V> {
    buckets: Vec<Vec<(K, V)>>,
    size: usize,
    capacity: usize,
}

impl<K: Hash + Eq + Clone, V: Clone> ChainedHashTable<K, V> {
    pub fn new(capacity: usize) -> Self {
        ChainedHashTable {
            buckets: vec![Vec::new(); capacity],
            size: 0,
            capacity,
        }
    }

    fn hash(&self, key: &K) -> usize {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        (hasher.finish() as usize) % self.capacity
    }

    fn resize(&mut self) {
        let old_buckets = std::mem::replace(&mut self.buckets, vec![Vec::new(); self.capacity * 2]);
        self.capacity *= 2;
        self.size = 0;

        for bucket in old_buckets {
            for (key, value) in bucket {
                self.insert(key, value);
            }
        }
    }
}

impl<K: Hash + Eq + Clone, V: Clone> HashTable<K, V> for ChainedHashTable<K, V> {
    fn insert(&mut self, key: K, value: V) -> Option<V> {
        let index = self.hash(&key);
        let bucket = &mut self.buckets[index];

        // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„é”®
        for (i, (existing_key, existing_value)) in bucket.iter_mut().enumerate() {
            if *existing_key == key {
                let old_value = existing_value.clone();
                *existing_value = value;
                return Some(old_value);
            }
        }

        // æ’å…¥æ–°é”®å€¼å¯¹
        bucket.push((key, value));
        self.size += 1;

        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        if self.size > self.capacity * 2 {
            self.resize();
        }

        None
    }

    fn get(&self, key: &K) -> Option<&V> {
        let index = self.hash(key);
        let bucket = &self.buckets[index];

        for (existing_key, value) in bucket {
            if existing_key == key {
                return Some(value);
            }
        }

        None
    }

    fn remove(&mut self, key: &K) -> Option<V> {
        let index = self.hash(key);
        let bucket = &mut self.buckets[index];

        for i in 0..bucket.len() {
            if bucket[i].0 == *key {
                self.size -= 1;
                return Some(bucket.remove(i).1);
            }
        }

        None
    }

    fn contains_key(&self, key: &K) -> bool {
        self.get(key).is_some()
    }

    fn size(&self) -> usize {
        self.size
    }

    fn is_empty(&self) -> bool {
        self.size == 0
    }
}
```

---

## 7. å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚

### 7.1 ç»å…¸æ•™æ / Classic Textbooks

1. [Cormen2022] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. ISBN: 978-0262046305
   - **Cormen-Leiserson-Rivest-Steinç®—æ³•å¯¼è®º**ï¼Œç®—æ³•è®¾è®¡ä¸åˆ†æçš„æƒå¨æ•™æã€‚æœ¬æ–‡æ¡£çš„æ•°æ®ç»“æ„ç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

2. [Sedgewick2011] Sedgewick, R., & Wayne, K. (2011). *Algorithms* (4th ed.). Addison-Wesley. ISBN: 978-0321573513
   - **Sedgewick-Wayneç®—æ³•æ•™æ**ï¼Œæ³¨é‡ç®—æ³•å®ç°ä¸å®è·µã€‚æœ¬æ–‡æ¡£çš„æ•°æ®ç»“æ„å®ç°å‚è€ƒæ­¤ä¹¦ã€‚

3. [Tarjan1983] Tarjan, R. E. (1983). *Data Structures and Network Algorithms*. SIAM. ISBN: 978-0898711875
   - **Tarjanæ•°æ®ç»“æ„ä¸ç½‘ç»œç®—æ³•ç»å…¸è‘—ä½œ**ï¼Œå›¾ç®—æ³•çš„é‡è¦å‚è€ƒã€‚æœ¬æ–‡æ¡£çš„å›¾ç»“æ„ç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

4. [Okasaki1999] Okasaki, C. (1999). *Purely Functional Data Structures*. Cambridge University Press. ISBN: 978-0521663502
   - **Okasakiçº¯å‡½æ•°å¼æ•°æ®ç»“æ„ç»å…¸è‘—ä½œ**ï¼Œå‡½æ•°å¼ç¼–ç¨‹æ•°æ®ç»“æ„ç†è®ºã€‚æœ¬æ–‡æ¡£çš„å‡½æ•°å¼æ•°æ®ç»“æ„å‚è€ƒæ­¤ä¹¦ã€‚

5. [Mehlhorn1984] Mehlhorn, K. (1984). *Data Structures and Algorithms 1: Sorting and Searching*. Springer. ISBN: 978-3540137022
   - **Mehlhornæ•°æ®ç»“æ„ä¸ç®—æ³•ç»å…¸æ•™æ**ï¼Œæ’åºä¸æœç´¢çš„æƒå¨å‚è€ƒã€‚æœ¬æ–‡æ¡£çš„æœç´¢ç»“æ„å‚è€ƒæ­¤ä¹¦ã€‚

### 7.2 Wikiæ¦‚å¿µå‚è€ƒ / Wiki Concept References

- [Data Structure](https://en.wikipedia.org/wiki/Data_structure) - æ•°æ®ç»“æ„çš„æ ‡å‡†å®šä¹‰
- [Abstract Data Type](https://en.wikipedia.org/wiki/Abstract_data_type) - æŠ½è±¡æ•°æ®ç±»å‹
- [Array](https://en.wikipedia.org/wiki/Array_data_structure) - æ•°ç»„
- [Linked List](https://en.wikipedia.org/wiki/Linked_list) - é“¾è¡¨
- [Stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) - æ ˆ
- [Queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)) - é˜Ÿåˆ—
- [Binary Tree](https://en.wikipedia.org/wiki/Binary_tree) - äºŒå‰æ ‘
- [Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree) - äºŒå‰æœç´¢æ ‘
- [AVL Tree](https://en.wikipedia.org/wiki/AVL_tree) - AVLæ ‘
- [Red-Black Tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree) - çº¢é»‘æ ‘
- [Hash Table](https://en.wikipedia.org/wiki/Hash_table) - æ•£åˆ—è¡¨
- [B-tree](https://en.wikipedia.org/wiki/B-tree) - Bæ ‘

### 7.3 å¤§å­¦è¯¾ç¨‹å‚è€ƒ / University Course References

- **MIT 6.006**: Introduction to Algorithms. MIT OpenCourseWare. URL: <https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/>
- **Stanford CS161**: Design and Analysis of Algorithms. Stanford University. URL: <https://web.stanford.edu/class/cs161/>
- **CMU 15-451**: Algorithm Design and Analysis. Carnegie Mellon University. URL: <https://www.cs.cmu.edu/~15451/>

### 7.4 é¡¶çº§æœŸåˆŠè®ºæ–‡ / Top Journal Papers

#### æ•°æ®ç»“æ„ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Data Structure Theory

1. **Journal of the ACM (JACM)**
   - **Tarjan, R.E.** (1975). "Efficiency of a Good But Not Linear Set Union Algorithm". *Journal of the ACM*, 22(2), 215-225.
   - **Hopcroft, J.E., & Ullman, J.D.** (1973). "Set Merging Algorithms". *SIAM Journal on Computing*, 2(4), 294-303.
   - **Fredman, M.L., & Tarjan, R.E.** (1987). "Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms". *Journal of the ACM*, 34(3), 596-615.

2. **SIAM Journal on Computing (SICOMP)**
   - **Chazelle, B.** (2000). "A Minimum Spanning Tree Algorithm with Inverse-Ackermann Type Complexity". *Journal of the ACM*, 47(6), 1028-1047.
   - **Demaine, E.D., et al.** (2007). "Cache-Oblivious Streaming B-trees". *SIAM Journal on Computing*, 37(2), 358-378.
   - **PÄƒtraÅŸcu, M., & Thorup, M.** (2011). "The Power of Simple Tabulation Hashing". *Journal of the ACM*, 58(3), 1-50.

#### æŠ½è±¡æ•°æ®ç±»å‹é¡¶çº§æœŸåˆŠ / Top Journals in Abstract Data Types

1. **Theoretical Computer Science**
   - **Guttag, J.V., & Horning, J.J.** (1978). "The Algebraic Specification of Abstract Data Types". *Acta Informatica*, 10(1), 27-52.
   - **Goguen, J.A., et al.** (1978). "An Initial Algebra Approach to the Specification, Correctness, and Implementation of Abstract Data Types". *Current Trends in Programming Methodology*, 4, 80-149.
   - **Wirsing, M.** (1990). "Algebraic Specification". *Handbook of Theoretical Computer Science*, 675-788.

2. **Information and Computation**
   - **Burstall, R.M., & Goguen, J.A.** (1977). "Putting Theories Together to Make Specifications". *Proceedings of the 5th International Joint Conference on Artificial Intelligence*, 1045-1058.
   - **Ehrig, H., & Mahr, B.** (1985). *Fundamentals of Algebraic Specification 1: Equations and Initial Semantics*. Springer-Verlag.

#### æ•°æ®ç»“æ„ä¼˜åŒ–é¡¶çº§æœŸåˆŠ / Top Journals in Data Structure Optimization

1. **Journal of Computer and System Sciences**
   - **Bentley, J.L.** (1975). "Multidimensional Binary Search Trees Used for Associative Searching". *Communications of the ACM*, 18(9), 509-517.
   - **Guibas, L.J., & Sedgewick, R.** (1978). "A Dichromatic Framework for Balanced Trees". *Proceedings of the 19th Annual Symposium on Foundations of Computer Science*, 8-21.
   - **Sleator, D.D., & Tarjan, R.E.** (1985). "Self-Adjusting Binary Search Trees". *Journal of the ACM*, 32(3), 652-686.

2. **Computational Complexity**
   - **PÄƒtraÅŸcu, M.** (2008). "Lower Bounds for 2-Dimensional Range Counting". *Proceedings of the 39th Annual ACM Symposium on Theory of Computing*, 40-46.
   - **Thorup, M.** (2007). "Equivalence Between Priority Queues and Sorting". *Journal of the ACM*, 54(6), 1-28.

#### æ•£åˆ—ç†è®ºé¡¶çº§æœŸåˆŠ / Top Journals in Hashing Theory

1. **Communications of the ACM**
   - **Carter, J.L., & Wegman, M.N.** (1979). "Universal Classes of Hash Functions". *Journal of Computer and System Sciences*, 18(2), 143-154.
   - **Dietzfelbinger, M., et al.** (1994). "Dynamic Perfect Hashing: Upper and Lower Bounds". *SIAM Journal on Computing*, 23(4), 738-761.
   - **Pagh, R., & Rodler, F.F.** (2004). "Cuckoo Hashing". *Journal of Algorithms*, 51(2), 122-144.

2. **Operations Research**
   - **Gonnet, G.H.** (1981). "Expected Length of the Longest Probe Sequence in Hash Code Searching". *Journal of the ACM*, 28(2), 289-304.
   - **Larson, P.-Ã….** (1978). "Dynamic Hash Tables". *Communications of the ACM*, 31(4), 446-457.

#### å›¾æ•°æ®ç»“æ„é¡¶çº§æœŸåˆŠ / Top Journals in Graph Data Structures

1. **Mathematical Programming**
   - **Ahuja, R.K., et al.** (1993). *Network Flows: Theory, Algorithms, and Applications*. Prentice Hall.
   - **Goldberg, A.V., & Tarjan, R.E.** (1988). "A New Approach to the Maximum-Flow Problem". *Journal of the ACM*, 35(4), 921-940.

2. **Journal of Graph Theory**
   - **Bondy, J.A., & Murty, U.S.R.** (2008). *Graph Theory*. Springer.
   - **West, D.B.** (2001). *Introduction to Graph Theory* (2nd ed.). Prentice Hall.

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Data Structure**: <https://en.wikipedia.org/wiki/Data_structure>
   - æ•°æ®ç»“æ„çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«åŸºæœ¬å®šä¹‰ã€åˆ†ç±»å’Œæ“ä½œï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Abstract Data Type**: <https://en.wikipedia.org/wiki/Abstract_data_type>
   - æŠ½è±¡æ•°æ®ç±»å‹çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»ADTçš„å®šä¹‰å’Œå®ç°ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Tree (Data Structure)**: <https://en.wikipedia.org/wiki/Tree_(data_structure)>
   - æ ‘æ•°æ®ç»“æ„çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«äºŒå‰æ ‘ã€å¹³è¡¡æ ‘ç­‰ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

4. **Wikipedia - Hash Table**: <https://en.wikipedia.org/wiki/Hash_table>
   - å“ˆå¸Œè¡¨çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»æ•£åˆ—å‡½æ•°å’Œå†²çªè§£å†³ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

## 8. ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### 8.1 ç›¸å…³æ–‡æ¡£ / Related Documents

- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/23-æ•°æ®ç»“æ„å¤šç»´åˆ†æ.md` - æ•°æ®ç»“æ„å¤šç»´åˆ†æï¼ˆæ–°å¢ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/22-ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶.md` - ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/01-ç®—æ³•è®¾è®¡ç†è®º.md` - ç®—æ³•è®¾è®¡ç†è®º
- `04-ç®—æ³•å¤æ‚åº¦/06-ä¿¡æ¯è®ºä¸‹ç•Œ.md` - ä¿¡æ¯è®ºä¸‹ç•Œï¼ˆåŒ…å«æ•°æ®ç»“æ„çš„ä¿¡æ¯è®ºä¸‹ç•Œï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` - ç®—æ³•å…¨æ™¯æ¢³ç†ï¼ˆåŒ…å«æ•°æ®ç»“æ„åˆ†ææ¦‚è¿°ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

### 8.2 çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€** æ¨¡å—ï¼Œæ˜¯æ•°æ®ç»“æ„ç†è®ºçš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºæ•°æ®ç»“æ„å¤šç»´åˆ†ææ–‡æ¡£æä¾›ç†è®ºåŸºç¡€ã€‚

### 8.3 VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§4 - ä¿¡æ¯Â·æ•°æ®Â·æ•°æ®ç»“æ„åˆ†ææ¦‚è¿°
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£ä¸¥æ ¼éµå¾ªæ•°å­¦å½¢å¼åŒ–è§„èŒƒï¼Œæ‰€æœ‰å®šä¹‰å’Œå®šç†å‡é‡‡ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·è¡¨ç¤ºï¼Œå¹¶ç¬¦åˆå›½é™…é¡¶çº§å­¦æœ¯æœŸåˆŠæ ‡å‡†ã€‚*
