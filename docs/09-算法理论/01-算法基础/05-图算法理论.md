# 05-图算法理论 / Graph Algorithm Theory

## 目录 / Table of Contents

- [05-图算法理论 / Graph Algorithm Theory](#05-图算法理论--graph-algorithm-theory)
  - [目录 / Table of Contents](#目录--table-of-contents)
  - [1. 基本概念 / Basic Concepts](#1-基本概念--basic-concepts)
    - [1.1 图的基本定义 / Basic Graph Definition](#11-图的基本定义--basic-graph-definition)
    - [1.2 图的基本性质 / Basic Graph Properties](#12-图的基本性质--basic-graph-properties)
    - [1.3 图的连通性 / Graph Connectivity](#13-图的连通性--graph-connectivity)
  - [2. 图的遍历 / Graph Traversal](#2-图的遍历--graph-traversal)
    - [2.1 深度优先搜索 / Depth-First Search](#21-深度优先搜索--depth-first-search)
    - [2.2 广度优先搜索 / Breadth-First Search](#22-广度优先搜索--breadth-first-search)
    - [2.3 拓扑排序 / Topological Sorting](#23-拓扑排序--topological-sorting)
  - [3. 最短路径 / Shortest Path](#3-最短路径--shortest-path)
    - [3.1 Dijkstra算法 / Dijkstra's Algorithm](#31-dijkstra算法--dijkstras-algorithm)
    - [3.2 Bellman-Ford算法 / Bellman-Ford Algorithm](#32-bellman-ford算法--bellman-ford-algorithm)
    - [3.3 Floyd-Warshall算法 / Floyd-Warshall Algorithm](#33-floyd-warshall算法--floyd-warshall-algorithm)
  - [4. 最小生成树 / Minimum Spanning Tree](#4-最小生成树--minimum-spanning-tree)
    - [4.1 Kruskal算法 / Kruskal's Algorithm](#41-kruskal算法--kruskals-algorithm)
    - [4.2 Prim算法 / Prim's Algorithm](#42-prim算法--prims-algorithm)
    - [4.3 最小生成树性质 / MST Properties](#43-最小生成树性质--mst-properties)
  - [5. 强连通分量 / Strongly Connected Components](#5-强连通分量--strongly-connected-components)
    - [5.1 Kosaraju算法 / Kosaraju's Algorithm](#51-kosaraju算法--kosarajus-algorithm)
    - [5.2 Tarjan算法 / Tarjan's Algorithm](#52-tarjan算法--tarjans-algorithm)
  - [6. 网络流 / Network Flow](#6-网络流--network-flow)
    - [6.1 最大流问题 / Maximum Flow Problem](#61-最大流问题--maximum-flow-problem)
    - [6.2 Ford-Fulkerson算法 / Ford-Fulkerson Algorithm](#62-ford-fulkerson算法--ford-fulkerson-algorithm)
    - [6.3 Dinic算法 / Dinic's Algorithm](#63-dinic算法--dinics-algorithm)
  - [7. 实现示例 / Implementation Examples](#7-实现示例--implementation-examples)
    - [7.1 图的基本结构 / Basic Graph Structure](#71-图的基本结构--basic-graph-structure)
    - [7.2 DFS实现 / DFS Implementation](#72-dfs实现--dfs-implementation)
    - [7.3 BFS实现 / BFS Implementation](#73-bfs实现--bfs-implementation)
    - [7.4 Dijkstra算法实现 / Dijkstra Implementation](#74-dijkstra算法实现--dijkstra-implementation)
    - [7.5 Kruskal算法实现 / Kruskal Implementation](#75-kruskal算法实现--kruskal-implementation)
    - [7.6 强连通分量实现 / SCC Implementation](#76-强连通分量实现--scc-implementation)
  - [8. 参考文献 / References](#8-参考文献--references)
    - [8.1 经典教材 / Classic Textbooks](#81-经典教材--classic-textbooks)
    - [8.2 图论专著 / Graph Theory Monographs](#82-图论专著--graph-theory-monographs)
    - [8.3 算法设计 / Algorithm Design](#83-算法设计--algorithm-design)
    - [8.4 网络流理论 / Network Flow Theory](#84-网络流理论--network-flow-theory)
    - [8.5 在线资源 / Online Resources](#85-在线资源--online-resources)
  - [总结 / Summary](#总结--summary)
    - [核心概念 / Core Concepts](#核心概念--core-concepts)
    - [算法复杂度 / Algorithm Complexity](#算法复杂度--algorithm-complexity)
    - [实践应用 / Practical Applications](#实践应用--practical-applications)

---

## 1. 基本概念 / Basic Concepts

### 1.1 图的基本定义 / Basic Graph Definition

**定义 1.1.1** 图 $G = (V, E)$ 由顶点集 $V$ 和边集 $E$ 组成。
**Definition 1.1.1** A graph $G = (V, E)$ consists of a vertex set $V$ and an edge set $E$.

**图的类型 / Graph Types:**

- **无向图 / Undirected Graph**：边没有方向 / Edges have no direction
- **有向图 / Directed Graph**：边有方向 / Edges have direction
- **加权图 / Weighted Graph**：边有权重 / Edges have weights
- **多重图 / Multigraph**：允许重边 / Allows multiple edges

**定义 1.1.2** 图的表示 / Graph Representation：

1. **邻接矩阵 / Adjacency Matrix**：$A[i][j] = w$ 表示顶点 $i$ 和 $j$ 之间的边权重为 $w$ / $A[i][j] = w$ represents edge weight $w$ between vertices $i$ and $j$
2. **邻接表 / Adjacency List**：每个顶点维护其邻接顶点列表 / Each vertex maintains a list of its adjacent vertices

### 1.2 图的基本性质 / Basic Graph Properties

**定义 1.2.1** 顶点的度 / Vertex Degrees：

- **入度 / In-degree**：指向该顶点的边数 / Number of edges pointing to the vertex
- **出度 / Out-degree**：从该顶点出发的边数 / Number of edges leaving the vertex
- **度数 / Degree**：与顶点相连的边数（无向图） / Number of edges connected to the vertex (undirected graph)

**定义 1.2.2** 路径和环 / Paths and Cycles：

- **路径 / Path**：顶点序列 $v_1, v_2, \ldots, v_k$，其中 $(v_i, v_{i+1}) \in E$ / Vertex sequence $v_1, v_2, \ldots, v_k$ where $(v_i, v_{i+1}) \in E$
- **简单路径 / Simple Path**：不重复顶点的路径 / Path with no repeated vertices
- **环 / Cycle**：起点和终点相同的路径 / Path where start and end vertices are the same

**定理 1.2.1** 对于任意图 $G$ / For any graph $G$：
**Theorem 1.2.1** For any graph $G$:
$$\sum_{v \in V} \deg(v) = 2|E|$$

### 1.3 图的连通性 / Graph Connectivity

**定义 1.3.1** 连通性 / Connectivity：

- **连通图 / Connected Graph**：任意两个顶点间存在路径 / Path exists between any two vertices
- **连通分量 / Connected Component**：极大连通子图 / Maximal connected subgraph
- **强连通 / Strongly Connected**：有向图中任意两个顶点互相可达 / Any two vertices are mutually reachable in directed graph

**定义 1.3.2** 割点和桥 / Cut Vertices and Bridges：

- **割点 / Cut Vertex**：删除后增加连通分量数的顶点 / Vertex whose removal increases the number of connected components
- **桥 / Bridge**：删除后增加连通分量数的边 / Edge whose removal increases the number of connected components

---

## 2. 图的遍历 / Graph Traversal

### 2.1 深度优先搜索 / Depth-First Search

**定义 2.1.1** 深度优先搜索(DFS)优先探索深层节点。
**Definition 2.1.1** Depth-First Search (DFS) prioritizes exploring deep nodes.

**算法描述 / Algorithm Description:**

```text
DFS(G, v):
    visited[v] = true
    for each neighbor u of v:
        if not visited[u]:
            DFS(G, u)
```

**定理 2.1.1** DFS的时间复杂度为 $O(|V| + |E|)$。
**Theorem 2.1.1** The time complexity of DFS is $O(|V| + |E|)$.

### 2.2 广度优先搜索 / Breadth-First Search

**定义 2.2.1** 广度优先搜索(BFS)优先探索近邻节点。
**Definition 2.2.1** Breadth-First Search (BFS) prioritizes exploring neighboring nodes.

**算法描述 / Algorithm Description:**

```text
BFS(G, s):
    queue = [s]
    visited[s] = true
    while queue is not empty:
        v = queue.dequeue()
        for each neighbor u of v:
            if not visited[u]:
                visited[u] = true
                queue.enqueue(u)
```

**定理 2.2.1** BFS的时间复杂度为 $O(|V| + |E|)$。
**Theorem 2.2.1** The time complexity of BFS is $O(|V| + |E|)$.

### 2.3 拓扑排序 / Topological Sorting

**定义 2.3.1** 拓扑排序是有向无环图的线性排序。
**Definition 2.3.1** Topological sorting is a linear ordering of a directed acyclic graph.

**算法描述 / Algorithm Description:**

```text
TopologicalSort(G):
    result = []
    in_degree = compute_in_degree(G)
    queue = vertices with in_degree 0
    while queue is not empty:
        v = queue.dequeue()
        result.append(v)
        for each neighbor u of v:
            in_degree[u]--
            if in_degree[u] == 0:
                queue.enqueue(u)
    return result
```

---

## 3. 最短路径 / Shortest Path

### 3.1 Dijkstra算法 / Dijkstra's Algorithm

**定义 3.1.1** Dijkstra算法解决单源最短路径问题。
**Definition 3.1.1** Dijkstra's algorithm solves the single-source shortest path problem.

**算法描述 / Algorithm Description:**

```text
Dijkstra(G, s):
    dist[s] = 0
    dist[v] = ∞ for all v ≠ s
    Q = priority queue with all vertices
    while Q is not empty:
        u = Q.extract_min()
        for each neighbor v of u:
            if dist[u] + weight(u,v) < dist[v]:
                dist[v] = dist[u] + weight(u,v)
                Q.decrease_key(v, dist[v])
```

**定理 3.1.1** Dijkstra算法的时间复杂度为 $O((|V| + |E|) \log |V|)$。
**Theorem 3.1.1** The time complexity of Dijkstra's algorithm is $O((|V| + |E|) \log |V|)$.

### 3.2 Bellman-Ford算法 / Bellman-Ford Algorithm

**定义 3.2.1** Bellman-Ford算法可以处理负权边。
**Definition 3.2.1** Bellman-Ford algorithm can handle negative weight edges.

**算法描述 / Algorithm Description:**

```text
BellmanFord(G, s):
    dist[s] = 0
    dist[v] = ∞ for all v ≠ s
    for i = 1 to |V|-1:
        for each edge (u,v) in E:
            if dist[u] + weight(u,v) < dist[v]:
                dist[v] = dist[u] + weight(u,v)
    // Check for negative cycles
    for each edge (u,v) in E:
        if dist[u] + weight(u,v) < dist[v]:
            return "Negative cycle detected"
```

**定理 3.2.1** Bellman-Ford算法的时间复杂度为 $O(|V| \cdot |E|)$。
**Theorem 3.2.1** The time complexity of Bellman-Ford algorithm is $O(|V| \cdot |E|)$.

### 3.3 Floyd-Warshall算法 / Floyd-Warshall Algorithm

**定义 3.3.1** Floyd-Warshall算法解决所有点对最短路径问题。
**Definition 3.3.1** Floyd-Warshall algorithm solves the all-pairs shortest path problem.

**算法描述 / Algorithm Description:**

```text
FloydWarshall(G):
    dist = adjacency matrix of G
    for k = 1 to |V|:
        for i = 1 to |V|:
            for j = 1 to |V|:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

**定理 3.3.1** Floyd-Warshall算法的时间复杂度为 $O(|V|^3)$。
**Theorem 3.3.1** The time complexity of Floyd-Warshall algorithm is $O(|V|^3)$.

---

## 4. 最小生成树 / Minimum Spanning Tree

### 4.1 Kruskal算法 / Kruskal's Algorithm

**定义 4.1.1** Kruskal算法通过选择最小权重边构建最小生成树。
**Definition 4.1.1** Kruskal's algorithm builds MST by selecting minimum weight edges.

**算法描述 / Algorithm Description:**

```text
Kruskal(G):
    sort edges by weight
    MST = empty set
    for each edge (u,v) in sorted order:
        if adding (u,v) doesn't create cycle:
            MST.add((u,v))
    return MST
```

**定理 4.1.1** Kruskal算法的时间复杂度为 $O(|E| \log |E|)$。
**Theorem 4.1.1** The time complexity of Kruskal's algorithm is $O(|E| \log |E|)$.

### 4.2 Prim算法 / Prim's Algorithm

**定义 4.2.1** Prim算法从单个顶点开始构建最小生成树。
**Definition 4.2.1** Prim's algorithm builds MST starting from a single vertex.

**算法描述 / Algorithm Description:**

```text
Prim(G, s):
    MST = {s}
    Q = priority queue with edges from s
    while MST.size < |V|:
        (u,v) = Q.extract_min()
        if v not in MST:
            MST.add(v)
            for each neighbor w of v:
                if w not in MST:
                    Q.insert((v,w), weight(v,w))
```

**定理 4.2.1** Prim算法的时间复杂度为 $O((|V| + |E|) \log |V|)$。
**Theorem 4.2.1** The time complexity of Prim's algorithm is $O((|V| + |E|) \log |V|)$.

### 4.3 最小生成树性质 / MST Properties

**定理 4.3.1** 最小生成树包含 $|V| - 1$ 条边。
**Theorem 4.3.1** Minimum spanning tree contains $|V| - 1$ edges.

**定理 4.3.2** 最小生成树是唯一的当且仅当所有边权重都不同。
**Theorem 4.3.2** MST is unique if and only if all edge weights are distinct.

---

## 5. 强连通分量 / Strongly Connected Components

### 5.1 Kosaraju算法 / Kosaraju's Algorithm

**定义 5.1.1** Kosaraju算法通过两次DFS找到强连通分量。
**Definition 5.1.1** Kosaraju's algorithm finds SCCs using two DFS passes.

**算法描述 / Algorithm Description:**

```text
Kosaraju(G):
    // First DFS to get finish times
    visited = [false] * |V|
    finish_times = []
    for v in V:
        if not visited[v]:
            DFS1(G, v, visited, finish_times)
    
    // Second DFS on transpose graph
    G_T = transpose(G)
    visited = [false] * |V|
    SCCs = []
    for v in reversed(finish_times):
        if not visited[v]:
            SCC = []
            DFS2(G_T, v, visited, SCC)
            SCCs.append(SCC)
    return SCCs
```

### 5.2 Tarjan算法 / Tarjan's Algorithm

**定义 5.2.1** Tarjan算法使用单次DFS找到强连通分量。
**Definition 5.2.1** Tarjan's algorithm finds SCCs using a single DFS pass.

**算法描述 / Algorithm Description:**

```text
Tarjan(G):
    index = 0
    stack = []
    indices = [-1] * |V|
    low_links = [-1] * |V|
    on_stack = [false] * |V|
    SCCs = []
    
    for v in V:
        if indices[v] == -1:
            strongconnect(v, index, stack, indices, low_links, on_stack, SCCs)
    return SCCs
```

---

## 6. 网络流 / Network Flow

### 6.1 最大流问题 / Maximum Flow Problem

**定义 6.1.1** 最大流问题是在容量约束下找到从源点到汇点的最大流量。
**Definition 6.1.1** Maximum flow problem finds maximum flow from source to sink under capacity constraints.

**形式化定义 / Formal Definition:**
给定网络 $G = (V, E)$ 和容量函数 $c: E \rightarrow \mathbb{R}^+$，找到最大流 $f: E \rightarrow \mathbb{R}^+$。
Given network $G = (V, E)$ and capacity function $c: E \rightarrow \mathbb{R}^+$, find maximum flow $f: E \rightarrow \mathbb{R}^+$.

### 6.2 Ford-Fulkerson算法 / Ford-Fulkerson Algorithm

**定义 6.2.1** Ford-Fulkerson算法通过寻找增广路径计算最大流。
**Definition 6.2.1** Ford-Fulkerson algorithm computes maximum flow by finding augmenting paths.

**算法描述 / Algorithm Description:**

```text
FordFulkerson(G, s, t):
    f = zero flow
    while there exists augmenting path p from s to t:
        cf(p) = min{cf(e) : e in p}
        for each edge e in p:
            if e in E:
                f[e] += cf(p)
            else:
                f[reverse(e)] -= cf(p)
    return f
```

### 6.3 Dinic算法 / Dinic's Algorithm

**定义 6.3.1** Dinic算法使用分层网络优化最大流计算。
**Definition 6.3.1** Dinic's algorithm optimizes maximum flow computation using layered networks.

**定理 6.3.1** Dinic算法的时间复杂度为 $O(|V|^2 |E|)$。
**Theorem 6.3.1** The time complexity of Dinic's algorithm is $O(|V|^2 |E|)$.

---

## 7. 实现示例 / Implementation Examples

### 7.1 图的基本结构 / Basic Graph Structure

```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct Graph {
    vertices: Vec<usize>,
    edges: HashMap<(usize, usize), f64>,
    directed: bool,
}

impl Graph {
    pub fn new(directed: bool) -> Self {
        Graph {
            vertices: Vec::new(),
            edges: HashMap::new(),
            directed,
        }
    }
    
    pub fn add_vertex(&mut self, v: usize) {
        if !self.vertices.contains(&v) {
            self.vertices.push(v);
        }
    }
    
    pub fn add_edge(&mut self, from: usize, to: usize, weight: f64) {
        self.edges.insert((from, to), weight);
        if !self.directed {
            self.edges.insert((to, from), weight);
        }
    }
    
    pub fn get_neighbors(&self, v: usize) -> Vec<usize> {
        self.edges
            .iter()
            .filter_map(|((from, to), _)| {
                if *from == v {
                    Some(*to)
                } else {
                    None
                }
            })
            .collect()
    }
}
```

### 7.2 DFS实现 / DFS Implementation

```rust
impl Graph {
    pub fn dfs(&self, start: usize) -> Vec<usize> {
        let mut visited = vec![false; self.vertices.len()];
        let mut result = Vec::new();
        self.dfs_recursive(start, &mut visited, &mut result);
        result
    }
    
    fn dfs_recursive(&self, v: usize, visited: &mut [bool], result: &mut Vec<usize>) {
        visited[v] = true;
        result.push(v);
        
        for neighbor in self.get_neighbors(v) {
            if !visited[neighbor] {
                self.dfs_recursive(neighbor, visited, result);
            }
        }
    }
}
```

### 7.3 BFS实现 / BFS Implementation

```rust
use std::collections::VecDeque;

impl Graph {
    pub fn bfs(&self, start: usize) -> Vec<usize> {
        let mut visited = vec![false; self.vertices.len()];
        let mut queue = VecDeque::new();
        let mut result = Vec::new();
        
        visited[start] = true;
        queue.push_back(start);
        
        while let Some(v) = queue.pop_front() {
            result.push(v);
            
            for neighbor in self.get_neighbors(v) {
                if !visited[neighbor] {
                    visited[neighbor] = true;
                    queue.push_back(neighbor);
                }
            }
        }
        
        result
    }
}
```

### 7.4 Dijkstra算法实现 / Dijkstra Implementation

```rust
use std::collections::BinaryHeap;
use std::cmp::Ordering;

#[derive(PartialEq, Eq)]
struct State {
    cost: f64,
    position: usize,
}

impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        other.cost.partial_cmp(&self.cost).unwrap()
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Graph {
    pub fn dijkstra(&self, start: usize) -> Vec<f64> {
        let mut dist = vec![f64::INFINITY; self.vertices.len()];
        let mut heap = BinaryHeap::new();
        
        dist[start] = 0.0;
        heap.push(State { cost: 0.0, position: start });
        
        while let Some(State { cost, position }) = heap.pop() {
            if cost > dist[position] {
                continue;
            }
            
            for neighbor in self.get_neighbors(position) {
                let edge_weight = self.edges.get(&(position, neighbor)).unwrap_or(&f64::INFINITY);
                let next = State {
                    cost: cost + edge_weight,
                    position: neighbor,
                };
                
                if next.cost < dist[neighbor] {
                    heap.push(next);
                    dist[neighbor] = next.cost;
                }
            }
        }
        
        dist
    }
}
```

### 7.5 Kruskal算法实现 / Kruskal Implementation

```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct Edge {
    from: usize,
    to: usize,
    weight: f64,
}

impl Graph {
    pub fn kruskal(&self) -> Vec<(usize, usize)> {
        let mut edges: Vec<Edge> = self.edges
            .iter()
            .map(|((from, to), weight)| Edge {
                from: *from,
                to: *to,
                weight: *weight,
            })
            .collect();
        
        edges.sort_by(|a, b| a.weight.partial_cmp(&b.weight).unwrap());
        
        let mut uf = UnionFind::new(self.vertices.len());
        let mut mst = Vec::new();
        
        for edge in edges {
            if uf.union(edge.from, edge.to) {
                mst.push((edge.from, edge.to));
            }
        }
        
        mst
    }
}

struct UnionFind {
    parent: Vec<usize>,
    rank: Vec<usize>,
}

impl UnionFind {
    fn new(size: usize) -> Self {
        UnionFind {
            parent: (0..size).collect(),
            rank: vec![0; size],
        }
    }
    
    fn find(&mut self, x: usize) -> usize {
        if self.parent[x] != x {
            self.parent[x] = self.find(self.parent[x]);
        }
        self.parent[x]
    }
    
    fn union(&mut self, x: usize, y: usize) -> bool {
        let px = self.find(x);
        let py = self.find(y);
        
        if px == py {
            return false;
        }
        
        if self.rank[px] < self.rank[py] {
            self.parent[px] = py;
        } else if self.rank[px] > self.rank[py] {
            self.parent[py] = px;
        } else {
            self.parent[py] = px;
            self.rank[px] += 1;
        }
        
        true
    }
}
```

### 7.6 强连通分量实现 / SCC Implementation

```rust
impl Graph {
    pub fn kosaraju(&self) -> Vec<Vec<usize>> {
        let mut visited = vec![false; self.vertices.len()];
        let mut finish_times = Vec::new();
        
        // First DFS to get finish times
        for &v in &self.vertices {
            if !visited[v] {
                self.dfs_finish_times(v, &mut visited, &mut finish_times);
            }
        }
        
        // Second DFS on transpose graph
        let transpose = self.transpose();
        let mut visited = vec![false; self.vertices.len()];
        let mut sccs = Vec::new();
        
        for &v in finish_times.iter().rev() {
            if !visited[v] {
                let mut scc = Vec::new();
                transpose.dfs_scc(v, &mut visited, &mut scc);
                sccs.push(scc);
            }
        }
        
        sccs
    }
    
    fn dfs_finish_times(&self, v: usize, visited: &mut [bool], finish_times: &mut Vec<usize>) {
        visited[v] = true;
        
        for neighbor in self.get_neighbors(v) {
            if !visited[neighbor] {
                self.dfs_finish_times(neighbor, visited, finish_times);
            }
        }
        
        finish_times.push(v);
    }
    
    fn transpose(&self) -> Graph {
        let mut transpose = Graph::new(self.directed);
        
        for &v in &self.vertices {
            transpose.add_vertex(v);
        }
        
        for ((from, to), weight) in &self.edges {
            transpose.add_edge(*to, *from, *weight);
        }
        
        transpose
    }
    
    fn dfs_scc(&self, v: usize, visited: &mut [bool], scc: &mut Vec<usize>) {
        visited[v] = true;
        scc.push(v);
        
        for neighbor in self.get_neighbors(v) {
            if !visited[neighbor] {
                self.dfs_scc(neighbor, visited, scc);
            }
        }
    }
}
```

---

## 8. 参考文献 / References

### 8.1 经典教材 / Classic Textbooks

- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms (3rd ed.). MIT Press.
- Kleinberg, J., & Tardos, É. (2006). Algorithm Design. Pearson.

### 8.2 图论专著 / Graph Theory Monographs

- Bondy, J. A., & Murty, U. S. R. (2008). Graph Theory. Springer.
- Diestel, R. (2017). Graph Theory (5th ed.). Springer.

### 8.3 算法设计 / Algorithm Design

- Skiena, S. S. (2008). The Algorithm Design Manual (2nd ed.). Springer.
- Sedgewick, R., & Wayne, K. (2011). Algorithms (4th ed.). Addison-Wesley.

### 8.4 网络流理论 / Network Flow Theory

- Ahuja, R. K., Magnanti, T. L., & Orlin, J. B. (1993). Network Flows: Theory, Algorithms, and Applications. Prentice Hall.

### 8.5 在线资源 / Online Resources

- [Graph Algorithms - Stanford CS161](http://web.stanford.edu/class/cs161/)
- [Network Flow - MIT 6.046J](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/)

---

## 总结 / Summary

### 核心概念 / Core Concepts

- 图的基本定义和表示方法 / Basic graph definitions and representations
- 图的遍历算法：DFS和BFS / Graph traversal algorithms: DFS and BFS
- 最短路径算法：Dijkstra、Bellman-Ford、Floyd-Warshall / Shortest path algorithms: Dijkstra, Bellman-Ford, Floyd-Warshall
- 最小生成树算法：Kruskal、Prim / Minimum spanning tree algorithms: Kruskal, Prim
- 强连通分量算法：Kosaraju、Tarjan / Strongly connected component algorithms: Kosaraju, Tarjan
- 网络流算法：Ford-Fulkerson、Dinic / Network flow algorithms: Ford-Fulkerson, Dinic

### 算法复杂度 / Algorithm Complexity

- 图遍历：$O(|V| + |E|)$ / Graph traversal: $O(|V| + |E|)$
- 最短路径：Dijkstra $O((|V| + |E|) \log |V|)$，Bellman-Ford $O(|V| \cdot |E|)$，Floyd-Warshall $O(|V|^3)$ / Shortest path: Dijkstra $O((|V| + |E|) \log |V|)$, Bellman-Ford $O(|V| \cdot |E|)$, Floyd-Warshall $O(|V|^3)$
- 最小生成树：Kruskal $O(|E| \log |E|)$，Prim $O((|V| + |E|) \log |V|)$ / MST: Kruskal $O(|E| \log |E|)$, Prim $O((|V| + |E|) \log |V|)$
- 强连通分量：Kosaraju $O(|V| + |E|)$，Tarjan $O(|V| + |E|)$ / SCC: Kosaraju $O(|V| + |E|)$, Tarjan $O(|V| + |E|)$
- 网络流：Ford-Fulkerson $O(|E| \cdot f^*)$，Dinic $O(|V|^2 |E|)$ / Network flow: Ford-Fulkerson $O(|E| \cdot f^*)$, Dinic $O(|V|^2 |E|)$

### 实践应用 / Practical Applications

- 社交网络分析 / Social network analysis
- 路由算法 / Routing algorithms
- 网络设计 / Network design
- 生物信息学 / Bioinformatics
- 计算机视觉 / Computer vision
- 推荐系统 / Recommendation systems
