# 1. ä¸­è‹±æœ¯è¯­å¯¹ç…§è¡¨ (Chinese-English Terminology Reference)

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## å›½é™…æ ‡å‡†æœ¯è¯­ä½“ç³» / International Standard Terminology System

æœ¬æœ¯è¯­å¯¹ç…§è¡¨åŸºäºä»¥ä¸‹å›½é™…æ ‡å‡†å»ºç«‹ï¼š

- **ISO/IEC 2382**: ä¿¡æ¯æŠ€æœ¯è¯æ±‡æ ‡å‡†
- **IEEE 610.12**: è½¯ä»¶å·¥ç¨‹æœ¯è¯­æ ‡å‡†
- **ACM Computing Classification System**: è®¡ç®—æœºç§‘å­¦åˆ†ç±»ä½“ç³»
- **MathSciNet**: æ•°å­¦æ–‡çŒ®æ•°æ®åº“æœ¯è¯­æ ‡å‡†
- **arXiv**: é¢„å°æœ¬æ•°æ®åº“æœ¯è¯­æ ‡å‡†

This terminology reference is based on the following international standards:

- **ISO/IEC 2382**: Information technology vocabulary standards
- **IEEE 610.12**: Software engineering terminology standards
- **ACM Computing Classification System**: Computer science classification system
- **MathSciNet**: Mathematical literature database terminology standards
- **arXiv**: Preprint database terminology standards

## ç›®å½• (Table of Contents)

- [1. ä¸­è‹±æœ¯è¯­å¯¹ç…§è¡¨ (Chinese-English Terminology Reference)](#1-ä¸­è‹±æœ¯è¯­å¯¹ç…§è¡¨-chinese-english-terminology-reference)
  - [å›½é™…æ ‡å‡†æœ¯è¯­ä½“ç³» / International Standard Terminology System](#å›½é™…æ ‡å‡†æœ¯è¯­ä½“ç³»--international-standard-terminology-system)
  - [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
  - [1.1 åŸºç¡€ç†è®ºæœ¯è¯­ (Basic Theory Terms)](#11-åŸºç¡€ç†è®ºæœ¯è¯­-basic-theory-terms)
    - [1.1.1 é›†åˆè®º (Set Theory)](#111-é›†åˆè®º-set-theory)
    - [1.1.2 å‡½æ•°è®º (Function Theory)](#112-å‡½æ•°è®º-function-theory)
  - [1.2 é€’å½’ç†è®ºæœ¯è¯­ (Recursion Theory Terms)](#12-é€’å½’ç†è®ºæœ¯è¯­-recursion-theory-terms)
    - [1.2.1 é€’å½’å‡½æ•° (Recursive Functions)](#121-é€’å½’å‡½æ•°-recursive-functions)
    - [1.2.2 è®¡ç®—ç†è®º (Computability Theory)](#122-è®¡ç®—ç†è®º-computability-theory)
  - [1.3 å½¢å¼åŒ–è¯æ˜æœ¯è¯­ (Formal Proof Terms)](#13-å½¢å¼åŒ–è¯æ˜æœ¯è¯­-formal-proof-terms)
    - [1.3.1 è¯æ˜æ–¹æ³• (Proof Methods)](#131-è¯æ˜æ–¹æ³•-proof-methods)
    - [1.3.2 é€»è¾‘ç³»ç»Ÿ (Logical Systems)](#132-é€»è¾‘ç³»ç»Ÿ-logical-systems)
  - [1.4 ç®—æ³•å¤æ‚åº¦æœ¯è¯­ (Algorithm Complexity Terms)](#14-ç®—æ³•å¤æ‚åº¦æœ¯è¯­-algorithm-complexity-terms)
    - [1.4.1 æ—¶é—´å¤æ‚åº¦ (Time Complexity)](#141-æ—¶é—´å¤æ‚åº¦-time-complexity)
    - [1.4.2 ç©ºé—´å¤æ‚åº¦ (Space Complexity)](#142-ç©ºé—´å¤æ‚åº¦-space-complexity)
    - [1.4.3 å¤æ‚åº¦ç±» (Complexity Classes)](#143-å¤æ‚åº¦ç±»-complexity-classes)
  - [1.5 ç±»å‹ç†è®ºæœ¯è¯­ (Type Theory Terms)](#15-ç±»å‹ç†è®ºæœ¯è¯­-type-theory-terms)
    - [1.5.1 åŸºæœ¬ç±»å‹ (Basic Types)](#151-åŸºæœ¬ç±»å‹-basic-types)
    - [1.5.2 é«˜çº§ç±»å‹ (Advanced Types)](#152-é«˜çº§ç±»å‹-advanced-types)
  - [1.6 é€»è¾‘ç³»ç»Ÿæœ¯è¯­ (Logic System Terms)](#16-é€»è¾‘ç³»ç»Ÿæœ¯è¯­-logic-system-terms)
    - [1.6.1 å‘½é¢˜é€»è¾‘ (Propositional Logic)](#161-å‘½é¢˜é€»è¾‘-propositional-logic)
    - [1.6.2 ä¸€é˜¶é€»è¾‘ (First-Order Logic)](#162-ä¸€é˜¶é€»è¾‘-first-order-logic)
  - [1.7 è®¡ç®—æ¨¡å‹æœ¯è¯­ (Computational Model Terms)](#17-è®¡ç®—æ¨¡å‹æœ¯è¯­-computational-model-terms)
    - [1.7.1 Î»æ¼”ç®— (Lambda Calculus)](#171-Î»æ¼”ç®—-lambda-calculus)
    - [1.7.2 è‡ªåŠ¨æœºç†è®º (Automata Theory)](#172-è‡ªåŠ¨æœºç†è®º-automata-theory)
  - [1.8 å®ç°ç¤ºä¾‹æœ¯è¯­ (Implementation Example Terms)](#18-å®ç°ç¤ºä¾‹æœ¯è¯­-implementation-example-terms)
    - [1.8.1 ç¼–ç¨‹è¯­è¨€ (Programming Languages)](#181-ç¼–ç¨‹è¯­è¨€-programming-languages)
    - [1.8.2 å½¢å¼åŒ–éªŒè¯ (Formal Verification)](#182-å½¢å¼åŒ–éªŒè¯-formal-verification)
  - [1.9 é«˜çº§ä¸»é¢˜æœ¯è¯­ (Advanced Topic Terms)](#19-é«˜çº§ä¸»é¢˜æœ¯è¯­-advanced-topic-terms)
    - [1.9.1 èŒƒç•´è®º (Category Theory)](#191-èŒƒç•´è®º-category-theory)
    - [1.9.2 åŒä¼¦ç±»å‹è®º (Homotopy Type Theory)](#192-åŒä¼¦ç±»å‹è®º-homotopy-type-theory)
    - [1.9.3 è¯æ˜åŠ©æ‰‹ (Proof Assistant)](#193-è¯æ˜åŠ©æ‰‹-proof-assistant)
  - [1.10 ç®—æ³•ç†è®ºæœ¯è¯­ (Algorithm Theory Terms)](#110-ç®—æ³•ç†è®ºæœ¯è¯­-algorithm-theory-terms)
    - [1.10.1 ç®—æ³•è®¾è®¡ (Algorithm Design)](#1101-ç®—æ³•è®¾è®¡-algorithm-design)
    - [1.10.2 æ•°æ®ç»“æ„ (Data Structures)](#1102-æ•°æ®ç»“æ„-data-structures)
  - [ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
    - [ç›¸å…³æ–‡æ¡£ / Related Documents](#ç›¸å…³æ–‡æ¡£--related-documents)
    - [çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
    - [VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)
  - [æ–°å¢æœ¯è¯­å¯¹ç…§ï¼ˆæœ¬æœŸï¼‰](#æ–°å¢æœ¯è¯­å¯¹ç…§æœ¬æœŸ)

---

## 1.1 åŸºç¡€ç†è®ºæœ¯è¯­ (Basic Theory Terms)

### 1.1.1 é›†åˆè®º (Set Theory)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| é›†åˆ | Set | ä¸€ç»„ä¸åŒå¯¹è±¡çš„æ— åºé›†åˆ / An unordered collection of distinct objects | Wikipedia: Set (mathematics) |
| å…ƒç´  | Element | é›†åˆä¸­çš„æˆå‘˜ / A member of a set | Wikipedia: Element (mathematics) |
| å­é›† | Subset | ä¸€ä¸ªé›†åˆçš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯å¦ä¸€ä¸ªé›†åˆçš„å…ƒç´  / A set whose elements are all contained in another set | Wikipedia: Subset |
| å¹¶é›† | Union | ä¸¤ä¸ªé›†åˆä¸­æ‰€æœ‰å…ƒç´ çš„é›†åˆ / The set of all elements in either of two sets | Wikipedia: Union (set theory) |
| äº¤é›† | Intersection | ä¸¤ä¸ªé›†åˆä¸­å…±åŒå…ƒç´ çš„é›†åˆ / The set of elements common to two sets | Wikipedia: Intersection (set theory) |
| è¡¥é›† | Complement | ä¸åœ¨ç»™å®šé›†åˆä¸­çš„å…ƒç´ çš„é›†åˆ / The set of elements not in a given set | Wikipedia: Complement (set theory) |
| ç¬›å¡å°”ç§¯ | Cartesian Product | ä¸¤ä¸ªé›†åˆçš„æœ‰åºå¯¹é›†åˆ / The set of ordered pairs from two sets | Wikipedia: Cartesian product |
| å¹‚é›† | Power Set | ä¸€ä¸ªé›†åˆçš„æ‰€æœ‰å­é›†çš„é›†åˆ / The set of all subsets of a set | Wikipedia: Power set |
| ç©ºé›† | Empty Set | ä¸åŒ…å«ä»»ä½•å…ƒç´ çš„é›†åˆ / A set containing no elements | Wikipedia: Empty set |
| å•å…ƒç´ é›† | Singleton | åªåŒ…å«ä¸€ä¸ªå…ƒç´ çš„é›†åˆ / A set containing exactly one element | Wikipedia: Singleton (mathematics) |

### 1.1.2 å‡½æ•°è®º (Function Theory)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| å‡½æ•° | Function | ä»ä¸€ä¸ªé›†åˆåˆ°å¦ä¸€ä¸ªé›†åˆçš„æ˜ å°„ / A mapping from one set to another | Wikipedia: Function (mathematics) |
| å®šä¹‰åŸŸ | Domain | å‡½æ•°çš„è¾“å…¥é›†åˆ / The set of inputs for a function | Wikipedia: Domain of a function |
| å€¼åŸŸ | Codomain | å‡½æ•°çš„è¾“å‡ºé›†åˆ / The set of possible outputs for a function | Wikipedia: Codomain |
| åƒ | Image | å‡½æ•°å®é™…è¾“å‡ºçš„é›†åˆ / The set of actual outputs of a function | Wikipedia: Image (mathematics) |
| å•å°„ | Injective | ä¸åŒè¾“å…¥å¯¹åº”ä¸åŒè¾“å‡ºçš„å‡½æ•° / A function where different inputs map to different outputs | Wikipedia: Injective function |
| æ»¡å°„ | Surjective | æ¯ä¸ªè¾“å‡ºéƒ½æœ‰å¯¹åº”è¾“å…¥çš„å‡½æ•° / A function where every output has a corresponding input | Wikipedia: Surjective function |
| åŒå°„ | Bijective | æ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„çš„å‡½æ•° / A function that is both injective and surjective | Wikipedia: Bijection |
| å¤åˆå‡½æ•° | Composition | ä¸¤ä¸ªå‡½æ•°çš„ç»„åˆ / The combination of two functions | Wikipedia: Function composition |
| é€†å‡½æ•° | Inverse Function | å‡½æ•°çš„åå‘æ˜ å°„ / The reverse mapping of a function | Wikipedia: Inverse function |
| æ’ç­‰å‡½æ•° | Identity Function | å°†æ¯ä¸ªå…ƒç´ æ˜ å°„åˆ°è‡ªèº«çš„å‡½æ•° / A function that maps each element to itself | Wikipedia: Identity function |

---

## 1.2 é€’å½’ç†è®ºæœ¯è¯­ (Recursion Theory Terms)

### 1.2.1 é€’å½’å‡½æ•° (Recursive Functions)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| åŸå§‹é€’å½’å‡½æ•° | Primitive Recursive Function | ç”±åŸºæœ¬å‡½æ•°é€šè¿‡å¤åˆå’ŒåŸå§‹é€’å½’æ„é€ çš„å‡½æ•° / Functions constructed from basic functions by composition and primitive recursion | Wikipedia: Primitive recursive function |
| ä¸€èˆ¬é€’å½’å‡½æ•° | General Recursive Function | é€šè¿‡Î¼ç®—å­å®šä¹‰çš„é€’å½’å‡½æ•° / Recursive functions defined using the Î¼-operator | Wikipedia: General recursive function |
| Î¼é€’å½’å‡½æ•° | Î¼-Recursive Function | ä½¿ç”¨Î¼ç®—å­çš„é€’å½’å‡½æ•° / Recursive functions using the Î¼-operator | Wikipedia: Î¼-recursive function |
| éƒ¨åˆ†é€’å½’å‡½æ•° | Partial Recursive Function | å¯èƒ½åœ¨æŸäº›è¾“å…¥ä¸Šæœªå®šä¹‰çš„é€’å½’å‡½æ•° / Recursive functions that may be undefined on some inputs | Wikipedia: Partial recursive function |
| é€’å½’å¯æšä¸¾ | Recursively Enumerable | å¯ä»¥é€šè¿‡ç®—æ³•æšä¸¾çš„é›†åˆ / A set that can be enumerated by an algorithm | Wikipedia: Recursively enumerable set |
| é€’å½’å¯è§£ | Recursive | å¯ä»¥é€šè¿‡ç®—æ³•åˆ¤å®šæˆå‘˜èµ„æ ¼çš„é›†åˆ / A set whose membership can be decided by an algorithm | Wikipedia: Recursive set |
| é€’å½’ä¸å¯è§£ | Recursively Unsolvable | æ— æ³•é€šè¿‡ç®—æ³•åˆ¤å®šæˆå‘˜èµ„æ ¼çš„é›†åˆ / A set whose membership cannot be decided by an algorithm | Wikipedia: Recursively unsolvable |
| åœæœºé—®é¢˜ | Halting Problem | åˆ¤æ–­ç¨‹åºæ˜¯å¦åœæœºçš„ä¸å¯è§£é—®é¢˜ / The unsolvable problem of determining if a program halts | Wikipedia: Halting problem |
| å›¾çµæœº | Turing Machine | æŠ½è±¡è®¡ç®—æ¨¡å‹ / An abstract computational model | Wikipedia: Turing machine |
| ä¸˜å¥‡-å›¾çµè®ºé¢˜ | Church-Turing Thesis | å…³äºå¯è®¡ç®—æ€§çš„åŸºæœ¬å‡è®¾ / A fundamental assumption about computability | Wikipedia: Church-Turing thesis |

### 1.2.2 è®¡ç®—ç†è®º (Computability Theory)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| å¯è®¡ç®—æ€§ | Computability | å‡½æ•°æˆ–é—®é¢˜æ˜¯å¦å¯ä»¥é€šè¿‡ç®—æ³•è§£å†³ / Whether a function or problem can be solved by an algorithm | Wikipedia: Computability theory |
| å¯åˆ¤å®šæ€§ | Decidability | é—®é¢˜æ˜¯å¦å¯ä»¥é€šè¿‡ç®—æ³•åˆ¤å®š / Whether a problem can be decided by an algorithm | Wikipedia: Decision problem |
| å¤æ‚æ€§ | Complexity | ç®—æ³•æˆ–é—®é¢˜çš„è®¡ç®—èµ„æºéœ€æ±‚ / The computational resource requirements of an algorithm or problem | Wikipedia: Computational complexity theory |
| å½’çº¦ | Reduction | å°†ä¸€ä¸ªé—®é¢˜è½¬åŒ–ä¸ºå¦ä¸€ä¸ªé—®é¢˜çš„æ–¹æ³• / A method of transforming one problem into another | Wikipedia: Reduction (complexity) |
| å®Œå…¨æ€§ | Completeness | é—®é¢˜åœ¨æŸä¸ªå¤æ‚æ€§ç±»ä¸­çš„ä»£è¡¨æ€§ / The representativeness of a problem in a complexity class | Wikipedia: Complete (complexity) |
| å›°éš¾æ€§ | Hardness | é—®é¢˜åœ¨æŸä¸ªå¤æ‚æ€§ç±»ä¸­çš„éš¾åº¦ / The difficulty of a problem in a complexity class | Wikipedia: Hardness (complexity) |

---

## 1.3 å½¢å¼åŒ–è¯æ˜æœ¯è¯­ (Formal Proof Terms)

### 1.3.1 è¯æ˜æ–¹æ³• (Proof Methods)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| å½’çº³æ³• | Mathematical Induction | åŸºäºè‡ªç„¶æ•°æ€§è´¨çš„è¯æ˜æ–¹æ³• / A proof method based on properties of natural numbers | Wikipedia: Mathematical induction |
| æ„é€ æ€§è¯æ˜ | Constructive Proof | æä¾›å…·ä½“æ„é€ çš„è¯æ˜ / A proof that provides a concrete construction | Wikipedia: Constructive proof |
| åè¯æ³• | Proof by Contradiction | é€šè¿‡å‡è®¾åé¢æ¥è¯æ˜çš„æ–¹æ³• / A proof method that assumes the opposite | Wikipedia: Proof by contradiction |
| ç›´æ¥è¯æ˜ | Direct Proof | ä»å‰æç›´æ¥æ¨å¯¼ç»“è®ºçš„è¯æ˜ / A proof that directly derives the conclusion from premises | Wikipedia: Direct proof |
| å¯¹å¶è¯æ˜ | Proof by Contrapositive | é€šè¿‡è¯æ˜é€†å¦å‘½é¢˜æ¥è¯æ˜åŸå‘½é¢˜ / A proof that proves the contrapositive | Wikipedia: Contraposition |
| å­˜åœ¨æ€§è¯æ˜ | Existence Proof | è¯æ˜æŸå¯¹è±¡å­˜åœ¨çš„è¯æ˜ / A proof that demonstrates the existence of an object | Wikipedia: Existence theorem |
| å”¯ä¸€æ€§è¯æ˜ | Uniqueness Proof | è¯æ˜æŸå¯¹è±¡å”¯ä¸€çš„è¯æ˜ / A proof that demonstrates the uniqueness of an object | Wikipedia: Uniqueness theorem |

### 1.3.2 é€»è¾‘ç³»ç»Ÿ (Logical Systems)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| å‘½é¢˜é€»è¾‘ | Propositional Logic | ç ”ç©¶å‘½é¢˜ä¹‹é—´å…³ç³»çš„é€»è¾‘ / Logic that studies relationships between propositions | Wikipedia: Propositional logic |
| ä¸€é˜¶é€»è¾‘ | First-Order Logic | åŒ…å«é‡è¯çš„é€»è¾‘ç³»ç»Ÿ / A logical system that includes quantifiers | Wikipedia: First-order logic |
| ç›´è§‰é€»è¾‘ | Intuitionistic Logic | åŸºäºæ„é€ æ€§æ•°å­¦çš„é€»è¾‘ / Logic based on constructive mathematics | Wikipedia: Intuitionistic logic |
| æ¨¡æ€é€»è¾‘ | Modal Logic | ç ”ç©¶å¿…ç„¶æ€§å’Œå¯èƒ½æ€§çš„é€»è¾‘ / Logic that studies necessity and possibility | Wikipedia: Modal logic |
| è°“è¯é€»è¾‘ | Predicate Logic | åŒ…å«è°“è¯å’Œé‡è¯çš„é€»è¾‘ / Logic that includes predicates and quantifiers | Wikipedia: Predicate logic |

---

## 1.4 ç®—æ³•å¤æ‚åº¦æœ¯è¯­ (Algorithm Complexity Terms)

### 1.4.1 æ—¶é—´å¤æ‚åº¦ (Time Complexity)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| æ—¶é—´å¤æ‚åº¦ | Time Complexity | ç®—æ³•æ‰§è¡Œæ—¶é—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„å‡½æ•° / A function describing how algorithm execution time grows with input size | Wikipedia: Time complexity |
| æ¸è¿›åˆ†æ | Asymptotic Analysis | åˆ†æç®—æ³•åœ¨æé™æƒ…å†µä¸‹çš„è¡Œä¸º / Analysis of algorithm behavior in the limit | Wikipedia: Asymptotic analysis |
| å¤§Oè®°å· | Big O Notation | æè¿°å‡½æ•°å¢é•¿ä¸Šç•Œçš„è®°å· / Notation for describing upper bounds of function growth | Wikipedia: Big O notation |
| å¤§Î©è®°å· | Big Omega Notation | æè¿°å‡½æ•°å¢é•¿ä¸‹ç•Œçš„è®°å· / Notation for describing lower bounds of function growth | Wikipedia: Big Omega notation |
| å¤§Î˜è®°å· | Big Theta Notation | æè¿°å‡½æ•°å¢é•¿ç´§ç•Œçš„è®°å· / Notation for describing tight bounds of function growth | Wikipedia: Big Theta notation |
| å¸¸æ•°æ—¶é—´ | Constant Time | O(1)æ—¶é—´å¤æ‚åº¦ / O(1) time complexity | Wikipedia: Constant time |
| å¯¹æ•°æ—¶é—´ | Logarithmic Time | O(log n)æ—¶é—´å¤æ‚åº¦ / O(log n) time complexity | Wikipedia: Logarithmic time |
| çº¿æ€§æ—¶é—´ | Linear Time | O(n)æ—¶é—´å¤æ‚åº¦ / O(n) time complexity | Wikipedia: Linear time |
| å¹³æ–¹æ—¶é—´ | Quadratic Time | O(nÂ²)æ—¶é—´å¤æ‚åº¦ / O(nÂ²) time complexity | Wikipedia: Quadratic time |
| æŒ‡æ•°æ—¶é—´ | Exponential Time | O(2â¿)æ—¶é—´å¤æ‚åº¦ / O(2â¿) time complexity | Wikipedia: Exponential time |

### 1.4.2 ç©ºé—´å¤æ‚åº¦ (Space Complexity)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| ç©ºé—´å¤æ‚åº¦ | Space Complexity | ç®—æ³•æ‰€éœ€å†…å­˜ç©ºé—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„å‡½æ•° / A function describing how algorithm memory usage grows with input size | Wikipedia: Space complexity |
| è¾…åŠ©ç©ºé—´ | Auxiliary Space | ç®—æ³•é™¤è¾“å…¥å¤–æ‰€éœ€çš„é¢å¤–ç©ºé—´ / Extra space required by an algorithm beyond the input | Wikipedia: Auxiliary space |
| åŸåœ°ç®—æ³• | In-Place Algorithm | ä½¿ç”¨å¸¸æ•°é¢å¤–ç©ºé—´çš„ç®—æ³• / An algorithm that uses constant extra space | Wikipedia: In-place algorithm |
| çº¿æ€§ç©ºé—´ | Linear Space | O(n)ç©ºé—´å¤æ‚åº¦ / O(n) space complexity | Wikipedia: Linear space |
| å¯¹æ•°ç©ºé—´ | Logarithmic Space | O(log n)ç©ºé—´å¤æ‚åº¦ / O(log n) space complexity | Wikipedia: Logarithmic space |

### 1.4.3 å¤æ‚åº¦ç±» (Complexity Classes)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| Pç±» | P (Polynomial Time) | å¯åœ¨å¤šé¡¹å¼æ—¶é—´å†…è§£å†³çš„é—®é¢˜ç±» / Class of problems solvable in polynomial time | Wikipedia: P (complexity) |
| NPç±» | NP (Nondeterministic Polynomial) | å¯åœ¨å¤šé¡¹å¼æ—¶é—´å†…éªŒè¯è§£çš„é—®é¢˜ç±» / Class of problems whose solutions can be verified in polynomial time | Wikipedia: NP (complexity) |
| PSPACEç±» | PSPACE | å¯åœ¨å¤šé¡¹å¼ç©ºé—´å†…è§£å†³çš„é—®é¢˜ç±» / Class of problems solvable in polynomial space | Wikipedia: PSPACE |
| EXPç±» | EXP (Exponential Time) | å¯åœ¨æŒ‡æ•°æ—¶é—´å†…è§£å†³çš„é—®é¢˜ç±» / Class of problems solvable in exponential time | Wikipedia: EXPTIME |
| NPå®Œå…¨ | NP-Complete | NPç±»ä¸­æœ€å›°éš¾çš„é—®é¢˜ / The hardest problems in NP | Wikipedia: NP-completeness |
| NPå›°éš¾ | NP-Hard | è‡³å°‘ä¸NPå®Œå…¨é—®é¢˜ä¸€æ ·å›°éš¾çš„é—®é¢˜ / Problems at least as hard as NP-complete problems | Wikipedia: NP-hardness |

---

## 1.5 ç±»å‹ç†è®ºæœ¯è¯­ (Type Theory Terms)

### 1.5.1 åŸºæœ¬ç±»å‹ (Basic Types)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| ç±»å‹ | Type | å€¼çš„åˆ†ç±»æˆ–é›†åˆ / A classification or set of values | Wikipedia: Type theory |
| ç±»å‹ç³»ç»Ÿ | Type System | å®šä¹‰ç±»å‹åŠå…¶å…³ç³»çš„è§„åˆ™é›†åˆ / A set of rules defining types and their relationships | Wikipedia: Type system |
| é™æ€ç±»å‹ | Static Type | åœ¨ç¼–è¯‘æ—¶ç¡®å®šçš„ç±»å‹ / Types determined at compile time | Wikipedia: Static type |
| åŠ¨æ€ç±»å‹ | Dynamic Type | åœ¨è¿è¡Œæ—¶ç¡®å®šçš„ç±»å‹ / Types determined at runtime | Wikipedia: Dynamic type |
| å¼ºç±»å‹ | Strong Type | ä¸å…è®¸éšå¼ç±»å‹è½¬æ¢çš„ç±»å‹ç³»ç»Ÿ / Type systems that don't allow implicit type conversions | Wikipedia: Strong typing |
| å¼±ç±»å‹ | Weak Type | å…è®¸éšå¼ç±»å‹è½¬æ¢çš„ç±»å‹ç³»ç»Ÿ / Type systems that allow implicit type conversions | Wikipedia: Weak typing |
| ç±»å‹æ¨å¯¼ | Type Inference | è‡ªåŠ¨æ¨å¯¼è¡¨è¾¾å¼ç±»å‹çš„è¿‡ç¨‹ / The process of automatically deducing expression types | Wikipedia: Type inference |
| ç±»å‹æ£€æŸ¥ | Type Checking | éªŒè¯ç±»å‹æ­£ç¡®æ€§çš„è¿‡ç¨‹ / The process of verifying type correctness | Wikipedia: Type checking |

### 1.5.2 é«˜çº§ç±»å‹ (Advanced Types)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| ä¾èµ–ç±»å‹ | Dependent Type | ä¾èµ–äºå€¼çš„ç±»å‹ / Types that depend on values | Wikipedia: Dependent type |
| åŒä¼¦ç±»å‹è®º | Homotopy Type Theory | ç»“åˆç±»å‹è®ºå’ŒåŒä¼¦è®ºçš„æ•°å­¦åŸºç¡€ / Mathematical foundations combining type theory and homotopy theory | Wikipedia: Homotopy type theory |
| é«˜é˜¶ç±»å‹ | Higher-Order Type | ä»¥ç±»å‹ä¸ºå‚æ•°æˆ–è¿”å›ç±»å‹çš„ç±»å‹ / Types that take or return other types | Wikipedia: Higher-order type |
| ç±»å‹æ— | Type Family | å‚æ•°åŒ–çš„ç±»å‹é›†åˆ / A parameterized collection of types | Wikipedia: Type family |
| ç±»å‹ç±» | Type Class | å®šä¹‰ç±»å‹è¡Œä¸ºçš„æ¥å£ / Interfaces that define type behavior | Wikipedia: Type class |
| å•å­ | Monad | å°è£…è®¡ç®—ä¸Šä¸‹æ–‡çš„ç»“æ„ / Structures that encapsulate computational context | Wikipedia: Monad (functional programming) |
| å‡½å­ | Functor | ä¿æŒç»“æ„çš„æ˜ å°„ / Mappings that preserve structure | Wikipedia: Functor |
| åº”ç”¨å‡½å­ | Applicative Functor | æ”¯æŒå‡½æ•°åº”ç”¨çš„å‡½å­ / Functors that support function application | Wikipedia: Applicative functor |

---

## 1.6 é€»è¾‘ç³»ç»Ÿæœ¯è¯­ (Logic System Terms)

### 1.6.1 å‘½é¢˜é€»è¾‘ (Propositional Logic)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| å‘½é¢˜ | Proposition | å¯ä»¥åˆ¤æ–­çœŸå‡çš„é™ˆè¿° / A statement that can be judged true or false | Wikipedia: Proposition |
| é€»è¾‘è¿æ¥è¯ | Logical Connective | è¿æ¥å‘½é¢˜çš„è¿ç®—ç¬¦ / Operators that connect propositions | Wikipedia: Logical connective |
| åˆå– | Conjunction | é€»è¾‘ä¸è¿ç®— / Logical AND operation | Wikipedia: Logical conjunction |
| æå– | Disjunction | é€»è¾‘æˆ–è¿ç®— / Logical OR operation | Wikipedia: Logical disjunction |
| å¦å®š | Negation | é€»è¾‘éè¿ç®— / Logical NOT operation | Wikipedia: Negation |
| è•´å« | Implication | é€»è¾‘è•´å«è¿ç®— / Logical implication operation | Wikipedia: Material conditional |
| ç­‰ä»· | Equivalence | é€»è¾‘ç­‰ä»·è¿ç®— / Logical equivalence operation | Wikipedia: Logical biconditional |
| é‡è¨€å¼ | Tautology | åœ¨æ‰€æœ‰èµ‹å€¼ä¸‹éƒ½ä¸ºçœŸçš„å…¬å¼ / A formula that is true under all assignments | Wikipedia: Tautology (logic) |
| çŸ›ç›¾å¼ | Contradiction | åœ¨æ‰€æœ‰èµ‹å€¼ä¸‹éƒ½ä¸ºå‡çš„å…¬å¼ / A formula that is false under all assignments | Wikipedia: Contradiction |
| å¯æ»¡è¶³å¼ | Satisfiable | è‡³å°‘æœ‰ä¸€ä¸ªçœŸèµ‹å€¼çš„å…¬å¼ / A formula that has at least one true assignment | Wikipedia: Satisfiability |

### 1.6.2 ä¸€é˜¶é€»è¾‘ (First-Order Logic)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| è°“è¯ | Predicate | æè¿°å¯¹è±¡æ€§è´¨çš„ç¬¦å· / Symbols that describe object properties | Wikipedia: Predicate (mathematical logic) |
| é‡è¯ | Quantifier | è¡¨ç¤ºæ•°é‡èŒƒå›´çš„ç¬¦å· / Symbols that indicate quantity scope | Wikipedia: Quantifier (logic) |
| å…¨ç§°é‡è¯ | Universal Quantifier | è¡¨ç¤º"å¯¹æ‰€æœ‰"çš„ç¬¦å· / Symbol for "for all" | Wikipedia: Universal quantification |
| å­˜åœ¨é‡è¯ | Existential Quantifier | è¡¨ç¤º"å­˜åœ¨"çš„ç¬¦å· / Symbol for "there exists" | Wikipedia: Existential quantification |
| è‡ªç”±å˜é‡ | Free Variable | ä¸è¢«é‡è¯çº¦æŸçš„å˜é‡ / Variables not bound by quantifiers | Wikipedia: Free variables and bound variables |
| çº¦æŸå˜é‡ | Bound Variable | è¢«é‡è¯çº¦æŸçš„å˜é‡ / Variables bound by quantifiers | Wikipedia: Free variables and bound variables |
| é¡¹ | Term | è¯­è¨€ä¸­çš„åŸºæœ¬è¡¨è¾¾å¼ / Basic expressions in the language | Wikipedia: Term (logic) |
| å…¬å¼ | Formula | é€»è¾‘è¯­è¨€ä¸­çš„è¡¨è¾¾å¼ / Expressions in logical language | Wikipedia: Well-formed formula |

---

## 1.7 è®¡ç®—æ¨¡å‹æœ¯è¯­ (Computational Model Terms)

### 1.7.1 Î»æ¼”ç®— (Lambda Calculus)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| Î»è¡¨è¾¾å¼ | Lambda Expression | åŒ¿åå‡½æ•°çš„è¡¨ç¤º / Representation of anonymous functions | Wikipedia: Lambda calculus |
| Î»æŠ½è±¡ | Lambda Abstraction | å‡½æ•°å®šä¹‰çš„å½¢å¼ / The form of function definition | Wikipedia: Lambda abstraction |
| Î»åº”ç”¨ | Lambda Application | å‡½æ•°è°ƒç”¨çš„å½¢å¼ / The form of function application | Wikipedia: Lambda application |
| Î²å½’çº¦ | Beta Reduction | å‡½æ•°åº”ç”¨çš„å½’çº¦è§„åˆ™ / Reduction rule for function application | Wikipedia: Beta reduction |
| Î±è½¬æ¢ | Alpha Conversion | å˜é‡é‡å‘½åçš„è½¬æ¢ / Conversion by renaming variables | Wikipedia: Alpha conversion |
| Î·è½¬æ¢ | Eta Conversion | å‡½æ•°å¤–å»¶æ€§çš„è½¬æ¢ / Conversion by function extensionality | Wikipedia: Eta conversion |
| èŒƒå¼ | Normal Form | æ— æ³•è¿›ä¸€æ­¥å½’çº¦çš„è¡¨è¾¾å¼ / Expressions that cannot be reduced further | Wikipedia: Normal form (lambda calculus) |
| å¼ºèŒƒå¼åŒ– | Strong Normalization | æ‰€æœ‰å½’çº¦åºåˆ—éƒ½ç»ˆæ­¢çš„æ€§è´¨ / Property that all reduction sequences terminate | Wikipedia: Normalization property (lambda calculus) |

### 1.7.2 è‡ªåŠ¨æœºç†è®º (Automata Theory)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| æœ‰é™è‡ªåŠ¨æœº | Finite Automaton | å…·æœ‰æœ‰é™çŠ¶æ€çš„æŠ½è±¡æœºå™¨ / Abstract machines with finite states | Wikipedia: Finite automaton |
| ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº | Deterministic Finite Automaton | æ¯ä¸ªçŠ¶æ€è½¬ç§»éƒ½æ˜¯ç¡®å®šçš„è‡ªåŠ¨æœº / Automata where each state transition is deterministic | Wikipedia: Deterministic finite automaton |
| éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº | Nondeterministic Finite Automaton | å…è®¸å¤šä¸ªå¯èƒ½è½¬ç§»çš„è‡ªåŠ¨æœº / Automata that allow multiple possible transitions | Wikipedia: Nondeterministic finite automaton |
| ä¸‹æ¨è‡ªåŠ¨æœº | Pushdown Automaton | å…·æœ‰æ ˆçš„è‡ªåŠ¨æœº / Automata with a stack | Wikipedia: Pushdown automaton |
| å›¾çµæœº | Turing Machine | å…·æœ‰æ— é™å¸¦çš„è‡ªåŠ¨æœº / Automata with an infinite tape | Wikipedia: Turing machine |
| æ­£åˆ™è¯­è¨€ | Regular Language | è¢«æœ‰é™è‡ªåŠ¨æœºè¯†åˆ«çš„è¯­è¨€ / Languages recognized by finite automata | Wikipedia: Regular language |
| ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ | Context-Free Language | è¢«ä¸‹æ¨è‡ªåŠ¨æœºè¯†åˆ«çš„è¯­è¨€ / Languages recognized by pushdown automata | Wikipedia: Context-free language |
| é€’å½’å¯æšä¸¾è¯­è¨€ | Recursively Enumerable Language | è¢«å›¾çµæœºè¯†åˆ«çš„è¯­è¨€ / Languages recognized by Turing machines | Wikipedia: Recursively enumerable language |

---

## 1.8 å®ç°ç¤ºä¾‹æœ¯è¯­ (Implementation Example Terms)

### 1.8.1 ç¼–ç¨‹è¯­è¨€ (Programming Languages)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| Rust | Rust | ç³»ç»Ÿçº§ç¼–ç¨‹è¯­è¨€ / Systems programming language | Wikipedia: Rust (programming language) |
| Haskell | Haskell | çº¯å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ / Pure functional programming language | Wikipedia: Haskell (programming language) |
| Lean | Lean | å®šç†è¯æ˜åŠ©æ‰‹å’Œç¼–ç¨‹è¯­è¨€ / Theorem prover and programming language | Wikipedia: Lean (proof assistant) |
| Agda | Agda | ä¾èµ–ç±»å‹å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ / Dependently typed functional programming language | Wikipedia: Agda (programming language) |
| Coq | Coq | äº¤äº’å¼å®šç†è¯æ˜åŠ©æ‰‹ / Interactive theorem prover | Wikipedia: Coq |
| Isabelle | Isabelle | é€šç”¨è¯æ˜åŠ©æ‰‹ / Generic proof assistant | Wikipedia: Isabelle (proof assistant) |

### 1.8.2 å½¢å¼åŒ–éªŒè¯ (Formal Verification)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| å½¢å¼åŒ–éªŒè¯ | Formal Verification | ä½¿ç”¨æ•°å­¦æ–¹æ³•éªŒè¯ç³»ç»Ÿæ­£ç¡®æ€§ / Using mathematical methods to verify system correctness | Wikipedia: Formal verification |
| å®šç†è¯æ˜ | Theorem Proving | æ„é€ æ•°å­¦è¯æ˜çš„è¿‡ç¨‹ / The process of constructing mathematical proofs | Wikipedia: Automated theorem proving |
| æ¨¡å‹æ£€æŸ¥ | Model Checking | è‡ªåŠ¨éªŒè¯æœ‰é™çŠ¶æ€ç³»ç»Ÿçš„æ–¹æ³• / Automated method for verifying finite-state systems | Wikipedia: Model checking |
| æŠ½è±¡è§£é‡Š | Abstract Interpretation | ç¨‹åºè¯­ä¹‰çš„è¿‘ä¼¼åˆ†ææ–¹æ³• / Approximate analysis method for program semantics | Wikipedia: Abstract interpretation |
| ç¨‹åºéªŒè¯ | Program Verification | éªŒè¯ç¨‹åºæ»¡è¶³è§„èŒƒçš„è¿‡ç¨‹ / Process of verifying that programs satisfy specifications | Wikipedia: Program verification |
| è§„èŒƒè¯­è¨€ | Specification Language | æè¿°ç³»ç»Ÿè¡Œä¸ºçš„è¯­è¨€ / Languages for describing system behavior | Wikipedia: Specification language |

---

## 1.9 é«˜çº§ä¸»é¢˜æœ¯è¯­ (Advanced Topic Terms)

### 1.9.1 èŒƒç•´è®º (Category Theory)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| èŒƒç•´ | Category | å¯¹è±¡å’Œæ€å°„çš„é›†åˆ / A collection of objects and morphisms | Wikipedia: Category (mathematics) |
| å¯¹è±¡ | Object | èŒƒç•´ä¸­çš„å…ƒç´  / Elements in a category | Wikipedia: Object (category theory) |
| æ€å°„ | Morphism | å¯¹è±¡ä¹‹é—´çš„æ˜ å°„ / Mappings between objects | Wikipedia: Morphism |
| å‡½å­ | Functor | èŒƒç•´ä¹‹é—´çš„æ˜ å°„ / Mappings between categories | Wikipedia: Functor |
| è‡ªç„¶å˜æ¢ | Natural Transformation | å‡½å­ä¹‹é—´çš„æ€å°„ / Morphisms between functors | Wikipedia: Natural transformation |
| å•å­ | Monad | è‡ªå‡½å­èŒƒç•´ä¸Šçš„å¹ºåŠç¾¤å¯¹è±¡ / Monoid objects in the category of endofunctors | Wikipedia: Monad (category theory) |
| ä¼´éšå‡½å­ | Adjoint Functors | å…·æœ‰ç‰¹æ®Šå…³ç³»çš„å‡½å­å¯¹ / Pairs of functors with special relationships | Wikipedia: Adjoint functors |
| æé™ | Limit | å›¾çš„æé™å¯¹è±¡ / Limit objects of diagrams | Wikipedia: Limit (category theory) |
| ä½™æé™ | Colimit | å›¾çš„ä½™æé™å¯¹è±¡ / Colimit objects of diagrams | Wikipedia: Colimit |
| ç§¯ | Product | ä¸¤ä¸ªå¯¹è±¡çš„ç§¯ / Product of two objects | Wikipedia: Product (category theory) |
| ä½™ç§¯ | Coproduct | ä¸¤ä¸ªå¯¹è±¡çš„ä½™ç§¯ / Coproduct of two objects | Wikipedia: Coproduct |

### 1.9.2 åŒä¼¦ç±»å‹è®º (Homotopy Type Theory)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| åŒä¼¦ç±»å‹ | Homotopy Type | è¢«è§†ä¸ºç©ºé—´çš„ç±»å‹ / Types viewed as spaces | Wikipedia: Homotopy type theory |
| è·¯å¾„ | Path | ç±»å‹å…ƒç´ ä¹‹é—´çš„ç­‰ä»·å…³ç³» / Equivalence relations between type elements | Wikipedia: Path (topology) |
| é«˜é˜¶è·¯å¾„ | Higher Path | è·¯å¾„ä¹‹é—´çš„ç­‰ä»·å…³ç³» / Equivalence relations between paths | Wikipedia: Higher-order path |
| åŒä¼¦ç­‰ä»· | Homotopy Equivalence | ç±»å‹ä¹‹é—´çš„ç­‰ä»·å…³ç³» / Equivalence relations between types | Wikipedia: Homotopy equivalence |
| å•å€¼å…¬ç† | Univalence Axiom | ç­‰ä»·ç±»å‹ç›¸ç­‰çš„å…¬ç† / Axiom that equivalent types are equal | Wikipedia: Univalence axiom |
| é«˜é˜¶å½’çº³ç±»å‹ | Higher Inductive Type | åŒ…å«è·¯å¾„çš„å½’çº³ç±»å‹ / Inductive types that include paths | Wikipedia: Higher inductive type |
| åŒä¼¦ç¾¤ | Homotopy Group | ç©ºé—´çš„ä»£æ•°ä¸å˜é‡ / Algebraic invariants of spaces | Wikipedia: Homotopy group |
| çº¤ç»´ä¸› | Fiber Bundle | å±€éƒ¨å¹³å‡¡çš„ç©ºé—´ / Locally trivial spaces | Wikipedia: Fiber bundle |
| ä¸»ä¸› | Principal Bundle | å…·æœ‰ç¾¤ä½œç”¨çš„çº¤ç»´ä¸› / Fiber bundles with group actions | Wikipedia: Principal bundle |

### 1.9.3 è¯æ˜åŠ©æ‰‹ (Proof Assistant)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| è¯æ˜åŠ©æ‰‹ | Proof Assistant | å¸®åŠ©æ„é€ å½¢å¼åŒ–è¯æ˜çš„è®¡ç®—æœºç¨‹åº / Computer programs that help construct formal proofs | Wikipedia: Proof assistant |
| äº¤äº’å¼è¯æ˜ | Interactive Proving | ç”¨æˆ·æŒ‡å¯¼çš„è¯æ˜æ„é€  / User-guided proof construction | Wikipedia: Interactive theorem proving |
| è‡ªåŠ¨åŒ–è¯æ˜ | Automated Proving | è‡ªåŠ¨æ„é€ è¯æ˜çš„è¿‡ç¨‹ / Process of automatically constructing proofs | Wikipedia: Automated theorem proving |
| ç­–ç•¥ | Tactic | è¯æ˜æ„é€ çš„åŸºæœ¬å·¥å…· / Basic tools for proof construction | Wikipedia: Tactic (proof assistant) |
| ç›®æ ‡ | Goal | éœ€è¦è¯æ˜çš„å‘½é¢˜ / Propositions that need to be proved | Wikipedia: Goal (proof assistant) |
| å‡è®¾ | Hypothesis | è¯æ˜ä¸­å¯ç”¨çš„å‰æ / Premises available in a proof | Wikipedia: Hypothesis |
| å¼•ç† | Lemma | è¾…åŠ©è¯æ˜çš„å‘½é¢˜ / Propositions that assist in proofs | Wikipedia: Lemma (mathematics) |
| å®šç† | Theorem | å·²è¯æ˜çš„é‡è¦å‘½é¢˜ / Important propositions that have been proved | Wikipedia: Theorem |
| å…¬ç† | Axiom | æ— éœ€è¯æ˜çš„åŸºæœ¬å‡è®¾ / Basic assumptions that need no proof | Wikipedia: Axiom |
| æ¨ç†è§„åˆ™ | Inference Rule | ä»å‰ææ¨å¯¼ç»“è®ºçš„è§„åˆ™ / Rules for deriving conclusions from premises | Wikipedia: Rule of inference |

---

## 1.10 ç®—æ³•ç†è®ºæœ¯è¯­ (Algorithm Theory Terms)

### 1.10.1 ç®—æ³•è®¾è®¡ (Algorithm Design)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| ç®—æ³• | Algorithm | è§£å†³é—®é¢˜çš„æœ‰é™æ­¥éª¤åºåˆ— / A finite sequence of steps to solve a problem | Wikipedia: Algorithm |
| ç®—æ³•è®¾è®¡ | Algorithm Design | æ„é€ ç®—æ³•çš„è¿‡ç¨‹ / The process of constructing algorithms | Wikipedia: Algorithm design |
| åˆ†æ²»æ³• | Divide and Conquer | å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜çš„ç­–ç•¥ / Strategy of breaking problems into subproblems | Wikipedia: Divide and conquer algorithm |
| åŠ¨æ€è§„åˆ’ | Dynamic Programming | é€šè¿‡å­˜å‚¨å­é—®é¢˜è§£æ¥ä¼˜åŒ–é€’å½’çš„ç­–ç•¥ / Strategy of optimizing recursion by storing subproblem solutions | Wikipedia: Dynamic programming |
| è´ªå¿ƒç®—æ³• | Greedy Algorithm | åœ¨æ¯ä¸€æ­¥é€‰æ‹©å±€éƒ¨æœ€ä¼˜è§£çš„ç®—æ³• / Algorithms that choose locally optimal solutions at each step | Wikipedia: Greedy algorithm |
| å›æº¯ç®—æ³• | Backtracking | é€šè¿‡å°è¯•å’Œå›æº¯æ¥æœç´¢è§£çš„ç®—æ³• / Algorithms that search for solutions by trying and backtracking | Wikipedia: Backtracking |
| åˆ†æ”¯é™ç•Œ | Branch and Bound | é€šè¿‡å‰ªææ¥ä¼˜åŒ–æœç´¢çš„ç®—æ³• / Algorithms that optimize search by pruning | Wikipedia: Branch and bound |
| éšæœºç®—æ³• | Randomized Algorithm | ä½¿ç”¨éšæœºæ€§çš„ç®—æ³• / Algorithms that use randomness | Wikipedia: Randomized algorithm |
| è¿‘ä¼¼ç®—æ³• | Approximation Algorithm | æä¾›è¿‘ä¼¼è§£çš„ç®—æ³• / Algorithms that provide approximate solutions | Wikipedia: Approximation algorithm |
| å¯å‘å¼ç®—æ³• | Heuristic Algorithm | åŸºäºç»éªŒè§„åˆ™çš„ç®—æ³• / Algorithms based on experience-based rules | Wikipedia: Heuristic |

### 1.10.2 æ•°æ®ç»“æ„ (Data Structures)

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/Definition | å‚è€ƒæ¥æº/Reference |
|----|----|----|----|
| æ•°æ®ç»“æ„ | Data Structure | ç»„ç»‡å’Œå­˜å‚¨æ•°æ®çš„æ–¹å¼ / Ways of organizing and storing data | Wikipedia: Data structure |
| æ•°ç»„ | Array | è¿ç»­å­˜å‚¨çš„ç›¸åŒç±»å‹å…ƒç´ é›†åˆ / Collection of same-type elements stored contiguously | Wikipedia: Array data structure |
| é“¾è¡¨ | Linked List | é€šè¿‡æŒ‡é’ˆè¿æ¥çš„èŠ‚ç‚¹åºåˆ— / Sequence of nodes connected by pointers | Wikipedia: Linked list |
| æ ˆ | Stack | åè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ / Last-in-first-out data structure | Wikipedia: Stack (abstract data type) |
| é˜Ÿåˆ— | Queue | å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ / First-in-first-out data structure | Wikipedia: Queue (abstract data type) |
| æ ‘ | Tree | å±‚æ¬¡ç»“æ„çš„æ•°æ®ç»„ç»‡æ–¹å¼ / Hierarchical way of organizing data | Wikipedia: Tree (data structure) |
| å›¾ | Graph | èŠ‚ç‚¹å’Œè¾¹çš„é›†åˆ / Collection of nodes and edges | Wikipedia: Graph (discrete mathematics) |
| æ•£åˆ—è¡¨ | Hash Table | åŸºäºæ•£åˆ—å‡½æ•°çš„æ•°æ®ç»“æ„ / Data structure based on hash functions | Wikipedia: Hash table |
| å † | Heap | ç‰¹æ®Šçš„æ ‘å½¢æ•°æ®ç»“æ„ / Special tree-shaped data structure | Wikipedia: Heap (data structure) |
| å­—å…¸ | Dictionary | é”®å€¼å¯¹çš„æ•°æ®ç»“æ„ / Data structure of key-value pairs | Wikipedia: Dictionary (data structure) |

---

## ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### ç›¸å…³æ–‡æ¡£ / Related Documents

- `11-å›½é™…åŒ–/02-Wikiå›½é™…æ¦‚å¿µå¯¹é½.md` - Wikiå›½é™…æ¦‚å¿µå¯¹é½æ–‡æ¡£
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` - ç®—æ³•å…¨æ™¯æ¢³ç†ï¼ˆåŒ…å«æœ¯è¯­å®šä¹‰ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•
- `docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md` - é¡¹ç›®æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨

### çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **11-å›½é™…åŒ–** æ¨¡å—ï¼Œæ˜¯é¡¹ç›®å›½é™…åŒ–æ”¯æŒçš„åŸºç¡€æ–‡æ¡£ï¼Œä¸ºå¤šè¯­è¨€æ”¯æŒæä¾›æœ¯è¯­æ ‡å‡†åŒ–åŸºç¡€ã€‚

### VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§1 - å½¢å¼åŒ–å®šä¹‰ï¼ˆåŒ…å«ç®—æ³•ã€ä¿¡æ¯ã€æ•°æ®ç­‰æœ¯è¯­å®šä¹‰ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` Â§6 - æ ‡å‡†å¯¹é½ç´¢å¼•ï¼ˆWikipediaæ¦‚å¿µå¯¹é½ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

---

*æœ¬æœ¯è¯­å¯¹ç…§è¡¨æ¶µç›–äº†é¡¹ç›®ä¸­çš„æ‰€æœ‰æ ¸å¿ƒæ¦‚å¿µï¼Œç¡®ä¿ä¸Wikiå›½é™…æ¦‚å¿µå®šä¹‰å®Œå…¨ä¸€è‡´ï¼Œä¸ºåç»­å¤šè¯­è¨€æ”¯æŒæä¾›æ ‡å‡†åŒ–åŸºç¡€ã€‚*

## æ–°å¢æœ¯è¯­å¯¹ç…§ï¼ˆæœ¬æœŸï¼‰

| ä¸­æ–‡ | è‹±æ–‡ | è¯´æ˜ | å…³è”æ–‡æ¡£ |
|---|---|---|---|
| åä¾‹å¼•å¯¼åˆæˆ | CEGIS (Counterexample-Guided Inductive Synthesis) | ä»¥åä¾‹é©±åŠ¨çš„åˆæˆé—­ç¯ | `10-é«˜çº§ä¸»é¢˜/21-ç®—æ³•åˆæˆä¸å…ƒç¼–ç¨‹é«˜çº§åº”ç”¨.md` |
| è¯­æ³•å¼•å¯¼åˆæˆ | SyGuS (Syntax-Guided Synthesis) | å¸¦è¯­æ³•çº¦æŸçš„ç¨‹åºåˆæˆèŒƒå¼ | åŒä¸Š |
| äºŒæ¬¡æ— çº¦æŸäºŒå…ƒä¼˜åŒ– | QUBO | å°†ç»„åˆé—®é¢˜è¡¨è¾¾ä¸ºäºŒå…ƒå˜é‡çš„äºŒæ¬¡ä¼˜åŒ– | `10-é«˜çº§ä¸»é¢˜/22-é‡å­ç®—æ³•åœ¨é‡‘èç§‘æŠ€ä¸­çš„åº”ç”¨.md` |
| é£é™©ä»·å€¼ | VaR (Value at Risk) | åœ¨ç»™å®šç½®ä¿¡åº¦ä¸‹çš„æœ€å¤§æ½œåœ¨æŸå¤± | åŒä¸Š |
| æ¡ä»¶é£é™©ä»·å€¼ | CVaR (Conditional VaR) | è¶…è¿‡VaRéƒ¨åˆ†çš„æœŸæœ›æŸå¤± | åŒä¸Š |
| å‚æ•°åŒ–é‡å­ç”µè·¯ | PQC (Parametric Quantum Circuit) | å¸¦å¯è®­ç»ƒå‚æ•°çš„é‡å­çº¿è·¯ | `10-é«˜çº§ä¸»é¢˜/28-ç®—æ³•é‡å­æœºå™¨å­¦ä¹ ç†è®º.md` |
| å·®åˆ†éšç§ | DP (Differential Privacy) | é€šè¿‡å™ªå£°æœºåˆ¶ä¿æŠ¤éšç§ | `10-é«˜çº§ä¸»é¢˜/27-ç®—æ³•è”é‚¦å­¦ä¹ ä¸éšç§ä¿æŠ¤ç†è®º.md` |
| å®‰å…¨å¤šæ–¹è®¡ç®— | SMPC (Secure Multi-Party Computation) | å¤šå‚ä¸æ–¹å®‰å…¨è®¡ç®— | åŒä¸Š |
| åŒæ€åŠ å¯† | HE (Homomorphic Encryption) | æ”¯æŒå¯†æ–‡è®¡ç®—çš„åŠ å¯†æŠ€æœ¯ | åŒä¸Š |
| éšæœºå¹³æ»‘ | Randomized Smoothing | ä¸€ç±»è®¤è¯é²æ£’æ€§æŠ€æœ¯ | `10-é«˜çº§ä¸»é¢˜/26-ç®—æ³•é²æ£’æ€§ä¸å¯¹æŠ—æ€§é˜²å¾¡ç†è®º.md` |
