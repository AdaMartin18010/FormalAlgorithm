---
title: 7.3 ç»„åˆå­é€»è¾‘ / Combinatory Logic
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: è®¡ç®—æ¨¡å‹å·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 7.3 ç»„åˆå­é€»è¾‘ / Combinatory Logic

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€ç»„åˆå­é€»è¾‘çš„å½¢å¼åŒ–å®šä¹‰ã€SKI/BCKWç»„åˆå­ä¸å½’çº¦ç³»ç»Ÿã€‚
- å»ºç«‹ç»„åˆå­é€»è¾‘ä¸Î»æ¼”ç®—çš„å¯¹åº”å…³ç³»ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ç»„åˆå­é€»è¾‘ã€SKIç»„åˆå­ã€BCKWç»„åˆå­ã€ç»„åˆå­å½’çº¦ã€ç±»å‹ç»„åˆå­é€»è¾‘ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ç»„åˆå­é€»è¾‘ï¼ˆCombinatory Logicï¼‰ï¼šä½¿ç”¨ç»„åˆå­è¡¨ç¤ºå¯è®¡ç®—å‡½æ•°çš„å½¢å¼ç³»ç»Ÿã€‚
- SKIç»„åˆå­ï¼šSã€Kã€Iä¸‰ä¸ªåŸºæœ¬ç»„åˆå­ã€‚
- BCKWç»„åˆå­ï¼šBã€Cã€Kã€Wå››ä¸ªåŸºæœ¬ç»„åˆå­ã€‚
- è®°å·çº¦å®šï¼š`S`ã€`K`ã€`I` è¡¨ç¤ºç»„åˆå­ï¼Œ`â†’` è¡¨ç¤ºå½’çº¦ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- Î»æ¼”ç®—ï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/02-Î»æ¼”ç®—.md`ã€‚
- å›¾çµæœºï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/01-å›¾çµæœº.md`ã€‚
- ç±»å‹ç†è®ºï¼šå‚è§ `05-ç±»å‹ç†è®º/` ç›¸å…³æ–‡æ¡£ã€‚

### å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References

ç»„åˆå­é€»è¾‘ä¸è®¡ç®—æ¨¡å‹å¯ä¸ **MIT 18.404 Theory of Computation**ã€**CMU 15-251** ç­‰è¯¾ç¨‹å¯¹æ ‡ã€‚è¯¾ç¨‹ä¸æ¨¡å—æ˜ å°„è§ [å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- SKIç»„åˆå­
- BCKWç»„åˆå­
- å½’çº¦
- ç±»å‹ç³»ç»Ÿ

## ç›®å½• (Table of Contents)

- [7.3 ç»„åˆå­é€»è¾‘ / Combinatory Logic](#73-ç»„åˆå­é€»è¾‘--combinatory-logic)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References](#å›½é™…è¯¾ç¨‹å‚è€ƒ--international-course-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [3.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#31-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [3.1.1 ç»„åˆå­é€»è¾‘å®šä¹‰ (Definition of Combinatory Logic)](#311-ç»„åˆå­é€»è¾‘å®šä¹‰-definition-of-combinatory-logic)
  - [3.1.2 ç»„åˆå­é€»è¾‘çš„å†å² (History of Combinatory Logic)](#312-ç»„åˆå­é€»è¾‘çš„å†å²-history-of-combinatory-logic)
  - [3.1.3 ç»„åˆå­é€»è¾‘ä¸Î»æ¼”ç®—çš„å…³ç³» (Relationship with Lambda Calculus)](#313-ç»„åˆå­é€»è¾‘ä¸Î»æ¼”ç®—çš„å…³ç³»-relationship-with-lambda-calculus)
- [3.1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#314-å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
- [3.2 SKIç»„åˆå­ (SKI Combinators)](#32-skiç»„åˆå­-ski-combinators)
  - [3.2.1 SKIç»„åˆå­å®šä¹‰ (Definition of SKI Combinators)](#321-skiç»„åˆå­å®šä¹‰-definition-of-ski-combinators)
  - [3.2.2 SKIç»„åˆå­çš„æ€§è´¨ (Properties of SKI Combinators)](#322-skiç»„åˆå­çš„æ€§è´¨-properties-of-ski-combinators)
  - [3.2.3 SKIç»„åˆå­çš„ç»„åˆ (Composition of SKI Combinators)](#323-skiç»„åˆå­çš„ç»„åˆ-composition-of-ski-combinators)
- [3.3 BCKWç»„åˆå­ (BCKW Combinators)](#33-bckwç»„åˆå­-bckw-combinators)
  - [3.3.1 BCKWç»„åˆå­å®šä¹‰ (Definition of BCKW Combinators)](#331-bckwç»„åˆå­å®šä¹‰-definition-of-bckw-combinators)
  - [3.3.2 BCKWç»„åˆå­çš„æ€§è´¨ (Properties of BCKW Combinators)](#332-bckwç»„åˆå­çš„æ€§è´¨-properties-of-bckw-combinators)
  - [3.3.3 BCKWç»„åˆå­çš„å…³ç³» (Relationships of BCKW Combinators)](#333-bckwç»„åˆå­çš„å…³ç³»-relationships-of-bckw-combinators)
- [3.4 å½’çº¦ (Reduction)](#34-å½’çº¦-reduction)
  - [3.4.1 ç»„åˆå­å½’çº¦è§„åˆ™ (Combinator Reduction Rules)](#341-ç»„åˆå­å½’çº¦è§„åˆ™-combinator-reduction-rules)
  - [3.4.2 å½’çº¦ç­–ç•¥ (Reduction Strategies)](#342-å½’çº¦ç­–ç•¥-reduction-strategies)
  - [3.4.3 æ­£è§„å½¢å¼ (Normal Form)](#343-æ­£è§„å½¢å¼-normal-form)
- [3.5 ç±»å‹ç³»ç»Ÿ (Type System)](#35-ç±»å‹ç³»ç»Ÿ-type-system)
  - [3.5.1 ç®€å•ç±»å‹ç»„åˆå­é€»è¾‘ (Simply Typed Combinatory Logic)](#351-ç®€å•ç±»å‹ç»„åˆå­é€»è¾‘-simply-typed-combinatory-logic)
  - [3.5.2 å¤šæ€ç»„åˆå­é€»è¾‘ (Polymorphic Combinatory Logic)](#352-å¤šæ€ç»„åˆå­é€»è¾‘-polymorphic-combinatory-logic)
  - [3.5.3 ä¾èµ–ç±»å‹ç»„åˆå­é€»è¾‘ (Dependent Combinatory Logic)](#353-ä¾èµ–ç±»å‹ç»„åˆå­é€»è¾‘-dependent-combinatory-logic)
- [3.6 å®ç°ç¤ºä¾‹ (Implementation Examples)](#36-å®ç°ç¤ºä¾‹-implementation-examples)
  - [3.6.1 ç»„åˆå­é€»è¾‘è§£é‡Šå™¨ (Combinatory Logic Interpreter)](#361-ç»„åˆå­é€»è¾‘è§£é‡Šå™¨-combinatory-logic-interpreter)
  - [3.6.2 ç±»å‹ç»„åˆå­é€»è¾‘å®ç° (Typed Combinatory Logic Implementation)](#362-ç±»å‹ç»„åˆå­é€»è¾‘å®ç°-typed-combinatory-logic-implementation)
  - [3.6.3 ç»„åˆå­é€»è¾‘æµ‹è¯• (Combinatory Logic Testing)](#363-ç»„åˆå­é€»è¾‘æµ‹è¯•-combinatory-logic-testing)
- [3.7 å‚è€ƒæ–‡çŒ® / References](#37-å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)

---

## 3.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 3.1.1 ç»„åˆå­é€»è¾‘å®šä¹‰ (Definition of Combinatory Logic)

**ç»„åˆå­é€»è¾‘å®šä¹‰ / Definition of Combinatory Logic:**

ç»„åˆå­é€»è¾‘æ˜¯ä¸€ç§å½¢å¼ç³»ç»Ÿï¼Œå®ƒä½¿ç”¨ç»„åˆå­ï¼ˆå›ºå®šçš„å‡½æ•°ï¼‰æ¥è¡¨ç¤ºæ‰€æœ‰å¯è®¡ç®—å‡½æ•°ï¼Œè€Œä¸éœ€è¦å˜é‡ç»‘å®šã€‚å®ƒæ˜¯Î»æ¼”ç®—çš„æ›¿ä»£å½¢å¼ï¼Œç”±æ‘©è¥¿Â·ç”³èŠ¬å…‹å°”å’Œå“ˆæ–¯å…‹å°”Â·æŸ¯é‡Œå‘å±•ã€‚

Combinatory logic is a formal system that uses combinators (fixed functions) to represent all computable functions without variable binding. It is an alternative to lambda calculus, developed by Moses SchÃ¶nfinkel and Haskell Curry.

**ç»„åˆå­é€»è¾‘çš„ç‰¹ç‚¹ / Characteristics of Combinatory Logic:**

1. **æ— å˜é‡ç»‘å®š (No Variable Binding) / No Variable Binding:**
   - ä¸éœ€è¦Î»æŠ½è±¡ / No lambda abstraction needed
   - æ‰€æœ‰å‡½æ•°éƒ½é€šè¿‡ç»„åˆå­è¡¨ç¤º / All functions represented through combinators

2. **ç»„åˆæ€§ (Combinatorial) / Combinatorial:**
   - é€šè¿‡ç»„åˆå­ç»„åˆæ„å»ºå¤æ‚å‡½æ•° / Build complex functions through combinator composition
   - å‡½æ•°å¼ç¼–ç¨‹çš„åŸºç¡€ / Foundation of functional programming

3. **å›¾çµå®Œå¤‡æ€§ (Turing Completeness) / Turing Completeness:**
   - å¯ä»¥è¡¨è¾¾æ‰€æœ‰å¯è®¡ç®—å‡½æ•° / Can express all computable functions
   - ä¸Î»æ¼”ç®—ç­‰ä»· / Equivalent to lambda calculus

### 3.1.2 ç»„åˆå­é€»è¾‘çš„å†å² (History of Combinatory Logic)

**åˆ›å§‹äºº / Founders:**

1. **æ‘©è¥¿Â·ç”³èŠ¬å…‹å°” (Moses SchÃ¶nfinkel)**: 1924å¹´é¦–æ¬¡æå‡ºç»„åˆå­é€»è¾‘
2. **å“ˆæ–¯å…‹å°”Â·æŸ¯é‡Œ (Haskell Curry)**: è¿›ä¸€æ­¥å‘å±•äº†ç»„åˆå­é€»è¾‘ç†è®º

**å‘å±•å†ç¨‹ / Development History:**

1. **1924å¹´**: ç”³èŠ¬å…‹å°”é¦–æ¬¡æå‡ºç»„åˆå­é€»è¾‘ / SchÃ¶nfinkel first proposes combinatory logic
2. **1930å¹´ä»£**: æŸ¯é‡Œè¿›ä¸€æ­¥å‘å±•ç†è®º / Curry further develops the theory
3. **1950å¹´ä»£**: åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­åº”ç”¨ / Application in functional programming
4. **ç°ä»£**: åœ¨ç±»å‹ç†è®ºå’Œç¨‹åºè¯­è¨€ç†è®ºä¸­å¹¿æ³›åº”ç”¨ / Widespread application in type theory and programming language theory

### 3.1.3 ç»„åˆå­é€»è¾‘ä¸Î»æ¼”ç®—çš„å…³ç³» (Relationship with Lambda Calculus)

**ç­‰ä»·æ€§ (Equivalence) / Equivalence:**

ç»„åˆå­é€»è¾‘ä¸Î»æ¼”ç®—åœ¨è®¡ç®—èƒ½åŠ›ä¸Šæ˜¯ç­‰ä»·çš„ã€‚

Combinatory logic and lambda calculus are equivalent in computational power.

**è½¬æ¢å…³ç³» (Translation) / Translation:**

1. **Î»æ¼”ç®—åˆ°ç»„åˆå­é€»è¾‘ (Lambda Calculus to Combinatory Logic) / Lambda Calculus to Combinatory Logic:**
   - é€šè¿‡æŠ½è±¡æ¶ˆé™¤ç®—æ³• / Through abstraction elimination algorithm
   - å°†Î»é¡¹è½¬æ¢ä¸ºç»„åˆå­é¡¹ / Convert lambda terms to combinator terms

2. **ç»„åˆå­é€»è¾‘åˆ°Î»æ¼”ç®— (Combinatory Logic to Lambda Calculus) / Combinatory Logic to Lambda Calculus:**
   - é€šè¿‡ç›´æ¥ç¿»è¯‘ / Through direct translation
   - å°†ç»„åˆå­é¡¹è½¬æ¢ä¸ºÎ»é¡¹ / Convert combinator terms to lambda terms

---

## 3.1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

**è§£é‡Šä¸ç›´è§‚**ï¼šç»„åˆå­é€»è¾‘ç”¨å›ºå®šç»„åˆå­ï¼ˆSã€Kã€I ç­‰ï¼‰è¡¨ç¤ºå¯è®¡ç®—å‡½æ•°ï¼Œæ— éœ€å˜é‡ç»‘å®šï¼›ä¸ Î» æ¼”ç®—ç­‰ä»·ï¼ˆæŠ½è±¡ç®—æ³•ï¼‰ï¼Œä¸ºæ— å˜é‡å®ç°ä¸ç±»å‹ç»„åˆå­æä¾›åŸºç¡€ï¼ˆè§ 02-Î»æ¼”ç®—ã€05-ç±»å‹ç†è®ºï¼‰ã€‚

**æ¦‚å¿µå±æ€§è¡¨**ï¼šSã€Kã€I â€” SKI ç»„åˆå­ï¼›Bã€Cã€Kã€W â€” BCKWï¼›å½’çº¦è§„åˆ™ â€” S f g x â†’ f x (g x) ç­‰ï¼›ä¸ Î» æ¼”ç®— â€” æŠ½è±¡ç®—æ³•å°† Î» é¡¹è¯‘ä¸ºç»„åˆå­ã€‚

**æ¦‚å¿µå…³ç³»**ï¼šç»„åˆå­é€»è¾‘ â€”equivalent_toâ€” Î» æ¼”ç®—ï¼ˆè§ 02ï¼‰ï¼›ä¸ 05-ç±»å‹ç†è®º â€” ç±»å‹ç»„åˆå­é€»è¾‘ï¼ˆè§ Â§3.5ï¼‰ï¼›ä¸ 01-å›¾çµæœº â€” Church-Turing ç­‰ä»·é“¾ï¼ˆè§ 08ï¼‰ã€‚

**æ¦‚å¿µä¾èµ–å›¾**ï¼šSKI/BCKW â†’ ç»„åˆå­é€»è¾‘ï¼›æŠ½è±¡ç®—æ³• â†’ Î» æ¼”ç®—ç­‰ä»·ï¼›ç±»å‹ç»„åˆå­ â†’ 05-ç®€å•ç±»å‹è®ºï¼›è§ 02ã€08ã€‚

**æ€ç»´å¯¼å›¾**ï¼šç»„åˆå­é€»è¾‘ â†’ SKIã€BCKWã€å½’çº¦ã€æ­£è§„å½¢å¼ã€ç±»å‹ç»„åˆå­ â†’ Î» æ¼”ç®—ã€ç±»å‹è®ºã€å›¾çµå®Œå¤‡ã€‚

**å¤šç»´çŸ©é˜µ**ï¼šSKI/BCKW â€” ç»„åˆå­é›†ï¼›æ— ç±»å‹/ç±»å‹ â€” ä¸ 05 å¯¹åº”ï¼›ä¸ Î» æ¼”ç®— â€” ç­‰ä»·ä¸ç¿»è¯‘ã€‚

**å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘**ï¼šç»„åˆå­ä¸å½’çº¦è§„åˆ™ â†’ å›¾çµå®Œå¤‡ï¼›ä¸ Î» æ¼”ç®—ç­‰ä»·ï¼ˆæŠ½è±¡ç®—æ³•ï¼‰ï¼›ç±»å‹ç»„åˆå­ â†’ è§ Â§3.5ã€‚

**åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘**ï¼šæ— å˜é‡å®ç° â†’ ç»„åˆå­è§£é‡Šå™¨ï¼ˆè§ Â§3.6ï¼‰ï¼›ç±»å‹è®ºå¯¹åº” â†’ è§ 05-ç±»å‹ç³»ç»Ÿï¼›å¯è®¡ç®—æ€§ â†’ è§ 01ã€02ã€08ã€‚

---

## 3.2 SKIç»„åˆå­ (SKI Combinators)

### 3.2.1 SKIç»„åˆå­å®šä¹‰ (Definition of SKI Combinators)

**SKIç»„åˆå­å®šä¹‰ / Definition of SKI Combinators:**

SKIç»„åˆå­æ˜¯ç»„åˆå­é€»è¾‘ä¸­æœ€åŸºæœ¬çš„ä¸‰ä¸ªç»„åˆå­ï¼Œå®ƒä»¬æ„æˆäº†ä¸€ä¸ªå›¾çµå®Œå¤‡çš„ç³»ç»Ÿã€‚

SKI combinators are the three most basic combinators in combinatory logic, forming a Turing complete system.

**Sç»„åˆå­ (S Combinator) / S Combinator:**

$$S = \lambda x y z.((x z)(y z))$$

Sç»„åˆå­å®ç°å‡½æ•°åº”ç”¨çš„åˆ†å‘ã€‚

The S combinator implements function application distribution.

**Kç»„åˆå­ (K Combinator) / K Combinator:**

$$K = \lambda x y.x$$

Kç»„åˆå­å®ç°å¸¸é‡å‡½æ•°ã€‚

The K combinator implements the constant function.

**Iç»„åˆå­ (I Combinator) / I Combinator:**

$$I = \lambda x.x$$

Iç»„åˆå­å®ç°æ’ç­‰å‡½æ•°ã€‚

The I combinator implements the identity function.

### 3.2.2 SKIç»„åˆå­çš„æ€§è´¨ (Properties of SKI Combinators)

**Sç»„åˆå­çš„æ€§è´¨ / Properties of S Combinator:**

1. **åº”ç”¨åˆ†å‘ (Application Distribution) / Application Distribution:**
   - $S f g x = (f x)(g x)$
   - å°†å‡½æ•°åº”ç”¨åˆ†å‘åˆ°ä¸¤ä¸ªå‚æ•° / Distributes function application to two arguments

2. **ç»„åˆæ€§ (Combinatorial) / Combinatorial:**
   - å¯ä»¥ç»„åˆå…¶ä»–ç»„åˆå­ / Can combine other combinators
   - å®ç°å¤æ‚çš„å‡½æ•°ç»„åˆ / Implements complex function composition

**Kç»„åˆå­çš„æ€§è´¨ / Properties of K Combinator:**

1. **å¸¸é‡å‡½æ•° (Constant Function) / Constant Function:**
   - $K x y = x$
   - å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•° / Ignores the second argument

2. **æŠ•å½±å‡½æ•° (Projection Function) / Projection Function:**
   - å®ç°åˆ°ç¬¬ä¸€ä¸ªå‚æ•°çš„æŠ•å½± / Implements projection to the first argument

**Iç»„åˆå­çš„æ€§è´¨ / Properties of I Combinator:**

1. **æ’ç­‰å‡½æ•° (Identity Function) / Identity Function:**
   - $I x = x$
   - è¿”å›è¾“å…¥ä¸å˜ / Returns input unchanged

2. **å•ä½å…ƒ (Unit Element) / Unit Element:**
   - åœ¨ç»„åˆè¿ç®—ä¸­ä½œä¸ºå•ä½å…ƒ / Acts as unit element in composition

### 3.2.3 SKIç»„åˆå­çš„ç»„åˆ (Composition of SKI Combinators)

**ç»„åˆè§„åˆ™ (Composition Rules) / Composition Rules:**

1. **Sç»„åˆè§„åˆ™ (S Composition Rule) / S Composition Rule:**
   - $(S f g) x = (f x)(g x)$

2. **Kç»„åˆè§„åˆ™ (K Composition Rule) / K Composition Rule:**
   - $(K x) y = x$

3. **Iç»„åˆè§„åˆ™ (I Composition Rule) / I Composition Rule:**
   - $I x = x$

**å¤æ‚ç»„åˆç¤ºä¾‹ / Complex Composition Examples:**

1. **å¸ƒå°”çœŸ (Boolean True) / Boolean True:**
   - $T = K = \lambda x y.x$

2. **å¸ƒå°”å‡ (Boolean False) / Boolean False:**
   - $F = K I = \lambda x y.y$

3. **é€»è¾‘ä¸ (Logical AND) / Logical AND:**
   - $AND = S(S(K(S(K S)))(S(S(K S)(S(K K)(S(K S)(S(K(S K))K))))(K(K K))$

---

## 3.3 BCKWç»„åˆå­ (BCKW Combinators)

### 3.3.1 BCKWç»„åˆå­å®šä¹‰ (Definition of BCKW Combinators)

**BCKWç»„åˆå­å®šä¹‰ / Definition of BCKW Combinators:**

BCKWç»„åˆå­æ˜¯SKIç»„åˆå­çš„æ‰©å±•ï¼Œæä¾›äº†æ›´å¤šçš„ç»„åˆå­æ¥ç®€åŒ–è¡¨è¾¾ã€‚

BCKW combinators are an extension of SKI combinators, providing more combinators to simplify expressions.

**Bç»„åˆå­ (B Combinator) / B Combinator:**

$$B = \lambda f g x.f(g x)$$

Bç»„åˆå­å®ç°å‡½æ•°ç»„åˆã€‚

The B combinator implements function composition.

**Cç»„åˆå­ (C Combinator) / C Combinator:**

$$C = \lambda f x y.f y x$$

Cç»„åˆå­å®ç°å‚æ•°äº¤æ¢ã€‚

The C combinator implements argument swapping.

**Kç»„åˆå­ (K Combinator) / K Combinator:**

$$K = \lambda x y.x$$

Kç»„åˆå­å®ç°å¸¸é‡å‡½æ•°ã€‚

The K combinator implements the constant function.

**Wç»„åˆå­ (W Combinator) / W Combinator:**

$$W = \lambda f x.f x x$$

Wç»„åˆå­å®ç°å‚æ•°å¤åˆ¶ã€‚

The W combinator implements argument duplication.

### 3.3.2 BCKWç»„åˆå­çš„æ€§è´¨ (Properties of BCKW Combinators)

**Bç»„åˆå­çš„æ€§è´¨ / Properties of B Combinator:**

1. **å‡½æ•°ç»„åˆ (Function Composition) / Function Composition:**
   - $B f g x = f(g x)$
   - å®ç°å‡½æ•°çš„ç»„åˆ / Implements function composition

2. **ç»“åˆå¾‹ (Associativity) / Associativity:**
   - $B(B f g) h = B f(B g h)$
   - æ»¡è¶³ç»“åˆå¾‹ / Satisfies associativity

**Cç»„åˆå­çš„æ€§è´¨ / Properties of C Combinator:**

1. **å‚æ•°äº¤æ¢ (Argument Swapping) / Argument Swapping:**
   - $C f x y = f y x$
   - äº¤æ¢å‡½æ•°çš„ä¸¤ä¸ªå‚æ•° / Swaps two arguments of a function

2. **äº¤æ¢å¾‹ (Commutativity) / Commutativity:**
   - $C(C f) = f$
   - æ»¡è¶³äº¤æ¢å¾‹ / Satisfies commutativity

**Wç»„åˆå­çš„æ€§è´¨ / Properties of W Combinator:**

1. **å‚æ•°å¤åˆ¶ (Argument Duplication) / Argument Duplication:**
   - $W f x = f x x$
   - å°†å‚æ•°å¤åˆ¶ç»™å‡½æ•° / Duplicates argument for function

2. **å¹‚ç­‰æ€§ (Idempotency) / Idempotency:**
   - $W(W f) = W f$
   - æ»¡è¶³å¹‚ç­‰æ€§ / Satisfies idempotency

### 3.3.3 BCKWç»„åˆå­çš„å…³ç³» (Relationships of BCKW Combinators)

**SKIåˆ°BCKWçš„è½¬æ¢ (SKI to BCKW Translation) / SKI to BCKW Translation:**

1. **Sç»„åˆå­ (S Combinator) / S Combinator:**
   - $S = B(B W)(B B C)$

2. **Iç»„åˆå­ (I Combinator) / I Combinator:**
   - $I = W K$

**BCKWåˆ°SKIçš„è½¬æ¢ (BCKW to SKI Translation) / BCKW to SKI Translation:**

1. **Bç»„åˆå­ (B Combinator) / B Combinator:**
   - $B = S(K S)K$

2. **Cç»„åˆå­ (C Combinator) / C Combinator:**
   - $C = S(B B S)(K K)$

3. **Wç»„åˆå­ (W Combinator) / W Combinator:**
   - $W = S S(K I)$

---

## 3.4 å½’çº¦ (Reduction)

### 3.4.1 ç»„åˆå­å½’çº¦è§„åˆ™ (Combinator Reduction Rules)

**SKIå½’çº¦è§„åˆ™ (SKI Reduction Rules) / SKI Reduction Rules:**

1. **Så½’çº¦ (S Reduction) / S Reduction:**
   - $S f g x \rightarrow (f x)(g x)$

2. **Kå½’çº¦ (K Reduction) / K Reduction:**
   - $K x y \rightarrow x$

3. **Iå½’çº¦ (I Reduction) / I Reduction:**
   - $I x \rightarrow x$

**BCKWå½’çº¦è§„åˆ™ (BCKW Reduction Rules) / BCKW Reduction Rules:**

1. **Bå½’çº¦ (B Reduction) / B Reduction:**
   - $B f g x \rightarrow f(g x)$

2. **Cå½’çº¦ (C Reduction) / C Reduction:**
   - $C f x y \rightarrow f y x$

3. **Wå½’çº¦ (W Reduction) / W Reduction:**
   - $W f x \rightarrow f x x$

### 3.4.2 å½’çº¦ç­–ç•¥ (Reduction Strategies)

**å½’çº¦ç­–ç•¥å®šä¹‰ / Definition of Reduction Strategies:**

å½’çº¦ç­–ç•¥å†³å®šäº†åœ¨å¤šä¸ªå¯èƒ½çš„å½’çº¦ä¸­é€‰æ‹©å“ªä¸€ä¸ªã€‚

Reduction strategies determine which reduction to choose when multiple reductions are possible.

**å¸¸è§å½’çº¦ç­–ç•¥ / Common Reduction Strategies:**

1. **æœ€å·¦æœ€å¤–å½’çº¦ (Leftmost Outermost) / Leftmost Outermost:**
   - æ€»æ˜¯å½’çº¦æœ€å·¦è¾¹çš„å¯å½’çº¦é¡¹ / Always reduce the leftmost reducible term

2. **æœ€å·¦æœ€å†…å½’çº¦ (Leftmost Innermost) / Leftmost Innermost:**
   - æ€»æ˜¯å½’çº¦æœ€å†…å±‚çš„å¯å½’çº¦é¡¹ / Always reduce the innermost reducible term

3. **æ­£è§„åºå½’çº¦ (Normal Order) / Normal Order:**
   - ä¼˜å…ˆå½’çº¦æœ€å¤–å±‚çš„å¯å½’çº¦é¡¹ / Prefer to reduce outermost reducible terms

### 3.4.3 æ­£è§„å½¢å¼ (Normal Form)

**æ­£è§„å½¢å¼å®šä¹‰ / Definition of Normal Form:**

ç»„åˆå­é¡¹ $M$ æ˜¯æ­£è§„å½¢å¼ï¼Œå¦‚æœæ²¡æœ‰å½’çº¦å¯ä»¥ä» $M$ å¯¼å‡ºã€‚

A combinator term $M$ is in normal form if no reduction can be derived from $M$.

**æ­£è§„åŒ–å®šç† (Normalization Theorem) / Normalization Theorem:**

å¦‚æœç»„åˆå­é¡¹æœ‰æ­£è§„å½¢å¼ï¼Œåˆ™æœ€å·¦æœ€å¤–å½’çº¦ç­–ç•¥ä¼šæ‰¾åˆ°å®ƒã€‚

If a combinator term has a normal form, then the leftmost outermost reduction strategy will find it.

---

## 3.5 ç±»å‹ç³»ç»Ÿ (Type System)

### 3.5.1 ç®€å•ç±»å‹ç»„åˆå­é€»è¾‘ (Simply Typed Combinatory Logic)

**ç±»å‹å®šä¹‰ / Type Definition:**

ç®€å•ç±»å‹ç»„åˆå­é€»è¾‘çš„ç±»å‹é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

Types in simply typed combinatory logic are recursively defined as follows:

1. **åŸºæœ¬ç±»å‹ (Base Types) / Base Types:**
   - å¦‚ $bool$, $int$, $nat$ ç­‰ / Such as $bool$, $int$, $nat$, etc.

2. **å‡½æ•°ç±»å‹ (Function Types) / Function Types:**
   - å¦‚æœ $\sigma$ å’Œ $\tau$ æ˜¯ç±»å‹ï¼Œåˆ™ $\sigma \rightarrow \tau$ æ˜¯ç±»å‹
   - If $\sigma$ and $\tau$ are types, then $\sigma \rightarrow \tau$ is a type

**ç±»å‹è§„åˆ™ / Type Rules:**

1. **Sç»„åˆå­ç±»å‹ (S Combinator Type) / S Combinator Type:**
   - $S : (\sigma \rightarrow \tau \rightarrow \rho) \rightarrow (\sigma \rightarrow \tau) \rightarrow \sigma \rightarrow \rho$

2. **Kç»„åˆå­ç±»å‹ (K Combinator Type) / K Combinator Type:**
   - $K : \sigma \rightarrow \tau \rightarrow \sigma$

3. **Iç»„åˆå­ç±»å‹ (I Combinator Type) / I Combinator Type:**
   - $I : \sigma \rightarrow \sigma$

4. **åº”ç”¨è§„åˆ™ (Application Rule) / Application Rule:**
   - $\frac{M : \sigma \rightarrow \tau \quad N : \sigma}{M N : \tau}$

### 3.5.2 å¤šæ€ç»„åˆå­é€»è¾‘ (Polymorphic Combinatory Logic)

**å¤šæ€ç±»å‹å®šä¹‰ / Polymorphic Type Definition:**

å¤šæ€ç»„åˆå­é€»è¾‘æ‰©å±•äº†ç®€å•ç±»å‹ç»„åˆå­é€»è¾‘ï¼Œå¼•å…¥äº†ç±»å‹å˜é‡å’Œå…¨ç§°é‡è¯ã€‚

Polymorphic combinatory logic extends simply typed combinatory logic by introducing type variables and universal quantifiers.

**å¤šæ€ç±»å‹æ„é€  / Polymorphic Type Constructions:**

1. **ç±»å‹å˜é‡ (Type Variables) / Type Variables:**
   - $\alpha, \beta, \gamma$ ç­‰ / $\alpha, \beta, \gamma$, etc.

2. **å…¨ç§°ç±»å‹ (Universal Types) / Universal Types:**
   - $\forall \alpha.\sigma$ è¡¨ç¤ºå¯¹æ‰€æœ‰ç±»å‹ $\alpha$ï¼Œ$\sigma$ éƒ½æˆç«‹
   - $\forall \alpha.\sigma$ means that $\sigma$ holds for all types $\alpha$

**å¤šæ€ç±»å‹è§„åˆ™ / Polymorphic Type Rules:**

1. **ç±»å‹æŠ½è±¡ (Type Abstraction) / Type Abstraction:**
   - $\frac{M : \sigma}{M : \forall \alpha.\sigma}$ (å¦‚æœ $\alpha$ ä¸åœ¨ $M$ ä¸­è‡ªç”±å‡ºç°)

2. **ç±»å‹åº”ç”¨ (Type Application) / Type Application:**
   - $\frac{M : \forall \alpha.\sigma}{M[\tau] : \sigma[\tau/\alpha]}$

### 3.5.3 ä¾èµ–ç±»å‹ç»„åˆå­é€»è¾‘ (Dependent Combinatory Logic)

**ä¾èµ–ç±»å‹å®šä¹‰ / Dependent Type Definition:**

ä¾èµ–ç±»å‹ç»„åˆå­é€»è¾‘å…è®¸ç±»å‹ä¾èµ–äºå€¼ï¼Œæä¾›äº†æ›´å¼ºçš„è¡¨è¾¾èƒ½åŠ›ã€‚

Dependent combinatory logic allows types to depend on values, providing stronger expressive power.

**ä¾èµ–ç±»å‹æ„é€  / Dependent Type Constructions:**

1. **ä¾èµ–å‡½æ•°ç±»å‹ (Dependent Function Types) / Dependent Function Types:**
   - $\Pi x : A.B(x)$ è¡¨ç¤ºå¯¹äºæ‰€æœ‰ $x : A$ï¼Œ$B(x)$ ç±»å‹
   - $\Pi x : A.B(x)$ means type $B(x)$ for all $x : A$

2. **ä¾èµ–ç§¯ç±»å‹ (Dependent Product Types) / Dependent Product Types:**
   - $\Sigma x : A.B(x)$ è¡¨ç¤ºå­˜åœ¨ $x : A$ï¼Œä½¿å¾— $B(x)$ ç±»å‹
   - $\Sigma x : A.B(x)$ means there exists $x : A$ such that $B(x)$ is a type

---

## 3.6 å®ç°ç¤ºä¾‹ (Implementation Examples)

### 3.6.1 ç»„åˆå­é€»è¾‘è§£é‡Šå™¨ (Combinatory Logic Interpreter)

```rust
use std::collections::HashMap;

/// ç»„åˆå­é€»è¾‘è§£é‡Šå™¨ / Combinatory Logic Interpreter
pub struct CombinatoryLogicInterpreter {
    environment: HashMap<String, CombinatorTerm>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum CombinatorTerm {
    Variable(String),
    S,
    K,
    I,
    B,
    C,
    W,
    Application(Box<CombinatorTerm>, Box<CombinatorTerm>),
}

impl CombinatoryLogicInterpreter {
    /// åˆ›å»ºæ–°çš„è§£é‡Šå™¨ / Create new interpreter
    pub fn new() -> Self {
        CombinatoryLogicInterpreter {
            environment: HashMap::new(),
        }
    }

    /// è§£æç»„åˆå­é¡¹ / Parse combinator term
    pub fn parse(&self, input: &str) -> Result<CombinatorTerm, String> {
        let tokens = self.tokenize(input)?;
        self.parse_tokens(&tokens)
    }

    /// è¯æ³•åˆ†æ / Tokenization
    fn tokenize(&self, input: &str) -> Result<Vec<String>, String> {
        let mut tokens = Vec::new();
        let mut current = String::new();

        for ch in input.chars() {
            match ch {
                ' ' | '\t' | '\n' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                }
                '(' | ')' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                    tokens.push(ch.to_string());
                }
                _ => current.push(ch),
            }
        }

        if !current.is_empty() {
            tokens.push(current);
        }

        Ok(tokens)
    }

    /// è§£ææ ‡è®° / Parse tokens
    fn parse_tokens(&self, tokens: &[String]) -> Result<CombinatorTerm, String> {
        if tokens.is_empty() {
            return Err("Empty token list".to_string());
        }

        match tokens[0].as_str() {
            "S" => Ok(CombinatorTerm::S),
            "K" => Ok(CombinatorTerm::K),
            "I" => Ok(CombinatorTerm::I),
            "B" => Ok(CombinatorTerm::B),
            "C" => Ok(CombinatorTerm::C),
            "W" => Ok(CombinatorTerm::W),
            "(" => {
                if tokens.len() < 3 || tokens[tokens.len() - 1] != ")" {
                    return Err("Invalid application syntax".to_string());
                }
                let inner_tokens = &tokens[1..tokens.len() - 1];
                self.parse_application(inner_tokens)
            }
            var_name => {
                if tokens.len() == 1 {
                    Ok(CombinatorTerm::Variable(var_name.to_string()))
                } else {
                    self.parse_application(tokens)
                }
            }
        }
    }

    /// è§£æåº”ç”¨ / Parse application
    fn parse_application(&self, tokens: &[String]) -> Result<CombinatorTerm, String> {
        if tokens.len() < 2 {
            return Err("Invalid application".to_string());
        }

        let mut terms = Vec::new();
        let mut current_tokens = Vec::new();

        for token in tokens {
            match token.as_str() {
                "(" => {
                    if !current_tokens.is_empty() {
                        terms.push(self.parse_tokens(&current_tokens)?);
                        current_tokens.clear();
                    }
                    current_tokens.push(token.clone());
                }
                ")" => {
                    current_tokens.push(token.clone());
                    if !current_tokens.is_empty() {
                        terms.push(self.parse_tokens(&current_tokens)?);
                        current_tokens.clear();
                    }
                }
                _ => {
                    if current_tokens.is_empty() {
                        terms.push(self.parse_tokens(&[token.clone()])?);
                    } else {
                        current_tokens.push(token.clone());
                    }
                }
            }
        }

        if terms.len() < 2 {
            return Err("Application requires at least two terms".to_string());
        }

        let mut result = terms[0].clone();
        for term in terms.iter().skip(1) {
            result = CombinatorTerm::Application(Box::new(result), Box::new(term.clone()));
        }

        Ok(result)
    }

    /// SKIå½’çº¦ / SKI reduction
    pub fn ski_reduce(&self, term: &CombinatorTerm) -> Option<CombinatorTerm> {
        match term {
            CombinatorTerm::Application(func, arg) => {
                match func.as_ref() {
                    CombinatorTerm::S => {
                        // S f g x -> (f x)(g x)
                        if let CombinatorTerm::Application(f, g) = arg.as_ref() {
                            Some(CombinatorTerm::Application(
                                Box::new(CombinatorTerm::Application(f.clone(), arg.clone())),
                                Box::new(CombinatorTerm::Application(g.clone(), arg.clone())),
                            ))
                        } else {
                            None
                        }
                    }
                    CombinatorTerm::K => {
                        // K x y -> x
                        Some(arg.as_ref().clone())
                    }
                    CombinatorTerm::I => {
                        // I x -> x
                        Some(arg.as_ref().clone())
                    }
                    _ => None,
                }
            }
            _ => None,
        }
    }

    /// BCKWå½’çº¦ / BCKW reduction
    pub fn bckw_reduce(&self, term: &CombinatorTerm) -> Option<CombinatorTerm> {
        match term {
            CombinatorTerm::Application(func, arg) => {
                match func.as_ref() {
                    CombinatorTerm::B => {
                        // B f g x -> f(g x)
                        if let CombinatorTerm::Application(f, g) = arg.as_ref() {
                            Some(CombinatorTerm::Application(
                                f.clone(),
                                Box::new(CombinatorTerm::Application(g.clone(), arg.clone())),
                            ))
                        } else {
                            None
                        }
                    }
                    CombinatorTerm::C => {
                        // C f x y -> f y x
                        if let CombinatorTerm::Application(f, x) = arg.as_ref() {
                            Some(CombinatorTerm::Application(
                                f.clone(),
                                Box::new(CombinatorTerm::Application(arg.clone(), x.clone())),
                            ))
                        } else {
                            None
                        }
                    }
                    CombinatorTerm::W => {
                        // W f x -> f x x
                        Some(CombinatorTerm::Application(
                            arg.as_ref().clone(),
                            Box::new(CombinatorTerm::Application(arg.as_ref().clone(), arg.clone())),
                        ))
                    }
                    _ => self.ski_reduce(term),
                }
            }
            _ => None,
        }
    }

    /// å½’çº¦åˆ°æ­£è§„å½¢å¼ / Reduce to normal form
    pub fn reduce_to_normal_form(&self, term: &CombinatorTerm) -> CombinatorTerm {
        let mut current = term.clone();

        loop {
            if let Some(reduced) = self.bckw_reduce(&current) {
                current = reduced;
            } else {
                // å°è¯•å½’çº¦å­é¡¹ / Try to reduce subterms
                let mut changed = false;
                current = self.reduce_subterms(&current, &mut changed);
                if !changed {
                    break;
                }
            }
        }

        current
    }

    /// å½’çº¦å­é¡¹ / Reduce subterms
    fn reduce_subterms(&self, term: &CombinatorTerm, changed: &mut bool) -> CombinatorTerm {
        match term {
            CombinatorTerm::Variable(_) | CombinatorTerm::S | CombinatorTerm::K |
            CombinatorTerm::I | CombinatorTerm::B | CombinatorTerm::C | CombinatorTerm::W => {
                term.clone()
            }
            CombinatorTerm::Application(func, arg) => {
                let new_func = self.reduce_subterms(func, changed);
                let new_arg = self.reduce_subterms(arg, changed);

                if new_func != **func || new_arg != **arg {
                    *changed = true;
                }

                CombinatorTerm::Application(Box::new(new_func), Box::new(new_arg))
            }
        }
    }
}
```

### 3.6.2 ç±»å‹ç»„åˆå­é€»è¾‘å®ç° (Typed Combinatory Logic Implementation)

```rust
/// ç±»å‹ç»„åˆå­é€»è¾‘å®ç° / Typed Combinatory Logic Implementation
pub struct TypedCombinatoryLogicInterpreter {
    type_environment: HashMap<String, Type>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Base(String),
    Function(Box<Type>, Box<Type>),
    Universal(String, Box<Type>),
}

#[derive(Debug, Clone)]
pub struct TypedCombinatorTerm {
    pub term: CombinatorTerm,
    pub type_info: Type,
}

impl TypedCombinatoryLogicInterpreter {
    /// åˆ›å»ºæ–°çš„ç±»å‹è§£é‡Šå™¨ / Create new typed interpreter
    pub fn new() -> Self {
        TypedCombinatoryLogicInterpreter {
            type_environment: HashMap::new(),
        }
    }

    /// ç±»å‹æ£€æŸ¥ / Type checking
    pub fn type_check(&self, term: &CombinatorTerm, context: &HashMap<String, Type>) -> Result<Type, String> {
        match term {
            CombinatorTerm::Variable(x) => {
                context.get(x)
                    .cloned()
                    .ok_or_else(|| format!("Variable {} not found in context", x))
            }
            CombinatorTerm::S => {
                // S: (Ïƒâ†’Ï„â†’Ï) â†’ (Ïƒâ†’Ï„) â†’ Ïƒ â†’ Ï
                let sigma = Type::Base("Ïƒ".to_string());
                let tau = Type::Base("Ï„".to_string());
                let rho = Type::Base("Ï".to_string());

                let func1 = Type::Function(Box::new(sigma.clone()), Box::new(Type::Function(Box::new(tau.clone()), Box::new(rho.clone()))));
                let func2 = Type::Function(Box::new(sigma.clone()), Box::new(tau));
                let result = Type::Function(Box::new(sigma), Box::new(rho));

                Ok(Type::Function(Box::new(func1), Box::new(Type::Function(Box::new(func2), Box::new(result)))))
            }
            CombinatorTerm::K => {
                // K: Ïƒ â†’ Ï„ â†’ Ïƒ
                let sigma = Type::Base("Ïƒ".to_string());
                let tau = Type::Base("Ï„".to_string());
                Ok(Type::Function(Box::new(sigma.clone()), Box::new(Type::Function(Box::new(tau), Box::new(sigma)))))
            }
            CombinatorTerm::I => {
                // I: Ïƒ â†’ Ïƒ
                let sigma = Type::Base("Ïƒ".to_string());
                Ok(Type::Function(Box::new(sigma.clone()), Box::new(sigma)))
            }
            CombinatorTerm::B => {
                // B: (Ï„â†’Ï) â†’ (Ïƒâ†’Ï„) â†’ Ïƒ â†’ Ï
                let sigma = Type::Base("Ïƒ".to_string());
                let tau = Type::Base("Ï„".to_string());
                let rho = Type::Base("Ï".to_string());

                let func1 = Type::Function(Box::new(tau.clone()), Box::new(rho.clone()));
                let func2 = Type::Function(Box::new(sigma.clone()), Box::new(tau));
                let result = Type::Function(Box::new(sigma), Box::new(rho));

                Ok(Type::Function(Box::new(func1), Box::new(Type::Function(Box::new(func2), Box::new(result)))))
            }
            CombinatorTerm::C => {
                // C: (Ïƒâ†’Ï„â†’Ï) â†’ Ï„ â†’ Ïƒ â†’ Ï
                let sigma = Type::Base("Ïƒ".to_string());
                let tau = Type::Base("Ï„".to_string());
                let rho = Type::Base("Ï".to_string());

                let func = Type::Function(Box::new(sigma.clone()), Box::new(Type::Function(Box::new(tau.clone()), Box::new(rho.clone()))));
                let result = Type::Function(Box::new(sigma), Box::new(rho));

                Ok(Type::Function(Box::new(func), Box::new(Type::Function(Box::new(tau), Box::new(result)))))
            }
            CombinatorTerm::W => {
                // W: (Ïƒâ†’Ïƒâ†’Ï„) â†’ Ïƒ â†’ Ï„
                let sigma = Type::Base("Ïƒ".to_string());
                let tau = Type::Base("Ï„".to_string());

                let func = Type::Function(Box::new(sigma.clone()), Box::new(Type::Function(Box::new(sigma.clone()), Box::new(tau.clone()))));
                let result = Type::Function(Box::new(sigma), Box::new(tau));

                Ok(Type::Function(Box::new(func), Box::new(result)))
            }
            CombinatorTerm::Application(func, arg) => {
                let func_type = self.type_check(func, context)?;
                let arg_type = self.type_check(arg, context)?;

                match func_type {
                    Type::Function(input_type, output_type) => {
                        if *input_type == arg_type {
                            Ok(*output_type)
                        } else {
                            Err(format!("Type mismatch: expected {:?}, got {:?}", input_type, arg_type))
                        }
                    }
                    _ => Err("Function type expected".to_string()),
                }
            }
        }
    }

    /// ç±»å‹æ¨å¯¼ / Type inference
    pub fn type_inference(&self, term: &CombinatorTerm) -> Result<Type, String> {
        let context = HashMap::new();
        self.type_check(term, &context)
    }

    /// åˆ›å»ºç±»å‹åŒ–çš„ç»„åˆå­é¡¹ / Create typed combinator term
    pub fn create_typed_term(&self, term: CombinatorTerm) -> Result<TypedCombinatorTerm, String> {
        let type_info = self.type_inference(&term)?;
        Ok(TypedCombinatorTerm { term, type_info })
    }
}
```

### 3.6.3 ç»„åˆå­é€»è¾‘æµ‹è¯• (Combinatory Logic Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_combinator_parsing() {
        let interpreter = CombinatoryLogicInterpreter::new();

        // æµ‹è¯•åŸºæœ¬ç»„åˆå­ / Test basic combinators
        let result = interpreter.parse("S");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), CombinatorTerm::S));

        let result = interpreter.parse("K");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), CombinatorTerm::K));

        let result = interpreter.parse("I");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), CombinatorTerm::I));

        // æµ‹è¯•åº”ç”¨ / Test application
        let result = interpreter.parse("(S K) I");
        assert!(result.is_ok());
        if let Ok(CombinatorTerm::Application(func, arg)) = result {
            assert!(matches!(*func, CombinatorTerm::Application(_, _)));
            assert!(matches!(*arg, CombinatorTerm::I));
        } else {
            panic!("Expected application");
        }
    }

    #[test]
    fn test_ski_reduction() {
        let interpreter = CombinatoryLogicInterpreter::new();

        // æµ‹è¯•Kå½’çº¦ / Test K reduction
        let term = CombinatorTerm::Application(
            Box::new(CombinatorTerm::K),
            Box::new(CombinatorTerm::Application(
                Box::new(CombinatorTerm::Variable("x".to_string())),
                Box::new(CombinatorTerm::Variable("y".to_string())),
            )),
        );

        let reduced = interpreter.ski_reduce(&term);
        assert!(reduced.is_some());
        assert_eq!(reduced.unwrap(), CombinatorTerm::Variable("x".to_string()));

        // æµ‹è¯•Iå½’çº¦ / Test I reduction
        let term = CombinatorTerm::Application(
            Box::new(CombinatorTerm::I),
            Box::new(CombinatorTerm::Variable("x".to_string())),
        );

        let reduced = interpreter.ski_reduce(&term);
        assert!(reduced.is_some());
        assert_eq!(reduced.unwrap(), CombinatorTerm::Variable("x".to_string()));
    }

    #[test]
    fn test_bckw_reduction() {
        let interpreter = CombinatoryLogicInterpreter::new();

        // æµ‹è¯•Bå½’çº¦ / Test B reduction
        let term = CombinatorTerm::Application(
            Box::new(CombinatorTerm::B),
            Box::new(CombinatorTerm::Application(
                Box::new(CombinatorTerm::Variable("f".to_string())),
                Box::new(CombinatorTerm::Variable("g".to_string())),
            )),
        );

        let reduced = interpreter.bckw_reduce(&term);
        assert!(reduced.is_some());

        // æµ‹è¯•Wå½’çº¦ / Test W reduction
        let term = CombinatorTerm::Application(
            Box::new(CombinatorTerm::W),
            Box::new(CombinatorTerm::Variable("f".to_string())),
        );

        let reduced = interpreter.bckw_reduce(&term);
        assert!(reduced.is_some());
    }

    #[test]
    fn test_type_checking() {
        let typed_interpreter = TypedCombinatoryLogicInterpreter::new();

        // æµ‹è¯•Sç»„åˆå­ç±»å‹ / Test S combinator type
        let result = typed_interpreter.type_inference(&CombinatorTerm::S);
        assert!(result.is_ok());

        // æµ‹è¯•Kç»„åˆå­ç±»å‹ / Test K combinator type
        let result = typed_interpreter.type_inference(&CombinatorTerm::K);
        assert!(result.is_ok());

        // æµ‹è¯•Iç»„åˆå­ç±»å‹ / Test I combinator type
        let result = typed_interpreter.type_inference(&CombinatorTerm::I);
        assert!(result.is_ok());
    }

    #[test]
    fn test_boolean_combinators() {
        let interpreter = CombinatoryLogicInterpreter::new();

        // å¸ƒå°”çœŸ: T = K
        let true_combinator = CombinatorTerm::K;

        // å¸ƒå°”å‡: F = K I
        let false_combinator = CombinatorTerm::Application(
            Box::new(CombinatorTerm::K),
            Box::new(CombinatorTerm::I),
        );

        // æµ‹è¯•å¸ƒå°”ç»„åˆå­ / Test boolean combinators
        let true_reduced = interpreter.reduce_to_normal_form(&true_combinator);
        assert_eq!(true_reduced, true_combinator);

        let false_reduced = interpreter.reduce_to_normal_form(&false_combinator);
        assert_eq!(false_reduced, false_combinator);
    }
}
```

---

## 3.7 å‚è€ƒæ–‡çŒ® / References

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**: æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ [CITATION_STANDARD.md](../CITATION_STANDARD.md)ã€[å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md](../å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)ï¼‰ã€‚æ–‡å†…é‡‡ç”¨ [Key] æ ¼å¼å¼•ç”¨ï¼Œä¸å‚è€ƒæ–‡çŒ®åˆ—è¡¨å¯¹åº”ã€‚

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Schonfinkel1924] SchÃ¶nfinkel, M. (1924). "Ãœber die Bausteine der mathematischen Logik". *Mathematische Annalen*, 92(3-4), 305-316.
   - **SchÃ¶nfinkelç»„åˆå­é€»è¾‘çš„å¼€åˆ›æ€§è®ºæ–‡**ï¼Œå¥ å®šäº†ç»„åˆå­é€»è¾‘çš„åŸºç¡€ã€‚æœ¬æ–‡æ¡£çš„æ ¸å¿ƒå†…å®¹åŸºäºæ­¤è®ºæ–‡ã€‚

2. [CurryFeys1958] Curry, H. B., & Feys, R. (1958). *Combinatory Logic* (Vol. 1). North-Holland.
   - **Curry-Feysç»„åˆå­é€»è¾‘çš„ç»å…¸ä¸“è‘—**ï¼Œç³»ç»Ÿåœ°å‘å±•äº†ç»„åˆå­é€»è¾‘ç†è®ºã€‚æœ¬æ–‡æ¡£çš„åŸºç¡€æ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. [HindleySeldin2008] Hindley, J. R., & Seldin, J. P. (2008). *Lambda-Calculus and Combinators: An Introduction* (2nd ed.). Cambridge University Press. ISBN: 978-0521898850
   - **Hindley-Seldin Î»æ¼”ç®—ä¸ç»„åˆå­çš„æƒå¨æ•™æ**ã€‚æœ¬æ–‡æ¡£çš„åŸºç¡€æ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

2. [Barendregt1984] Barendregt, H. P. (1984). *The Lambda Calculus: Its Syntax and Semantics* (Revised ed.). North-Holland. ISBN: 978-0444875082
   - Barendregt Î»æ¼”ç®—çš„æƒå¨ä¸“è‘—ï¼ŒåŒ…å«ç»„åˆå­é€»è¾‘çš„æ·±å…¥è®¨è®ºã€‚

3. Smullyan, R. M. (1985). *To Mock a Mockingbird and Other Logic Puzzles*. Alfred A. Knopf.
   - Smullyançš„ç»„åˆå­é€»è¾‘è¶£å‘³å…¥é—¨ä¹¦ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Combinatory Logic**: <https://en.wikipedia.org/wiki/Combinatory_logic>
   - ç»„åˆå­é€»è¾‘çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«SKIç»„åˆå­å’ŒBCKWç»„åˆå­ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Lambda Calculus**: <https://en.wikipedia.org/wiki/Lambda_calculus>
   - Î»æ¼”ç®—çš„Wikipediaæ¡ç›®ï¼Œä»‹ç»ç»„åˆå­é€»è¾‘ä¸Î»æ¼”ç®—çš„å…³ç³»ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£æä¾›äº†ç»„åˆå­é€»è¾‘çš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€SKIç»„åˆå­ã€BCKWç»„åˆå­ã€å½’çº¦ã€ç±»å‹ç³»ç»Ÿå’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
