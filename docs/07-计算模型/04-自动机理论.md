---
title: 7.4 è‡ªåŠ¨æœºç†è®º / Automata Theory
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: è®¡ç®—æ¨¡å‹å·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 7.4 è‡ªåŠ¨æœºç†è®º / Automata Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€è‡ªåŠ¨æœºç†è®ºçš„å½¢å¼åŒ–å®šä¹‰ã€æœ‰é™è‡ªåŠ¨æœºã€ä¸‹æ¨è‡ªåŠ¨æœºä¸å›¾çµæœºã€‚
- å»ºç«‹è‡ªåŠ¨æœºä¸å½¢å¼è¯­è¨€çš„å¯¹åº”å…³ç³»ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- è‡ªåŠ¨æœºç†è®ºã€æœ‰é™è‡ªåŠ¨æœºã€ä¸‹æ¨è‡ªåŠ¨æœºã€å›¾çµæœºã€å½¢å¼è¯­è¨€ã€æ­£åˆ™è¯­è¨€ã€ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- è‡ªåŠ¨æœºï¼ˆAutomatonï¼‰ï¼šæŠ½è±¡çš„è®¡ç®—æ¨¡å‹ã€‚
- æœ‰é™è‡ªåŠ¨æœºï¼ˆFinite Automatonï¼‰ï¼šå…·æœ‰æœ‰é™çŠ¶æ€çš„è‡ªåŠ¨æœºã€‚
- ä¸‹æ¨è‡ªåŠ¨æœºï¼ˆPushdown Automatonï¼‰ï¼šå…·æœ‰æ ˆçš„è‡ªåŠ¨æœºã€‚
- è®°å·çº¦å®šï¼š`Q` è¡¨ç¤ºçŠ¶æ€é›†ï¼Œ`Î£` è¡¨ç¤ºè¾“å…¥å­—æ¯è¡¨ï¼Œ`Î´` è¡¨ç¤ºè½¬ç§»å‡½æ•°ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- å›¾çµæœºï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/01-å›¾çµæœº.md`ã€‚
- å½¢å¼è¯­è¨€ï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/04-è‡ªåŠ¨æœºç†è®º.md`ã€‚
- è®¡ç®—æ¨¡å‹ï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- æœ‰é™è‡ªåŠ¨æœº
- ä¸‹æ¨è‡ªåŠ¨æœº
- å›¾çµæœº

## ç›®å½• (Table of Contents)

- [7.4 è‡ªåŠ¨æœºç†è®º / Automata Theory](#74-è‡ªåŠ¨æœºç†è®º--automata-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [4.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#41-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [4.1.1 è‡ªåŠ¨æœºç†è®ºå®šä¹‰ (Definition of Automata Theory)](#411-è‡ªåŠ¨æœºç†è®ºå®šä¹‰-definition-of-automata-theory)
  - [4.1.2 è‡ªåŠ¨æœºåˆ†ç±» (Classification of Automata)](#412-è‡ªåŠ¨æœºåˆ†ç±»-classification-of-automata)
  - [4.1.3 å½¢å¼è¯­è¨€ (Formal Languages)](#413-å½¢å¼è¯­è¨€-formal-languages)
- [4.2 æœ‰é™è‡ªåŠ¨æœº (Finite Automata)](#42-æœ‰é™è‡ªåŠ¨æœº-finite-automata)
  - [4.2.1 æœ‰é™è‡ªåŠ¨æœºå®šä¹‰ (Definition of Finite Automata)](#421-æœ‰é™è‡ªåŠ¨æœºå®šä¹‰-definition-of-finite-automata)
  - [4.2.2 ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Deterministic Finite Automata)](#422-ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº-deterministic-finite-automata)
  - [4.2.3 éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Nondeterministic Finite Automata)](#423-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº-nondeterministic-finite-automata)
  - [4.2.4 æœ‰é™è‡ªåŠ¨æœºçš„åº”ç”¨ (Applications of Finite Automata)](#424-æœ‰é™è‡ªåŠ¨æœºçš„åº”ç”¨-applications-of-finite-automata)
- [4.3 ä¸‹æ¨è‡ªåŠ¨æœº (Pushdown Automata)](#43-ä¸‹æ¨è‡ªåŠ¨æœº-pushdown-automata)
  - [4.3.1 ä¸‹æ¨è‡ªåŠ¨æœºå®šä¹‰ (Definition of Pushdown Automata)](#431-ä¸‹æ¨è‡ªåŠ¨æœºå®šä¹‰-definition-of-pushdown-automata)
  - [4.3.2 ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº (Deterministic Pushdown Automata)](#432-ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº-deterministic-pushdown-automata)
  - [4.3.3 éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº (Nondeterministic Pushdown Automata)](#433-éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº-nondeterministic-pushdown-automata)
  - [4.3.4 ä¸‹æ¨è‡ªåŠ¨æœºçš„åº”ç”¨ (Applications of Pushdown Automata)](#434-ä¸‹æ¨è‡ªåŠ¨æœºçš„åº”ç”¨-applications-of-pushdown-automata)
- [4.4 å›¾çµæœº (Turing Machines)](#44-å›¾çµæœº-turing-machines)
  - [4.4.1 å›¾çµæœºå®šä¹‰ (Definition of Turing Machines)](#441-å›¾çµæœºå®šä¹‰-definition-of-turing-machines)
  - [4.4.2 å›¾çµæœºçš„é…ç½® (Turing Machine Configurations)](#442-å›¾çµæœºçš„é…ç½®-turing-machine-configurations)
  - [4.4.3 å›¾çµæœºçš„å˜ç§ (Variants of Turing Machines)](#443-å›¾çµæœºçš„å˜ç§-variants-of-turing-machines)
  - [4.4.4 å›¾çµæœºçš„åº”ç”¨ (Applications of Turing Machines)](#444-å›¾çµæœºçš„åº”ç”¨-applications-of-turing-machines)
- [4.5 å®ç°ç¤ºä¾‹ (Implementation Examples)](#45-å®ç°ç¤ºä¾‹-implementation-examples)
  - [4.5.1 æœ‰é™è‡ªåŠ¨æœºå®ç° (Finite Automata Implementation)](#451-æœ‰é™è‡ªåŠ¨æœºå®ç°-finite-automata-implementation)
  - [4.5.2 ä¸‹æ¨è‡ªåŠ¨æœºå®ç° (Pushdown Automata Implementation)](#452-ä¸‹æ¨è‡ªåŠ¨æœºå®ç°-pushdown-automata-implementation)
  - [4.5.3 å›¾çµæœºå®ç° (Turing Machine Implementation)](#453-å›¾çµæœºå®ç°-turing-machine-implementation)
  - [4.5.4 è‡ªåŠ¨æœºç†è®ºæµ‹è¯• (Automata Theory Testing)](#454-è‡ªåŠ¨æœºç†è®ºæµ‹è¯•-automata-theory-testing)
- [4.6 å‚è€ƒæ–‡çŒ® / References](#46-å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)

---

## 4.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 4.1.1 è‡ªåŠ¨æœºç†è®ºå®šä¹‰ (Definition of Automata Theory)

**è‡ªåŠ¨æœºç†è®ºå®šä¹‰ / Definition of Automata Theory:**

è‡ªåŠ¨æœºç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œç ”ç©¶æŠ½è±¡æœºå™¨ï¼ˆè‡ªåŠ¨æœºï¼‰çš„è®¡ç®—èƒ½åŠ›å’Œå½¢å¼è¯­è¨€ã€‚å®ƒæ˜¯è®¡ç®—ç†è®ºçš„åŸºç¡€ï¼Œä¸ºç†è§£è®¡ç®—å¤æ‚æ€§æä¾›äº†é‡è¦å·¥å…·ã€‚

Automata theory is a branch of computer science that studies the computational capabilities of abstract machines (automata) and formal languages. It is the foundation of computability theory and provides important tools for understanding computational complexity.

**è‡ªåŠ¨æœºç†è®ºçš„ç‰¹ç‚¹ / Characteristics of Automata Theory:**

1. **æŠ½è±¡æ€§ (Abstraction) / Abstraction:**
   - ç ”ç©¶æŠ½è±¡çš„è®¡ç®—æ¨¡å‹ / Studies abstract computational models
   - ä¸ä¾èµ–å…·ä½“çš„ç¡¬ä»¶å®ç° / Independent of specific hardware implementations

2. **å±‚æ¬¡æ€§ (Hierarchy) / Hierarchy:**
   - ä¸åŒè‡ªåŠ¨æœºå…·æœ‰ä¸åŒçš„è®¡ç®—èƒ½åŠ› / Different automata have different computational capabilities
   - å½¢æˆè®¡ç®—èƒ½åŠ›çš„å±‚æ¬¡ç»“æ„ / Forms a hierarchy of computational capabilities

3. **å½¢å¼åŒ– (Formalization) / Formalization:**
   - ä½¿ç”¨ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰ / Uses rigorous mathematical definitions
   - æä¾›å½¢å¼åŒ–çš„è¯æ˜æ–¹æ³• / Provides formal proof methods

### 4.1.2 è‡ªåŠ¨æœºåˆ†ç±» (Classification of Automata)

**è‡ªåŠ¨æœºå±‚æ¬¡ç»“æ„ / Automata Hierarchy:**

```text
å›¾çµæœº (Turing Machines) - æœ€å¼ºå¤§ / Most powerful
    â†“
ä¸‹æ¨è‡ªåŠ¨æœº (Pushdown Automata) - ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ / Context-free languages
    â†“
æœ‰é™è‡ªåŠ¨æœº (Finite Automata) - æ­£åˆ™è¯­è¨€ / Regular languages
    â†“
æœ‰é™çŠ¶æ€æœº (Finite State Machines) - æœ€åŸºæœ¬ / Most basic
```

**è®¡ç®—èƒ½åŠ›æ¯”è¾ƒ / Computational Power Comparison:**

1. **æœ‰é™è‡ªåŠ¨æœº (Finite Automata) / Finite Automata:**
   - è¯†åˆ«æ­£åˆ™è¯­è¨€ / Recognize regular languages
   - å…·æœ‰æœ‰é™å†…å­˜ / Have finite memory

2. **ä¸‹æ¨è‡ªåŠ¨æœº (Pushdown Automata) / Pushdown Automata:**
   - è¯†åˆ«ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ / Recognize context-free languages
   - å…·æœ‰æ ˆå†…å­˜ / Have stack memory

3. **å›¾çµæœº (Turing Machines) / Turing Machines:**
   - è¯†åˆ«é€’å½’å¯æšä¸¾è¯­è¨€ / Recognize recursively enumerable languages
   - å…·æœ‰æ— é™å†…å­˜ / Have infinite memory

### 4.1.3 å½¢å¼è¯­è¨€ (Formal Languages)

**å½¢å¼è¯­è¨€å®šä¹‰ / Definition of Formal Languages:**

å½¢å¼è¯­è¨€æ˜¯å­—æ¯è¡¨ä¸Šå­—ç¬¦ä¸²çš„é›†åˆï¼Œæ˜¯è‡ªåŠ¨æœºç†è®ºç ”ç©¶çš„æ ¸å¿ƒå¯¹è±¡ã€‚

A formal language is a set of strings over an alphabet, which is the core object of study in automata theory.

**è¯­è¨€å±‚æ¬¡ (Language Hierarchy) / Language Hierarchy:**

1. **æ­£åˆ™è¯­è¨€ (Regular Languages) / Regular Languages:**
   - ç”±æœ‰é™è‡ªåŠ¨æœºè¯†åˆ« / Recognized by finite automata
   - å¯ä»¥ç”¨æ­£åˆ™è¡¨è¾¾å¼è¡¨ç¤º / Can be represented by regular expressions

2. **ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ (Context-Free Languages) / Context-Free Languages:**
   - ç”±ä¸‹æ¨è‡ªåŠ¨æœºè¯†åˆ« / Recognized by pushdown automata
   - å¯ä»¥ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•è¡¨ç¤º / Can be represented by context-free grammars

3. **é€’å½’è¯­è¨€ (Recursive Languages) / Recursive Languages:**
   - ç”±å›¾çµæœºè¯†åˆ« / Recognized by Turing machines
   - å…·æœ‰åœæœºä¿è¯ / Have halting guarantee

4. **é€’å½’å¯æšä¸¾è¯­è¨€ (Recursively Enumerable Languages) / Recursively Enumerable Languages:**
   - ç”±å›¾çµæœºåŠè¯†åˆ« / Semi-recognized by Turing machines
   - å¯èƒ½ä¸ä¿è¯åœæœº / May not guarantee halting

---

## 4.2 æœ‰é™è‡ªåŠ¨æœº (Finite Automata)

### 4.2.1 æœ‰é™è‡ªåŠ¨æœºå®šä¹‰ (Definition of Finite Automata)

**æœ‰é™è‡ªåŠ¨æœºå®šä¹‰ / Definition of Finite Automata:**

æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

A finite automaton is a quintuple $M = (Q, \Sigma, \delta, q_0, F)$, where:

1. **$Q$ æ˜¯æœ‰é™çŠ¶æ€é›† (Finite Set of States) / Finite Set of States:**
   - åŒ…å«æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€ / Contains all possible states

2. **$\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨ (Input Alphabet) / Input Alphabet:**
   - åŒ…å«æ‰€æœ‰å¯èƒ½çš„è¾“å…¥ç¬¦å· / Contains all possible input symbols

3. **$\delta$ æ˜¯è½¬ç§»å‡½æ•° (Transition Function) / Transition Function:**
   - $\delta: Q \times \Sigma \rightarrow Q$
   - å®šä¹‰çŠ¶æ€è½¬ç§»è§„åˆ™ / Defines state transition rules

4. **$q_0$ æ˜¯åˆå§‹çŠ¶æ€ (Initial State) / Initial State:**
   - $q_0 \in Q$ / $q_0 \in Q$

5. **$F$ æ˜¯æ¥å—çŠ¶æ€é›† (Set of Accepting States) / Set of Accepting States:**
   - $F \subseteq Q$ / $F \subseteq Q$

### 4.2.2 ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Deterministic Finite Automata)

**ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºå®šä¹‰ / Definition of Deterministic Finite Automata:**

ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (DFA) æ˜¯æœ‰é™è‡ªåŠ¨æœºçš„ä¸€ç§ï¼Œå…¶è½¬ç§»å‡½æ•°æ˜¯ç¡®å®šæ€§çš„ã€‚

A deterministic finite automaton (DFA) is a type of finite automaton whose transition function is deterministic.

**DFAçš„ç‰¹ç‚¹ / Characteristics of DFA:**

1. **ç¡®å®šæ€§ (Deterministic) / Deterministic:**
   - å¯¹äºæ¯ä¸ªçŠ¶æ€å’Œè¾“å…¥ç¬¦å·ï¼Œåªæœ‰ä¸€ä¸ªåç»§çŠ¶æ€ / For each state and input symbol, there is exactly one successor state

2. **å®Œæ•´æ€§ (Complete) / Complete:**
   - è½¬ç§»å‡½æ•°å¯¹æ‰€æœ‰çŠ¶æ€å’Œè¾“å…¥ç¬¦å·éƒ½æœ‰å®šä¹‰ / Transition function is defined for all states and input symbols

3. **å¯è®¡ç®—æ€§ (Computable) / Computable:**
   - å¯ä»¥åœ¨çº¿æ€§æ—¶é—´å†…åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦è¢«æ¥å— / Can determine string acceptance in linear time

**DFAçš„æ¥å—æ¡ä»¶ / Acceptance Condition for DFA:**

å­—ç¬¦ä¸² $w$ è¢«DFA $M$ æ¥å—ï¼Œå½“ä¸”ä»…å½“ä»åˆå§‹çŠ¶æ€å¼€å§‹ï¼ŒæŒ‰ç…§è½¬ç§»å‡½æ•°è½¬ç§»åï¼Œæœ€ç»ˆçŠ¶æ€åœ¨ $F$ ä¸­ã€‚

A string $w$ is accepted by DFA $M$ if and only if starting from the initial state and following the transition function, the final state is in $F$.

### 4.2.3 éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Nondeterministic Finite Automata)

**éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºå®šä¹‰ / Definition of Nondeterministic Finite Automata:**

éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (NFA) æ˜¯æœ‰é™è‡ªåŠ¨æœºçš„ä¸€ç§ï¼Œå…¶è½¬ç§»å‡½æ•°å¯ä»¥äº§ç”Ÿå¤šä¸ªåç»§çŠ¶æ€ã€‚

A nondeterministic finite automaton (NFA) is a type of finite automaton whose transition function can produce multiple successor states.

**NFAçš„ç‰¹ç‚¹ / Characteristics of NFA:**

1. **éç¡®å®šæ€§ (Nondeterministic) / Nondeterministic:**
   - å¯¹äºæ¯ä¸ªçŠ¶æ€å’Œè¾“å…¥ç¬¦å·ï¼Œå¯èƒ½æœ‰å¤šä¸ªåç»§çŠ¶æ€ / For each state and input symbol, there may be multiple successor states

2. **Îµè½¬ç§» (Epsilon Transitions) / Epsilon Transitions:**
   - å…è®¸ä¸æ¶ˆè€—è¾“å…¥ç¬¦å·çš„è½¬ç§» / Allows transitions without consuming input symbols

3. **ç­‰ä»·æ€§ (Equivalence) / Equivalence:**
   - NFAä¸DFAåœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»· / NFA and DFA are equivalent in computational power

**NFAçš„æ¥å—æ¡ä»¶ / Acceptance Condition for NFA:**

å­—ç¬¦ä¸² $w$ è¢«NFA $M$ æ¥å—ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä¸€æ¡ä»åˆå§‹çŠ¶æ€åˆ°æ¥å—çŠ¶æ€çš„è·¯å¾„ã€‚

A string $w$ is accepted by NFA $M$ if and only if there exists a path from the initial state to an accepting state.

### 4.2.4 æœ‰é™è‡ªåŠ¨æœºçš„åº”ç”¨ (Applications of Finite Automata)

**æ­£åˆ™è¡¨è¾¾å¼ (Regular Expressions) / Regular Expressions:**

æœ‰é™è‡ªåŠ¨æœºä¸æ­£åˆ™è¡¨è¾¾å¼ç­‰ä»·ï¼Œå¯ä»¥ç›¸äº’è½¬æ¢ã€‚

Finite automata are equivalent to regular expressions and can be converted to each other.

**è¯æ³•åˆ†æ (Lexical Analysis) / Lexical Analysis:**

ç¼–è¯‘å™¨ä½¿ç”¨æœ‰é™è‡ªåŠ¨æœºè¿›è¡Œè¯æ³•åˆ†æã€‚

Compilers use finite automata for lexical analysis.

**æ¨¡å¼åŒ¹é… (Pattern Matching) / Pattern Matching:**

å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•åŸºäºæœ‰é™è‡ªåŠ¨æœºã€‚

String matching algorithms are based on finite automata.

---

## 4.3 ä¸‹æ¨è‡ªåŠ¨æœº (Pushdown Automata)

### 4.3.1 ä¸‹æ¨è‡ªåŠ¨æœºå®šä¹‰ (Definition of Pushdown Automata)

**ä¸‹æ¨è‡ªåŠ¨æœºå®šä¹‰ / Definition of Pushdown Automata:**

ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ï¼Œå…¶ä¸­ï¼š

A pushdown automaton is a septuple $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$, where:

1. **$Q$ æ˜¯æœ‰é™çŠ¶æ€é›† (Finite Set of States) / Finite Set of States:**
   - åŒ…å«æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€ / Contains all possible states

2. **$\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨ (Input Alphabet) / Input Alphabet:**
   - åŒ…å«æ‰€æœ‰å¯èƒ½çš„è¾“å…¥ç¬¦å· / Contains all possible input symbols

3. **$\Gamma$ æ˜¯æ ˆå­—æ¯è¡¨ (Stack Alphabet) / Stack Alphabet:**
   - åŒ…å«æ‰€æœ‰å¯èƒ½çš„æ ˆç¬¦å· / Contains all possible stack symbols

4. **$\delta$ æ˜¯è½¬ç§»å‡½æ•° (Transition Function) / Transition Function:**
   - $\delta: Q \times \Sigma \times \Gamma \rightarrow 2^{Q \times \Gamma^*}$
   - å®šä¹‰çŠ¶æ€å’Œæ ˆçš„è½¬ç§»è§„åˆ™ / Defines transition rules for states and stack

5. **$q_0$ æ˜¯åˆå§‹çŠ¶æ€ (Initial State) / Initial State:**
   - $q_0 \in Q$ / $q_0 \in Q$

6. **$Z_0$ æ˜¯åˆå§‹æ ˆç¬¦å· (Initial Stack Symbol) / Initial Stack Symbol:**
   - $Z_0 \in \Gamma$ / $Z_0 \in \Gamma$

7. **$F$ æ˜¯æ¥å—çŠ¶æ€é›† (Set of Accepting States) / Set of Accepting States:**
   - $F \subseteq Q$ / $F \subseteq Q$

**å®šç† 4.2.1** (æœ‰é™è‡ªåŠ¨æœºçš„ç­‰ä»·æ€§) å¯¹äºä»»ä½•éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (NFA)ï¼Œå­˜åœ¨ä¸€ä¸ªç­‰ä»·çš„ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (DFA)ã€‚

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡å­é›†æ„é€ æ³•æ¥è¯æ˜è¿™ä¸ªå®šç†ã€‚

**æ„é€ è¿‡ç¨‹ï¼š**

ç»™å®šNFA $N = (Q_N, \Sigma, \delta_N, q_0, F_N)$ï¼Œæ„é€ DFA $D = (Q_D, \Sigma, \delta_D, q_0', F_D)$ï¼š

1. **çŠ¶æ€é›†æ„é€ ï¼š** $Q_D = 2^{Q_N}$ï¼Œå³æ‰€æœ‰ $Q_N$ çš„å­é›†
2. **åˆå§‹çŠ¶æ€ï¼š** $q_0' = \{q_0\}$
3. **è½¬ç§»å‡½æ•°ï¼š** å¯¹äº $S \in Q_D$ å’Œ $a \in \Sigma$ï¼Œ
   $$\delta_D(S, a) = \bigcup_{q \in S} \delta_N(q, a)$$
4. **æ¥å—çŠ¶æ€ï¼š** $F_D = \{S \in Q_D : S \cap F_N \neq \emptyset\}$

**ç­‰ä»·æ€§è¯æ˜ï¼š**

**å¼•ç†ï¼š** å¯¹äºä»»ä½•å­—ç¬¦ä¸² $w$ï¼Œ$\delta_D^*(\{q_0\}, w) = \delta_N^*(q_0, w)$

**åŸºç¡€æƒ…å†µï¼š** $w = \varepsilon$

- $\delta_D^*(\{q_0\}, \varepsilon) = \{q_0\}$
- $\delta_N^*(q_0, \varepsilon) = \{q_0\}$

**å½’çº³æ­¥éª¤ï¼š** å‡è®¾å¯¹äº $|w| = n$ æˆç«‹ï¼Œè¯æ˜å¯¹äº $wa$ æˆç«‹

- $\delta_D^*(\{q_0\}, wa) = \delta_D(\delta_D^*(\{q_0\}, w), a)$
- $= \delta_D(\delta_N^*(q_0, w), a)$
- $= \bigcup_{q \in \delta_N^*(q_0, w)} \delta_N(q, a)$
- $= \delta_N^*(q_0, wa)$

**æ¥å—æ€§è¯æ˜ï¼š**

- $w \in L(D)$ å½“ä¸”ä»…å½“ $\delta_D^*(\{q_0\}, w) \cap F_D \neq \emptyset$
- å½“ä¸”ä»…å½“ $\delta_N^*(q_0, w) \cap F_N \neq \emptyset$
- å½“ä¸”ä»…å½“ $w \in L(N)$

å› æ­¤ï¼ŒNFAå’ŒDFAæ˜¯ç­‰ä»·çš„ã€‚$\square$

**å®šç† 4.2.2** (æ³µå¼•ç†) å¦‚æœ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™å­˜åœ¨æ­£æ•´æ•° $n$ï¼Œä½¿å¾—å¯¹äºä»»ä½•å­—ç¬¦ä¸² $w \in L$ ä¸” $|w| \geq n$ï¼Œå­˜åœ¨åˆ†è§£ $w = xyz$ï¼Œå…¶ä¸­ï¼š

1. $|xy| \leq n$
2. $|y| > 0$
3. å¯¹äºæ‰€æœ‰ $k \geq 0$ï¼Œ$xy^k z \in L$

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡æœ‰é™è‡ªåŠ¨æœºçš„çŠ¶æ€æ•°æ¥è¯æ˜æ³µå¼•ç†ã€‚

**æ„é€ è¯æ˜ï¼š**

è®¾ $M = (Q, \Sigma, \delta, q_0, F)$ æ˜¯æ¥å— $L$ çš„DFAï¼Œä»¤ $n = |Q|$ã€‚

å¯¹äºä»»ä½•å­—ç¬¦ä¸² $w \in L$ ä¸” $|w| \geq n$ï¼Œè€ƒè™‘ $M$ åœ¨ $w$ ä¸Šçš„è®¡ç®—è·¯å¾„ï¼š
$$q_0 \xrightarrow{w_1} q_1 \xrightarrow{w_2} q_2 \cdots \xrightarrow{w_n} q_n \cdots$$

ç”±äº $|Q| = n$ï¼Œæ ¹æ®é¸½å·¢åŸç†ï¼Œåœ¨å‰ $n+1$ ä¸ªçŠ¶æ€ä¸­è‡³å°‘æœ‰ä¸¤ä¸ªçŠ¶æ€ç›¸åŒï¼Œè®¾ä¸º $q_i = q_j$ï¼Œå…¶ä¸­ $i < j \leq n$ã€‚

**åˆ†è§£æ„é€ ï¼š**

- $x = w_1 w_2 \cdots w_i$
- $y = w_{i+1} w_{i+2} \cdots w_j$
- $z = w_{j+1} w_{j+2} \cdots w_m$

**éªŒè¯æ¡ä»¶ï¼š**

1. $|xy| = j \leq n$
2. $|y| = j - i > 0$
3. å¯¹äºä»»ä½• $k \geq 0$ï¼Œ$xy^k z$ å¯¹åº”çš„è®¡ç®—è·¯å¾„ä¸ºï¼š
   $$q_0 \xrightarrow{x} q_i \xrightarrow{y^k} q_i \xrightarrow{z} q_f \in F$$

å› æ­¤ï¼Œ$xy^k z \in L$ å¯¹äºæ‰€æœ‰ $k \geq 0$ã€‚

å› æ­¤ï¼Œæ³µå¼•ç†æˆç«‹ã€‚$\square$

### 4.3.2 ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº (Deterministic Pushdown Automata)

**ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºå®šä¹‰ / Definition of Deterministic Pushdown Automata:**

ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº (DPDA) æ˜¯ä¸‹æ¨è‡ªåŠ¨æœºçš„ä¸€ç§ï¼Œå…¶è½¬ç§»å‡½æ•°æ˜¯ç¡®å®šæ€§çš„ã€‚

A deterministic pushdown automaton (DPDA) is a type of pushdown automaton whose transition function is deterministic.

**DPDAçš„ç‰¹ç‚¹ / Characteristics of DPDA:**

1. **ç¡®å®šæ€§ (Deterministic) / Deterministic:**
   - å¯¹äºæ¯ä¸ªçŠ¶æ€ã€è¾“å…¥ç¬¦å·å’Œæ ˆé¡¶ç¬¦å·ï¼Œæœ€å¤šæœ‰ä¸€ä¸ªè½¬ç§» / For each state, input symbol, and stack top symbol, there is at most one transition

2. **Îµè½¬ç§»é™åˆ¶ (Epsilon Transition Restriction) / Epsilon Transition Restriction:**
   - å¦‚æœå­˜åœ¨Îµè½¬ç§»ï¼Œåˆ™ä¸èƒ½æœ‰å…¶ä»–è½¬ç§» / If epsilon transition exists, no other transitions are allowed

3. **è®¡ç®—èƒ½åŠ› (Computational Power) / Computational Power:**
   - æ¯”NFAæ›´å¼ºå¤§ï¼Œä½†æ¯”å›¾çµæœºå¼± / More powerful than NFA but weaker than Turing machines

### 4.3.3 éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº (Nondeterministic Pushdown Automata)

**éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºå®šä¹‰ / Definition of Nondeterministic Pushdown Automata:**

éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº (NPDA) æ˜¯ä¸‹æ¨è‡ªåŠ¨æœºçš„ä¸€ç§ï¼Œå…¶è½¬ç§»å‡½æ•°å¯ä»¥äº§ç”Ÿå¤šä¸ªåç»§é…ç½®ã€‚

A nondeterministic pushdown automaton (NPDA) is a type of pushdown automaton whose transition function can produce multiple successor configurations.

**NPDAçš„ç‰¹ç‚¹ / Characteristics of NPDA:**

1. **éç¡®å®šæ€§ (Nondeterministic) / Nondeterministic:**
   - å¯¹äºæ¯ä¸ªçŠ¶æ€ã€è¾“å…¥ç¬¦å·å’Œæ ˆé¡¶ç¬¦å·ï¼Œå¯èƒ½æœ‰å¤šä¸ªè½¬ç§» / For each state, input symbol, and stack top symbol, there may be multiple transitions

2. **Îµè½¬ç§» (Epsilon Transitions) / Epsilon Transitions:**
   - å…è®¸ä¸æ¶ˆè€—è¾“å…¥ç¬¦å·çš„è½¬ç§» / Allows transitions without consuming input symbols

3. **ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ (Context-Free Languages) / Context-Free Languages:**
   - NPDAè¯†åˆ«ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ / NPDA recognizes context-free languages

### 4.3.4 ä¸‹æ¨è‡ªåŠ¨æœºçš„åº”ç”¨ (Applications of Pushdown Automata)

**è¯­æ³•åˆ†æ (Parsing) / Parsing:**

ç¼–è¯‘å™¨ä½¿ç”¨ä¸‹æ¨è‡ªåŠ¨æœºè¿›è¡Œè¯­æ³•åˆ†æã€‚

Compilers use pushdown automata for parsing.

**è‡ªç„¶è¯­è¨€å¤„ç† (Natural Language Processing) / Natural Language Processing:**

ä¸‹æ¨è‡ªåŠ¨æœºç”¨äºè‡ªç„¶è¯­è¨€çš„å¥æ³•åˆ†æã€‚

Pushdown automata are used for syntactic analysis of natural languages.

**XMLå¤„ç† (XML Processing) / XML Processing:**

XMLè§£æå™¨åŸºäºä¸‹æ¨è‡ªåŠ¨æœºã€‚

XML parsers are based on pushdown automata.

---

## 4.4 å›¾çµæœº (Turing Machines)

### 4.4.1 å›¾çµæœºå®šä¹‰ (Definition of Turing Machines)

**å›¾çµæœºå®šä¹‰ / Definition of Turing Machines:**

å›¾çµæœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$ï¼Œå…¶ä¸­ï¼š

A Turing machine is a septuple $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$, where:

1. **$Q$ æ˜¯æœ‰é™çŠ¶æ€é›† (Finite Set of States) / Finite Set of States:**
   - åŒ…å«æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€ / Contains all possible states

2. **$\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨ (Input Alphabet) / Input Alphabet:**
   - åŒ…å«æ‰€æœ‰å¯èƒ½çš„è¾“å…¥ç¬¦å· / Contains all possible input symbols

3. **$\Gamma$ æ˜¯ç£å¸¦å­—æ¯è¡¨ (Tape Alphabet) / Tape Alphabet:**
   - åŒ…å«æ‰€æœ‰å¯èƒ½çš„ç£å¸¦ç¬¦å· / Contains all possible tape symbols
   - $\Sigma \subseteq \Gamma$ / $\Sigma \subseteq \Gamma$

4. **$\delta$ æ˜¯è½¬ç§»å‡½æ•° (Transition Function) / Transition Function:**
   - $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R, N\}$
   - å®šä¹‰çŠ¶æ€ã€ç¬¦å·å’Œç§»åŠ¨çš„è½¬ç§»è§„åˆ™ / Defines transition rules for state, symbol, and movement

5. **$q_0$ æ˜¯åˆå§‹çŠ¶æ€ (Initial State) / Initial State:**
   - $q_0 \in Q$ / $q_0 \in Q$

6. **$B$ æ˜¯ç©ºç™½ç¬¦å· (Blank Symbol) / Blank Symbol:**
   - $B \in \Gamma \setminus \Sigma$ / $B \in \Gamma \setminus \Sigma$

7. **$F$ æ˜¯æ¥å—çŠ¶æ€é›† (Set of Accepting States) / Set of Accepting States:**
   - $F \subseteq Q$ / $F \subseteq Q$

### 4.4.2 å›¾çµæœºçš„é…ç½® (Turing Machine Configurations)

**é…ç½®å®šä¹‰ / Definition of Configurations:**

å›¾çµæœºçš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, \alpha, \beta)$ï¼Œå…¶ä¸­ï¼š

A Turing machine configuration is a triple $(q, \alpha, \beta)$, where:

1. **$q$ æ˜¯å½“å‰çŠ¶æ€ (Current State) / Current State:**
   - $q \in Q$ / $q \in Q$

2. **$\alpha$ æ˜¯ç£å¸¦å¤´éƒ¨å·¦ä¾§çš„å†…å®¹ (Content Left of Head) / Content Left of Head:**
   - $\alpha \in \Gamma^*$ / $\alpha \in \Gamma^*$

3. **$\beta$ æ˜¯ç£å¸¦å¤´éƒ¨åŠå…¶å³ä¾§çš„å†…å®¹ (Content at and Right of Head) / Content at and Right of Head:**
   - $\beta \in \Gamma^*$ / $\beta \in \Gamma^*$

**è½¬ç§»å…³ç³» (Transition Relation) / Transition Relation:**

é…ç½® $(q, \alpha, \beta)$ è½¬ç§»åˆ°é…ç½® $(q', \alpha', \beta')$ï¼Œè®°ä½œï¼š

Configuration $(q, \alpha, \beta)$ transitions to configuration $(q', \alpha', \beta')$, denoted as:

$$(q, \alpha, \beta) \vdash (q', \alpha', \beta')$$

### 4.4.3 å›¾çµæœºçš„å˜ç§ (Variants of Turing Machines)

**å¤šå¸¦å›¾çµæœº (Multi-Tape Turing Machines) / Multi-Tape Turing Machines:**

å¤šå¸¦å›¾çµæœºæœ‰å¤šä¸ªç£å¸¦ï¼Œæ¯ä¸ªç£å¸¦éƒ½æœ‰è‡ªå·±çš„è¯»å†™å¤´ã€‚

Multi-tape Turing machines have multiple tapes, each with its own read-write head.

**éç¡®å®šæ€§å›¾çµæœº (Nondeterministic Turing Machines) / Nondeterministic Turing Machines:**

éç¡®å®šæ€§å›¾çµæœºçš„è½¬ç§»å‡½æ•°å¯ä»¥äº§ç”Ÿå¤šä¸ªåç»§é…ç½®ã€‚

Nondeterministic Turing machines can produce multiple successor configurations.

**é€šç”¨å›¾çµæœº (Universal Turing Machines) / Universal Turing Machines:**

é€šç”¨å›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿä»»ä½•å…¶ä»–å›¾çµæœºã€‚

Universal Turing machines can simulate any other Turing machine.

### 4.4.4 å›¾çµæœºçš„åº”ç”¨ (Applications of Turing Machines)

**å¯è®¡ç®—æ€§ç†è®º (Computability Theory) / Computability Theory:**

å›¾çµæœºæ˜¯ç ”ç©¶å¯è®¡ç®—æ€§çš„æ ‡å‡†æ¨¡å‹ã€‚

Turing machines are the standard model for studying computability.

**å¤æ‚æ€§ç†è®º (Complexity Theory) / Complexity Theory:**

å›¾çµæœºç”¨äºå®šä¹‰è®¡ç®—å¤æ‚æ€§ç±»ã€‚

Turing machines are used to define computational complexity classes.

**ç¨‹åºè¯­è¨€ç†è®º (Programming Language Theory) / Programming Language Theory:**

å›¾çµæœºä¸ºç¨‹åºè¯­è¨€æä¾›ç†è®ºåŸºç¡€ã€‚

Turing machines provide theoretical foundation for programming languages.

---

## 4.5 å®ç°ç¤ºä¾‹ (Implementation Examples)

### 4.5.1 æœ‰é™è‡ªåŠ¨æœºå®ç° (Finite Automata Implementation)

```rust
use std::collections::HashMap;

/// æœ‰é™è‡ªåŠ¨æœºå®ç° / Finite Automata Implementation
pub struct FiniteAutomaton {
    states: Vec<String>,
    alphabet: Vec<char>,
    transitions: HashMap<(String, char), String>,
    initial_state: String,
    accepting_states: Vec<String>,
}

impl FiniteAutomaton {
    /// åˆ›å»ºæ–°çš„æœ‰é™è‡ªåŠ¨æœº / Create new finite automaton
    pub fn new(
        states: Vec<String>,
        alphabet: Vec<char>,
        initial_state: String,
        accepting_states: Vec<String>,
    ) -> Self {
        FiniteAutomaton {
            states,
            alphabet,
            transitions: HashMap::new(),
            initial_state,
            accepting_states,
        }
    }

    /// æ·»åŠ è½¬ç§» / Add transition
    pub fn add_transition(&mut self, from_state: &str, symbol: char, to_state: &str) {
        self.transitions.insert((from_state.to_string(), symbol), to_state.to_string());
    }

    /// æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦è¢«æ¥å— / Check if string is accepted
    pub fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();

        for symbol in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state.clone();
            } else {
                return false; // æ²¡æœ‰è½¬ç§» / No transition
            }
        }

        self.accepting_states.contains(&current_state)
    }

    /// è·å–æ‰€æœ‰å¯è¾¾çŠ¶æ€ / Get all reachable states
    pub fn get_reachable_states(&self) -> Vec<String> {
        let mut reachable = vec![self.initial_state.clone()];
        let mut new_states = vec![self.initial_state.clone()];

        while !new_states.is_empty() {
            let mut next_new_states = Vec::new();

            for state in &new_states {
                for symbol in &self.alphabet {
                    if let Some(next_state) = self.transitions.get(&(state.clone(), *symbol)) {
                        if !reachable.contains(next_state) {
                            reachable.push(next_state.clone());
                            next_new_states.push(next_state.clone());
                        }
                    }
                }
            }

            new_states = next_new_states;
        }

        reachable
    }

    /// æœ€å°åŒ–è‡ªåŠ¨æœº / Minimize automaton
    pub fn minimize(&self) -> FiniteAutomaton {
        // ç®€åŒ–å®ç°ï¼šç§»é™¤ä¸å¯è¾¾çŠ¶æ€ / Simplified implementation: remove unreachable states
        let reachable_states = self.get_reachable_states();
        let reachable_accepting: Vec<String> = self.accepting_states
            .iter()
            .filter(|state| reachable_states.contains(state))
            .cloned()
            .collect();

        let mut minimized = FiniteAutomaton::new(
            reachable_states,
            self.alphabet.clone(),
            self.initial_state.clone(),
            reachable_accepting,
        );

        // å¤åˆ¶å¯è¾¾çŠ¶æ€çš„è½¬ç§» / Copy transitions for reachable states
        for (key, value) in &self.transitions {
            if reachable_states.contains(&key.0) && reachable_states.contains(value) {
                minimized.transitions.insert(key.clone(), value.clone());
            }
        }

        minimized
    }
}
```

### 4.5.2 ä¸‹æ¨è‡ªåŠ¨æœºå®ç° (Pushdown Automata Implementation)

```rust
/// ä¸‹æ¨è‡ªåŠ¨æœºå®ç° / Pushdown Automata Implementation
pub struct PushdownAutomaton {
    states: Vec<String>,
    input_alphabet: Vec<char>,
    stack_alphabet: Vec<char>,
    transitions: HashMap<(String, char, char), Vec<(String, String)>>,
    initial_state: String,
    initial_stack_symbol: char,
    accepting_states: Vec<String>,
}

impl PushdownAutomaton {
    /// åˆ›å»ºæ–°çš„ä¸‹æ¨è‡ªåŠ¨æœº / Create new pushdown automaton
    pub fn new(
        states: Vec<String>,
        input_alphabet: Vec<char>,
        stack_alphabet: Vec<char>,
        initial_state: String,
        initial_stack_symbol: char,
        accepting_states: Vec<String>,
    ) -> Self {
        PushdownAutomaton {
            states,
            input_alphabet,
            stack_alphabet,
            transitions: HashMap::new(),
            initial_state,
            initial_stack_symbol,
            accepting_states,
        }
    }

    /// æ·»åŠ è½¬ç§» / Add transition
    pub fn add_transition(&mut self, from_state: &str, input_symbol: char, stack_symbol: char,
                         to_state: &str, stack_push: &str) {
        let key = (from_state.to_string(), input_symbol, stack_symbol);
        let value = (to_state.to_string(), stack_push.to_string());

        self.transitions.entry(key).or_insert_with(Vec::new).push(value);
    }

    /// æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦è¢«æ¥å— / Check if string is accepted
    pub fn accepts(&self, input: &str) -> bool {
        let initial_config = PDAConfiguration {
            state: self.initial_state.clone(),
            input: input.chars().collect(),
            input_pos: 0,
            stack: vec![self.initial_stack_symbol],
        };

        self.accepts_from_config(initial_config)
    }

    /// ä»é…ç½®å¼€å§‹æ£€æŸ¥æ¥å— / Check acceptance from configuration
    fn accepts_from_config(&self, config: PDAConfiguration) -> bool {
        // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æ¥å—çŠ¶æ€ / Check if reached accepting state
        if config.input_pos >= config.input.len() {
            return self.accepting_states.contains(&config.state);
        }

        let current_input = config.input[config.input_pos];
        let current_stack_top = config.stack.last().unwrap_or(&'Z');

        let key = (config.state.clone(), current_input, *current_stack_top);

        if let Some(transitions) = self.transitions.get(&key) {
            for (new_state, stack_push) in transitions {
                let mut new_stack = config.stack.clone();
                new_stack.pop(); // ç§»é™¤æ ˆé¡¶ / Remove stack top

                // å‹å…¥æ–°ç¬¦å· / Push new symbols
                for symbol in stack_push.chars().rev() {
                    new_stack.push(symbol);
                }

                let new_config = PDAConfiguration {
                    state: new_state.clone(),
                    input: config.input.clone(),
                    input_pos: config.input_pos + 1,
                    stack: new_stack,
                };

                if self.accepts_from_config(new_config) {
                    return true;
                }
            }
        }

        false
    }
}

#[derive(Clone)]
struct PDAConfiguration {
    state: String,
    input: Vec<char>,
    input_pos: usize,
    stack: Vec<char>,
}
```

### 4.5.3 å›¾çµæœºå®ç° (Turing Machine Implementation)

```rust
/// å›¾çµæœºå®ç° / Turing Machine Implementation
pub struct TuringMachine {
    states: Vec<String>,
    input_alphabet: Vec<char>,
    tape_alphabet: Vec<char>,
    transitions: HashMap<(String, char), (String, char, Movement)>,
    initial_state: String,
    blank_symbol: char,
    accepting_states: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum Movement {
    Left,
    Right,
    Stay,
}

impl TuringMachine {
    /// åˆ›å»ºæ–°çš„å›¾çµæœº / Create new Turing machine
    pub fn new(
        states: Vec<String>,
        input_alphabet: Vec<char>,
        tape_alphabet: Vec<char>,
        initial_state: String,
        blank_symbol: char,
        accepting_states: Vec<String>,
    ) -> Self {
        TuringMachine {
            states,
            input_alphabet,
            tape_alphabet,
            transitions: HashMap::new(),
            initial_state,
            blank_symbol,
            accepting_states,
        }
    }

    /// æ·»åŠ è½¬ç§» / Add transition
    pub fn add_transition(&mut self, from_state: &str, read_symbol: char,
                         to_state: &str, write_symbol: char, movement: Movement) {
        let key = (from_state.to_string(), read_symbol);
        let value = (to_state.to_string(), write_symbol, movement);
        self.transitions.insert(key, value);
    }

    /// è¿è¡Œå›¾çµæœº / Run Turing machine
    pub fn run(&self, input: &str) -> (bool, Vec<char>) {
        let mut tape: Vec<char> = input.chars().collect();
        let mut head_pos = 0;
        let mut current_state = self.initial_state.clone();
        let mut step_count = 0;
        let max_steps = 10000; // é˜²æ­¢æ— é™å¾ªç¯ / Prevent infinite loops

        while step_count < max_steps {
            // æ‰©å±•ç£å¸¦å¦‚æœéœ€è¦ / Extend tape if needed
            while head_pos >= tape.len() {
                tape.push(self.blank_symbol);
            }
            while head_pos < 0 {
                tape.insert(0, self.blank_symbol);
                head_pos += 1;
            }

            let current_symbol = tape[head_pos];
            let key = (current_state.clone(), current_symbol);

            if let Some((new_state, write_symbol, movement)) = self.transitions.get(&key) {
                // æ‰§è¡Œè½¬ç§» / Execute transition
                tape[head_pos] = *write_symbol;
                current_state = new_state.clone();

                match movement {
                    Movement::Left => head_pos -= 1,
                    Movement::Right => head_pos += 1,
                    Movement::Stay => {},
                }

                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æ¥å—çŠ¶æ€ / Check if reached accepting state
                if self.accepting_states.contains(&current_state) {
                    return (true, tape);
                }
            } else {
                // æ²¡æœ‰è½¬ç§»ï¼Œåœæœº / No transition, halt
                break;
            }

            step_count += 1;
        }

        (false, tape)
    }

    /// æ£€æŸ¥è¯­è¨€æˆå‘˜èµ„æ ¼ / Check language membership
    pub fn accepts(&self, input: &str) -> bool {
        let (accepted, _) = self.run(input);
        accepted
    }
}
```

### 4.5.4 è‡ªåŠ¨æœºç†è®ºæµ‹è¯• (Automata Theory Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_finite_automaton() {
        // åˆ›å»ºè¯†åˆ«å¶æ•°ä¸ªaçš„DFA / Create DFA recognizing even number of a's
        let mut dfa = FiniteAutomaton::new(
            vec!["q0".to_string(), "q1".to_string()],
            vec!['a', 'b'],
            "q0".to_string(),
            vec!["q0".to_string()],
        );

        dfa.add_transition("q0", 'a', "q1");
        dfa.add_transition("q0", 'b', "q0");
        dfa.add_transition("q1", 'a', "q0");
        dfa.add_transition("q1", 'b', "q1");

        // æµ‹è¯•æ¥å— / Test acceptance
        assert!(dfa.accepts(""));
        assert!(dfa.accepts("aa"));
        assert!(dfa.accepts("aabb"));
        assert!(!dfa.accepts("a"));
        assert!(!dfa.accepts("aaa"));
    }

    #[test]
    fn test_pushdown_automaton() {
        // åˆ›å»ºè¯†åˆ«a^n b^nçš„PDA / Create PDA recognizing a^n b^n
        let mut pda = PushdownAutomaton::new(
            vec!["q0".to_string(), "q1".to_string(), "q2".to_string()],
            vec!['a', 'b'],
            vec!['Z', 'A'],
            "q0".to_string(),
            'Z',
            vec!["q2".to_string()],
        );

        // è¯»å–aï¼Œå‹å…¥A / Read a, push A
        pda.add_transition("q0", 'a', 'Z', "q0", "AZ");
        pda.add_transition("q0", 'a', 'A', "q0", "AA");

        // è¯»å–bï¼Œå¼¹å‡ºA / Read b, pop A
        pda.add_transition("q0", 'b', 'A', "q1", "");
        pda.add_transition("q1", 'b', 'A', "q1", "");

        // æ¥å—ç©ºæ ˆ / Accept with empty stack
        pda.add_transition("q1", '\0', 'Z', "q2", "");

        // æµ‹è¯•æ¥å— / Test acceptance
        assert!(pda.accepts(""));
        assert!(pda.accepts("ab"));
        assert!(pda.accepts("aabb"));
        assert!(!pda.accepts("a"));
        assert!(!pda.accepts("abb"));
    }

    #[test]
    fn test_turing_machine() {
        // åˆ›å»ºå¤åˆ¶è¾“å…¥çš„å›¾çµæœº / Create Turing machine that copies input
        let mut tm = TuringMachine::new(
            vec!["q0".to_string(), "q1".to_string(), "q2".to_string(), "q3".to_string()],
            vec!['a', 'b'],
            vec!['a', 'b', 'X', 'Y', 'B'],
            "q0".to_string(),
            'B',
            vec!["q3".to_string()],
        );

        // ç®€åŒ–å®ç°ï¼šè¯†åˆ«å›æ–‡ / Simplified implementation: recognize palindromes
        tm.add_transition("q0", 'a', "q1", 'X', Movement::Right);
        tm.add_transition("q0", 'b', "q1", 'Y', Movement::Right);
        tm.add_transition("q0", 'B', "q3", 'B', Movement::Stay);

        tm.add_transition("q1", 'a', "q1", 'a', Movement::Right);
        tm.add_transition("q1", 'b', "q1", 'b', Movement::Right);
        tm.add_transition("q1", 'B', "q2", 'B', Movement::Left);

        tm.add_transition("q2", 'a', "q2", 'a', Movement::Left);
        tm.add_transition("q2", 'b', "q2", 'b', Movement::Left);
        tm.add_transition("q2", 'X', "q0", 'X', Movement::Right);
        tm.add_transition("q2", 'Y', "q0", 'Y', Movement::Right);

        // æµ‹è¯•æ¥å— / Test acceptance
        assert!(tm.accepts(""));
        assert!(tm.accepts("a"));
        assert!(tm.accepts("aa"));
        assert!(tm.accepts("aba"));
        assert!(!tm.accepts("ab"));
    }
}
```

---

## 4.6 å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚æ–‡çŒ®æŒ‰ç…§"ç»å…¸å¥ åŸºæ–‡çŒ® â†’ æ ‡å‡†æ•™æ"çš„å±‚æ¬¡ç»„ç»‡ã€‚

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Turing1936] Turing, A. M. (1936). "On Computable Numbers, with an Application to the Entscheidungsproblem". *Proceedings of the London Mathematical Society*, 2(42), 230-265. DOI: 10.1112/plms/s2-42.1.230
   - Turingå›¾çµæœºçš„å¼€åˆ›æ€§è®ºæ–‡ï¼Œç°ä»£è®¡ç®—æœºç§‘å­¦çš„å¥ åŸºä¹‹ä½œã€‚æœ¬æ–‡æ¡£çš„å›¾çµæœºéƒ¨åˆ†å‚è€ƒæ­¤è®ºæ–‡ã€‚

2. [Kleene1956] Kleene, S. C. (1956). "Representation of Events in Nerve Nets and Finite Automata". In *Automata Studies*, pp. 3-42. Princeton University Press.
   - **Kleeneæœ‰é™è‡ªåŠ¨æœºçš„å¼€åˆ›æ€§å·¥ä½œ**ï¼Œå¥ å®šäº†æœ‰é™è‡ªåŠ¨æœºç†è®ºçš„åŸºç¡€ã€‚

3. [RabinScott1959] Rabin, M. O., & Scott, D. (1959). "Finite Automata and Their Decision Problems". *IBM Journal of Research and Development*, 3(2), 114-125. DOI: 10.1147/rd.32.0114
   - **Rabin-Scottéç¡®å®šæ€§è‡ªåŠ¨æœºçš„ç»å…¸è®ºæ–‡**ï¼Œå»ºç«‹äº†éç¡®å®šæ€§è‡ªåŠ¨æœºç†è®ºã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. [HopcroftUllman2006] Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation* (3rd ed.). Pearson. ISBN: 978-0321455369
   - **Hopcroft-Ullmanè‡ªåŠ¨æœºç†è®ºçš„æƒå¨æ•™æ**ï¼Œè‡ªåŠ¨æœºç†è®ºçš„ç»å…¸ä¹‹ä½œã€‚æœ¬æ–‡æ¡£çš„åŸºç¡€æ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

2. [Sipser2013] Sipser, M. (2013). *Introduction to the Theory of Computation* (3rd ed.). Cengage Learning. ISBN: 978-1133187790
   - Sipserè®¡ç®—ç†è®ºçš„æƒå¨æ•™æï¼Œå¹¿æ³›ä½¿ç”¨äºä¸–ç•Œå„å¤§å­¦ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Automata Theory**: <https://en.wikipedia.org/wiki/Automata_theory>
   - è‡ªåŠ¨æœºç†è®ºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«æœ‰é™è‡ªåŠ¨æœºã€ä¸‹æ¨è‡ªåŠ¨æœºç­‰æ ¸å¿ƒæ¦‚å¿µï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

2. **Wikipedia - Finite Automaton**: <https://en.wikipedia.org/wiki/Finite_automaton>
   - æœ‰é™è‡ªåŠ¨æœºçš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»DFAå’ŒNFAï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

3. **Wikipedia - Pushdown Automaton**: <https://en.wikipedia.org/wiki/Pushdown_automaton>
   - ä¸‹æ¨è‡ªåŠ¨æœºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«ä¸‹æ¨è‡ªåŠ¨æœºçš„å®šä¹‰å’Œæ€§è´¨ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
**æœ€åæ›´æ–° / Last Updated**: 2025-11-14
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-11-14)

---

*æœ¬æ–‡æ¡£æä¾›äº†è‡ªåŠ¨æœºç†è®ºçš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€æœ‰é™è‡ªåŠ¨æœºã€ä¸‹æ¨è‡ªåŠ¨æœºã€å›¾çµæœºå’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
