---
title: 7.5 é‡å­è®¡ç®—æ¨¡å‹ / Quantum Computing Model
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: è®¡ç®—æ¨¡å‹å·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 7.5 é‡å­è®¡ç®—æ¨¡å‹ / Quantum Computing Model

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€é‡å­è®¡ç®—çš„å½¢å¼åŒ–å®šä¹‰ã€é‡å­æ¯”ç‰¹ã€é‡å­é—¨ä¸é‡å­ç®—æ³•ã€‚
- å»ºç«‹é‡å­è®¡ç®—åœ¨è®¡ç®—ç†è®ºä¸­çš„åœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- é‡å­è®¡ç®—ã€é‡å­æ¯”ç‰¹ã€é‡å­å åŠ ã€é‡å­çº ç¼ ã€é‡å­é—¨ã€é‡å­ç®—æ³•ã€BQPç±»ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- é‡å­è®¡ç®—ï¼ˆQuantum Computingï¼‰ï¼šåˆ©ç”¨é‡å­åŠ›å­¦ç°è±¡çš„è®¡ç®—æ¨¡å‹ã€‚
- é‡å­æ¯”ç‰¹ï¼ˆQubitï¼‰ï¼šé‡å­è®¡ç®—çš„åŸºæœ¬å•ä½ã€‚
- é‡å­é—¨ï¼ˆQuantum Gateï¼‰ï¼šé‡å­è®¡ç®—çš„åŸºæœ¬æ“ä½œã€‚
- è®°å·çº¦å®šï¼š`|0âŸ©`ã€`|1âŸ©` è¡¨ç¤ºé‡å­æ€ï¼Œ`âŠ—` è¡¨ç¤ºå¼ é‡ç§¯ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- å›¾çµæœºï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/01-å›¾çµæœº.md`ã€‚
- å¤æ‚åº¦ç†è®ºï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/` ç›¸å…³æ–‡æ¡£ã€‚
- è®¡ç®—æ¨¡å‹ï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/` ç›¸å…³æ–‡æ¡£ã€‚

### å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References

é‡å­è®¡ç®—æ¨¡å‹å¯ä¸ **MIT 18.404**ã€**CMU 15-251** åŠé‡å­è®¡ç®—ä¸“é¢˜è¯¾ç¨‹å¯¹æ ‡ã€‚è¯¾ç¨‹ä¸æ¨¡å—æ˜ å°„è§ [å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- é‡å­æ¯”ç‰¹
- é‡å­é—¨
- é‡å­ç®—æ³•

## ç›®å½• (Table of Contents)

- [7.5 é‡å­è®¡ç®—æ¨¡å‹ / Quantum Computing Model](#75-é‡å­è®¡ç®—æ¨¡å‹--quantum-computing-model)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References](#å›½é™…è¯¾ç¨‹å‚è€ƒ--international-course-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.1 é‡å­è®¡ç®—å®šä¹‰ (Definition of Quantum Computing)](#11-é‡å­è®¡ç®—å®šä¹‰-definition-of-quantum-computing)
  - [1.2 é‡å­åŠ›å­¦åŸºç¡€ (Quantum Mechanics Foundation)](#12-é‡å­åŠ›å­¦åŸºç¡€-quantum-mechanics-foundation)
  - [1.3 é‡å­è®¡ç®—ä¼˜åŠ¿ (Quantum Computing Advantages)](#13-é‡å­è®¡ç®—ä¼˜åŠ¿-quantum-computing-advantages)
  - [1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#14-å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
- [2. é‡å­æ¯”ç‰¹ (Quantum Bits)](#2-é‡å­æ¯”ç‰¹-quantum-bits)
  - [2.1 é‡å­æ¯”ç‰¹å®šä¹‰ (Definition of Quantum Bits)](#21-é‡å­æ¯”ç‰¹å®šä¹‰-definition-of-quantum-bits)
  - [2.2 é‡å­å åŠ æ€ (Quantum Superposition)](#22-é‡å­å åŠ æ€-quantum-superposition)
  - [2.3 é‡å­çº ç¼  (Quantum Entanglement)](#23-é‡å­çº ç¼ -quantum-entanglement)
- [3. é‡å­é—¨ (Quantum Gates)](#3-é‡å­é—¨-quantum-gates)
  - [3.1 å•æ¯”ç‰¹é‡å­é—¨ (Single-Qubit Gates)](#31-å•æ¯”ç‰¹é‡å­é—¨-single-qubit-gates)
  - [3.2 å¤šæ¯”ç‰¹é‡å­é—¨ (Multi-Qubit Gates)](#32-å¤šæ¯”ç‰¹é‡å­é—¨-multi-qubit-gates)
  - [3.3 é€šç”¨é‡å­é—¨é›† (Universal Quantum Gate Sets)](#33-é€šç”¨é‡å­é—¨é›†-universal-quantum-gate-sets)
- [4. é‡å­ç®—æ³• (Quantum Algorithms)](#4-é‡å­ç®—æ³•-quantum-algorithms)
  - [4.1 é‡å­å‚…é‡Œå¶å˜æ¢ (Quantum Fourier Transform)](#41-é‡å­å‚…é‡Œå¶å˜æ¢-quantum-fourier-transform)
  - [4.2 Groveræœç´¢ç®—æ³• (Grover's Search Algorithm)](#42-groveræœç´¢ç®—æ³•-grovers-search-algorithm)
  - [4.3 Shoråˆ†è§£ç®—æ³• (Shor's Factoring Algorithm)](#43-shoråˆ†è§£ç®—æ³•-shors-factoring-algorithm)
- [5. é‡å­å¤æ‚åº¦ç†è®º (Quantum Complexity Theory)](#5-é‡å­å¤æ‚åº¦ç†è®º-quantum-complexity-theory)
  - [5.1 BQPç±» (BQP Class)](#51-bqpç±»-bqp-class)
  - [5.2 QMAç±» (QMA Class)](#52-qmaç±»-qma-class)
  - [5.3 é‡å­ä¸‹ç•Œ (Quantum Lower Bounds)](#53-é‡å­ä¸‹ç•Œ-quantum-lower-bounds)
- [6. é‡å­é”™è¯¯çº æ­£ (Quantum Error Correction)](#6-é‡å­é”™è¯¯çº æ­£-quantum-error-correction)
  - [6.1 é‡å­é”™è¯¯ç±»å‹ (Types of Quantum Errors)](#61-é‡å­é”™è¯¯ç±»å‹-types-of-quantum-errors)
  - [6.2 ç¨³å®šå­ç  (Stabilizer Codes)](#62-ç¨³å®šå­ç -stabilizer-codes)
  - [6.3 è¡¨é¢ç  (Surface Codes)](#63-è¡¨é¢ç -surface-codes)
- [7. å®ç°ç¤ºä¾‹ (Implementation Examples)](#7-å®ç°ç¤ºä¾‹-implementation-examples)
  - [7.1 é‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨ (Quantum Bit Simulator)](#71-é‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨-quantum-bit-simulator)
  - [7.2 é‡å­é—¨å®ç° (Quantum Gate Implementation)](#72-é‡å­é—¨å®ç°-quantum-gate-implementation)
  - [7.3 é‡å­ç®—æ³•å®ç° (Quantum Algorithm Implementation)](#73-é‡å­ç®—æ³•å®ç°-quantum-algorithm-implementation)
  - [7.4 é‡å­é”™è¯¯çº æ­£å®ç° (Quantum Error Correction Implementation)](#74-é‡å­é”™è¯¯çº æ­£å®ç°-quantum-error-correction-implementation)
- [8. å‚è€ƒæ–‡çŒ® / References](#8-å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.1 é‡å­è®¡ç®—å®šä¹‰ (Definition of Quantum Computing)

**å®šä¹‰ 1.1.1** (é‡å­è®¡ç®— / Quantum Computing)
é‡å­è®¡ç®—æ˜¯åˆ©ç”¨é‡å­åŠ›å­¦ç°è±¡è¿›è¡Œä¿¡æ¯å¤„ç†çš„è®¡ç®—æ¨¡å‹ã€‚

**Definition 1.1.1** (Quantum Computing)
Quantum computing is a computational model that uses quantum mechanical phenomena for information processing.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$QC = (H, U, M)$$

å…¶ä¸­ (where):

- $H$ æ˜¯å¸Œå°”ä¼¯ç‰¹ç©ºé—´ (is the Hilbert space)
- $U$ æ˜¯é…‰ç®—å­é›†åˆ (is the set of unitary operators)
- $M$ æ˜¯æµ‹é‡ç®—å­é›†åˆ (is the set of measurement operators)

### 1.2 é‡å­åŠ›å­¦åŸºç¡€ (Quantum Mechanics Foundation)

**å®šä¹‰ 1.2.1** (é‡å­æ€ / Quantum State)
é‡å­æ€æ˜¯å¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸­çš„å•ä½å‘é‡ã€‚

**Definition 1.2.1** (Quantum State)
A quantum state is a unit vector in Hilbert space.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$|\psi\rangle = \sum_{i} \alpha_i |i\rangle$$

å…¶ä¸­ $\sum_{i} |\alpha_i|^2 = 1$ï¼Œ$|\psi\rangle$ è¡¨ç¤ºé‡å­æ€ï¼Œ$|i\rangle$ è¡¨ç¤ºè®¡ç®—åŸºæ€ï¼Œ$\alpha_i$ è¡¨ç¤ºå¤æ•°æŒ¯å¹…ã€‚

**Definition 1.2.2** (é‡å­æµ‹é‡ / Quantum Measurement)
é‡å­æµ‹é‡å°†é‡å­æ€æŠ•å½±åˆ°æµ‹é‡åŸºä¸Šã€‚

**Definition 1.2.2** (Quantum Measurement)
Quantum measurement projects quantum states onto measurement bases.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$P(i) = |\langle i|\psi\rangle|^2$$

### 1.3 é‡å­è®¡ç®—ä¼˜åŠ¿ (Quantum Computing Advantages)

**å®šä¹‰ 1.3.1** (é‡å­å¹¶è¡Œæ€§ / Quantum Parallelism)
é‡å­è®¡ç®—æœºå¯ä»¥åŒæ—¶å¤„ç†å¤šä¸ªè®¡ç®—è·¯å¾„ã€‚

**Definition 1.3.1** (Quantum Parallelism)
Quantum computers can process multiple computational paths simultaneously.

**å®šä¹‰ 1.3.2** (é‡å­çº ç¼  / Quantum Entanglement)
é‡å­æ¯”ç‰¹ä¹‹é—´çš„éå±€åŸŸå…³è”ã€‚

**Definition 1.3.2** (Quantum Entanglement)
Non-local correlations between quantum bits.

**å®šä¹‰ 1.3.3** (é‡å­å¹²æ¶‰ / Quantum Interference)
é‡å­æ€ä¹‹é—´çš„ç›¸é•¿å’Œç›¸æ¶ˆå¹²æ¶‰ã€‚

**Definition 1.3.3** (Quantum Interference)
Constructive and destructive interference between quantum states.

### 1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

**è§£é‡Šä¸ç›´è§‚**ï¼šé‡å­è®¡ç®—åˆ©ç”¨é‡å­æ€å åŠ ä¸çº ç¼ åœ¨å¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸Šæ–½è¡Œé…‰æ¼”åŒ–ä¸æµ‹é‡ï¼›é‡å­æ¯”ç‰¹ã€é‡å­é—¨ã€é‡å­ç®—æ³•æ„æˆ BQP ç­‰å¤æ‚åº¦ç±»ï¼Œä¸ç»å…¸å›¾çµæœºåœ¨å¯è®¡ç®—æ€§ä¸Šç­‰ä»·ã€åœ¨å¤æ‚åº¦ä¸Šå¯åˆ†ç¦»ï¼ˆå¦‚ Shor/Groverï¼‰ã€‚

**æ¦‚å¿µå±æ€§è¡¨**ï¼šé‡å­è®¡ç®— $QC=(H,U,M)$ â€” å¸Œå°”ä¼¯ç‰¹ç©ºé—´ã€é…‰ç®—å­ã€æµ‹é‡ï¼›é‡å­æ¯”ç‰¹ $|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$ï¼›é‡å­é—¨ â€” é…‰çŸ©é˜µï¼›BQP/QMA â€” é‡å­å¤æ‚åº¦ç±»ï¼ˆè§ Â§5ï¼‰ã€‚

**æ¦‚å¿µå…³ç³»**ï¼šé‡å­è®¡ç®— â€”extendsâ€” è®¡ç®—æ¨¡å‹ï¼ˆ07ï¼‰ï¼›ä¸ 01-å›¾çµæœº â€” å¯è®¡ç®—æ€§ç­‰ä»·ã€å¤æ‚åº¦æœ‰åˆ«ï¼›ä¸ 04-ç®—æ³•å¤æ‚åº¦ â€” BQPã€QMA ä¸ Pã€NP å…³ç³»ã€‚

**æ¦‚å¿µä¾èµ–å›¾**ï¼šé‡å­æ€ â†’ é‡å­æ¯”ç‰¹ â†’ é‡å­é—¨ â†’ é‡å­ç”µè·¯ â†’ é‡å­ç®—æ³•ï¼›BQP âŠ† PPï¼›è§ 01ã€04-å¤æ‚åº¦ç±»ã€‚

**æ€ç»´å¯¼å›¾**ï¼šé‡å­è®¡ç®— â†’ é‡å­æ¯”ç‰¹ã€é‡å­é—¨ã€é‡å­ç®—æ³•ã€é‡å­çº é”™ â†’ å¤æ‚åº¦(BQP/QMA)ã€ç‰©ç†å®ç°ã€ä¸ç»å…¸è®¡ç®—å¯¹æ¯”ã€‚

**å¤šç»´çŸ©é˜µ**ï¼šqubit/é—¨/ç”µè·¯/ç®—æ³• â€” è¡¨è¾¾åŠ›ï¼›BQP/QMA â€” å¤æ‚åº¦ç±»ï¼›ä¸ TM/Î» â€” å¯è®¡ç®—æ€§ç­‰ä»·ã€å¤æ‚åº¦åˆ†ç¦»ã€‚

**è®ºè¯ä¸è¯æ˜è¡”æ¥**ï¼šå®šä¹‰ 1.1.1 å½¢å¼åŒ– $QC=(H,U,M)$ï¼›BQP å®šä¹‰ä¸ PP åŒ…å«å…³ç³»è§ Â§5.1ï¼›ä¸å›¾çµå¯è®¡ç®—ç­‰ä»·è§ 08-è®¡ç®—æ¨¡å‹ç­‰ä»·æ€§ã€‚

**å†³ç­–æ ‘**ï¼šé—®é¢˜ç±»å‹ â†’ ç»å…¸/é‡å­é€‰å‹ï¼ˆå› æ•°åˆ†è§£ã€æœç´¢ç”¨é‡å­ä¼˜åŠ¿ï¼‰ï¼›å®ç°å±‚æ¬¡ â†’ æ¨¡æ‹Ÿ/çœŸå®ç¡¬ä»¶/çº é”™ã€‚

**å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘**ï¼šé‡å­å…¬è®¾ â†’ æ€ã€æ¼”åŒ–ã€æµ‹é‡ï¼›BQPâŠ†PPï¼›é‡å­ä¸‹ç•Œï¼ˆè§ Â§5.3ï¼‰ã€‚

**åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘**ï¼šå¯†ç /ä¼˜åŒ–/æ¨¡æ‹Ÿ â†’ é€‰ç®—æ³•(Shor/Grover/VQE ç­‰)ï¼›é”™è¯¯çº æ­£ â†’ ç¨³å®šå­ç /è¡¨é¢ç ï¼ˆè§ Â§6ï¼‰ã€‚

---

## 2. é‡å­æ¯”ç‰¹ (Quantum Bits)

### 2.1 é‡å­æ¯”ç‰¹å®šä¹‰ (Definition of Quantum Bits)

**å®šä¹‰ 2.1.1** (é‡å­æ¯”ç‰¹ / Quantum Bit)
é‡å­æ¯”ç‰¹æ˜¯é‡å­è®¡ç®—çš„åŸºæœ¬ä¿¡æ¯å•ä½ï¼Œå¯ä»¥å¤„äºå åŠ æ€ã€‚

**Definition 2.1.1** (Quantum Bit)
A quantum bit is the basic unit of information in quantum computing, which can exist in superposition.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$$

å…¶ä¸­ $|\alpha|^2 + |\beta|^2 = 1$ã€‚

**Definition 2.1.2** (å¸ƒæ´›èµ«çƒ / Bloch Sphere)
é‡å­æ¯”ç‰¹çš„å‡ ä½•è¡¨ç¤ºã€‚

**Definition 2.1.2** (Bloch Sphere)
Geometric representation of quantum bits.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$|\psi\rangle = \cos\frac{\theta}{2}|0\rangle + e^{i\phi}\sin\frac{\theta}{2}|1\rangle$$

### 2.2 é‡å­å åŠ æ€ (Quantum Superposition)

**å®šä¹‰ 2.2.1** (å åŠ æ€ / Superposition State)
é‡å­æ¯”ç‰¹å¯ä»¥åŒæ—¶å¤„äºå¤šä¸ªç»å…¸çŠ¶æ€çš„çº¿æ€§ç»„åˆã€‚

**Definition 2.2.1** (Superposition State)
A quantum bit can exist in a linear combination of multiple classical states simultaneously.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$|\psi\rangle = \sum_{i=0}^{2^n-1} \alpha_i|i\rangle$$

å…¶ä¸­ $\sum_{i} |\alpha_i|^2 = 1$ã€‚

**å®šä¹‰ 2.2.2** (æµ‹é‡åç¼© / Measurement Collapse)
æµ‹é‡æ—¶é‡å­æ€åç¼©åˆ°æŸä¸ªæœ¬å¾æ€ã€‚

**Definition 2.2.2** (Measurement Collapse)
Quantum states collapse to eigenstates upon measurement.

### 2.3 é‡å­çº ç¼  (Quantum Entanglement)

**å®šä¹‰ 2.3.1** (è´å°”æ€ / Bell States)
ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„æœ€å¤§çº ç¼ æ€ã€‚

**Definition 2.3.1** (Bell States)
Maximally entangled states of two quantum bits.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$$
$$|\Phi^-\rangle = \frac{1}{\sqrt{2}}(|00\rangle - |11\rangle)$$
$$|\Psi^+\rangle = \frac{1}{\sqrt{2}}(|01\rangle + |10\rangle)$$
$$|\Psi^-\rangle = \frac{1}{\sqrt{2}}(|01\rangle - |10\rangle)$$

**å®šä¹‰ 2.3.2** (çº ç¼ åº¦é‡ / Entanglement Measure)
å†¯Â·è¯ºä¾æ›¼ç†µæ˜¯çº ç¼ çš„åº¦é‡ã€‚

**Definition 2.3.2** (Entanglement Measure)
Von Neumann entropy is a measure of entanglement.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$S(\rho) = -\text{Tr}(\rho \log \rho)$$

---

## 3. é‡å­é—¨ (Quantum Gates)

### 3.1 å•æ¯”ç‰¹é‡å­é—¨ (Single-Qubit Gates)

**å®šä¹‰ 3.1.1** (Paulié—¨ / Pauli Gates)
$$X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}, \quad Y = \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}, \quad Z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}$$

**Definition 3.1.1** (Pauli Gates)
$$X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}, \quad Y = \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}, \quad Z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}$$

**å®šä¹‰ 3.1.2** (Hadamardé—¨ / Hadamard Gate)
$$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$

**Definition 3.1.2** (Hadamard Gate)
$$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$

**å®šä¹‰ 3.1.3** (ç›¸ä½é—¨ / Phase Gate)
$$S = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}, \quad T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix}$$

**Definition 3.1.3** (Phase Gate)
$$S = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}, \quad T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix}$$

### 3.2 å¤šæ¯”ç‰¹é‡å­é—¨ (Multi-Qubit Gates)

**å®šä¹‰ 3.2.1** (CNOTé—¨ / CNOT Gate)
$$CNOT = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix}$$

**Definition 3.2.1** (CNOT Gate)
$$CNOT = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix}$$

**å®šä¹‰ 3.2.2** (SWAPé—¨ / SWAP Gate)
$$SWAP = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix}$$

**Definition 3.2.2** (SWAP Gate)
$$SWAP = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix}$$

**å®šä¹‰ 3.2.3** (Toffolié—¨ / Toffoli Gate)
ä¸‰æ¯”ç‰¹å—æ§éé—¨ã€‚

**Definition 3.2.3** (Toffoli Gate)
Three-qubit controlled-NOT gate.

### 3.3 é€šç”¨é‡å­é—¨é›† (Universal Quantum Gate Sets)

**å®šä¹‰ 3.3.1** (é€šç”¨é—¨é›† / Universal Gate Set)
ä»»ä½•é‡å­é—¨éƒ½å¯ä»¥ç”¨é€šç”¨é—¨é›†è¿‘ä¼¼åˆ°ä»»æ„ç²¾åº¦ã€‚

**Definition 3.3.1** (Universal Gate Set)
Any quantum gate can be approximated to arbitrary precision using a universal gate set.

**å®šç† 3.3.1** (Solovay-Kitaevå®šç† / Solovay-Kitaev Theorem)
ä»»ä½•å•æ¯”ç‰¹é—¨éƒ½å¯ä»¥ç”¨æœ‰é™é—¨é›†è¿‘ä¼¼åˆ°ç²¾åº¦ $\epsilon$ï¼Œé—¨æ•° $O(\log^c(1/\epsilon))$ã€‚

**Theorem 3.3.1** (Solovay-Kitaev Theorem)
Any single-qubit gate can be approximated to precision $\epsilon$ using a finite gate set with $O(\log^c(1/\epsilon))$ gates.

---

## 4. é‡å­ç®—æ³• (Quantum Algorithms)

### 4.1 é‡å­å‚…é‡Œå¶å˜æ¢ (Quantum Fourier Transform)

**å®šä¹‰ 4.1.1** (é‡å­å‚…é‡Œå¶å˜æ¢ / Quantum Fourier Transform)
$$QFT|j\rangle = \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} e^{2\pi i jk/N}|k\rangle$$

**Definition 4.1.1** (Quantum Fourier Transform)
$$QFT|j\rangle = \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} e^{2\pi i jk/N}|k\rangle$$

**ç®—æ³•å¤æ‚åº¦ (Algorithm Complexity):**

- æ—¶é—´å¤æ‚åº¦: $O(n^2)$
- ç©ºé—´å¤æ‚åº¦: $O(n)$

**Algorithm Complexity:**

- Time complexity: $O(n^2)$
- Space complexity: $O(n)$

### 4.2 Groveræœç´¢ç®—æ³• (Grover's Search Algorithm)

**å®šä¹‰ 4.2.1** (Groverç®—æ³• / Grover's Algorithm)
åœ¨æ— åºæ•°æ®åº“ä¸­æœç´¢çš„é‡å­ç®—æ³•ã€‚

**Definition 4.2.1** (Grover's Algorithm)
Quantum algorithm for searching in an unordered database.

**ç®—æ³•æ­¥éª¤ (Algorithm Steps):**

1. åˆå§‹åŒ–å åŠ æ€ (Initialize superposition state)
2. åº”ç”¨Oracle (Apply Oracle)
3. åº”ç”¨æ‰©æ•£ç®—å­ (Apply diffusion operator)
4. é‡å¤æ­¥éª¤2-3 (Repeat steps 2-3)

**ç®—æ³•å¤æ‚åº¦ (Algorithm Complexity):**

- æ—¶é—´å¤æ‚åº¦: $O(\sqrt{N})$
- ç»å…¸ç®—æ³•: $O(N)$

**Algorithm Complexity:**

- Time complexity: $O(\sqrt{N})$
- Classical algorithm: $O(N)$

### 4.3 Shoråˆ†è§£ç®—æ³• (Shor's Factoring Algorithm)

**å®šä¹‰ 4.3.1** (Shorç®—æ³• / Shor's Algorithm)
ç”¨äºå¤§æ•´æ•°åˆ†è§£çš„é‡å­ç®—æ³•ã€‚

**Definition 4.3.1** (Shor's Algorithm)
Quantum algorithm for factoring large integers.

**ç®—æ³•æ­¥éª¤ (Algorithm Steps):**

1. é€‰æ‹©éšæœºæ•° (Choose random number)
2. è®¡ç®—å‘¨æœŸ (Compute period)
3. ä½¿ç”¨é‡å­å‚…é‡Œå¶å˜æ¢ (Use quantum Fourier transform)
4. ç»å…¸åå¤„ç† (Classical post-processing)

**ç®—æ³•å¤æ‚åº¦ (Algorithm Complexity):**

- æ—¶é—´å¤æ‚åº¦: $O((\log N)^3)$
- ç»å…¸ç®—æ³•: $O(e^{(\log N)^{1/3}(\log\log N)^{2/3}})$

**Algorithm Complexity:**

- Time complexity: $O((\log N)^3)$
- Classical algorithm: $O(e^{(\log N)^{1/3}(\log\log N)^{2/3}})$

---

## 5. é‡å­å¤æ‚åº¦ç†è®º (Quantum Complexity Theory)

### 5.1 BQPç±» (BQP Class)

**å®šä¹‰ 5.1.1** (BQPç±» / BQP Class)
æœ‰ç•Œé”™è¯¯é‡å­å¤šé¡¹å¼æ—¶é—´ç±»ã€‚

**Definition 5.1.1** (BQP Class)
Bounded-error quantum polynomial time class.

**å½¢å¼åŒ–å®šä¹‰ (Formal Definition):**
$$BQP = \{L : \exists \text{ quantum algorithm } A \text{ s.t. } A \text{ decides } L \text{ in polynomial time}\}$$

**å®šä¹‰ 5.1.2** (é‡å­å›¾çµæœº / Quantum Turing Machine)
é‡å­å›¾çµæœºæ˜¯ç»å…¸å›¾çµæœºçš„é‡å­æ¨å¹¿ã€‚

**Definition 5.1.2** (Quantum Turing Machine)
Quantum Turing machine is the quantum generalization of classical Turing machine.

### 5.2 QMAç±» (QMA Class)

**å®šä¹‰ 5.2.1** (QMAç±» / QMA Class)
é‡å­æ¢…æ—-äºšç‘Ÿç±»ã€‚

**Definition 5.2.1** (QMA Class)
Quantum Merlin-Arthur class.

**å½¢å¼åŒ–å®šä¹‰ (Formal Definition):**
$$QMA = \{L : \exists \text{ quantum verifier } V \text{ s.t. } L \text{ is decided by } V\}$$

### 5.3 é‡å­ä¸‹ç•Œ (Quantum Lower Bounds)

**å®šç† 5.3.1** (é‡å­æŸ¥è¯¢ä¸‹ç•Œ / Quantum Query Lower Bounds)
ä½¿ç”¨é‡å­æŸ¥è¯¢æ¨¡å‹å¯ä»¥è¯æ˜æŸäº›é—®é¢˜çš„ä¸‹ç•Œã€‚

**Theorem 5.3.1** (Quantum Query Lower Bounds)
Quantum query model can be used to prove lower bounds for certain problems.

**å®šç† 5.3.2** (é‡å­é€šä¿¡å¤æ‚åº¦ / Quantum Communication Complexity)
é‡å­é€šä¿¡å¯ä»¥é™ä½æŸäº›é—®é¢˜çš„é€šä¿¡å¤æ‚åº¦ã€‚

**Theorem 5.3.2** (Quantum Communication Complexity)
Quantum communication can reduce communication complexity for certain problems.

---

## 6. é‡å­é”™è¯¯çº æ­£ (Quantum Error Correction)

### 6.1 é‡å­é”™è¯¯ç±»å‹ (Types of Quantum Errors)

**å®šä¹‰ 6.1.1** (æ¯”ç‰¹ç¿»è½¬é”™è¯¯ / Bit Flip Error)
$$X|\psi\rangle$$

**Definition 6.1.1** (Bit Flip Error)
$$X|\psi\rangle$$

**å®šä¹‰ 6.1.2** (ç›¸ä½ç¿»è½¬é”™è¯¯ / Phase Flip Error)
$$Z|\psi\rangle$$

**Definition 6.1.2** (Phase Flip Error)
$$Z|\psi\rangle$$

**å®šä¹‰ 6.1.3** (é€€ç›¸å¹² / Decoherence)
é‡å­æ€ä¸ç¯å¢ƒç›¸äº’ä½œç”¨å¯¼è‡´çš„é”™è¯¯ã€‚

**Definition 6.1.3** (Decoherence)
Errors caused by interaction between quantum states and environment.

### 6.2 ç¨³å®šå­ç  (Stabilizer Codes)

**å®šä¹‰ 6.2.1** (ç¨³å®šå­ / Stabilizer)
$$S = \langle g_1, g_2, \ldots, g_k \rangle$$

å…¶ä¸­ $g_i$ æ˜¯æ³¡åˆ©ç®—å­ã€‚

**Definition 6.2.1** (Stabilizer)
$$S = \langle g_1, g_2, \ldots, g_k \rangle$$

where $g_i$ are Pauli operators.

**å®šä¹‰ 6.2.2** (ç¼–ç ç©ºé—´ / Code Space)
$$C = \{|\psi\rangle : g|\psi\rangle = |\psi\rangle \text{ for all } g \in S\}$$

**Definition 6.2.2** (Code Space)
$$C = \{|\psi\rangle : g|\psi\rangle = |\psi\rangle \text{ for all } g \in S\}$$

### 6.3 è¡¨é¢ç  (Surface Codes)

**å®šä¹‰ 6.3.1** (è¡¨é¢ç  / Surface Code)
åŸºäºäºŒç»´æ™¶æ ¼çš„æ‹“æ‰‘é‡å­é”™è¯¯çº æ­£ç ã€‚

**Definition 6.3.1** (Surface Code)
Topological quantum error correction code based on two-dimensional lattice.

**å®šä¹‰ 6.3.2** (é€»è¾‘é‡å­æ¯”ç‰¹ / Logical Qubit)
ç”±å¤šä¸ªç‰©ç†é‡å­æ¯”ç‰¹ç¼–ç çš„é‡å­æ¯”ç‰¹ã€‚

**Definition 6.3.2** (Logical Qubit)
Quantum bit encoded by multiple physical quantum bits.

---

## 7. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 7.1 é‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨ (Quantum Bit Simulator)

```rust
use num_complex::Complex64;
use std::f64::consts::PI;

#[derive(Debug, Clone)]
pub struct QuantumBit {
    alpha: Complex64,
    beta: Complex64,
}

impl QuantumBit {
    pub fn new(alpha: Complex64, beta: Complex64) -> Self {
        let norm = (alpha.norm_sqr() + beta.norm_sqr()).sqrt();
        QuantumBit {
            alpha: alpha / norm,
            beta: beta / norm,
        }
    }

    pub fn zero() -> Self {
        QuantumBit {
            alpha: Complex64::new(1.0, 0.0),
            beta: Complex64::new(0.0, 0.0),
        }
    }

    pub fn one() -> Self {
        QuantumBit {
            alpha: Complex64::new(0.0, 0.0),
            beta: Complex64::new(1.0, 0.0),
        }
    }

    pub fn hadamard() -> Self {
        QuantumBit {
            alpha: Complex64::new(1.0 / 2.0_f64.sqrt(), 0.0),
            beta: Complex64::new(1.0 / 2.0_f64.sqrt(), 0.0),
        }
    }

    pub fn measure(&self) -> bool {
        let prob_one = self.beta.norm_sqr();
        rand::random::<f64>() < prob_one
    }

    pub fn apply_x(&mut self) {
        let temp = self.alpha;
        self.alpha = self.beta.clone();
        self.beta = temp;
    }

    pub fn apply_z(&mut self) {
        self.beta = -self.beta.clone();
    }

    pub fn apply_h(&mut self) {
        let alpha_new = (self.alpha + self.beta.clone()) / 2.0_f64.sqrt();
        let beta_new = (self.alpha - self.beta.clone()) / 2.0_f64.sqrt();
        self.alpha = alpha_new;
        self.beta = beta_new;
    }

    pub fn apply_phase(&mut self, theta: f64) {
        self.beta = self.beta * Complex64::new(theta.cos(), theta.sin());
    }
}

// é‡å­é—¨å®ç°
pub struct QuantumGate;

impl QuantumGate {
    pub fn x(qbit: &mut QuantumBit) {
        qbit.apply_x();
    }

    pub fn z(qbit: &mut QuantumBit) {
        qbit.apply_z();
    }

    pub fn h(qbit: &mut QuantumBit) {
        qbit.apply_h();
    }

    pub fn phase(qbit: &mut QuantumBit, theta: f64) {
        qbit.apply_phase(theta);
    }

    pub fn cnot(control: &mut QuantumBit, target: &mut QuantumBit) {
        if control.measure() {
            target.apply_x();
        }
    }
}
```

### 7.2 é‡å­é—¨å®ç° (Quantum Gate Implementation)

```rust
use nalgebra::{Matrix2, Matrix4, Complex};

pub struct QuantumGateMatrix;

impl QuantumGateMatrix {
    pub fn x() -> Matrix2<Complex<f64>> {
        Matrix2::new(
            Complex::new(0.0, 0.0), Complex::new(1.0, 0.0),
            Complex::new(1.0, 0.0), Complex::new(0.0, 0.0)
        )
    }

    pub fn y() -> Matrix2<Complex<f64>> {
        Matrix2::new(
            Complex::new(0.0, 0.0), Complex::new(0.0, -1.0),
            Complex::new(0.0, 1.0), Complex::new(0.0, 0.0)
        )
    }

    pub fn z() -> Matrix2<Complex<f64>> {
        Matrix2::new(
            Complex::new(1.0, 0.0), Complex::new(0.0, 0.0),
            Complex::new(0.0, 0.0), Complex::new(-1.0, 0.0)
        )
    }

    pub fn h() -> Matrix2<Complex<f64>> {
        let factor = 1.0 / 2.0_f64.sqrt();
        Matrix2::new(
            Complex::new(factor, 0.0), Complex::new(factor, 0.0),
            Complex::new(factor, 0.0), Complex::new(-factor, 0.0)
        )
    }

    pub fn s() -> Matrix2<Complex<f64>> {
        Matrix2::new(
            Complex::new(1.0, 0.0), Complex::new(0.0, 0.0),
            Complex::new(0.0, 0.0), Complex::new(0.0, 1.0)
        )
    }

    pub fn t() -> Matrix2<Complex<f64>> {
        Matrix2::new(
            Complex::new(1.0, 0.0), Complex::new(0.0, 0.0),
            Complex::new(0.0, 0.0), Complex::new(0.0, 1.0)
        )
    }

    pub fn cnot() -> Matrix4<Complex<f64>> {
        Matrix4::new(
            Complex::new(1.0, 0.0), Complex::new(0.0, 0.0), Complex::new(0.0, 0.0), Complex::new(0.0, 0.0),
            Complex::new(0.0, 0.0), Complex::new(1.0, 0.0), Complex::new(0.0, 0.0), Complex::new(0.0, 0.0),
            Complex::new(0.0, 0.0), Complex::new(0.0, 0.0), Complex::new(0.0, 0.0), Complex::new(1.0, 0.0),
            Complex::new(0.0, 0.0), Complex::new(0.0, 0.0), Complex::new(1.0, 0.0), Complex::new(0.0, 0.0)
        )
    }
}

// é‡å­ç”µè·¯å®ç°
pub struct QuantumCircuit {
    gates: Vec<(String, Vec<usize>)>,
    num_qubits: usize,
}

impl QuantumCircuit {
    pub fn new(num_qubits: usize) -> Self {
        QuantumCircuit {
            gates: Vec::new(),
            num_qubits,
        }
    }

    pub fn add_gate(&mut self, gate_name: String, qubits: Vec<usize>) {
        self.gates.push((gate_name, qubits));
    }

    pub fn x(&mut self, qubit: usize) {
        self.add_gate("X".to_string(), vec![qubit]);
    }

    pub fn h(&mut self, qubit: usize) {
        self.add_gate("H".to_string(), vec![qubit]);
    }

    pub fn cnot(&mut self, control: usize, target: usize) {
        self.add_gate("CNOT".to_string(), vec![control, target]);
    }

    pub fn execute(&self, initial_state: Vec<Complex<f64>>) -> Vec<Complex<f64>> {
        let mut state = initial_state;

        for (gate_name, qubits) in &self.gates {
            match gate_name.as_str() {
                "X" => {
                    let qubit = qubits[0];
                    state = self.apply_x_gate(state, qubit);
                }
                "H" => {
                    let qubit = qubits[0];
                    state = self.apply_h_gate(state, qubit);
                }
                "CNOT" => {
                    let control = qubits[0];
                    let target = qubits[1];
                    state = self.apply_cnot_gate(state, control, target);
                }
                _ => {}
            }
        }

        state
    }

    fn apply_x_gate(&self, state: Vec<Complex<f64>>, qubit: usize) -> Vec<Complex<f64>> {
        let mut new_state = state.clone();
        let mask = 1 << qubit;

        for i in 0..state.len() {
            if (i & mask) == 0 {
                let j = i | mask;
                if j < state.len() {
                    new_state[i] = state[j];
                    new_state[j] = state[i];
                }
            }
        }

        new_state
    }

    fn apply_h_gate(&self, state: Vec<Complex<f64>>, qubit: usize) -> Vec<Complex<f64>> {
        let mut new_state = vec![Complex::new(0.0, 0.0); state.len()];
        let mask = 1 << qubit;
        let factor = 1.0 / 2.0_f64.sqrt();

        for i in 0..state.len() {
            let j = i ^ mask;
            if j < state.len() {
                new_state[i] = (state[i] + state[j]) * factor;
                new_state[j] = (state[i] - state[j]) * factor;
            }
        }

        new_state
    }

    fn apply_cnot_gate(&self, state: Vec<Complex<f64>>, control: usize, target: usize) -> Vec<Complex<f64>> {
        let mut new_state = state.clone();
        let control_mask = 1 << control;
        let target_mask = 1 << target;

        for i in 0..state.len() {
            if (i & control_mask) != 0 {
                let j = i ^ target_mask;
                if j < state.len() {
                    new_state[i] = state[j];
                    new_state[j] = state[i];
                }
            }
        }

        new_state
    }
}
```

### 7.3 é‡å­ç®—æ³•å®ç° (Quantum Algorithm Implementation)

```rust
pub struct GroverAlgorithm {
    oracle: Box<dyn Fn(usize) -> bool>,
    num_qubits: usize,
}

impl GroverAlgorithm {
    pub fn new(oracle: Box<dyn Fn(usize) -> bool>, num_qubits: usize) -> Self {
        GroverAlgorithm { oracle, num_qubits }
    }

    pub fn run(&self) -> Option<usize> {
        let n = 1 << self.num_qubits;
        let iterations = ((n as f64).sqrt() * std::f64::consts::PI / 4.0) as usize;

        let mut circuit = QuantumCircuit::new(self.num_qubits);

        // åˆå§‹åŒ–å åŠ æ€
        for i in 0..self.num_qubits {
            circuit.h(i);
        }

        // Groverè¿­ä»£
        for _ in 0..iterations {
            // Oracle
            self.apply_oracle(&mut circuit);

            // æ‰©æ•£ç®—å­
            self.apply_diffusion(&mut circuit);
        }

        // æµ‹é‡
        self.measure(&circuit)
    }

    fn apply_oracle(&self, circuit: &mut QuantumCircuit) {
        // ç®€åŒ–çš„Oracleå®ç°
        for i in 0..self.num_qubits {
            circuit.x(i);
        }
        circuit.cnot(0, 1);
        for i in 0..self.num_qubits {
            circuit.x(i);
        }
    }

    fn apply_diffusion(&self, circuit: &mut QuantumCircuit) {
        for i in 0..self.num_qubits {
            circuit.h(i);
        }

        for i in 0..self.num_qubits {
            circuit.x(i);
        }

        circuit.cnot(0, 1);

        for i in 0..self.num_qubits {
            circuit.x(i);
        }

        for i in 0..self.num_qubits {
            circuit.h(i);
        }
    }

    fn measure(&self, circuit: &QuantumCircuit) -> Option<usize> {
        // ç®€åŒ–çš„æµ‹é‡å®ç°
        Some(0)
    }
}

pub struct ShorAlgorithm {
    n: usize,
}

impl ShorAlgorithm {
    pub fn new(n: usize) -> Self {
        ShorAlgorithm { n }
    }

    pub fn factor(&self) -> Option<(usize, usize)> {
        // ç®€åŒ–çš„Shorç®—æ³•å®ç°
        if self.n % 2 == 0 {
            return Some((2, self.n / 2));
        }

        // éšæœºé€‰æ‹©a
        let a = 2;

        // è®¡ç®—gcd
        let gcd = self.gcd(a, self.n);
        if gcd > 1 {
            return Some((gcd, self.n / gcd));
        }

        // å¯»æ‰¾å‘¨æœŸï¼ˆç®€åŒ–å®ç°ï¼‰
        let period = self.find_period(a);
        if period % 2 == 0 {
            let factor1 = self.mod_pow(a, period / 2, self.n) + 1;
            let factor2 = self.mod_pow(a, period / 2, self.n) - 1;

            let gcd1 = self.gcd(factor1, self.n);
            let gcd2 = self.gcd(factor2, self.n);

            if gcd1 > 1 && gcd1 < self.n {
                return Some((gcd1, self.n / gcd1));
            }
            if gcd2 > 1 && gcd2 < self.n {
                return Some((gcd2, self.n / gcd2));
            }
        }

        None
    }

    fn gcd(&self, mut a: usize, mut b: usize) -> usize {
        while b != 0 {
            let temp = b;
            b = a % b;
            a = temp;
        }
        a
    }

    fn mod_pow(&self, mut base: usize, mut exp: usize, modulus: usize) -> usize {
        let mut result = 1;
        base = base % modulus;

        while exp > 0 {
            if exp % 2 == 1 {
                result = (result * base) % modulus;
            }
            exp = exp >> 1;
            base = (base * base) % modulus;
        }

        result
    }

    fn find_period(&self, a: usize) -> usize {
        // ç®€åŒ–çš„å‘¨æœŸæŸ¥æ‰¾
        let mut x = 1;
        let mut period = 0;

        for i in 1..=self.n {
            x = (x * a) % self.n;
            if x == 1 {
                period = i;
                break;
            }
        }

        period
    }
}
```

### 7.4 é‡å­é”™è¯¯çº æ­£å®ç° (Quantum Error Correction Implementation)

```rust
pub struct QuantumErrorCorrection {
    code_distance: usize,
}

impl QuantumErrorCorrection {
    pub fn new(code_distance: usize) -> Self {
        QuantumErrorCorrection { code_distance }
    }

    pub fn encode_logical_qubit(&self, logical_state: bool) -> Vec<bool> {
        // ç®€åŒ–çš„ç¼–ç å®ç°
        let mut encoded = vec![false; self.code_distance * self.code_distance];

        if logical_state {
            // ç¼–ç |1âŸ©çŠ¶æ€
            for i in 0..self.code_distance {
                encoded[i * self.code_distance] = true;
            }
        }

        encoded
    }

    pub fn decode_logical_qubit(&self, encoded_state: &[bool]) -> Option<bool> {
        // ç®€åŒ–çš„è§£ç å®ç°
        let mut syndrome = Vec::new();

        // è®¡ç®—ç¨³å®šå­æµ‹é‡
        for i in 0..self.code_distance - 1 {
            for j in 0..self.code_distance - 1 {
                let syndrome_bit = self.measure_stabilizer(encoded_state, i, j);
                syndrome.push(syndrome_bit);
            }
        }

        // é”™è¯¯çº æ­£
        let corrected_state = self.correct_errors(encoded_state, &syndrome);

        // è§£ç é€»è¾‘é‡å­æ¯”ç‰¹
        self.decode_from_corrected(&corrected_state)
    }

    fn measure_stabilizer(&self, state: &[bool], i: usize, j: usize) -> bool {
        // ç®€åŒ–çš„ç¨³å®šå­æµ‹é‡
        let index1 = i * self.code_distance + j;
        let index2 = i * self.code_distance + j + 1;
        let index3 = (i + 1) * self.code_distance + j;
        let index4 = (i + 1) * self.code_distance + j + 1;

        if index4 < state.len() {
            state[index1] ^ state[index2] ^ state[index3] ^ state[index4]
        } else {
            false
        }
    }

    fn correct_errors(&self, state: &[bool], syndrome: &[bool]) -> Vec<bool> {
        // ç®€åŒ–çš„é”™è¯¯çº æ­£
        let mut corrected = state.to_vec();

        // åŸºäºsyndromeè¿›è¡Œé”™è¯¯çº æ­£
        for (i, &syndrome_bit) in syndrome.iter().enumerate() {
            if syndrome_bit {
                let error_position = i % (self.code_distance - 1);
                let error_row = i / (self.code_distance - 1);
                let error_index = error_row * self.code_distance + error_position;

                if error_index < corrected.len() {
                    corrected[error_index] = !corrected[error_index];
                }
            }
        }

        corrected
    }

    fn decode_from_corrected(&self, corrected_state: &[bool]) -> Option<bool> {
        // ç®€åŒ–çš„è§£ç 
        let mut logical_value = false;

        // æ£€æŸ¥ç¬¬ä¸€è¡Œçš„å¥‡å¶æ€§
        let mut parity = 0;
        for j in 0..self.code_distance {
            if corrected_state[j] {
                parity += 1;
            }
        }

        logical_value = parity % 2 == 1;
        Some(logical_value)
    }
}

// è¡¨é¢ç å®ç°
pub struct SurfaceCode {
    size: usize,
    data_qubits: Vec<bool>,
    syndrome_qubits: Vec<bool>,
}

impl SurfaceCode {
    pub fn new(size: usize) -> Self {
        let num_data_qubits = size * size;
        let num_syndrome_qubits = (size - 1) * (size - 1);

        SurfaceCode {
            size,
            data_qubits: vec![false; num_data_qubits],
            syndrome_qubits: vec![false; num_syndrome_qubits],
        }
    }

    pub fn encode_logical_x(&mut self) {
        // ç¼–ç Xé€»è¾‘é—¨
        for i in 0..self.size {
            let index = i * self.size;
            if index < self.data_qubits.len() {
                self.data_qubits[index] = true;
            }
        }
    }

    pub fn encode_logical_z(&mut self) {
        // ç¼–ç Zé€»è¾‘é—¨
        for j in 0..self.size {
            if j < self.data_qubits.len() {
                self.data_qubits[j] = true;
            }
        }
    }

    pub fn measure_syndrome(&mut self) -> Vec<bool> {
        let mut syndrome = Vec::new();

        // æµ‹é‡Xå‹ç¨³å®šå­
        for i in 0..self.size - 1 {
            for j in 0..self.size - 1 {
                let syndrome_bit = self.measure_x_stabilizer(i, j);
                syndrome.push(syndrome_bit);
            }
        }

        // æµ‹é‡Zå‹ç¨³å®šå­
        for i in 0..self.size - 1 {
            for j in 0..self.size - 1 {
                let syndrome_bit = self.measure_z_stabilizer(i, j);
                syndrome.push(syndrome_bit);
            }
        }

        syndrome
    }

    fn measure_x_stabilizer(&self, i: usize, j: usize) -> bool {
        // æµ‹é‡Xå‹ç¨³å®šå­
        let mut parity = 0;

        let indices = [
            i * self.size + j,
            i * self.size + j + 1,
            (i + 1) * self.size + j,
            (i + 1) * self.size + j + 1,
        ];

        for &index in &indices {
            if index < self.data_qubits.len() && self.data_qubits[index] {
                parity += 1;
            }
        }

        parity % 2 == 1
    }

    fn measure_z_stabilizer(&self, i: usize, j: usize) -> bool {
        // æµ‹é‡Zå‹ç¨³å®šå­
        let mut parity = 0;

        let indices = [
            i * self.size + j,
            i * self.size + j + 1,
            (i + 1) * self.size + j,
            (i + 1) * self.size + j + 1,
        ];

        for &index in &indices {
            if index < self.data_qubits.len() && self.data_qubits[index] {
                parity += 1;
            }
        }

        parity % 2 == 1
    }
}
```

---

## 8. å‚è€ƒæ–‡çŒ® / References

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**: æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ [CITATION_STANDARD.md](../CITATION_STANDARD.md)ã€[å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md](../å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)ï¼‰ã€‚æ–‡å†…é‡‡ç”¨ [Key] æ ¼å¼å¼•ç”¨ï¼Œä¸å‚è€ƒæ–‡çŒ®åˆ—è¡¨å¯¹åº”ã€‚

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Shor1994] Shor, P. W. (1994). "Algorithms for Quantum Computation: Discrete Logarithms and Factoring". In *35th Annual Symposium on Foundations of Computer Science (FOCS)*, pp. 124-134. IEEE. DOI: 10.1109/SFCS.1994.365700
   - **Shorå› å­åˆ†è§£ç®—æ³•çš„å¼€åˆ›æ€§è®ºæ–‡**ï¼Œé‡å­è®¡ç®—é‡Œç¨‹ç¢‘ã€‚æœ¬æ–‡æ¡£çš„Shorç®—æ³•éƒ¨åˆ†å‚è€ƒæ­¤è®ºæ–‡ã€‚

2. [Grover1996] Grover, L. K. (1996). "A Fast Quantum Mechanical Algorithm for Database Search". In *28th Annual ACM Symposium on Theory of Computing (STOC)*, pp. 212-219. ACM. DOI: 10.1145/237814.237866
   - **Groveræœç´¢ç®—æ³•çš„å¼€åˆ›æ€§è®ºæ–‡**ã€‚æœ¬æ–‡æ¡£çš„Groverç®—æ³•éƒ¨åˆ†å‚è€ƒæ­¤è®ºæ–‡ã€‚

3. [Arute2019] Arute, F., et al. (2019). "Quantum Supremacy Using a Programmable Superconducting Processor". *Nature*, 574(7779), 505-510. DOI: 10.1038/s41586-019-1666-5
   - Googleé‡å­éœ¸æƒçš„é‡Œç¨‹ç¢‘è®ºæ–‡ï¼Œæœ¬æ–‡æ¡£çš„é‡å­è®¡ç®—å‰æ²¿éƒ¨åˆ†å‚è€ƒæ­¤è®ºæ–‡ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. [NielsenChuang2010] Nielsen, M. A., & Chuang, I. L. (2010). *Quantum Computation and Quantum Information* (10th Anniversary ed.). Cambridge University Press. ISBN: 978-1107002173
   - **Nielsen-Chuangé‡å­è®¡ç®—çš„æƒå¨æ•™æ**ï¼Œè¢«èª‰ä¸º"é‡å­è®¡ç®—åœ£ç»"ã€‚æœ¬æ–‡æ¡£çš„åŸºç¡€æ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

2. Kitaev, A. Y., Shen, A., & Vyalyi, M. N. (2002). *Classical and Quantum Computation*. American Mathematical Society.
   - é‡å­è®¡ç®—çš„ç»å…¸æ•™æã€‚

3. Preskill, J. (1998). "Reliable Quantum Computers". *Proceedings of the Royal Society of London. Series A*, 454(1969), 385-410.
   - Preskillé‡å­é”™è¯¯çº æ­£çš„é‡è¦ç»¼è¿°ã€‚

4. Aharonov, D., & Ben-Or, M. (1997). "Fault-tolerant quantum computation with constant error". *Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing*, 176-188.

5. Knill, E., Laflamme, R., & Zurek, W. H. (1998). "Resilient quantum computation". *Science*, 279(5349), 342-345.

6. Calderbank, A. R., & Shor, P. W. (1996). "Good quantum error-correcting codes exist". *Physical Review A*, 54(2), 1098.

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Quantum Computing**: <https://en.wikipedia.org/wiki/Quantum_computing>
   - é‡å­è®¡ç®—çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«é‡å­æ¯”ç‰¹ã€é‡å­é—¨å’Œé‡å­ç®—æ³•ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Quantum Circuit**: <https://en.wikipedia.org/wiki/Quantum_circuit>
   - é‡å­ç”µè·¯çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»é‡å­é—¨å’Œé‡å­ç”µè·¯ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Shor's Algorithm**: <https://en.wikipedia.org/wiki/Shor%27s_algorithm>
   - Shorç®—æ³•çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«å› å­åˆ†è§£çš„é‡å­ç®—æ³•ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

4. **Wikipedia - Grover's Algorithm**: <https://en.wikipedia.org/wiki/Grover%27s_algorithm>
   - Groverç®—æ³•çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»é‡å­æœç´¢ç®—æ³•ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£æä¾›äº†é‡å­è®¡ç®—æ¨¡å‹çš„å®Œæ•´å½¢å¼åŒ–æ¡†æ¶ï¼ŒåŒ…æ‹¬é‡å­æ¯”ç‰¹ã€é‡å­é—¨ã€é‡å­ç®—æ³•ã€é‡å­å¤æ‚åº¦ç†è®ºå’Œé‡å­é”™è¯¯çº æ­£çš„ç†è®ºåŸºç¡€ã€å½¢å¼åŒ–å®šä¹‰å’Œå®ç°ç¤ºä¾‹ã€‚*
