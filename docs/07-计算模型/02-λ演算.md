---
title: 7.2 Î»æ¼”ç®— / Lambda Calculus
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: è®¡ç®—æ¨¡å‹å·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 7.2 Î»æ¼”ç®— / Lambda Calculus

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€Î»æ¼”ç®—çš„å½¢å¼åŒ–å®šä¹‰ã€è¯­æ³•ã€å½’çº¦ä¸ç±»å‹ç³»ç»Ÿã€‚
- å»ºç«‹Î»æ¼”ç®—åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸è®¡ç®—ç†è®ºä¸­çš„åŸºç¡€åœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- Î»æ¼”ç®—ã€Î»é¡¹ã€Î²å½’çº¦ã€Î±ç­‰ä»·ã€æ­£è§„å½¢å¼ã€ç±»å‹Î»æ¼”ç®—ã€Curry-Howardå¯¹åº”ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- Î»æ¼”ç®—ï¼ˆLambda Calculusï¼‰ï¼šç ”ç©¶å‡½æ•°å®šä¹‰ã€åº”ç”¨å’Œé€’å½’çš„å½¢å¼ç³»ç»Ÿã€‚
- Î»é¡¹ï¼ˆLambda Termsï¼‰ï¼šÎ»æ¼”ç®—çš„è¯­æ³•å¯¹è±¡ã€‚
- Î²å½’çº¦ï¼ˆBeta Reductionï¼‰ï¼šå‡½æ•°åº”ç”¨çš„å½’çº¦è§„åˆ™ã€‚
- è®°å·çº¦å®šï¼š`Î»` è¡¨ç¤ºæŠ½è±¡ï¼Œ`â†’` è¡¨ç¤ºå‡½æ•°ç±»å‹ï¼Œ`âŠ¢` è¡¨ç¤ºç±»å‹æ¨å¯¼ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- å›¾çµæœºï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/01-å›¾çµæœº.md`ã€‚
- ç±»å‹ç†è®ºï¼šå‚è§ `05-ç±»å‹ç†è®º/` ç›¸å…³æ–‡æ¡£ã€‚
- å‡½æ•°å¼ç¼–ç¨‹ï¼šå‚è§ `08-å®ç°ç¤ºä¾‹/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- è¯­æ³•
- å½’çº¦
- ç±»å‹ç³»ç»Ÿ
- è¯­ä¹‰

## ç›®å½• (Table of Contents)

- [7.2 Î»æ¼”ç®— / Lambda Calculus](#72-Î»æ¼”ç®—--lambda-calculus)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.1 Î»æ¼”ç®—å®šä¹‰ (Definition of Lambda Calculus)](#11-Î»æ¼”ç®—å®šä¹‰-definition-of-lambda-calculus)
  - [1.2 Î»æ¼”ç®—çš„å†å² (History of Lambda Calculus)](#12-Î»æ¼”ç®—çš„å†å²-history-of-lambda-calculus)
  - [1.3 Î»æ¼”ç®—çš„åº”ç”¨ (Applications of Lambda Calculus)](#13-Î»æ¼”ç®—çš„åº”ç”¨-applications-of-lambda-calculus)
- [2. è¯­æ³• (Syntax)](#2-è¯­æ³•-syntax)
  - [2.1 Î»é¡¹çš„å®šä¹‰ (Definition of Lambda Terms)](#21-Î»é¡¹çš„å®šä¹‰-definition-of-lambda-terms)
  - [2.2 è¯­æ³•çº¦å®š (Syntactic Conventions)](#22-è¯­æ³•çº¦å®š-syntactic-conventions)
  - [2.3 Î±ç­‰ä»· (Alpha Equivalence)](#23-Î±ç­‰ä»·-alpha-equivalence)
- [3. å½’çº¦ (Reduction)](#3-å½’çº¦-reduction)
  - [3.1 Î²å½’çº¦ (Beta Reduction)](#31-Î²å½’çº¦-beta-reduction)
  - [3.2 Î·å½’çº¦ (Eta Reduction)](#32-Î·å½’çº¦-eta-reduction)
  - [3.3 å½’çº¦ç­–ç•¥ (Reduction Strategies)](#33-å½’çº¦ç­–ç•¥-reduction-strategies)
  - [3.4 æ­£è§„å½¢å¼ (Normal Form)](#34-æ­£è§„å½¢å¼-normal-form)
- [4. ç±»å‹ç³»ç»Ÿ (Type System)](#4-ç±»å‹ç³»ç»Ÿ-type-system)
  - [4.1 ç®€å•ç±»å‹Î»æ¼”ç®— (Simply Typed Lambda Calculus)](#41-ç®€å•ç±»å‹Î»æ¼”ç®—-simply-typed-lambda-calculus)
  - [4.2 å¤šæ€Î»æ¼”ç®— (Polymorphic Lambda Calculus)](#42-å¤šæ€Î»æ¼”ç®—-polymorphic-lambda-calculus)
  - [4.3 ä¾èµ–ç±»å‹Î»æ¼”ç®— (Dependent Lambda Calculus)](#43-ä¾èµ–ç±»å‹Î»æ¼”ç®—-dependent-lambda-calculus)
- [5. è¯­ä¹‰ (Semantics)](#5-è¯­ä¹‰-semantics)
  - [5.1 æ“ä½œè¯­ä¹‰ (Operational Semantics)](#51-æ“ä½œè¯­ä¹‰-operational-semantics)
  - [5.2 æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)](#52-æŒ‡ç§°è¯­ä¹‰-denotational-semantics)
  - [5.3 å…¬ç†è¯­ä¹‰ (Axiomatic Semantics)](#53-å…¬ç†è¯­ä¹‰-axiomatic-semantics)
- [6. å®ç°ç¤ºä¾‹ (Implementation Examples)](#6-å®ç°ç¤ºä¾‹-implementation-examples)
  - [6.1 Î»æ¼”ç®—è§£é‡Šå™¨ (Lambda Calculus Interpreter)](#61-Î»æ¼”ç®—è§£é‡Šå™¨-lambda-calculus-interpreter)
  - [6.2 ç±»å‹Î»æ¼”ç®—å®ç° (Typed Lambda Calculus Implementation)](#62-ç±»å‹Î»æ¼”ç®—å®ç°-typed-lambda-calculus-implementation)
  - [6.3 Î»æ¼”ç®—æµ‹è¯• (Lambda Calculus Testing)](#63-Î»æ¼”ç®—æµ‹è¯•-lambda-calculus-testing)
- [7. å‚è€ƒæ–‡çŒ® / References](#7-å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)
- [ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
  - [ç›¸å…³æ–‡æ¡£ / Related Documents](#ç›¸å…³æ–‡æ¡£--related-documents)
  - [çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
  - [VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.1 Î»æ¼”ç®—å®šä¹‰ (Definition of Lambda Calculus)

**Î»æ¼”ç®—å®šä¹‰ / Definition of Lambda Calculus:**

Î»æ¼”ç®—æ˜¯ä¸€ç§å½¢å¼ç³»ç»Ÿï¼Œç”¨äºç ”ç©¶å‡½æ•°å®šä¹‰ã€å‡½æ•°åº”ç”¨å’Œé€’å½’ã€‚å®ƒæ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„ç†è®ºåŸºç¡€ï¼Œä¹Ÿæ˜¯è®¡ç®—ç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µä¹‹ä¸€ã€‚

Lambda calculus is a formal system for studying function definition, function application, and recursion. It is the theoretical foundation of functional programming and one of the core concepts in computability theory.

**Î»æ¼”ç®—çš„ç‰¹ç‚¹ / Characteristics of Lambda Calculus:**

1. **å‡½æ•°å¼ (Functional) / Functional:**
   - åŸºäºå‡½æ•°çš„æ¦‚å¿µ / Based on the concept of functions
   - æ”¯æŒé«˜é˜¶å‡½æ•° / Supports higher-order functions

2. **ç®€æ´æ€§ (Simplicity) / Simplicity:**
   - åªæœ‰ä¸‰ä¸ªåŸºæœ¬æ„é€  / Only three basic constructs
   - è¯­æ³•æå…¶ç®€æ´ / Extremely simple syntax

3. **å›¾çµå®Œå¤‡æ€§ (Turing Completeness) / Turing Completeness:**
   - å¯ä»¥è¡¨è¾¾æ‰€æœ‰å¯è®¡ç®—å‡½æ•° / Can express all computable functions
   - ä¸å›¾çµæœºç­‰ä»· / Equivalent to Turing machines

### 1.2 Î»æ¼”ç®—çš„å†å² (History of Lambda Calculus)

**åˆ›å§‹äºº / Founder:**

é˜¿éš†ä½Â·ä¸˜å¥‡ (Alonzo Church) åœ¨1930å¹´ä»£å‘æ˜äº†Î»æ¼”ç®—ï¼Œä½œä¸ºæ•°å­¦é€»è¾‘çš„å½¢å¼åŒ–ç³»ç»Ÿã€‚

Alonzo Church invented lambda calculus in the 1930s as a formal system for mathematical logic.

**å‘å±•å†ç¨‹ / Development History:**

1. **1930å¹´ä»£**: ä¸˜å¥‡å‘æ˜Î»æ¼”ç®— / Church invents lambda calculus
2. **1936å¹´**: ä¸˜å¥‡-å›¾çµè®ºé¢˜æå‡º / Church-Turing thesis proposed
3. **1950å¹´ä»£**: å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€å‘å±• / Development of functional programming languages
4. **1960å¹´ä»£**: ç±»å‹Î»æ¼”ç®—å‘å±• / Development of typed lambda calculus
5. **ç°ä»£**: åœ¨è®¡ç®—æœºç§‘å­¦ä¸­å¹¿æ³›åº”ç”¨ / Widespread application in computer science

### 1.3 Î»æ¼”ç®—çš„åº”ç”¨ (Applications of Lambda Calculus)

**ç†è®ºåº”ç”¨ / Theoretical Applications:**

1. **è®¡ç®—ç†è®º / Computability Theory:**
   - å¯è®¡ç®—æ€§ç ”ç©¶ / Study of computability
   - å¤æ‚åº¦åˆ†æ / Complexity analysis

2. **ç±»å‹ç†è®º / Type Theory:**
   - ç±»å‹ç³»ç»Ÿè®¾è®¡ / Type system design
   - ç¨‹åºéªŒè¯ / Program verification

**å®è·µåº”ç”¨ / Practical Applications:**

1. **å‡½æ•°å¼ç¼–ç¨‹ / Functional Programming:**
   - Haskell, ML, Lispç­‰è¯­è¨€ / Languages like Haskell, ML, Lisp
   - å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼ / Functional programming paradigm

2. **ç¨‹åºè¯­è¨€ç†è®º / Programming Language Theory:**
   - è¯­è¨€è®¾è®¡ / Language design
   - è¯­ä¹‰ç ”ç©¶ / Semantic research

---

## 2. è¯­æ³• (Syntax)

### 2.1 Î»é¡¹çš„å®šä¹‰ (Definition of Lambda Terms)

**Î»é¡¹å®šä¹‰ / Definition of Lambda Terms:**

Î»é¡¹æ˜¯Î»æ¼”ç®—çš„åŸºæœ¬è¯­æ³•å•ä½ï¼Œé€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

Lambda terms are the basic syntactic units of lambda calculus, recursively defined as follows:

1. **å˜é‡ (Variables) / Variables:**
   - å¦‚æœ $x$ æ˜¯å˜é‡ï¼Œåˆ™ $x$ æ˜¯Î»é¡¹
   - If $x$ is a variable, then $x$ is a lambda term

2. **æŠ½è±¡ (Abstraction) / Abstraction:**
   - å¦‚æœ $x$ æ˜¯å˜é‡ï¼Œ$M$ æ˜¯Î»é¡¹ï¼Œåˆ™ $\lambda x.M$ æ˜¯Î»é¡¹
   - If $x$ is a variable and $M$ is a lambda term, then $\lambda x.M$ is a lambda term

3. **åº”ç”¨ (Application) / Application:**
   - å¦‚æœ $M$ å’Œ $N$ æ˜¯Î»é¡¹ï¼Œåˆ™ $(M N)$ æ˜¯Î»é¡¹
   - If $M$ and $N$ are lambda terms, then $(M N)$ is a lambda term

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$\text{Lambda Terms} ::= x \mid \lambda x.M \mid (M N)$$

å…¶ä¸­ $x$ æ˜¯å˜é‡ï¼Œ$M$ å’Œ $N$ æ˜¯Î»é¡¹ã€‚

where $x$ is a variable, and $M$ and $N$ are lambda terms.

### 2.2 è¯­æ³•çº¦å®š (Syntactic Conventions)

**æ‹¬å·çº¦å®š / Parentheses Convention:**

1. **åº”ç”¨ç»“åˆæ€§ / Application Associativity:**
   - $(M N P)$ è¡¨ç¤º $((M N) P)$
   - $(M N P)$ means $((M N) P)$

2. **æŠ½è±¡ç»“åˆæ€§ / Abstraction Associativity:**
   - $\lambda x y z.M$ è¡¨ç¤º $\lambda x.(\lambda y.(\lambda z.M))$
   - $\lambda x y z.M$ means $\lambda x.(\lambda y.(\lambda z.M))$

3. **ä¼˜å…ˆçº§ / Precedence:**
   - æŠ½è±¡æ¯”åº”ç”¨ä¼˜å…ˆçº§é«˜ / Abstraction has higher precedence than application
   - $\lambda x.M N$ è¡¨ç¤º $\lambda x.(M N)$
   - $\lambda x.M N$ means $\lambda x.(M N)$

**å˜é‡çº¦å®š / Variable Convention:**

1. **è‡ªç”±å˜é‡ (Free Variables) / Free Variables:**
   - $FV(x) = \{x\}$
   - $FV(\lambda x.M) = FV(M) \setminus \{x\}$
   - $FV(M N) = FV(M) \cup FV(N)$

2. **çº¦æŸå˜é‡ (Bound Variables) / Bound Variables:**
   - åœ¨æŠ½è±¡ $\lambda x.M$ ä¸­ï¼Œ$x$ æ˜¯çº¦æŸå˜é‡
   - In abstraction $\lambda x.M$, $x$ is a bound variable

### 2.3 Î±ç­‰ä»· (Alpha Equivalence)

**Î±ç­‰ä»·å®šä¹‰ / Definition of Alpha Equivalence:**

ä¸¤ä¸ªÎ»é¡¹æ˜¯Î±ç­‰ä»·çš„ï¼Œå¦‚æœå®ƒä»¬å¯ä»¥é€šè¿‡é‡å‘½åçº¦æŸå˜é‡ç›¸äº’è½¬æ¢ã€‚

Two lambda terms are alpha equivalent if they can be converted to each other by renaming bound variables.

**Î±è½¬æ¢è§„åˆ™ / Alpha Conversion Rules:**

1. **é‡å‘½åçº¦æŸå˜é‡ / Renaming Bound Variables:**
   - $\lambda x.M \equiv_\alpha \lambda y.M[y/x]$ (å¦‚æœ $y$ ä¸åœ¨ $M$ ä¸­è‡ªç”±å‡ºç°)
   - $\lambda x.M \equiv_\alpha \lambda y.M[y/x]$ (if $y$ does not occur freely in $M$)

2. **é€’å½’å®šä¹‰ / Recursive Definition:**
   - $x \equiv_\alpha x$
   - $M \equiv_\alpha N \Rightarrow \lambda x.M \equiv_\alpha \lambda x.N$
   - $M_1 \equiv_\alpha N_1 \land M_2 \equiv_\alpha N_2 \Rightarrow (M_1 M_2) \equiv_\alpha (N_1 N_2)$

---

## 3. å½’çº¦ (Reduction)

### 3.1 Î²å½’çº¦ (Beta Reduction)

**Î²å½’çº¦å®šä¹‰ / Definition of Beta Reduction:**

Î²å½’çº¦æ˜¯Î»æ¼”ç®—çš„æ ¸å¿ƒå½’çº¦è§„åˆ™ï¼Œè¡¨ç¤ºå‡½æ•°åº”ç”¨ã€‚

Beta reduction is the core reduction rule of lambda calculus, representing function application.

**Î²å½’çº¦è§„åˆ™ / Beta Reduction Rule:**

$$(\lambda x.M) N \rightarrow_\beta M[N/x]$$

å…¶ä¸­ $M[N/x]$ è¡¨ç¤ºå°† $M$ ä¸­æ‰€æœ‰è‡ªç”±å‡ºç°çš„ $x$ æ›¿æ¢ä¸º $N$ã€‚

where $M[N/x]$ means replacing all free occurrences of $x$ in $M$ with $N$.

**æ›¿æ¢å®šä¹‰ / Substitution Definition:**

1. **å˜é‡æ›¿æ¢ / Variable Substitution:**
   - $x[N/x] = N$
   - $y[N/x] = y$ (å¦‚æœ $y \neq x$)

2. **æŠ½è±¡æ›¿æ¢ / Abstraction Substitution:**
   - $[\lambda y.M](N/x) = \lambda y.M[N/x]$ (å¦‚æœ $y \neq x$ ä¸” $y \notin FV(N)$)
   - $[\lambda x.M](N/x) = \lambda x.M$

3. **åº”ç”¨æ›¿æ¢ / Application Substitution:**
   - $[M_1 M_2](N/x) = (M_1[N/x])(M_2[N/x])$

### 3.2 Î·å½’çº¦ (Eta Reduction)

**Î·å½’çº¦å®šä¹‰ / Definition of Eta Reduction:**

Î·å½’çº¦è¡¨ç¤ºå‡½æ•°çš„å¤–å»¶æ€§ï¼Œå³ä¸¤ä¸ªå‡½æ•°å¦‚æœå¯¹æ‰€æœ‰è¾“å…¥éƒ½äº§ç”Ÿç›¸åŒè¾“å‡ºï¼Œåˆ™å®ƒä»¬ç›¸ç­‰ã€‚

Eta reduction represents function extensionality, meaning that two functions are equal if they produce the same output for all inputs.

**Î·å½’çº¦è§„åˆ™ / Eta Reduction Rule:**

$$\lambda x.(M x) \rightarrow_\eta M$$ (å¦‚æœ $x \notin FV(M)$)

### 3.3 å½’çº¦ç­–ç•¥ (Reduction Strategies)

**å½’çº¦ç­–ç•¥å®šä¹‰ / Definition of Reduction Strategies:**

å½’çº¦ç­–ç•¥å†³å®šäº†åœ¨å¤šä¸ªå¯èƒ½çš„å½’çº¦ä¸­é€‰æ‹©å“ªä¸€ä¸ªã€‚

Reduction strategies determine which reduction to choose when multiple reductions are possible.

**å¸¸è§å½’çº¦ç­–ç•¥ / Common Reduction Strategies:**

1. **æœ€å·¦æœ€å¤–å½’çº¦ (Leftmost Outermost) / Leftmost Outermost:**
   - æ€»æ˜¯å½’çº¦æœ€å·¦è¾¹çš„å¯å½’çº¦é¡¹ / Always reduce the leftmost reducible term

2. **æœ€å·¦æœ€å†…å½’çº¦ (Leftmost Innermost) / Leftmost Innermost:**
   - æ€»æ˜¯å½’çº¦æœ€å†…å±‚çš„å¯å½’çº¦é¡¹ / Always reduce the innermost reducible term

3. **æ­£è§„åºå½’çº¦ (Normal Order) / Normal Order:**
   - ä¼˜å…ˆå½’çº¦æœ€å¤–å±‚çš„å¯å½’çº¦é¡¹ / Prefer to reduce outermost reducible terms

### 3.4 æ­£è§„å½¢å¼ (Normal Form)

**æ­£è§„å½¢å¼å®šä¹‰ / Definition of Normal Form:**

Î»é¡¹ $M$ æ˜¯æ­£è§„å½¢å¼ï¼Œå¦‚æœæ²¡æœ‰Î²å½’çº¦å¯ä»¥ä» $M$ å¯¼å‡ºã€‚

A lambda term $M$ is in normal form if no beta reduction can be derived from $M$.

**æ­£è§„åŒ–å®šç† (Normalization Theorem) / Normalization Theorem:**

å¦‚æœÎ»é¡¹æœ‰æ­£è§„å½¢å¼ï¼Œåˆ™æœ€å·¦æœ€å¤–å½’çº¦ç­–ç•¥ä¼šæ‰¾åˆ°å®ƒã€‚

If a lambda term has a normal form, then the leftmost outermost reduction strategy will find it.

**å®šç† 2.3.1** (ä¸˜å¥‡-ç½—ç‘Ÿå®šç†) å¦‚æœÎ»é¡¹ $M$ å’Œ $N$ éƒ½æ˜¯æ­£è§„å½¢å¼ï¼Œä¸” $M =_\beta N$ï¼Œåˆ™ $M$ å’Œ $N$ æ˜¯Î±ç­‰ä»·çš„ã€‚

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡ç»“æ„å½’çº³æ¥è¯æ˜è¿™ä¸ªå®šç†ã€‚

**åŸºç¡€æƒ…å†µï¼š** å¦‚æœ $M$ å’Œ $N$ éƒ½æ˜¯å˜é‡ï¼Œåˆ™ $M =_\beta N$ æ„å‘³ç€ $M = N$ï¼Œå› æ­¤å®ƒä»¬æ˜¯Î±ç­‰ä»·çš„ã€‚

**å½’çº³æ­¥éª¤ï¼š**

**æƒ…å†µ1ï¼š** å‡è®¾ $M = \lambda x.M_1$ å’Œ $N = \lambda y.N_1$ éƒ½æ˜¯æŠ½è±¡ã€‚
å¦‚æœ $M =_\beta N$ï¼Œåˆ™å¯¹äºæ‰€æœ‰é¡¹ $P$ï¼Œ$M P =_\beta N P$ã€‚
è¿™æ„å‘³ç€ $M_1[P/x] =_\beta N_1[P/y]$ã€‚
é€šè¿‡å½’çº³å‡è®¾ï¼Œ$M_1$ å’Œ $N_1$ æ˜¯Î±ç­‰ä»·çš„ã€‚
å› æ­¤ï¼Œ$M$ å’Œ $N$ æ˜¯Î±ç­‰ä»·çš„ã€‚

**æƒ…å†µ2ï¼š** å‡è®¾ $M = M_1 M_2$ å’Œ $N = N_1 N_2$ éƒ½æ˜¯åº”ç”¨ã€‚
å¦‚æœ $M =_\beta N$ï¼Œåˆ™ $M_1 =_\beta N_1$ ä¸” $M_2 =_\beta N_2$ã€‚
é€šè¿‡å½’çº³å‡è®¾ï¼Œ$M_1$ å’Œ $N_1$ æ˜¯Î±ç­‰ä»·çš„ï¼Œ$M_2$ å’Œ $N_2$ æ˜¯Î±ç­‰ä»·çš„ã€‚
å› æ­¤ï¼Œ$M$ å’Œ $N$ æ˜¯Î±ç­‰ä»·çš„ã€‚

å› æ­¤ï¼Œä¸˜å¥‡-ç½—ç‘Ÿå®šç†æˆç«‹ã€‚$\square$

**å®šç† 2.3.2** (å½’çº¦çš„åˆæµæ€§) Î²å½’çº¦æ˜¯åˆæµçš„ï¼Œå³å¦‚æœ $M \rightarrow_\beta^* N_1$ ä¸” $M \rightarrow_\beta^* N_2$ï¼Œåˆ™å­˜åœ¨é¡¹ $P$ ä½¿å¾— $N_1 \rightarrow_\beta^* P$ ä¸” $N_2 \rightarrow_\beta^* P$ã€‚

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡å½’çº¦çš„å±€éƒ¨åˆæµæ€§æ¥è¯æ˜å…¨å±€åˆæµæ€§ã€‚

**æ­¥éª¤1ï¼š** è¯æ˜å±€éƒ¨åˆæµæ€§
å¦‚æœ $M \rightarrow_\beta N_1$ ä¸” $M \rightarrow_\beta N_2$ï¼Œåˆ™å­˜åœ¨é¡¹ $P$ ä½¿å¾— $N_1 \rightarrow_\beta^* P$ ä¸” $N_2 \rightarrow_\beta^* P$ã€‚

**æƒ…å†µ1ï¼š** å¦‚æœä¸¤ä¸ªå½’çº¦ä¸é‡å ï¼Œåˆ™å¯ä»¥ç›´æ¥åº”ç”¨ä¸¤ä¸ªå½’çº¦ã€‚
**æƒ…å†µ2ï¼š** å¦‚æœä¸¤ä¸ªå½’çº¦é‡å ï¼Œåˆ™å¯ä»¥é€šè¿‡Î²å½’çº¦çš„ä»£æ•°æ€§è´¨æ¥è¯æ˜åˆæµæ€§ã€‚

**æ­¥éª¤2ï¼š** é€šè¿‡å±€éƒ¨åˆæµæ€§å’Œå½’çº¦çš„æœ‰é™æ€§ï¼Œå¯ä»¥è¯æ˜å…¨å±€åˆæµæ€§ã€‚

å› æ­¤ï¼ŒÎ²å½’çº¦æ˜¯åˆæµçš„ã€‚$\square$

---

## 4. ç±»å‹ç³»ç»Ÿ (Type System)

### 4.1 ç®€å•ç±»å‹Î»æ¼”ç®— (Simply Typed Lambda Calculus)

**ç±»å‹å®šä¹‰ / Type Definition:**

ç®€å•ç±»å‹Î»æ¼”ç®—çš„ç±»å‹é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

Types in simply typed lambda calculus are recursively defined as follows:

1. **åŸºæœ¬ç±»å‹ (Base Types) / Base Types:**
   - å¦‚ $bool$, $int$, $nat$ ç­‰ / Such as $bool$, $int$, $nat$, etc.

2. **å‡½æ•°ç±»å‹ (Function Types) / Function Types:**
   - å¦‚æœ $\sigma$ å’Œ $\tau$ æ˜¯ç±»å‹ï¼Œåˆ™ $\sigma \rightarrow \tau$ æ˜¯ç±»å‹
   - If $\sigma$ and $\tau$ are types, then $\sigma \rightarrow \tau$ is a type

**ç±»å‹è§„åˆ™ / Type Rules:**

1. **å˜é‡è§„åˆ™ (Variable Rule) / Variable Rule:**
   - $\frac{x : \sigma \in \Gamma}{\Gamma \vdash x : \sigma}$

2. **æŠ½è±¡è§„åˆ™ (Abstraction Rule) / Abstraction Rule:**
   - $\frac{\Gamma, x : \sigma \vdash M : \tau}{\Gamma \vdash \lambda x.M : \sigma \rightarrow \tau}$

3. **åº”ç”¨è§„åˆ™ (Application Rule) / Application Rule:**
   - $\frac{\Gamma \vdash M : \sigma \rightarrow \tau \quad \Gamma \vdash N : \sigma}{\Gamma \vdash (M N) : \tau}$

**å®šç† 2.4.1** (ç±»å‹ä¿æŒæ€§) å¦‚æœ $\Gamma \vdash M : \sigma$ ä¸” $M \rightarrow_\beta N$ï¼Œåˆ™ $\Gamma \vdash N : \sigma$ã€‚

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡å¯¹å½’çº¦æ­¥éª¤çš„å½’çº³æ¥è¯æ˜ç±»å‹ä¿æŒæ€§ã€‚

**åŸºç¡€æƒ…å†µï¼š** å¯¹äºÎ²å½’çº¦ $(\lambda x.M) N \rightarrow_\beta M[N/x]$ï¼š

å‡è®¾ $\Gamma \vdash (\lambda x.M) N : \tau$ï¼Œåˆ™ï¼š

- $\Gamma \vdash \lambda x.M : \sigma \rightarrow \tau$
- $\Gamma \vdash N : \sigma$

æ ¹æ®æŠ½è±¡è§„åˆ™ï¼Œ$\Gamma, x : \sigma \vdash M : \tau$ã€‚

æ ¹æ®æ›¿æ¢å¼•ç†ï¼Œ$\Gamma \vdash M[N/x] : \tau$ã€‚

å› æ­¤ï¼Œç±»å‹åœ¨Î²å½’çº¦ä¸‹ä¿æŒã€‚$\square$

**å®šç† 2.4.2** (ç±»å‹æ¨å¯¼çš„å”¯ä¸€æ€§) å¦‚æœ $\Gamma \vdash M : \sigma$ ä¸” $\Gamma \vdash M : \tau$ï¼Œåˆ™ $\sigma = \tau$ã€‚

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡å¯¹Î»é¡¹ç»“æ„çš„å½’çº³æ¥è¯æ˜ç±»å‹æ¨å¯¼çš„å”¯ä¸€æ€§ã€‚

**åŸºç¡€æƒ…å†µï¼š** å¯¹äºå˜é‡ $x$ï¼Œå¦‚æœ $\Gamma \vdash x : \sigma$ ä¸” $\Gamma \vdash x : \tau$ï¼Œåˆ™æ ¹æ®å˜é‡è§„åˆ™ï¼Œ$x : \sigma \in \Gamma$ ä¸” $x : \tau \in \Gamma$ã€‚ç”±äºç±»å‹ç¯å¢ƒä¸­çš„ç»‘å®šæ˜¯å”¯ä¸€çš„ï¼Œ$\sigma = \tau$ã€‚

**å½’çº³æ­¥éª¤ï¼š**

**æƒ…å†µ1ï¼š** å‡è®¾ $M = \lambda x.M_1$ã€‚
å¦‚æœ $\Gamma \vdash \lambda x.M_1 : \sigma$ ä¸” $\Gamma \vdash \lambda x.M_1 : \tau$ï¼Œåˆ™ï¼š

- $\sigma = \sigma_1 \rightarrow \sigma_2$
- $\tau = \tau_1 \rightarrow \tau_2$
- $\Gamma, x : \sigma_1 \vdash M_1 : \sigma_2$
- $\Gamma, x : \tau_1 \vdash M_1 : \tau_2$

é€šè¿‡å½’çº³å‡è®¾ï¼Œ$\sigma_1 = \tau_1$ ä¸” $\sigma_2 = \tau_2$ï¼Œå› æ­¤ $\sigma = \tau$ã€‚

**æƒ…å†µ2ï¼š** å‡è®¾ $M = M_1 M_2$ã€‚
å¦‚æœ $\Gamma \vdash M_1 M_2 : \sigma$ ä¸” $\Gamma \vdash M_1 M_2 : \tau$ï¼Œåˆ™ï¼š

- $\Gamma \vdash M_1 : \sigma_1 \rightarrow \sigma$
- $\Gamma \vdash M_1 : \tau_1 \rightarrow \tau$
- $\Gamma \vdash M_2 : \sigma_1$
- $\Gamma \vdash M_2 : \tau_1$

é€šè¿‡å½’çº³å‡è®¾ï¼Œ$\sigma_1 \rightarrow \sigma = \tau_1 \rightarrow \tau$ ä¸” $\sigma_1 = \tau_1$ï¼Œå› æ­¤ $\sigma = \tau$ã€‚

å› æ­¤ï¼Œç±»å‹æ¨å¯¼æ˜¯å”¯ä¸€çš„ã€‚$\square$

### 4.2 å¤šæ€Î»æ¼”ç®— (Polymorphic Lambda Calculus)

**å¤šæ€ç±»å‹å®šä¹‰ / Polymorphic Type Definition:**

å¤šæ€Î»æ¼”ç®—æ‰©å±•äº†ç®€å•ç±»å‹Î»æ¼”ç®—ï¼Œå¼•å…¥äº†ç±»å‹å˜é‡å’Œå…¨ç§°é‡è¯ã€‚

Polymorphic lambda calculus extends simply typed lambda calculus by introducing type variables and universal quantifiers.

**ç±»å‹æ„é€  / Type Constructions:**

1. **ç±»å‹å˜é‡ (Type Variables) / Type Variables:**
   - $\alpha, \beta, \gamma$ ç­‰ / $\alpha, \beta, \gamma$, etc.

2. **å…¨ç§°ç±»å‹ (Universal Types) / Universal Types:**
   - $\forall \alpha.\sigma$ è¡¨ç¤ºå¯¹æ‰€æœ‰ç±»å‹ $\alpha$ï¼Œ$\sigma$ éƒ½æˆç«‹
   - $\forall \alpha.\sigma$ means that $\sigma$ holds for all types $\alpha$

**å¤šæ€ç±»å‹è§„åˆ™ / Polymorphic Type Rules:**

1. **ç±»å‹æŠ½è±¡ (Type Abstraction) / Type Abstraction:**
   - $\frac{\Gamma \vdash M : \sigma}{\Gamma \vdash \Lambda \alpha.M : \forall \alpha.\sigma}$ (å¦‚æœ $\alpha$ ä¸åœ¨ $\Gamma$ ä¸­è‡ªç”±å‡ºç°)

2. **ç±»å‹åº”ç”¨ (Type Application) / Type Application:**
   - $\frac{\Gamma \vdash M : \forall \alpha.\sigma}{\Gamma \vdash M[\tau] : \sigma[\tau/\alpha]}$

### 4.3 ä¾èµ–ç±»å‹Î»æ¼”ç®— (Dependent Lambda Calculus)

**ä¾èµ–ç±»å‹å®šä¹‰ / Dependent Type Definition:**

ä¾èµ–ç±»å‹Î»æ¼”ç®—å…è®¸ç±»å‹ä¾èµ–äºå€¼ï¼Œæä¾›äº†æ›´å¼ºçš„è¡¨è¾¾èƒ½åŠ›ã€‚

Dependent lambda calculus allows types to depend on values, providing stronger expressive power.

**ä¾èµ–ç±»å‹æ„é€  / Dependent Type Constructions:**

1. **ä¾èµ–å‡½æ•°ç±»å‹ (Dependent Function Types) / Dependent Function Types:**
   - $\Pi x : A.B(x)$ è¡¨ç¤ºå¯¹äºæ‰€æœ‰ $x : A$ï¼Œ$B(x)$ ç±»å‹
   - $\Pi x : A.B(x)$ means type $B(x)$ for all $x : A$

2. **ä¾èµ–ç§¯ç±»å‹ (Dependent Product Types) / Dependent Product Types:**
   - $\Sigma x : A.B(x)$ è¡¨ç¤ºå­˜åœ¨ $x : A$ï¼Œä½¿å¾— $B(x)$ ç±»å‹
   - $\Sigma x : A.B(x)$ means there exists $x : A$ such that $B(x)$ is a type

---

## 5. è¯­ä¹‰ (Semantics)

### 5.1 æ“ä½œè¯­ä¹‰ (Operational Semantics)

**æ“ä½œè¯­ä¹‰å®šä¹‰ / Definition of Operational Semantics:**

æ“ä½œè¯­ä¹‰é€šè¿‡å½’çº¦è§„åˆ™å®šä¹‰Î»æ¼”ç®—çš„è®¡ç®—è¡Œä¸ºã€‚

Operational semantics defines the computational behavior of lambda calculus through reduction rules.

**å°æ­¥è¯­ä¹‰ (Small-Step Semantics) / Small-Step Semantics:**

1. **Î²å½’çº¦è§„åˆ™ / Beta Reduction Rule:**
   - $\frac{}{(\lambda x.M) N \rightarrow M[N/x]}$

2. **åº”ç”¨è§„åˆ™ / Application Rules:**
   - $\frac{M \rightarrow M'}{M N \rightarrow M' N}$
   - $\frac{N \rightarrow N'}{M N \rightarrow M N'}$

3. **æŠ½è±¡è§„åˆ™ / Abstraction Rule:**
   - $\frac{M \rightarrow M'}{\lambda x.M \rightarrow \lambda x.M'}$

### 5.2 æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)

**æŒ‡ç§°è¯­ä¹‰å®šä¹‰ / Definition of Denotational Semantics:**

æŒ‡ç§°è¯­ä¹‰é€šè¿‡æ•°å­¦å¯¹è±¡è§£é‡ŠÎ»é¡¹çš„å«ä¹‰ã€‚

Denotational semantics interprets the meaning of lambda terms through mathematical objects.

**åŸŸè®ºè¯­ä¹‰ (Domain-Theoretic Semantics) / Domain-Theoretic Semantics:**

1. **åŸºæœ¬åŸŸ (Basic Domains) / Basic Domains:**
   - åŸºæœ¬ç±»å‹å¯¹åº”åŸºæœ¬åŸŸ / Basic types correspond to basic domains

2. **å‡½æ•°åŸŸ (Function Domains) / Function Domains:**
   - $[A \rightarrow B] = [A] \rightarrow [B]$
   - å‡½æ•°ç±»å‹å¯¹åº”å‡½æ•°åŸŸ / Function types correspond to function domains

3. **é€’å½’åŸŸ (Recursive Domains) / Recursive Domains:**
   - $D \cong D \rightarrow D$ ç”¨äºè§£é‡Šé€’å½’ç±»å‹
   - $D \cong D \rightarrow D$ for interpreting recursive types

### 5.3 å…¬ç†è¯­ä¹‰ (Axiomatic Semantics)

**å…¬ç†è¯­ä¹‰å®šä¹‰ / Definition of Axiomatic Semantics:**

å…¬ç†è¯­ä¹‰é€šè¿‡å…¬ç†å’Œæ¨ç†è§„åˆ™å®šä¹‰Î»æ¼”ç®—çš„æ€§è´¨ã€‚

Axiomatic semantics defines properties of lambda calculus through axioms and inference rules.

**åŸºæœ¬å…¬ç† / Basic Axioms:**

1. **Î±ç­‰ä»·å…¬ç† / Alpha Equivalence Axiom:**
   - $\lambda x.M = \lambda y.M[y/x]$ (å¦‚æœ $y$ ä¸åœ¨ $M$ ä¸­è‡ªç”±å‡ºç°)

2. **Î²ç­‰ä»·å…¬ç† / Beta Equivalence Axiom:**
   - $(\lambda x.M) N = M[N/x]$

3. **Î·ç­‰ä»·å…¬ç† / Eta Equivalence Axiom:**
   - $\lambda x.(M x) = M$ (å¦‚æœ $x \notin FV(M)$)

---

## 6. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 6.1 Î»æ¼”ç®—è§£é‡Šå™¨ (Lambda Calculus Interpreter)

```rust
use std::collections::HashMap;

/// Î»æ¼”ç®—è§£é‡Šå™¨ / Lambda Calculus Interpreter
pub struct LambdaInterpreter {
    environment: HashMap<String, LambdaTerm>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum LambdaTerm {
    Variable(String),
    Abstraction(String, Box<LambdaTerm>),
    Application(Box<LambdaTerm>, Box<LambdaTerm>),
}

impl LambdaInterpreter {
    /// åˆ›å»ºæ–°çš„è§£é‡Šå™¨ / Create new interpreter
    pub fn new() -> Self {
        LambdaInterpreter {
            environment: HashMap::new(),
        }
    }

    /// è§£æÎ»é¡¹ / Parse lambda term
    pub fn parse(&self, input: &str) -> Result<LambdaTerm, String> {
        let tokens = self.tokenize(input)?;
        self.parse_tokens(&tokens)
    }

    /// è¯æ³•åˆ†æ / Tokenization
    fn tokenize(&self, input: &str) -> Result<Vec<String>, String> {
        let mut tokens = Vec::new();
        let mut current = String::new();

        for ch in input.chars() {
            match ch {
                ' ' | '\t' | '\n' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                }
                '(' | ')' | 'Î»' | '.' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                    tokens.push(ch.to_string());
                }
                _ => current.push(ch),
            }
        }

        if !current.is_empty() {
            tokens.push(current);
        }

        Ok(tokens)
    }

    /// è§£ææ ‡è®° / Parse tokens
    fn parse_tokens(&self, tokens: &[String]) -> Result<LambdaTerm, String> {
        if tokens.is_empty() {
            return Err("Empty token list".to_string());
        }

        match tokens[0].as_str() {
            "Î»" => {
                if tokens.len() < 4 || tokens[2] != "." {
                    return Err("Invalid abstraction syntax".to_string());
                }
                let variable = tokens[1].clone();
                let body = self.parse_tokens(&tokens[3..])?;
                Ok(LambdaTerm::Abstraction(variable, Box::new(body)))
            }
            "(" => {
                if tokens.len() < 3 || tokens[tokens.len() - 1] != ")" {
                    return Err("Invalid application syntax".to_string());
                }
                let inner_tokens = &tokens[1..tokens.len() - 1];
                self.parse_application(inner_tokens)
            }
            var_name => {
                if tokens.len() == 1 {
                    Ok(LambdaTerm::Variable(var_name.to_string()))
                } else {
                    self.parse_application(tokens)
                }
            }
        }
    }

    /// è§£æåº”ç”¨ / Parse application
    fn parse_application(&self, tokens: &[String]) -> Result<LambdaTerm, String> {
        if tokens.len() < 2 {
            return Err("Invalid application".to_string());
        }

        let mut terms = Vec::new();
        let mut current_tokens = Vec::new();

        for token in tokens {
            match token.as_str() {
                "(" => {
                    if !current_tokens.is_empty() {
                        terms.push(self.parse_tokens(&current_tokens)?);
                        current_tokens.clear();
                    }
                    current_tokens.push(token.clone());
                }
                ")" => {
                    current_tokens.push(token.clone());
                    if !current_tokens.is_empty() {
                        terms.push(self.parse_tokens(&current_tokens)?);
                        current_tokens.clear();
                    }
                }
                _ => {
                    if current_tokens.is_empty() {
                        terms.push(LambdaTerm::Variable(token.clone()));
                    } else {
                        current_tokens.push(token.clone());
                    }
                }
            }
        }

        if terms.len() < 2 {
            return Err("Application requires at least two terms".to_string());
        }

        let mut result = terms[0].clone();
        for term in terms.iter().skip(1) {
            result = LambdaTerm::Application(Box::new(result), Box::new(term.clone()));
        }

        Ok(result)
    }

    /// è®¡ç®—è‡ªç”±å˜é‡ / Compute free variables
    pub fn free_variables(&self, term: &LambdaTerm) -> Vec<String> {
        match term {
            LambdaTerm::Variable(x) => vec![x.clone()],
            LambdaTerm::Abstraction(x, body) => {
                let mut fv = self.free_variables(body);
                fv.retain(|v| v != x);
                fv
            }
            LambdaTerm::Application(func, arg) => {
                let mut fv = self.free_variables(func);
                fv.extend(self.free_variables(arg));
                fv
            }
        }
    }

    /// æ›¿æ¢ / Substitution
    pub fn substitute(&self, term: &LambdaTerm, var: &str, replacement: &LambdaTerm) -> LambdaTerm {
        match term {
            LambdaTerm::Variable(x) => {
                if x == var {
                    replacement.clone()
                } else {
                    term.clone()
                }
            }
            LambdaTerm::Abstraction(x, body) => {
                if x == var {
                    term.clone()
                } else {
                    let free_vars = self.free_variables(replacement);
                    if free_vars.contains(x) {
                        // éœ€è¦Î±è½¬æ¢ / Need alpha conversion
                        let new_var = self.generate_fresh_variable(x);
                        let new_body = self.substitute(body, x, &LambdaTerm::Variable(new_var.clone()));
                        LambdaTerm::Abstraction(new_var, Box::new(self.substitute(&new_body, var, replacement)))
                    } else {
                        LambdaTerm::Abstraction(x.clone(), Box::new(self.substitute(body, var, replacement)))
                    }
                }
            }
            LambdaTerm::Application(func, arg) => {
                LambdaTerm::Application(
                    Box::new(self.substitute(func, var, replacement)),
                    Box::new(self.substitute(arg, var, replacement)),
                )
            }
        }
    }

    /// ç”Ÿæˆæ–°å˜é‡ / Generate fresh variable
    fn generate_fresh_variable(&self, base: &str) -> String {
        let mut counter = 0;
        loop {
            let new_var = format!("{}{}", base, counter);
            if !self.environment.contains_key(&new_var) {
                return new_var;
            }
            counter += 1;
        }
    }

    /// Î²å½’çº¦ / Beta reduction
    pub fn beta_reduce(&self, term: &LambdaTerm) -> Option<LambdaTerm> {
        match term {
            LambdaTerm::Application(func, arg) => {
                if let LambdaTerm::Abstraction(var, body) = func.as_ref() {
                    Some(self.substitute(body, var, arg))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    /// å½’çº¦åˆ°æ­£è§„å½¢å¼ / Reduce to normal form
    pub fn reduce_to_normal_form(&self, term: &LambdaTerm) -> LambdaTerm {
        let mut current = term.clone();

        loop {
            if let Some(reduced) = self.beta_reduce(&current) {
                current = reduced;
            } else {
                // å°è¯•å½’çº¦å­é¡¹ / Try to reduce subterms
                let mut changed = false;
                current = self.reduce_subterms(&current, &mut changed);
                if !changed {
                    break;
                }
            }
        }

        current
    }

    /// å½’çº¦å­é¡¹ / Reduce subterms
    fn reduce_subterms(&self, term: &LambdaTerm, changed: &mut bool) -> LambdaTerm {
        match term {
            LambdaTerm::Variable(_) => term.clone(),
            LambdaTerm::Abstraction(var, body) => {
                let new_body = self.reduce_subterms(body, changed);
                if new_body != **body {
                    *changed = true;
                }
                LambdaTerm::Abstraction(var.clone(), Box::new(new_body))
            }
            LambdaTerm::Application(func, arg) => {
                let new_func = self.reduce_subterms(func, changed);
                let new_arg = self.reduce_subterms(arg, changed);

                if new_func != **func || new_arg != **arg {
                    *changed = true;
                }

                LambdaTerm::Application(Box::new(new_func), Box::new(new_arg))
            }
        }
    }
}
```

### 6.2 ç±»å‹Î»æ¼”ç®—å®ç° (Typed Lambda Calculus Implementation)

```rust
/// ç±»å‹Î»æ¼”ç®—å®ç° / Typed Lambda Calculus Implementation
pub struct TypedLambdaInterpreter {
    type_environment: HashMap<String, Type>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Base(String),
    Function(Box<Type>, Box<Type>),
    Universal(String, Box<Type>),
}

#[derive(Debug, Clone)]
pub struct TypedLambdaTerm {
    pub term: LambdaTerm,
    pub type_info: Type,
}

impl TypedLambdaInterpreter {
    /// åˆ›å»ºæ–°çš„ç±»å‹è§£é‡Šå™¨ / Create new typed interpreter
    pub fn new() -> Self {
        TypedLambdaInterpreter {
            type_environment: HashMap::new(),
        }
    }

    /// ç±»å‹æ£€æŸ¥ / Type checking
    pub fn type_check(&self, term: &LambdaTerm, context: &HashMap<String, Type>) -> Result<Type, String> {
        match term {
            LambdaTerm::Variable(x) => {
                context.get(x)
                    .cloned()
                    .ok_or_else(|| format!("Variable {} not found in context", x))
            }
            LambdaTerm::Abstraction(x, body) => {
                // ä¸ºå‚æ•°åˆ†é…ä¸€ä¸ªç±»å‹å˜é‡ / Assign a type variable for the parameter
                let param_type = Type::Base(format!("T_{}", x));
                let mut new_context = context.clone();
                new_context.insert(x.clone(), param_type.clone());

                let body_type = self.type_check(body, &new_context)?;
                Ok(Type::Function(Box::new(param_type), Box::new(body_type)))
            }
            LambdaTerm::Application(func, arg) => {
                let func_type = self.type_check(func, context)?;
                let arg_type = self.type_check(arg, context)?;

                match func_type {
                    Type::Function(input_type, output_type) => {
                        if *input_type == arg_type {
                            Ok(*output_type)
                        } else {
                            Err(format!("Type mismatch: expected {:?}, got {:?}", input_type, arg_type))
                        }
                    }
                    _ => Err("Function type expected".to_string()),
                }
            }
        }
    }

    /// ç±»å‹æ¨å¯¼ / Type inference
    pub fn type_inference(&self, term: &LambdaTerm) -> Result<Type, String> {
        let context = HashMap::new();
        self.type_check(term, &context)
    }

    /// åˆ›å»ºç±»å‹åŒ–çš„Î»é¡¹ / Create typed lambda term
    pub fn create_typed_term(&self, term: LambdaTerm) -> Result<TypedLambdaTerm, String> {
        let type_info = self.type_inference(&term)?;
        Ok(TypedLambdaTerm { term, type_info })
    }
}
```

### 6.3 Î»æ¼”ç®—æµ‹è¯• (Lambda Calculus Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lambda_parsing() {
        let interpreter = LambdaInterpreter::new();

        // æµ‹è¯•å˜é‡ / Test variable
        let result = interpreter.parse("x");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), LambdaTerm::Variable(_)));

        // æµ‹è¯•æŠ½è±¡ / Test abstraction
        let result = interpreter.parse("Î»x.x");
        assert!(result.is_ok());
        if let Ok(LambdaTerm::Abstraction(var, body)) = result {
            assert_eq!(var, "x");
            assert!(matches!(*body, LambdaTerm::Variable(_)));
        } else {
            panic!("Expected abstraction");
        }

        // æµ‹è¯•åº”ç”¨ / Test application
        let result = interpreter.parse("(Î»x.x) y");
        assert!(result.is_ok());
        if let Ok(LambdaTerm::Application(func, arg)) = result {
            assert!(matches!(*func, LambdaTerm::Abstraction(_, _)));
            assert!(matches!(*arg, LambdaTerm::Variable(_)));
        } else {
            panic!("Expected application");
        }
    }

    #[test]
    fn test_beta_reduction() {
        let interpreter = LambdaInterpreter::new();

        // æµ‹è¯•ç®€å•çš„Î²å½’çº¦ / Test simple beta reduction
        let term = LambdaTerm::Application(
            Box::new(LambdaTerm::Abstraction("x".to_string(), Box::new(LambdaTerm::Variable("x".to_string())))),
            Box::new(LambdaTerm::Variable("y".to_string())),
        );

        let reduced = interpreter.beta_reduce(&term);
        assert!(reduced.is_some());
        assert_eq!(reduced.unwrap(), LambdaTerm::Variable("y".to_string()));
    }

    #[test]
    fn test_free_variables() {
        let interpreter = LambdaInterpreter::new();

        // æµ‹è¯•è‡ªç”±å˜é‡è®¡ç®— / Test free variable computation
        let term = LambdaTerm::Abstraction(
            "x".to_string(),
            Box::new(LambdaTerm::Application(
                Box::new(LambdaTerm::Variable("x".to_string())),
                Box::new(LambdaTerm::Variable("y".to_string())),
            )),
        );

        let free_vars = interpreter.free_variables(&term);
        assert_eq!(free_vars, vec!["y"]);
    }

    #[test]
    fn test_type_checking() {
        let typed_interpreter = TypedLambdaInterpreter::new();

        // æµ‹è¯•ç±»å‹æ£€æŸ¥ / Test type checking
        let term = LambdaTerm::Abstraction(
            "x".to_string(),
            Box::new(LambdaTerm::Variable("x".to_string())),
        );

        let result = typed_interpreter.type_inference(&term);
        assert!(result.is_ok());

        if let Ok(Type::Function(input_type, output_type)) = result {
            assert_eq!(*input_type, *output_type);
        } else {
            panic!("Expected function type");
        }
    }

    #[test]
    fn test_church_numerals() {
        let interpreter = LambdaInterpreter::new();

        // Church numeral 0: Î»f.Î»x.x
        let zero = LambdaTerm::Abstraction(
            "f".to_string(),
            Box::new(LambdaTerm::Abstraction(
                "x".to_string(),
                Box::new(LambdaTerm::Variable("x".to_string())),
            )),
        );

        // Church numeral 1: Î»f.Î»x.f x
        let one = LambdaTerm::Abstraction(
            "f".to_string(),
            Box::new(LambdaTerm::Abstraction(
                "x".to_string(),
                Box::new(LambdaTerm::Application(
                    Box::new(LambdaTerm::Variable("f".to_string())),
                    Box::new(LambdaTerm::Variable("x".to_string())),
                )),
            )),
        );

        // æµ‹è¯•Churchæ•° / Test Church numerals
        let zero_free_vars = interpreter.free_variables(&zero);
        assert!(zero_free_vars.is_empty());

        let one_free_vars = interpreter.free_variables(&one);
        assert!(one_free_vars.is_empty());
    }
}
```

---

## 7. å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚æ–‡çŒ®æŒ‰ç…§"ç»å…¸å¥ åŸºæ–‡çŒ® â†’ æ ‡å‡†æ•™æ"çš„å±‚æ¬¡ç»„ç»‡ã€‚

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Church1936Lambda] Church, A. (1936). "An Unsolvable Problem of Elementary Number Theory". *American Journal of Mathematics*, 58(2), 345-363. DOI: 10.2307/2371045
   - **Church Î»æ¼”ç®—çš„å¼€åˆ›æ€§è®ºæ–‡**ï¼Œå‡½æ•°å¼ç¼–ç¨‹çš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£çš„æ ¸å¿ƒå†…å®¹åŸºäºæ­¤è®ºæ–‡ã€‚

2. [Church1940] Church, A. (1940). "A Formulation of the Simple Theory of Types". *Journal of Symbolic Logic*, 5(2), 56-68.
   - Churchç®€å•ç±»å‹è®ºçš„ç»å…¸è®ºæ–‡ï¼Œæœ¬æ–‡æ¡£çš„ç±»å‹ç³»ç»Ÿéƒ¨åˆ†å‚è€ƒæ­¤è®ºæ–‡ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. [Barendregt1984] Barendregt, H. P. (1984). *The Lambda Calculus: Its Syntax and Semantics* (Revised ed.). North-Holland. ISBN: 978-0444875082
   - **Barendregt Î»æ¼”ç®—çš„æƒå¨ä¸“è‘—**ï¼Œè¢«èª‰ä¸º"Î»æ¼”ç®—åœ£ç»"ã€‚æœ¬æ–‡æ¡£çš„åŸºç¡€æ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

2. [Pierce2002] Pierce, B. C. (2002). *Types and Programming Languages*. MIT Press. ISBN: 978-0262162098
   - Pierceç±»å‹ä¸ç¨‹åºè®¾è®¡è¯­è¨€çš„ç»å…¸æ•™æï¼Œæœ¬æ–‡æ¡£çš„ç±»å‹ç³»ç»Ÿéƒ¨åˆ†å‚è€ƒæ­¤ä¹¦ã€‚

3. [HindleySeldin2008] Hindley, J. R., & Seldin, J. P. (2008). *Lambda-Calculus and Combinators: An Introduction* (2nd ed.). Cambridge University Press. ISBN: 978-0521898850
   - Hindley-Seldin Î»æ¼”ç®—ä¸ç»„åˆå­çš„æƒå¨æ•™æã€‚

4. Girard, J. Y., Lafont, Y., & Taylor, P. (1989). *Proofs and Types*. Cambridge University Press.
   - è¯æ˜ä¸ç±»å‹çš„ç»å…¸æ•™æã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Lambda Calculus**: <https://en.wikipedia.org/wiki/Lambda_calculus>
   - Î»æ¼”ç®—çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«è¯­æ³•ã€å½’çº¦å’Œç±»å‹ç³»ç»Ÿï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Church-Turing Thesis**: <https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis>
   - Church-Turingè®ºé¢˜çš„Wikipediaæ¡ç›®ï¼Œè¯´æ˜Î»æ¼”ç®—ä¸å›¾çµæœºçš„ç­‰ä»·æ€§ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Beta Reduction**: <https://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction>
   - Î²å½’çº¦çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»Î»æ¼”ç®—çš„å½’çº¦è§„åˆ™ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

## ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### ç›¸å…³æ–‡æ¡£ / Related Documents

- `07-è®¡ç®—æ¨¡å‹/08-è®¡ç®—æ¨¡å‹ç­‰ä»·æ€§ç†è®º.md` - è®¡ç®—æ¨¡å‹ç­‰ä»·æ€§ç†è®ºï¼ˆÎ»æ¼”ç®—ä¸å›¾çµæœºçš„ç­‰ä»·æ€§ï¼‰
- `07-è®¡ç®—æ¨¡å‹/01-å›¾çµæœº.md` - å›¾çµæœºï¼ˆä¸Î»æ¼”ç®—çš„ç­‰ä»·æ€§ï¼‰
- `05-ç±»å‹ç†è®º/02-ä¾èµ–ç±»å‹è®º.md` - ä¾èµ–ç±»å‹è®ºï¼ˆåŸºäºÎ»æ¼”ç®—çš„ç±»å‹ç³»ç»Ÿï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/22-ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶.md` - ç®—æ³•å…­ç»´åˆ†ç±»æ¡†æ¶ï¼ˆè®¡ç®—æ¨¡å‹ç»´åº¦ï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` - ç®—æ³•å…¨æ™¯æ¢³ç†ï¼ˆåŒ…å«Î»æ¼”ç®—æ¦‚è¿°ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

### çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **07-è®¡ç®—æ¨¡å‹** æ¨¡å—ï¼Œæ˜¯è®¡ç®—æ¨¡å‹ç†è®ºçš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºå‡½æ•°å¼ç¼–ç¨‹å’Œç±»å‹ç³»ç»Ÿæä¾›ç†è®ºåŸºç¡€ã€‚

### VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§2.1 - è®¡ç®—æ¨¡å‹ï¼ˆÎ»æ¼”ç®—ï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§3.1 - è®¡ç®—æ¨¡å‹ç­‰ä»·ï¼ˆChurch-Turingï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£æä¾›äº†Î»æ¼”ç®—çš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€è¯­æ³•ã€å½’çº¦ã€ç±»å‹ç³»ç»Ÿã€è¯­ä¹‰å’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
