# 细胞自动机理论 / Cellular Automata Theory

## 概述 / Overview

细胞自动机是一种离散的数学模型，由规则网格中的细胞组成，每个细胞根据简单的局部规则同步更新其状态。尽管规则简单，细胞自动机能够展现出复杂的全局行为，是研究复杂系统、自组织现象和计算理论的重要工具。

Cellular automata are discrete mathematical models consisting of cells arranged in a regular grid, where each cell updates its state synchronously according to simple local rules. Despite simple rules, cellular automata can exhibit complex global behavior and serve as important tools for studying complex systems, self-organization phenomena, and computational theory.

## 基本概念 / Basic Concepts

### 细胞自动机定义 / Definition of Cellular Automata

**定义 1.1** (细胞自动机 / Cellular Automaton)
一个细胞自动机是一个四元组 (L, S, N, f)，其中：

- L 是细胞的排列格局（通常是规则网格）
- S 是有限的状态集合
- N 是邻域定义
- f: S^|N| → S 是局部转移函数

**Definition 1.1** (Cellular Automaton)
A cellular automaton is a 4-tuple (L, S, N, f), where:

- L is the cell arrangement lattice (usually a regular grid)
- S is a finite set of states
- N is the neighborhood definition
- f: S^|N| → S is the local transition function

### 细胞自动机的组成要素 / Components of Cellular Automata

1. **网格结构** / Grid Structure
   - 一维、二维或高维网格
   - 有限或无限网格

2. **状态空间** / State Space
   - 每个细胞可能的状态集合
   - 通常是有限集合

3. **邻域** / Neighborhood
   - 影响细胞状态更新的邻近细胞
   - 常见的有冯·诺依曼邻域和摩尔邻域

4. **转移规则** / Transition Rules
   - 决定细胞下一时刻状态的函数
   - 基于当前细胞及其邻域的状态

## 一维细胞自动机 / One-Dimensional Cellular Automata

### 基本实现 / Basic Implementation

```rust
// 一维细胞自动机实现
// One-dimensional cellular automaton implementation

use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq)]
pub struct OneDimensionalCA {
    cells: Vec<u8>,
    rule: u8,
    size: usize,
    generation: usize,
}

impl OneDimensionalCA {
    pub fn new(size: usize, rule: u8) -> Self {
        let mut cells = vec![0; size];
        // 在中间放置一个活细胞作为种子
        if size > 0 {
            cells[size / 2] = 1;
        }
        
        Self {
            cells,
            rule,
            size,
            generation: 0,
        }
    }
    
    pub fn with_initial_state(size: usize, rule: u8, initial_state: Vec<u8>) -> Self {
        assert_eq!(initial_state.len(), size);
        
        Self {
            cells: initial_state,
            rule,
            size,
            generation: 0,
        }
    }
    
    pub fn step(&mut self) {
        let mut new_cells = vec![0; self.size];
        
        for i in 0..self.size {
            let left = if i == 0 { 0 } else { self.cells[i - 1] };
            let center = self.cells[i];
            let right = if i == self.size - 1 { 0 } else { self.cells[i + 1] };
            
            // 计算三个邻居的配置
            let config = (left << 2) | (center << 1) | right;
            
            // 应用规则
            new_cells[i] = (self.rule >> config) & 1;
        }
        
        self.cells = new_cells;
        self.generation += 1;
    }
    
    pub fn evolve(&mut self, steps: usize) {
        for _ in 0..steps {
            self.step();
        }
    }
    
    pub fn get_cells(&self) -> &[u8] {
        &self.cells
    }
    
    pub fn get_generation(&self) -> usize {
        self.generation
    }
    
    pub fn display(&self) -> String {
        self.cells
            .iter()
            .map(|&cell| if cell == 1 { '█' } else { ' ' })
            .collect()
    }
    
    // 计算密度（活细胞比例）
    pub fn density(&self) -> f64 {
        let alive_count = self.cells.iter().filter(|&&cell| cell == 1).count();
        alive_count as f64 / self.size as f64
    }
    
    // 检测周期性模式
    pub fn detect_period(&self, max_steps: usize) -> Option<usize> {
        let mut states = HashMap::new();
        let mut ca = self.clone();
        
        for step in 0..max_steps {
            let state_key = ca.cells.clone();
            if let Some(previous_step) = states.get(&state_key) {
                return Some(step - previous_step);
            }
            states.insert(state_key, step);
            ca.step();
        }
        
        None
    }
}

// Wolfram分类系统
pub struct WolframClassification;

impl WolframClassification {
    pub fn classify_rule(rule: u8, steps: usize, samples: usize) -> WolframClass {
        let mut total_entropy = 0.0;
        let mut periodic_count = 0;
        let mut chaotic_count = 0;
        
        for seed in 0..samples {
            let mut ca = OneDimensionalCA::new(100, rule);
            // 使用不同的初始条件
            if seed % 2 == 1 {
                ca.cells[25] = 1;
                ca.cells[75] = 1;
            }
            
            ca.evolve(steps);
            
            // 计算最终状态的熵
            let entropy = Self::calculate_entropy(&ca.cells);
            total_entropy += entropy;
            
            // 检测周期性
            if let Some(period) = ca.detect_period(50) {
                if period <= 10 {
                    periodic_count += 1;
                } else {
                    chaotic_count += 1;
                }
            } else {
                chaotic_count += 1;
            }
        }
        
        let average_entropy = total_entropy / samples as f64;
        let periodic_ratio = periodic_count as f64 / samples as f64;
        
        if average_entropy < 0.1 {
            WolframClass::ClassI
        } else if periodic_ratio > 0.8 {
            WolframClass::ClassII
        } else if average_entropy > 0.9 {
            WolframClass::ClassIV
        } else {
            WolframClass::ClassIII
        }
    }
    
    fn calculate_entropy(cells: &[u8]) -> f64 {
        let total = cells.len() as f64;
        let ones = cells.iter().filter(|&&x| x == 1).count() as f64;
        let zeros = total - ones;
        
        if ones == 0.0 || zeros == 0.0 {
            return 0.0;
        }
        
        let p_one = ones / total;
        let p_zero = zeros / total;
        
        -(p_one * p_one.log2() + p_zero * p_zero.log2())
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum WolframClass {
    ClassI,   // 同质态
    ClassII,  // 周期性结构
    ClassIII, // 混沌行为
    ClassIV,  // 复杂结构
}
```

### 著名的一维规则 / Famous One-Dimensional Rules

```rust
// 著名的细胞自动机规则
// Famous cellular automaton rules

pub struct FamousRules;

impl FamousRules {
    // Rule 30: 产生伪随机序列
    pub fn rule_30() -> OneDimensionalCA {
        OneDimensionalCA::new(101, 30)
    }
    
    // Rule 90: 生成Sierpinski三角形
    pub fn rule_90() -> OneDimensionalCA {
        OneDimensionalCA::new(101, 90)
    }
    
    // Rule 110: 图灵完备
    pub fn rule_110() -> OneDimensionalCA {
        OneDimensionalCA::new(101, 110)
    }
    
    // Rule 184: 交通流模型
    pub fn rule_184() -> OneDimensionalCA {
        OneDimensionalCA::new(101, 184)
    }
    
    // 分析规则的特性
    pub fn analyze_rule(rule: u8) -> RuleAnalysis {
        let mut ca = OneDimensionalCA::new(101, rule);
        let initial_density = ca.density();
        
        ca.evolve(100);
        let final_density = ca.density();
        
        let period = ca.detect_period(50);
        let classification = WolframClassification::classify_rule(rule, 100, 10);
        
        RuleAnalysis {
            rule,
            initial_density,
            final_density,
            density_change: final_density - initial_density,
            period,
            classification,
        }
    }
}

#[derive(Debug)]
pub struct RuleAnalysis {
    pub rule: u8,
    pub initial_density: f64,
    pub final_density: f64,
    pub density_change: f64,
    pub period: Option<usize>,
    pub classification: WolframClass,
}
```

## 二维细胞自动机 / Two-Dimensional Cellular Automata

### 生命游戏 / Game of Life

```rust
// Conway的生命游戏实现
// Conway's Game of Life implementation

#[derive(Clone, Debug)]
pub struct GameOfLife {
    grid: Vec<Vec<bool>>,
    width: usize,
    height: usize,
    generation: usize,
}

impl GameOfLife {
    pub fn new(width: usize, height: usize) -> Self {
        Self {
            grid: vec![vec![false; width]; height],
            width,
            height,
            generation: 0,
        }
    }
    
    pub fn set_cell(&mut self, x: usize, y: usize, alive: bool) {
        if x < self.width && y < self.height {
            self.grid[y][x] = alive;
        }
    }
    
    pub fn get_cell(&self, x: usize, y: usize) -> bool {
        if x < self.width && y < self.height {
            self.grid[y][x]
        } else {
            false
        }
    }
    
    pub fn count_neighbors(&self, x: usize, y: usize) -> usize {
        let mut count = 0;
        
        for dy in -1i32..=1 {
            for dx in -1i32..=1 {
                if dx == 0 && dy == 0 {
                    continue;
                }
                
                let nx = x as i32 + dx;
                let ny = y as i32 + dy;
                
                if nx >= 0 && ny >= 0 && (nx as usize) < self.width && (ny as usize) < self.height {
                    if self.grid[ny as usize][nx as usize] {
                        count += 1;
                    }
                }
            }
        }
        
        count
    }
    
    pub fn step(&mut self) {
        let mut new_grid = vec![vec![false; self.width]; self.height];
        
        for y in 0..self.height {
            for x in 0..self.width {
                let neighbors = self.count_neighbors(x, y);
                let current_cell = self.grid[y][x];
                
                // Conway的生命游戏规则
                new_grid[y][x] = match (current_cell, neighbors) {
                    (true, 2) | (true, 3) => true,  // 生存
                    (false, 3) => true,             // 繁殖
                    _ => false,                     // 死亡或保持死亡
                };
            }
        }
        
        self.grid = new_grid;
        self.generation += 1;
    }
    
    pub fn evolve(&mut self, steps: usize) {
        for _ in 0..steps {
            self.step();
        }
    }
    
    pub fn population(&self) -> usize {
        self.grid.iter()
            .flat_map(|row| row.iter())
            .filter(|&&cell| cell)
            .count()
    }
    
    pub fn display(&self) -> String {
        let mut result = String::new();
        for row in &self.grid {
            for &cell in row {
                result.push(if cell { '█' } else { '·' });
            }
            result.push('\n');
        }
        result
    }
    
    // 设置常见的初始模式
    pub fn set_glider(&mut self, x: usize, y: usize) {
        let pattern = vec![
            (1, 0), (2, 1), (0, 2), (1, 2), (2, 2)
        ];
        
        for (dx, dy) in pattern {
            self.set_cell(x + dx, y + dy, true);
        }
    }
    
    pub fn set_oscillator_blinker(&mut self, x: usize, y: usize) {
        self.set_cell(x, y, true);
        self.set_cell(x + 1, y, true);
        self.set_cell(x + 2, y, true);
    }
    
    pub fn set_still_life_block(&mut self, x: usize, y: usize) {
        self.set_cell(x, y, true);
        self.set_cell(x + 1, y, true);
        self.set_cell(x, y + 1, true);
        self.set_cell(x + 1, y + 1, true);
    }
    
    // 检测稳定模式
    pub fn is_stable(&self, previous_states: &[Vec<Vec<bool>>], max_history: usize) -> bool {
        if previous_states.is_empty() {
            return false;
        }
        
        // 检查是否与之前某个状态相同（周期性）
        for (i, prev_state) in previous_states.iter().enumerate().rev().take(max_history) {
            if *prev_state == self.grid {
                return true;
            }
        }
        
        false
    }
    
    pub fn get_generation(&self) -> usize {
        self.generation
    }
}

// 生命游戏模式分析器
pub struct LifePatternAnalyzer;

impl LifePatternAnalyzer {
    pub fn analyze_evolution(initial_pattern: &GameOfLife, max_generations: usize) -> EvolutionAnalysis {
        let mut game = initial_pattern.clone();
        let mut populations = Vec::new();
        let mut states_history = Vec::new();
        
        populations.push(game.population());
        states_history.push(game.grid.clone());
        
        let mut stable_generation = None;
        let mut period = None;
        
        for gen in 1..=max_generations {
            game.step();
            let current_population = game.population();
            populations.push(current_population);
            
            // 检查稳定性
            if game.is_stable(&states_history, 20) {
                if stable_generation.is_none() {
                    stable_generation = Some(gen);
                    
                    // 计算周期
                    for i in 1..=std::cmp::min(20, states_history.len()) {
                        if states_history.len() >= i && game.grid == states_history[states_history.len() - i] {
                            period = Some(i);
                            break;
                        }
                    }
                }
            }
            
            states_history.push(game.grid.clone());
            
            // 如果连续多代稳定，可以提前结束
            if stable_generation.is_some() && gen - stable_generation.unwrap() > 10 {
                break;
            }
        }
        
        EvolutionAnalysis {
            initial_population: populations[0],
            final_population: *populations.last().unwrap(),
            max_population: *populations.iter().max().unwrap(),
            min_population: *populations.iter().min().unwrap(),
            population_history: populations,
            stable_generation,
            period,
            total_generations: game.get_generation(),
        }
    }
    
    pub fn classify_pattern(&self, analysis: &EvolutionAnalysis) -> LifePatternType {
        if analysis.final_population == 0 {
            LifePatternType::Dies
        } else if let Some(period) = analysis.period {
            match period {
                1 => LifePatternType::StillLife,
                2..=50 => LifePatternType::Oscillator(period),
                _ => LifePatternType::Complex,
            }
        } else if analysis.stable_generation.is_some() {
            LifePatternType::StillLife
        } else {
            // 检查是否是移动模式（如滑翔机）
            if Self::is_spaceship(&analysis.population_history) {
                LifePatternType::Spaceship
            } else {
                LifePatternType::Complex
            }
        }
    }
    
    fn is_spaceship(population_history: &[usize]) -> bool {
        // 简化的太空船检测：种群数量保持相对稳定
        if population_history.len() < 10 {
            return false;
        }
        
        let recent_pops = &population_history[population_history.len()-10..];
        let avg = recent_pops.iter().sum::<usize>() as f64 / recent_pops.len() as f64;
        let variance = recent_pops.iter()
            .map(|&x| (x as f64 - avg).powi(2))
            .sum::<f64>() / recent_pops.len() as f64;
        
        variance < avg * 0.1 // 变异系数小于10%
    }
}

#[derive(Debug)]
pub struct EvolutionAnalysis {
    pub initial_population: usize,
    pub final_population: usize,
    pub max_population: usize,
    pub min_population: usize,
    pub population_history: Vec<usize>,
    pub stable_generation: Option<usize>,
    pub period: Option<usize>,
    pub total_generations: usize,
}

#[derive(Debug, PartialEq)]
pub enum LifePatternType {
    Dies,
    StillLife,
    Oscillator(usize),
    Spaceship,
    Complex,
}
```

## 通用细胞自动机框架 / Generic Cellular Automata Framework

### 可配置的细胞自动机 / Configurable Cellular Automata

```rust
// 通用细胞自动机框架
// Generic cellular automata framework

use std::collections::HashMap;

pub trait CellularAutomaton {
    type State: Clone + PartialEq + std::fmt::Debug;
    type Position: Clone + PartialEq + Eq + std::hash::Hash + std::fmt::Debug;
    
    fn get_state(&self, pos: &Self::Position) -> Self::State;
    fn set_state(&mut self, pos: &Self::Position, state: Self::State);
    fn get_neighbors(&self, pos: &Self::Position) -> Vec<Self::Position>;
    fn transition_rule(&self, current_state: &Self::State, neighbor_states: &[Self::State]) -> Self::State;
    fn step(&mut self);
    fn get_generation(&self) -> usize;
}

// 通用的基于规则的细胞自动机
#[derive(Clone, Debug)]
pub struct RuleBasedCA<S, P> {
    states: HashMap<P, S>,
    default_state: S,
    rule_table: HashMap<(S, Vec<S>), S>,
    generation: usize,
    dimensions: Vec<usize>,
}

impl<S, P> RuleBasedCA<S, P>
where
    S: Clone + PartialEq + std::fmt::Debug + std::hash::Hash + Eq,
    P: Clone + PartialEq + Eq + std::hash::Hash + std::fmt::Debug,
{
    pub fn new(default_state: S, dimensions: Vec<usize>) -> Self {
        Self {
            states: HashMap::new(),
            default_state,
            rule_table: HashMap::new(),
            generation: 0,
            dimensions,
        }
    }
    
    pub fn add_rule(&mut self, current: S, neighbors: Vec<S>, next: S) {
        self.rule_table.insert((current, neighbors), next);
    }
    
    pub fn get_all_positions(&self) -> Vec<P> {
        // 这个方法需要根据具体的位置类型实现
        // This method needs to be implemented based on the specific position type
        unimplemented!("Position enumeration depends on the specific position type")
    }
}

// 具体的二维整数位置实现
pub type Position2D = (i32, i32);

#[derive(Clone, Debug)]
pub struct CA2D<S> {
    states: HashMap<Position2D, S>,
    default_state: S,
    width: usize,
    height: usize,
    generation: usize,
    neighborhood_type: NeighborhoodType,
}

#[derive(Clone, Debug, PartialEq)]
pub enum NeighborhoodType {
    Moore,      // 8-邻域
    VonNeumann, // 4-邻域
    Custom(Vec<(i32, i32)>),
}

impl<S> CA2D<S>
where
    S: Clone + PartialEq + std::fmt::Debug,
{
    pub fn new(width: usize, height: usize, default_state: S, neighborhood: NeighborhoodType) -> Self {
        Self {
            states: HashMap::new(),
            default_state,
            width,
            height,
            generation: 0,
            neighborhood_type: neighborhood,
        }
    }
    
    pub fn get_neighbors(&self, pos: &Position2D) -> Vec<Position2D> {
        let (x, y) = *pos;
        let offsets = match &self.neighborhood_type {
            NeighborhoodType::Moore => vec![
                (-1, -1), (-1, 0), (-1, 1),
                (0, -1),           (0, 1),
                (1, -1),  (1, 0),  (1, 1),
            ],
            NeighborhoodType::VonNeumann => vec![
                (-1, 0), (0, -1), (0, 1), (1, 0),
            ],
            NeighborhoodType::Custom(offsets) => offsets.clone(),
        };
        
        offsets
            .into_iter()
            .map(|(dx, dy)| (x + dx, y + dy))
            .filter(|(nx, ny)| {
                *nx >= 0 && *ny >= 0 && 
                (*nx as usize) < self.width && (*ny as usize) < self.height
            })
            .collect()
    }
    
    pub fn set_state(&mut self, pos: Position2D, state: S) {
        if pos.0 >= 0 && pos.1 >= 0 && 
           (pos.0 as usize) < self.width && (pos.1 as usize) < self.height {
            self.states.insert(pos, state);
        }
    }
    
    pub fn get_state(&self, pos: &Position2D) -> S {
        self.states.get(pos).cloned().unwrap_or_else(|| self.default_state.clone())
    }
    
    pub fn step<F>(&mut self, rule: F)
    where
        F: Fn(&S, &[S]) -> S,
    {
        let mut new_states = HashMap::new();
        
        for y in 0..self.height {
            for x in 0..self.width {
                let pos = (x as i32, y as i32);
                let current_state = self.get_state(&pos);
                let neighbors = self.get_neighbors(&pos);
                let neighbor_states: Vec<S> = neighbors
                    .iter()
                    .map(|neighbor_pos| self.get_state(neighbor_pos))
                    .collect();
                
                let new_state = rule(&current_state, &neighbor_states);
                if new_state != self.default_state {
                    new_states.insert(pos, new_state);
                }
            }
        }
        
        self.states = new_states;
        self.generation += 1;
    }
    
    pub fn get_generation(&self) -> usize {
        self.generation
    }
    
    pub fn population(&self) -> usize {
        self.states.len()
    }
    
    pub fn density(&self) -> f64 {
        self.states.len() as f64 / (self.width * self.height) as f64
    }
}

// 森林火灾模型
#[derive(Clone, Debug, PartialEq)]
pub enum ForestState {
    Empty,
    Tree,
    Burning,
}

pub struct ForestFireCA {
    ca: CA2D<ForestState>,
    growth_probability: f64,
    lightning_probability: f64,
}

impl ForestFireCA {
    pub fn new(width: usize, height: usize, growth_prob: f64, lightning_prob: f64) -> Self {
        Self {
            ca: CA2D::new(width, height, ForestState::Empty, NeighborhoodType::VonNeumann),
            growth_probability: growth_prob,
            lightning_probability: lightning_prob,
        }
    }
    
    pub fn step(&mut self) {
        let growth_prob = self.growth_probability;
        let lightning_prob = self.lightning_probability;
        
        self.ca.step(|current_state, neighbor_states| {
            match current_state {
                ForestState::Empty => {
                    // 空地可能长出树
                    if rand::random::<f64>() < growth_prob {
                        ForestState::Tree
                    } else {
                        ForestState::Empty
                    }
                }
                ForestState::Tree => {
                    // 树可能被雷击或邻近火灾点燃
                    let has_burning_neighbor = neighbor_states
                        .iter()
                        .any(|state| *state == ForestState::Burning);
                    
                    if has_burning_neighbor || rand::random::<f64>() < lightning_prob {
                        ForestState::Burning
                    } else {
                        ForestState::Tree
                    }
                }
                ForestState::Burning => {
                    // 燃烧的树变成空地
                    ForestState::Empty
                }
            }
        });
    }
    
    pub fn get_statistics(&self) -> ForestStatistics {
        let mut empty_count = 0;
        let mut tree_count = 0;
        let mut burning_count = 0;
        
        for y in 0..self.ca.height {
            for x in 0..self.ca.width {
                match self.ca.get_state(&(x as i32, y as i32)) {
                    ForestState::Empty => empty_count += 1,
                    ForestState::Tree => tree_count += 1,
                    ForestState::Burning => burning_count += 1,
                }
            }
        }
        
        let total = self.ca.width * self.ca.height;
        
        ForestStatistics {
            empty_count,
            tree_count,
            burning_count,
            empty_ratio: empty_count as f64 / total as f64,
            tree_ratio: tree_count as f64 / total as f64,
            burning_ratio: burning_count as f64 / total as f64,
            generation: self.ca.get_generation(),
        }
    }
    
    pub fn display(&self) -> String {
        let mut result = String::new();
        for y in 0..self.ca.height {
            for x in 0..self.ca.width {
                let state = self.ca.get_state(&(x as i32, y as i32));
                let char = match state {
                    ForestState::Empty => '·',
                    ForestState::Tree => '♦',
                    ForestState::Burning => '♦',  // 或者用不同的字符表示燃烧
                };
                result.push(char);
            }
            result.push('\n');
        }
        result
    }
}

#[derive(Debug)]
pub struct ForestStatistics {
    pub empty_count: usize,
    pub tree_count: usize,
    pub burning_count: usize,
    pub empty_ratio: f64,
    pub tree_ratio: f64,
    pub burning_ratio: f64,
    pub generation: usize,
}
```

## 计算理论应用 / Computational Theory Applications

### 图灵完备性 / Turing Completeness

```rust
// 证明细胞自动机的图灵完备性
// Proving Turing completeness of cellular automata

pub struct UniversalCA {
    ca: OneDimensionalCA,
}

impl UniversalCA {
    // Rule 110是已知的图灵完备规则
    pub fn new_rule_110() -> Self {
        Self {
            ca: OneDimensionalCA::new(1000, 110),
        }
    }
    
    // 模拟图灵机操作
    pub fn simulate_turing_machine(&mut self, program: &TuringMachineProgram) -> Result<(), String> {
        // 将图灵机程序编码到细胞自动机的初始状态
        self.encode_turing_machine(program)?;
        
        // 运行细胞自动机直到达到停止条件
        let max_steps = 10000;
        for _ in 0..max_steps {
            self.ca.step();
            
            // 检查是否达到停止状态
            if self.is_halted() {
                break;
            }
        }
        
        Ok(())
    }
    
    fn encode_turing_machine(&mut self, program: &TuringMachineProgram) -> Result<(), String> {
        // 将图灵机的状态、转移表和磁带内容编码到CA的初始配置中
        // 这是一个复杂的编码过程，这里简化处理
        
        // 在CA中设置特殊的配置来表示图灵机
        let tape_start = 100;
        for (i, &symbol) in program.initial_tape.iter().enumerate() {
            if symbol == 1 {
                self.ca.cells[tape_start + i] = 1;
            }
        }
        
        // 设置状态编码
        let state_position = 50;
        self.encode_state(state_position, &program.initial_state);
        
        Ok(())
    }
    
    fn encode_state(&mut self, position: usize, state: &str) {
        // 将状态编码为二进制模式
        let state_hash = state.chars().map(|c| c as u8).sum::<u8>();
        for i in 0..8 {
            if (state_hash >> i) & 1 == 1 {
                self.ca.cells[position + i] = 1;
            }
        }
    }
    
    fn is_halted(&self) -> bool {
        // 检查是否存在停止模式
        // 这里简化为检查是否存在特定的周期性模式
        self.ca.detect_period(20).is_some()
    }
    
    // 构造通用计算模式
    pub fn create_universal_constructor() -> Self {
        let mut ca = Self::new_rule_110();
        
        // 设置通用构造器的初始配置
        // 这是一个能够构造任意模式的特殊配置
        let constructor_pattern = vec![
            1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1
        ];
        
        let start_pos = 400;
        for (i, &bit) in constructor_pattern.iter().enumerate() {
            ca.ca.cells[start_pos + i] = bit;
        }
        
        ca
    }
}

#[derive(Debug)]
pub struct TuringMachineProgram {
    pub initial_state: String,
    pub initial_tape: Vec<u8>,
    pub transition_table: HashMap<(String, u8), (String, u8, Direction)>,
    pub halt_states: Vec<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Direction {
    Left,
    Right,
}

// 复杂性类分析
pub struct ComplexityAnalyzer;

impl ComplexityAnalyzer {
    pub fn analyze_computational_power(rule: u8) -> ComputationalPower {
        let mut ca = OneDimensionalCA::new(200, rule);
        
        // 测试不同的计算任务
        let can_count = Self::test_counting_ability(&mut ca);
        let can_recognize_patterns = Self::test_pattern_recognition(&mut ca);
        let is_universal = Self::test_universality(rule);
        
        ComputationalPower {
            rule,
            can_count,
            can_recognize_patterns,
            is_universal,
            classification: WolframClassification::classify_rule(rule, 100, 20),
        }
    }
    
    fn test_counting_ability(ca: &mut OneDimensionalCA) -> bool {
        // 测试是否能够进行计数操作
        // 设置一个简单的计数模式
        ca.cells[50] = 1;
        ca.cells[51] = 1;
        ca.evolve(50);
        
        // 检查是否产生了规律的计数模式
        let pattern = &ca.cells[40..60];
        let ones_count = pattern.iter().filter(|&&x| x == 1).count();
        ones_count > 2 && ones_count < pattern.len() / 2
    }
    
    fn test_pattern_recognition(ca: &mut OneDimensionalCA) -> bool {
        // 测试模式识别能力
        // 设置一个特定模式并检查CA是否能识别
        let pattern = vec![1, 0, 1, 0, 1];
        for (i, &bit) in pattern.iter().enumerate() {
            ca.cells[100 + i] = bit;
        }
        
        ca.evolve(30);
        
        // 检查是否产生了响应模式
        ca.cells.iter().any(|&x| x == 1)
    }
    
    fn test_universality(rule: u8) -> bool {
        // 检查已知的通用规则
        match rule {
            110 => true,  // Rule 110是已知的图灵完备
            30 => false,  // Rule 30是混沌但不通用
            90 => false,  // Rule 90产生Sierpinski三角形
            _ => false,   // 其他规则假设不通用
        }
    }
}

#[derive(Debug)]
pub struct ComputationalPower {
    pub rule: u8,
    pub can_count: bool,
    pub can_recognize_patterns: bool,
    pub is_universal: bool,
    pub classification: WolframClass,
}
```

## 应用领域 / Application Areas

### 物理系统建模 / Physical System Modeling

```rust
// 物理系统的细胞自动机建模
// Cellular automata modeling of physical systems

// 流体动力学 - Lattice Boltzmann方法
#[derive(Clone, Debug)]
pub struct LatticeGasCA {
    grid: Vec<Vec<ParticleDistribution>>,
    width: usize,
    height: usize,
    generation: usize,
}

#[derive(Clone, Debug)]
pub struct ParticleDistribution {
    // 9个方向的粒子密度 (D2Q9模型)
    densities: [f64; 9],
}

impl ParticleDistribution {
    pub fn new() -> Self {
        Self {
            densities: [0.0; 9],
        }
    }
    
    pub fn total_density(&self) -> f64 {
        self.densities.iter().sum()
    }
    
    pub fn momentum(&self) -> (f64, f64) {
        // 计算动量
        let velocities = [
            (0.0, 0.0),   // 静止
            (1.0, 0.0),   // 东
            (0.0, 1.0),   // 北
            (-1.0, 0.0),  // 西
            (0.0, -1.0),  // 南
            (1.0, 1.0),   // 东北
            (-1.0, 1.0),  // 西北
            (-1.0, -1.0), // 西南
            (1.0, -1.0),  // 东南
        ];
        
        let mut px = 0.0;
        let mut py = 0.0;
        
        for i in 0..9 {
            px += self.densities[i] * velocities[i].0;
            py += self.densities[i] * velocities[i].1;
        }
        
        (px, py)
    }
}

impl LatticeGasCA {
    pub fn new(width: usize, height: usize) -> Self {
        Self {
            grid: vec![vec![ParticleDistribution::new(); width]; height],
            width,
            height,
            generation: 0,
        }
    }
    
    pub fn set_obstacle(&mut self, x: usize, y: usize) {
        // 设置障碍物（边界条件）
        if x < self.width && y < self.height {
            // 将所有方向的密度设为负值表示障碍
            for i in 0..9 {
                self.grid[y][x].densities[i] = -1.0;
            }
        }
    }
    
    pub fn add_inflow(&mut self, x: usize, y: usize, velocity: (f64, f64), density: f64) {
        if x < self.width && y < self.height {
            // 在指定位置添加流入
            let (vx, vy) = velocity;
            
            // 根据速度方向分配密度
            if vx > 0.0 {
                self.grid[y][x].densities[1] += density * vx;
            }
            if vy > 0.0 {
                self.grid[y][x].densities[2] += density * vy;
            }
            // ... 其他方向
        }
    }
    
    pub fn step(&mut self) {
        // Lattice Boltzmann步骤：碰撞和传播
        self.collision_step();
        self.streaming_step();
        self.generation += 1;
    }
    
    fn collision_step(&mut self) {
        // BGK碰撞算子
        let tau = 1.0; // 松弛时间
        
        for y in 0..self.height {
            for x in 0..self.width {
                if self.is_obstacle(x, y) {
                    continue;
                }
                
                let distribution = &mut self.grid[y][x];
                let rho = distribution.total_density();
                let (u, v) = distribution.momentum();
                
                if rho > 0.0 {
                    let u_norm = u / rho;
                    let v_norm = v / rho;
                    
                    // 计算平衡分布
                    let eq_dist = self.equilibrium_distribution(rho, u_norm, v_norm);
                    
                    // BGK碰撞
                    for i in 0..9 {
                        distribution.densities[i] += 
                            (eq_dist[i] - distribution.densities[i]) / tau;
                    }
                }
            }
        }
    }
    
    fn streaming_step(&mut self) {
        let mut new_grid = vec![vec![ParticleDistribution::new(); self.width]; self.height];
        
        // 粒子传播方向
        let directions = [
            (0, 0),   // 静止
            (1, 0),   // 东
            (0, 1),   // 北
            (-1, 0),  // 西
            (0, -1),  // 南
            (1, 1),   // 东北
            (-1, 1),  // 西北
            (-1, -1), // 西南
            (1, -1),  // 东南
        ];
        
        for y in 0..self.height {
            for x in 0..self.width {
                for i in 0..9 {
                    let (dx, dy) = directions[i];
                    let nx = x as i32 + dx;
                    let ny = y as i32 + dy;
                    
                    if nx >= 0 && ny >= 0 && 
                       (nx as usize) < self.width && (ny as usize) < self.height {
                        let density = self.grid[y][x].densities[i];
                        new_grid[ny as usize][nx as usize].densities[i] = density;
                    }
                }
            }
        }
        
        self.grid = new_grid;
    }
    
    fn equilibrium_distribution(&self, rho: f64, u: f64, v: f64) -> [f64; 9] {
        // Maxwell-Boltzmann平衡分布
        let weights = [4.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0, 
                      1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0];
        
        let velocities = [
            (0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (-1.0, 0.0), (0.0, -1.0),
            (1.0, 1.0), (-1.0, 1.0), (-1.0, -1.0), (1.0, -1.0)
        ];
        
        let mut eq = [0.0; 9];
        let u_sq = u * u + v * v;
        
        for i in 0..9 {
            let (cx, cy) = velocities[i];
            let cu = cx * u + cy * v;
            
            eq[i] = weights[i] * rho * (1.0 + 3.0 * cu + 4.5 * cu * cu - 1.5 * u_sq);
        }
        
        eq
    }
    
    fn is_obstacle(&self, x: usize, y: usize) -> bool {
        x < self.width && y < self.height && 
        self.grid[y][x].densities[0] < 0.0
    }
    
    pub fn get_velocity_field(&self) -> Vec<Vec<(f64, f64)>> {
        let mut field = vec![vec![(0.0, 0.0); self.width]; self.height];
        
        for y in 0..self.height {
            for x in 0..self.width {
                if !self.is_obstacle(x, y) {
                    let rho = self.grid[y][x].total_density();
                    if rho > 0.0 {
                        let (px, py) = self.grid[y][x].momentum();
                        field[y][x] = (px / rho, py / rho);
                    }
                }
            }
        }
        
        field
    }
}

// 生态系统建模 - 捕食者-猎物模型
#[derive(Clone, Debug, PartialEq)]
pub enum EcosystemState {
    Empty,
    Prey(u8),      // 猎物，数值表示年龄
    Predator(u8),  // 捕食者，数值表示饥饿程度
}

pub struct EcosystemCA {
    ca: CA2D<EcosystemState>,
    prey_reproduction_age: u8,
    predator_starvation_limit: u8,
    reproduction_probability: f64,
}

impl EcosystemCA {
    pub fn new(width: usize, height: usize) -> Self {
        Self {
            ca: CA2D::new(width, height, EcosystemState::Empty, NeighborhoodType::Moore),
            prey_reproduction_age: 3,
            predator_starvation_limit: 5,
            reproduction_probability: 0.3,
        }
    }
    
    pub fn step(&mut self) {
        let prey_repr_age = self.prey_reproduction_age;
        let pred_starv_limit = self.predator_starvation_limit;
        let repr_prob = self.reproduction_probability;
        
        self.ca.step(|current_state, neighbor_states| {
            match current_state {
                EcosystemState::Empty => {
                    // 空位可能被占据
                    let prey_neighbors = neighbor_states.iter()
                        .filter(|s| matches!(s, EcosystemState::Prey(_)))
                        .count();
                    
                    if prey_neighbors > 0 && rand::random::<f64>() < repr_prob {
                        EcosystemState::Prey(0)
                    } else {
                        EcosystemState::Empty
                    }
                }
                
                EcosystemState::Prey(age) => {
                    // 检查是否被捕食
                    let predator_neighbors = neighbor_states.iter()
                        .any(|s| matches!(s, EcosystemState::Predator(_)));
                    
                    if predator_neighbors && rand::random::<f64>() < 0.8 {
                        EcosystemState::Empty // 被吃掉
                    } else if *age >= prey_repr_age {
                        EcosystemState::Prey(0) // 繁殖后重置年龄
                    } else {
                        EcosystemState::Prey(age + 1) // 年龄增长
                    }
                }
                
                EcosystemState::Predator(hunger) => {
                    // 检查是否能找到食物
                    let prey_neighbors = neighbor_states.iter()
                        .any(|s| matches!(s, EcosystemState::Prey(_)));
                    
                    if prey_neighbors {
                        EcosystemState::Predator(0) // 找到食物，重置饥饿
                    } else if *hunger >= pred_starv_limit {
                        EcosystemState::Empty // 饿死
                    } else {
                        EcosystemState::Predator(hunger + 1) // 饥饿增加
                    }
                }
            }
        });
    }
    
    pub fn get_population_stats(&self) -> EcosystemStats {
        let mut prey_count = 0;
        let mut predator_count = 0;
        let mut empty_count = 0;
        
        for y in 0..self.ca.height {
            for x in 0..self.ca.width {
                match self.ca.get_state(&(x as i32, y as i32)) {
                    EcosystemState::Empty => empty_count += 1,
                    EcosystemState::Prey(_) => prey_count += 1,
                    EcosystemState::Predator(_) => predator_count += 1,
                }
            }
        }
        
        EcosystemStats {
            prey_count,
            predator_count,
            empty_count,
            generation: self.ca.get_generation(),
        }
    }
}

#[derive(Debug)]
pub struct EcosystemStats {
    pub prey_count: usize,
    pub predator_count: usize,
    pub empty_count: usize,
    pub generation: usize,
}
```

## 总结 / Summary

细胞自动机理论为我们提供了一个强大的工具来研究复杂系统、模拟自然现象和探索计算的基本性质。通过简单的局部规则，细胞自动机能够产生丰富的全局行为，展现了复杂性科学的核心思想。

Cellular automata theory provides us with a powerful tool for studying complex systems, simulating natural phenomena, and exploring fundamental properties of computation. Through simple local rules, cellular automata can generate rich global behavior, demonstrating core ideas of complexity science.

### 关键特点 / Key Features

1. **简单规则，复杂行为** / Simple Rules, Complex Behavior
   - 局部规则产生全局模式
   - 涌现现象的典型例子

2. **计算通用性** / Computational Universality
   - 某些CA规则是图灵完备的
   - 能够模拟任意计算

3. **广泛应用** / Wide Applications
   - 物理系统建模
   - 生物生态系统模拟
   - 社会现象研究

4. **理论基础** / Theoretical Foundation
   - 动力系统理论
   - 计算复杂性理论
   - 统计物理学

---

**参考文献 / References**:

1. Wolfram, S. (2002). A new kind of science. Wolfram Media.
2. Gardner, M. (1970). Mathematical games: The fantastic combinations of John Conway's new solitaire game "life". Scientific American, 223(4), 120-123.
3. von Neumann, J., & Burks, A. W. (1966). Theory of self-reproducing automata. University of Illinois Press.
4. Cook, M. (2004). Universality in elementary cellular automata. Complex systems, 15(1), 1-40.
5. Toffoli, T., & Margolus, N. (1987). Cellular automata machines: a new environment for modeling. MIT press.
