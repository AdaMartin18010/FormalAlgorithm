---
title: 7.6 ç»†èƒè‡ªåŠ¨æœºç†è®º / Cellular Automata Theory
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: è®¡ç®—æ¨¡å‹å·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 7.6 ç»†èƒè‡ªåŠ¨æœºç†è®º / Cellular Automata Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€ç»†èƒè‡ªåŠ¨æœºçš„å½¢å¼åŒ–å®šä¹‰ã€ä¸€ç»´/äºŒç»´ç»†èƒè‡ªåŠ¨æœºä¸è®¡ç®—ç†è®ºåº”ç”¨ã€‚
- å»ºç«‹ç»†èƒè‡ªåŠ¨æœºåœ¨å¤æ‚ç³»ç»Ÿç ”ç©¶ä¸­çš„åœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ç»†èƒè‡ªåŠ¨æœºã€ä¸€ç»´ç»†èƒè‡ªåŠ¨æœºã€äºŒç»´ç»†èƒè‡ªåŠ¨æœºã€ç”Ÿå‘½æ¸¸æˆã€å›¾çµå®Œå¤‡æ€§ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ç»†èƒè‡ªåŠ¨æœºï¼ˆCellular Automatonï¼‰ï¼šç¦»æ•£çš„æ•°å­¦æ¨¡å‹ï¼Œç”±è§„åˆ™ç½‘æ ¼ä¸­çš„ç»†èƒç»„æˆã€‚
- å±€éƒ¨è§„åˆ™ï¼ˆLocal Ruleï¼‰ï¼šå†³å®šç»†èƒçŠ¶æ€æ›´æ–°çš„è§„åˆ™ã€‚
- å›¾çµå®Œå¤‡æ€§ï¼ˆTuring Completenessï¼‰ï¼šèƒ½å¤Ÿæ¨¡æ‹Ÿå›¾çµæœºçš„è®¡ç®—èƒ½åŠ›ã€‚
- è®°å·çº¦å®šï¼š`L` è¡¨ç¤ºç½‘æ ¼ï¼Œ`S` è¡¨ç¤ºçŠ¶æ€é›†ï¼Œ`f` è¡¨ç¤ºè½¬ç§»å‡½æ•°ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- å›¾çµæœºï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/01-å›¾çµæœº.md`ã€‚
- è®¡ç®—æ¨¡å‹ï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/` ç›¸å…³æ–‡æ¡£ã€‚
- å¤æ‚ç³»ç»Ÿï¼šå‚è§ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- æ¦‚è¿°
- åŸºæœ¬æ¦‚å¿µ
- ä¸€ç»´ç»†èƒè‡ªåŠ¨æœº
- äºŒç»´ç»†èƒè‡ªåŠ¨æœº

## ç›®å½• (Table of Contents)

- [7.6 ç»†èƒè‡ªåŠ¨æœºç†è®º / Cellular Automata Theory](#76-ç»†èƒè‡ªåŠ¨æœºç†è®º--cellular-automata-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [æ¦‚è¿° / Overview](#æ¦‚è¿°--overview)
- [åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [ç»†èƒè‡ªåŠ¨æœºå®šä¹‰ / Definition of Cellular Automata](#ç»†èƒè‡ªåŠ¨æœºå®šä¹‰--definition-of-cellular-automata)
  - [ç»†èƒè‡ªåŠ¨æœºçš„ç»„æˆè¦ç´  / Components of Cellular Automata](#ç»†èƒè‡ªåŠ¨æœºçš„ç»„æˆè¦ç´ --components-of-cellular-automata)
- [ä¸€ç»´ç»†èƒè‡ªåŠ¨æœº / One-Dimensional Cellular Automata](#ä¸€ç»´ç»†èƒè‡ªåŠ¨æœº--one-dimensional-cellular-automata)
  - [åŸºæœ¬å®ç° / Basic Implementation](#åŸºæœ¬å®ç°--basic-implementation)
  - [è‘—åçš„ä¸€ç»´è§„åˆ™ / Famous One-Dimensional Rules](#è‘—åçš„ä¸€ç»´è§„åˆ™--famous-one-dimensional-rules)
- [äºŒç»´ç»†èƒè‡ªåŠ¨æœº / Two-Dimensional Cellular Automata](#äºŒç»´ç»†èƒè‡ªåŠ¨æœº--two-dimensional-cellular-automata)
  - [ç”Ÿå‘½æ¸¸æˆ / Game of Life](#ç”Ÿå‘½æ¸¸æˆ--game-of-life)
- [é€šç”¨ç»†èƒè‡ªåŠ¨æœºæ¡†æ¶ / Generic Cellular Automata Framework](#é€šç”¨ç»†èƒè‡ªåŠ¨æœºæ¡†æ¶--generic-cellular-automata-framework)
  - [å¯é…ç½®çš„ç»†èƒè‡ªåŠ¨æœº / Configurable Cellular Automata](#å¯é…ç½®çš„ç»†èƒè‡ªåŠ¨æœº--configurable-cellular-automata)
- [è®¡ç®—ç†è®ºåº”ç”¨ / Computational Theory Applications](#è®¡ç®—ç†è®ºåº”ç”¨--computational-theory-applications)
  - [å›¾çµå®Œå¤‡æ€§ / Turing Completeness](#å›¾çµå®Œå¤‡æ€§--turing-completeness)
- [åº”ç”¨é¢†åŸŸ / Application Areas](#åº”ç”¨é¢†åŸŸ--application-areas)
  - [ç‰©ç†ç³»ç»Ÿå»ºæ¨¡ / Physical System Modeling](#ç‰©ç†ç³»ç»Ÿå»ºæ¨¡--physical-system-modeling)
- [æ€»ç»“ / Summary](#æ€»ç»“--summary)
  - [å…³é”®ç‰¹ç‚¹ / Key Features](#å…³é”®ç‰¹ç‚¹--key-features)
- [å‚è€ƒæ–‡çŒ® / References](#å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)

## æ¦‚è¿° / Overview

ç»†èƒè‡ªåŠ¨æœºæ˜¯ä¸€ç§ç¦»æ•£çš„æ•°å­¦æ¨¡å‹ï¼Œç”±è§„åˆ™ç½‘æ ¼ä¸­çš„ç»†èƒç»„æˆï¼Œæ¯ä¸ªç»†èƒæ ¹æ®ç®€å•çš„å±€éƒ¨è§„åˆ™åŒæ­¥æ›´æ–°å…¶çŠ¶æ€ã€‚å°½ç®¡è§„åˆ™ç®€å•ï¼Œç»†èƒè‡ªåŠ¨æœºèƒ½å¤Ÿå±•ç°å‡ºå¤æ‚çš„å…¨å±€è¡Œä¸ºï¼Œæ˜¯ç ”ç©¶å¤æ‚ç³»ç»Ÿã€è‡ªç»„ç»‡ç°è±¡å’Œè®¡ç®—ç†è®ºçš„é‡è¦å·¥å…·ã€‚

Cellular automata are discrete mathematical models consisting of cells arranged in a regular grid, where each cell updates its state synchronously according to simple local rules. Despite simple rules, cellular automata can exhibit complex global behavior and serve as important tools for studying complex systems, self-organization phenomena, and computational theory.

## åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### ç»†èƒè‡ªåŠ¨æœºå®šä¹‰ / Definition of Cellular Automata

**å®šä¹‰ 1.1** (ç»†èƒè‡ªåŠ¨æœº / Cellular Automaton)
ä¸€ä¸ªç»†èƒè‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªå››å…ƒç»„ (L, S, N, f)ï¼Œå…¶ä¸­ï¼š

- L æ˜¯ç»†èƒçš„æ’åˆ—æ ¼å±€ï¼ˆé€šå¸¸æ˜¯è§„åˆ™ç½‘æ ¼ï¼‰
- S æ˜¯æœ‰é™çš„çŠ¶æ€é›†åˆ
- N æ˜¯é‚»åŸŸå®šä¹‰
- f: S^|N| â†’ S æ˜¯å±€éƒ¨è½¬ç§»å‡½æ•°

**Definition 1.1** (Cellular Automaton)
A cellular automaton is a 4-tuple (L, S, N, f), where:

- L is the cell arrangement lattice (usually a regular grid)
- S is a finite set of states
- N is the neighborhood definition
- f: S^|N| â†’ S is the local transition function

### ç»†èƒè‡ªåŠ¨æœºçš„ç»„æˆè¦ç´  / Components of Cellular Automata

1. **ç½‘æ ¼ç»“æ„** / Grid Structure
   - ä¸€ç»´ã€äºŒç»´æˆ–é«˜ç»´ç½‘æ ¼
   - æœ‰é™æˆ–æ— é™ç½‘æ ¼

2. **çŠ¶æ€ç©ºé—´** / State Space
   - æ¯ä¸ªç»†èƒå¯èƒ½çš„çŠ¶æ€é›†åˆ
   - é€šå¸¸æ˜¯æœ‰é™é›†åˆ

3. **é‚»åŸŸ** / Neighborhood
   - å½±å“ç»†èƒçŠ¶æ€æ›´æ–°çš„é‚»è¿‘ç»†èƒ
   - å¸¸è§çš„æœ‰å†¯Â·è¯ºä¾æ›¼é‚»åŸŸå’Œæ‘©å°”é‚»åŸŸ

4. **è½¬ç§»è§„åˆ™** / Transition Rules
   - å†³å®šç»†èƒä¸‹ä¸€æ—¶åˆ»çŠ¶æ€çš„å‡½æ•°
   - åŸºäºå½“å‰ç»†èƒåŠå…¶é‚»åŸŸçš„çŠ¶æ€

## ä¸€ç»´ç»†èƒè‡ªåŠ¨æœº / One-Dimensional Cellular Automata

### åŸºæœ¬å®ç° / Basic Implementation

```rust
// ä¸€ç»´ç»†èƒè‡ªåŠ¨æœºå®ç°
// One-dimensional cellular automaton implementation

use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq)]
pub struct OneDimensionalCA {
    cells: Vec<u8>,
    rule: u8,
    size: usize,
    generation: usize,
}

impl OneDimensionalCA {
    pub fn new(size: usize, rule: u8) -> Self {
        let mut cells = vec![0; size];
        // åœ¨ä¸­é—´æ”¾ç½®ä¸€ä¸ªæ´»ç»†èƒä½œä¸ºç§å­
        if size > 0 {
            cells[size / 2] = 1;
        }

        Self {
            cells,
            rule,
            size,
            generation: 0,
        }
    }

    pub fn with_initial_state(size: usize, rule: u8, initial_state: Vec<u8>) -> Self {
        assert_eq!(initial_state.len(), size);

        Self {
            cells: initial_state,
            rule,
            size,
            generation: 0,
        }
    }

    pub fn step(&mut self) {
        let mut new_cells = vec![0; self.size];

        for i in 0..self.size {
            let left = if i == 0 { 0 } else { self.cells[i - 1] };
            let center = self.cells[i];
            let right = if i == self.size - 1 { 0 } else { self.cells[i + 1] };

            // è®¡ç®—ä¸‰ä¸ªé‚»å±…çš„é…ç½®
            let config = (left << 2) | (center << 1) | right;

            // åº”ç”¨è§„åˆ™
            new_cells[i] = (self.rule >> config) & 1;
        }

        self.cells = new_cells;
        self.generation += 1;
    }

    pub fn evolve(&mut self, steps: usize) {
        for _ in 0..steps {
            self.step();
        }
    }

    pub fn get_cells(&self) -> &[u8] {
        &self.cells
    }

    pub fn get_generation(&self) -> usize {
        self.generation
    }

    pub fn display(&self) -> String {
        self.cells
            .iter()
            .map(|&cell| if cell == 1 { 'â–ˆ' } else { ' ' })
            .collect()
    }

    // è®¡ç®—å¯†åº¦ï¼ˆæ´»ç»†èƒæ¯”ä¾‹ï¼‰
    pub fn density(&self) -> f64 {
        let alive_count = self.cells.iter().filter(|&&cell| cell == 1).count();
        alive_count as f64 / self.size as f64
    }

    // æ£€æµ‹å‘¨æœŸæ€§æ¨¡å¼
    pub fn detect_period(&self, max_steps: usize) -> Option<usize> {
        let mut states = HashMap::new();
        let mut ca = self.clone();

        for step in 0..max_steps {
            let state_key = ca.cells.clone();
            if let Some(previous_step) = states.get(&state_key) {
                return Some(step - previous_step);
            }
            states.insert(state_key, step);
            ca.step();
        }

        None
    }
}

// Wolframåˆ†ç±»ç³»ç»Ÿ
pub struct WolframClassification;

impl WolframClassification {
    pub fn classify_rule(rule: u8, steps: usize, samples: usize) -> WolframClass {
        let mut total_entropy = 0.0;
        let mut periodic_count = 0;
        let mut chaotic_count = 0;

        for seed in 0..samples {
            let mut ca = OneDimensionalCA::new(100, rule);
            // ä½¿ç”¨ä¸åŒçš„åˆå§‹æ¡ä»¶
            if seed % 2 == 1 {
                ca.cells[25] = 1;
                ca.cells[75] = 1;
            }

            ca.evolve(steps);

            // è®¡ç®—æœ€ç»ˆçŠ¶æ€çš„ç†µ
            let entropy = Self::calculate_entropy(&ca.cells);
            total_entropy += entropy;

            // æ£€æµ‹å‘¨æœŸæ€§
            if let Some(period) = ca.detect_period(50) {
                if period <= 10 {
                    periodic_count += 1;
                } else {
                    chaotic_count += 1;
                }
            } else {
                chaotic_count += 1;
            }
        }

        let average_entropy = total_entropy / samples as f64;
        let periodic_ratio = periodic_count as f64 / samples as f64;

        if average_entropy < 0.1 {
            WolframClass::ClassI
        } else if periodic_ratio > 0.8 {
            WolframClass::ClassII
        } else if average_entropy > 0.9 {
            WolframClass::ClassIV
        } else {
            WolframClass::ClassIII
        }
    }

    fn calculate_entropy(cells: &[u8]) -> f64 {
        let total = cells.len() as f64;
        let ones = cells.iter().filter(|&&x| x == 1).count() as f64;
        let zeros = total - ones;

        if ones == 0.0 || zeros == 0.0 {
            return 0.0;
        }

        let p_one = ones / total;
        let p_zero = zeros / total;

        -(p_one * p_one.log2() + p_zero * p_zero.log2())
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum WolframClass {
    ClassI,   // åŒè´¨æ€
    ClassII,  // å‘¨æœŸæ€§ç»“æ„
    ClassIII, // æ··æ²Œè¡Œä¸º
    ClassIV,  // å¤æ‚ç»“æ„
}
```

### è‘—åçš„ä¸€ç»´è§„åˆ™ / Famous One-Dimensional Rules

```rust
// è‘—åçš„ç»†èƒè‡ªåŠ¨æœºè§„åˆ™
// Famous cellular automaton rules

pub struct FamousRules;

impl FamousRules {
    // Rule 30: äº§ç”Ÿä¼ªéšæœºåºåˆ—
    pub fn rule_30() -> OneDimensionalCA {
        OneDimensionalCA::new(101, 30)
    }

    // Rule 90: ç”ŸæˆSierpinskiä¸‰è§’å½¢
    pub fn rule_90() -> OneDimensionalCA {
        OneDimensionalCA::new(101, 90)
    }

    // Rule 110: å›¾çµå®Œå¤‡
    pub fn rule_110() -> OneDimensionalCA {
        OneDimensionalCA::new(101, 110)
    }

    // Rule 184: äº¤é€šæµæ¨¡å‹
    pub fn rule_184() -> OneDimensionalCA {
        OneDimensionalCA::new(101, 184)
    }

    // åˆ†æè§„åˆ™çš„ç‰¹æ€§
    pub fn analyze_rule(rule: u8) -> RuleAnalysis {
        let mut ca = OneDimensionalCA::new(101, rule);
        let initial_density = ca.density();

        ca.evolve(100);
        let final_density = ca.density();

        let period = ca.detect_period(50);
        let classification = WolframClassification::classify_rule(rule, 100, 10);

        RuleAnalysis {
            rule,
            initial_density,
            final_density,
            density_change: final_density - initial_density,
            period,
            classification,
        }
    }
}

#[derive(Debug)]
pub struct RuleAnalysis {
    pub rule: u8,
    pub initial_density: f64,
    pub final_density: f64,
    pub density_change: f64,
    pub period: Option<usize>,
    pub classification: WolframClass,
}
```

## äºŒç»´ç»†èƒè‡ªåŠ¨æœº / Two-Dimensional Cellular Automata

### ç”Ÿå‘½æ¸¸æˆ / Game of Life

```rust
// Conwayçš„ç”Ÿå‘½æ¸¸æˆå®ç°
// Conway's Game of Life implementation

#[derive(Clone, Debug)]
pub struct GameOfLife {
    grid: Vec<Vec<bool>>,
    width: usize,
    height: usize,
    generation: usize,
}

impl GameOfLife {
    pub fn new(width: usize, height: usize) -> Self {
        Self {
            grid: vec![vec![false; width]; height],
            width,
            height,
            generation: 0,
        }
    }

    pub fn set_cell(&mut self, x: usize, y: usize, alive: bool) {
        if x < self.width && y < self.height {
            self.grid[y][x] = alive;
        }
    }

    pub fn get_cell(&self, x: usize, y: usize) -> bool {
        if x < self.width && y < self.height {
            self.grid[y][x]
        } else {
            false
        }
    }

    pub fn count_neighbors(&self, x: usize, y: usize) -> usize {
        let mut count = 0;

        for dy in -1i32..=1 {
            for dx in -1i32..=1 {
                if dx == 0 && dy == 0 {
                    continue;
                }

                let nx = x as i32 + dx;
                let ny = y as i32 + dy;

                if nx >= 0 && ny >= 0 && (nx as usize) < self.width && (ny as usize) < self.height {
                    if self.grid[ny as usize][nx as usize] {
                        count += 1;
                    }
                }
            }
        }

        count
    }

    pub fn step(&mut self) {
        let mut new_grid = vec![vec![false; self.width]; self.height];

        for y in 0..self.height {
            for x in 0..self.width {
                let neighbors = self.count_neighbors(x, y);
                let current_cell = self.grid[y][x];

                // Conwayçš„ç”Ÿå‘½æ¸¸æˆè§„åˆ™
                new_grid[y][x] = match (current_cell, neighbors) {
                    (true, 2) | (true, 3) => true,  // ç”Ÿå­˜
                    (false, 3) => true,             // ç¹æ®–
                    _ => false,                     // æ­»äº¡æˆ–ä¿æŒæ­»äº¡
                };
            }
        }

        self.grid = new_grid;
        self.generation += 1;
    }

    pub fn evolve(&mut self, steps: usize) {
        for _ in 0..steps {
            self.step();
        }
    }

    pub fn population(&self) -> usize {
        self.grid.iter()
            .flat_map(|row| row.iter())
            .filter(|&&cell| cell)
            .count()
    }

    pub fn display(&self) -> String {
        let mut result = String::new();
        for row in &self.grid {
            for &cell in row {
                result.push(if cell { 'â–ˆ' } else { 'Â·' });
            }
            result.push('\n');
        }
        result
    }

    // è®¾ç½®å¸¸è§çš„åˆå§‹æ¨¡å¼
    pub fn set_glider(&mut self, x: usize, y: usize) {
        let pattern = vec![
            (1, 0), (2, 1), (0, 2), (1, 2), (2, 2)
        ];

        for (dx, dy) in pattern {
            self.set_cell(x + dx, y + dy, true);
        }
    }

    pub fn set_oscillator_blinker(&mut self, x: usize, y: usize) {
        self.set_cell(x, y, true);
        self.set_cell(x + 1, y, true);
        self.set_cell(x + 2, y, true);
    }

    pub fn set_still_life_block(&mut self, x: usize, y: usize) {
        self.set_cell(x, y, true);
        self.set_cell(x + 1, y, true);
        self.set_cell(x, y + 1, true);
        self.set_cell(x + 1, y + 1, true);
    }

    // æ£€æµ‹ç¨³å®šæ¨¡å¼
    pub fn is_stable(&self, previous_states: &[Vec<Vec<bool>>], max_history: usize) -> bool {
        if previous_states.is_empty() {
            return false;
        }

        // æ£€æŸ¥æ˜¯å¦ä¸ä¹‹å‰æŸä¸ªçŠ¶æ€ç›¸åŒï¼ˆå‘¨æœŸæ€§ï¼‰
        for (i, prev_state) in previous_states.iter().enumerate().rev().take(max_history) {
            if *prev_state == self.grid {
                return true;
            }
        }

        false
    }

    pub fn get_generation(&self) -> usize {
        self.generation
    }
}

// ç”Ÿå‘½æ¸¸æˆæ¨¡å¼åˆ†æå™¨
pub struct LifePatternAnalyzer;

impl LifePatternAnalyzer {
    pub fn analyze_evolution(initial_pattern: &GameOfLife, max_generations: usize) -> EvolutionAnalysis {
        let mut game = initial_pattern.clone();
        let mut populations = Vec::new();
        let mut states_history = Vec::new();

        populations.push(game.population());
        states_history.push(game.grid.clone());

        let mut stable_generation = None;
        let mut period = None;

        for gen in 1..=max_generations {
            game.step();
            let current_population = game.population();
            populations.push(current_population);

            // æ£€æŸ¥ç¨³å®šæ€§
            if game.is_stable(&states_history, 20) {
                if stable_generation.is_none() {
                    stable_generation = Some(gen);

                    // è®¡ç®—å‘¨æœŸ
                    for i in 1..=std::cmp::min(20, states_history.len()) {
                        if states_history.len() >= i && game.grid == states_history[states_history.len() - i] {
                            period = Some(i);
                            break;
                        }
                    }
                }
            }

            states_history.push(game.grid.clone());

            // å¦‚æœè¿ç»­å¤šä»£ç¨³å®šï¼Œå¯ä»¥æå‰ç»“æŸ
            if stable_generation.is_some() && gen - stable_generation.unwrap() > 10 {
                break;
            }
        }

        EvolutionAnalysis {
            initial_population: populations[0],
            final_population: *populations.last().unwrap(),
            max_population: *populations.iter().max().unwrap(),
            min_population: *populations.iter().min().unwrap(),
            population_history: populations,
            stable_generation,
            period,
            total_generations: game.get_generation(),
        }
    }

    pub fn classify_pattern(&self, analysis: &EvolutionAnalysis) -> LifePatternType {
        if analysis.final_population == 0 {
            LifePatternType::Dies
        } else if let Some(period) = analysis.period {
            match period {
                1 => LifePatternType::StillLife,
                2..=50 => LifePatternType::Oscillator(period),
                _ => LifePatternType::Complex,
            }
        } else if analysis.stable_generation.is_some() {
            LifePatternType::StillLife
        } else {
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç§»åŠ¨æ¨¡å¼ï¼ˆå¦‚æ»‘ç¿”æœºï¼‰
            if Self::is_spaceship(&analysis.population_history) {
                LifePatternType::Spaceship
            } else {
                LifePatternType::Complex
            }
        }
    }

    fn is_spaceship(population_history: &[usize]) -> bool {
        // ç®€åŒ–çš„å¤ªç©ºèˆ¹æ£€æµ‹ï¼šç§ç¾¤æ•°é‡ä¿æŒç›¸å¯¹ç¨³å®š
        if population_history.len() < 10 {
            return false;
        }

        let recent_pops = &population_history[population_history.len()-10..];
        let avg = recent_pops.iter().sum::<usize>() as f64 / recent_pops.len() as f64;
        let variance = recent_pops.iter()
            .map(|&x| (x as f64 - avg).powi(2))
            .sum::<f64>() / recent_pops.len() as f64;

        variance < avg * 0.1 // å˜å¼‚ç³»æ•°å°äº10%
    }
}

#[derive(Debug)]
pub struct EvolutionAnalysis {
    pub initial_population: usize,
    pub final_population: usize,
    pub max_population: usize,
    pub min_population: usize,
    pub population_history: Vec<usize>,
    pub stable_generation: Option<usize>,
    pub period: Option<usize>,
    pub total_generations: usize,
}

#[derive(Debug, PartialEq)]
pub enum LifePatternType {
    Dies,
    StillLife,
    Oscillator(usize),
    Spaceship,
    Complex,
}
```

## é€šç”¨ç»†èƒè‡ªåŠ¨æœºæ¡†æ¶ / Generic Cellular Automata Framework

### å¯é…ç½®çš„ç»†èƒè‡ªåŠ¨æœº / Configurable Cellular Automata

```rust
// é€šç”¨ç»†èƒè‡ªåŠ¨æœºæ¡†æ¶
// Generic cellular automata framework

use std::collections::HashMap;

pub trait CellularAutomaton {
    type State: Clone + PartialEq + std::fmt::Debug;
    type Position: Clone + PartialEq + Eq + std::hash::Hash + std::fmt::Debug;

    fn get_state(&self, pos: &Self::Position) -> Self::State;
    fn set_state(&mut self, pos: &Self::Position, state: Self::State);
    fn get_neighbors(&self, pos: &Self::Position) -> Vec<Self::Position>;
    fn transition_rule(&self, current_state: &Self::State, neighbor_states: &[Self::State]) -> Self::State;
    fn step(&mut self);
    fn get_generation(&self) -> usize;
}

// é€šç”¨çš„åŸºäºè§„åˆ™çš„ç»†èƒè‡ªåŠ¨æœº
#[derive(Clone, Debug)]
pub struct RuleBasedCA<S, P> {
    states: HashMap<P, S>,
    default_state: S,
    rule_table: HashMap<(S, Vec<S>), S>,
    generation: usize,
    dimensions: Vec<usize>,
}

impl<S, P> RuleBasedCA<S, P>
where
    S: Clone + PartialEq + std::fmt::Debug + std::hash::Hash + Eq,
    P: Clone + PartialEq + Eq + std::hash::Hash + std::fmt::Debug,
{
    pub fn new(default_state: S, dimensions: Vec<usize>) -> Self {
        Self {
            states: HashMap::new(),
            default_state,
            rule_table: HashMap::new(),
            generation: 0,
            dimensions,
        }
    }

    pub fn add_rule(&mut self, current: S, neighbors: Vec<S>, next: S) {
        self.rule_table.insert((current, neighbors), next);
    }

    pub fn get_all_positions(&self) -> Vec<P> {
        // è¿™ä¸ªæ–¹æ³•éœ€è¦æ ¹æ®å…·ä½“çš„ä½ç½®ç±»å‹å®ç°
        // This method needs to be implemented based on the specific position type
        unimplemented!("Position enumeration depends on the specific position type")
    }
}

// å…·ä½“çš„äºŒç»´æ•´æ•°ä½ç½®å®ç°
pub type Position2D = (i32, i32);

#[derive(Clone, Debug)]
pub struct CA2D<S> {
    states: HashMap<Position2D, S>,
    default_state: S,
    width: usize,
    height: usize,
    generation: usize,
    neighborhood_type: NeighborhoodType,
}

#[derive(Clone, Debug, PartialEq)]
pub enum NeighborhoodType {
    Moore,      // 8-é‚»åŸŸ
    VonNeumann, // 4-é‚»åŸŸ
    Custom(Vec<(i32, i32)>),
}

impl<S> CA2D<S>
where
    S: Clone + PartialEq + std::fmt::Debug,
{
    pub fn new(width: usize, height: usize, default_state: S, neighborhood: NeighborhoodType) -> Self {
        Self {
            states: HashMap::new(),
            default_state,
            width,
            height,
            generation: 0,
            neighborhood_type: neighborhood,
        }
    }

    pub fn get_neighbors(&self, pos: &Position2D) -> Vec<Position2D> {
        let (x, y) = *pos;
        let offsets = match &self.neighborhood_type {
            NeighborhoodType::Moore => vec![
                (-1, -1), (-1, 0), (-1, 1),
                (0, -1),           (0, 1),
                (1, -1),  (1, 0),  (1, 1),
            ],
            NeighborhoodType::VonNeumann => vec![
                (-1, 0), (0, -1), (0, 1), (1, 0),
            ],
            NeighborhoodType::Custom(offsets) => offsets.clone(),
        };

        offsets
            .into_iter()
            .map(|(dx, dy)| (x + dx, y + dy))
            .filter(|(nx, ny)| {
                *nx >= 0 && *ny >= 0 &&
                (*nx as usize) < self.width && (*ny as usize) < self.height
            })
            .collect()
    }

    pub fn set_state(&mut self, pos: Position2D, state: S) {
        if pos.0 >= 0 && pos.1 >= 0 &&
           (pos.0 as usize) < self.width && (pos.1 as usize) < self.height {
            self.states.insert(pos, state);
        }
    }

    pub fn get_state(&self, pos: &Position2D) -> S {
        self.states.get(pos).cloned().unwrap_or_else(|| self.default_state.clone())
    }

    pub fn step<F>(&mut self, rule: F)
    where
        F: Fn(&S, &[S]) -> S,
    {
        let mut new_states = HashMap::new();

        for y in 0..self.height {
            for x in 0..self.width {
                let pos = (x as i32, y as i32);
                let current_state = self.get_state(&pos);
                let neighbors = self.get_neighbors(&pos);
                let neighbor_states: Vec<S> = neighbors
                    .iter()
                    .map(|neighbor_pos| self.get_state(neighbor_pos))
                    .collect();

                let new_state = rule(&current_state, &neighbor_states);
                if new_state != self.default_state {
                    new_states.insert(pos, new_state);
                }
            }
        }

        self.states = new_states;
        self.generation += 1;
    }

    pub fn get_generation(&self) -> usize {
        self.generation
    }

    pub fn population(&self) -> usize {
        self.states.len()
    }

    pub fn density(&self) -> f64 {
        self.states.len() as f64 / (self.width * self.height) as f64
    }
}

// æ£®æ—ç«ç¾æ¨¡å‹
#[derive(Clone, Debug, PartialEq)]
pub enum ForestState {
    Empty,
    Tree,
    Burning,
}

pub struct ForestFireCA {
    ca: CA2D<ForestState>,
    growth_probability: f64,
    lightning_probability: f64,
}

impl ForestFireCA {
    pub fn new(width: usize, height: usize, growth_prob: f64, lightning_prob: f64) -> Self {
        Self {
            ca: CA2D::new(width, height, ForestState::Empty, NeighborhoodType::VonNeumann),
            growth_probability: growth_prob,
            lightning_probability: lightning_prob,
        }
    }

    pub fn step(&mut self) {
        let growth_prob = self.growth_probability;
        let lightning_prob = self.lightning_probability;

        self.ca.step(|current_state, neighbor_states| {
            match current_state {
                ForestState::Empty => {
                    // ç©ºåœ°å¯èƒ½é•¿å‡ºæ ‘
                    if rand::random::<f64>() < growth_prob {
                        ForestState::Tree
                    } else {
                        ForestState::Empty
                    }
                }
                ForestState::Tree => {
                    // æ ‘å¯èƒ½è¢«é›·å‡»æˆ–é‚»è¿‘ç«ç¾ç‚¹ç‡ƒ
                    let has_burning_neighbor = neighbor_states
                        .iter()
                        .any(|state| *state == ForestState::Burning);

                    if has_burning_neighbor || rand::random::<f64>() < lightning_prob {
                        ForestState::Burning
                    } else {
                        ForestState::Tree
                    }
                }
                ForestState::Burning => {
                    // ç‡ƒçƒ§çš„æ ‘å˜æˆç©ºåœ°
                    ForestState::Empty
                }
            }
        });
    }

    pub fn get_statistics(&self) -> ForestStatistics {
        let mut empty_count = 0;
        let mut tree_count = 0;
        let mut burning_count = 0;

        for y in 0..self.ca.height {
            for x in 0..self.ca.width {
                match self.ca.get_state(&(x as i32, y as i32)) {
                    ForestState::Empty => empty_count += 1,
                    ForestState::Tree => tree_count += 1,
                    ForestState::Burning => burning_count += 1,
                }
            }
        }

        let total = self.ca.width * self.ca.height;

        ForestStatistics {
            empty_count,
            tree_count,
            burning_count,
            empty_ratio: empty_count as f64 / total as f64,
            tree_ratio: tree_count as f64 / total as f64,
            burning_ratio: burning_count as f64 / total as f64,
            generation: self.ca.get_generation(),
        }
    }

    pub fn display(&self) -> String {
        let mut result = String::new();
        for y in 0..self.ca.height {
            for x in 0..self.ca.width {
                let state = self.ca.get_state(&(x as i32, y as i32));
                let char = match state {
                    ForestState::Empty => 'Â·',
                    ForestState::Tree => 'â™¦',
                    ForestState::Burning => 'â™¦',  // æˆ–è€…ç”¨ä¸åŒçš„å­—ç¬¦è¡¨ç¤ºç‡ƒçƒ§
                };
                result.push(char);
            }
            result.push('\n');
        }
        result
    }
}

#[derive(Debug)]
pub struct ForestStatistics {
    pub empty_count: usize,
    pub tree_count: usize,
    pub burning_count: usize,
    pub empty_ratio: f64,
    pub tree_ratio: f64,
    pub burning_ratio: f64,
    pub generation: usize,
}
```

## è®¡ç®—ç†è®ºåº”ç”¨ / Computational Theory Applications

### å›¾çµå®Œå¤‡æ€§ / Turing Completeness

```rust
// è¯æ˜ç»†èƒè‡ªåŠ¨æœºçš„å›¾çµå®Œå¤‡æ€§
// Proving Turing completeness of cellular automata

pub struct UniversalCA {
    ca: OneDimensionalCA,
}

impl UniversalCA {
    // Rule 110æ˜¯å·²çŸ¥çš„å›¾çµå®Œå¤‡è§„åˆ™
    pub fn new_rule_110() -> Self {
        Self {
            ca: OneDimensionalCA::new(1000, 110),
        }
    }

    // æ¨¡æ‹Ÿå›¾çµæœºæ“ä½œ
    pub fn simulate_turing_machine(&mut self, program: &TuringMachineProgram) -> Result<(), String> {
        // å°†å›¾çµæœºç¨‹åºç¼–ç åˆ°ç»†èƒè‡ªåŠ¨æœºçš„åˆå§‹çŠ¶æ€
        self.encode_turing_machine(program)?;

        // è¿è¡Œç»†èƒè‡ªåŠ¨æœºç›´åˆ°è¾¾åˆ°åœæ­¢æ¡ä»¶
        let max_steps = 10000;
        for _ in 0..max_steps {
            self.ca.step();

            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°åœæ­¢çŠ¶æ€
            if self.is_halted() {
                break;
            }
        }

        Ok(())
    }

    fn encode_turing_machine(&mut self, program: &TuringMachineProgram) -> Result<(), String> {
        // å°†å›¾çµæœºçš„çŠ¶æ€ã€è½¬ç§»è¡¨å’Œç£å¸¦å†…å®¹ç¼–ç åˆ°CAçš„åˆå§‹é…ç½®ä¸­
        // è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„ç¼–ç è¿‡ç¨‹ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†

        // åœ¨CAä¸­è®¾ç½®ç‰¹æ®Šçš„é…ç½®æ¥è¡¨ç¤ºå›¾çµæœº
        let tape_start = 100;
        for (i, &symbol) in program.initial_tape.iter().enumerate() {
            if symbol == 1 {
                self.ca.cells[tape_start + i] = 1;
            }
        }

        // è®¾ç½®çŠ¶æ€ç¼–ç 
        let state_position = 50;
        self.encode_state(state_position, &program.initial_state);

        Ok(())
    }

    fn encode_state(&mut self, position: usize, state: &str) {
        // å°†çŠ¶æ€ç¼–ç ä¸ºäºŒè¿›åˆ¶æ¨¡å¼
        let state_hash = state.chars().map(|c| c as u8).sum::<u8>();
        for i in 0..8 {
            if (state_hash >> i) & 1 == 1 {
                self.ca.cells[position + i] = 1;
            }
        }
    }

    fn is_halted(&self) -> bool {
        // æ£€æŸ¥æ˜¯å¦å­˜åœ¨åœæ­¢æ¨¡å¼
        // è¿™é‡Œç®€åŒ–ä¸ºæ£€æŸ¥æ˜¯å¦å­˜åœ¨ç‰¹å®šçš„å‘¨æœŸæ€§æ¨¡å¼
        self.ca.detect_period(20).is_some()
    }

    // æ„é€ é€šç”¨è®¡ç®—æ¨¡å¼
    pub fn create_universal_constructor() -> Self {
        let mut ca = Self::new_rule_110();

        // è®¾ç½®é€šç”¨æ„é€ å™¨çš„åˆå§‹é…ç½®
        // è¿™æ˜¯ä¸€ä¸ªèƒ½å¤Ÿæ„é€ ä»»æ„æ¨¡å¼çš„ç‰¹æ®Šé…ç½®
        let constructor_pattern = vec![
            1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1
        ];

        let start_pos = 400;
        for (i, &bit) in constructor_pattern.iter().enumerate() {
            ca.ca.cells[start_pos + i] = bit;
        }

        ca
    }
}

#[derive(Debug)]
pub struct TuringMachineProgram {
    pub initial_state: String,
    pub initial_tape: Vec<u8>,
    pub transition_table: HashMap<(String, u8), (String, u8, Direction)>,
    pub halt_states: Vec<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Direction {
    Left,
    Right,
}

// å¤æ‚æ€§ç±»åˆ†æ
pub struct ComplexityAnalyzer;

impl ComplexityAnalyzer {
    pub fn analyze_computational_power(rule: u8) -> ComputationalPower {
        let mut ca = OneDimensionalCA::new(200, rule);

        // æµ‹è¯•ä¸åŒçš„è®¡ç®—ä»»åŠ¡
        let can_count = Self::test_counting_ability(&mut ca);
        let can_recognize_patterns = Self::test_pattern_recognition(&mut ca);
        let is_universal = Self::test_universality(rule);

        ComputationalPower {
            rule,
            can_count,
            can_recognize_patterns,
            is_universal,
            classification: WolframClassification::classify_rule(rule, 100, 20),
        }
    }

    fn test_counting_ability(ca: &mut OneDimensionalCA) -> bool {
        // æµ‹è¯•æ˜¯å¦èƒ½å¤Ÿè¿›è¡Œè®¡æ•°æ“ä½œ
        // è®¾ç½®ä¸€ä¸ªç®€å•çš„è®¡æ•°æ¨¡å¼
        ca.cells[50] = 1;
        ca.cells[51] = 1;
        ca.evolve(50);

        // æ£€æŸ¥æ˜¯å¦äº§ç”Ÿäº†è§„å¾‹çš„è®¡æ•°æ¨¡å¼
        let pattern = &ca.cells[40..60];
        let ones_count = pattern.iter().filter(|&&x| x == 1).count();
        ones_count > 2 && ones_count < pattern.len() / 2
    }

    fn test_pattern_recognition(ca: &mut OneDimensionalCA) -> bool {
        // æµ‹è¯•æ¨¡å¼è¯†åˆ«èƒ½åŠ›
        // è®¾ç½®ä¸€ä¸ªç‰¹å®šæ¨¡å¼å¹¶æ£€æŸ¥CAæ˜¯å¦èƒ½è¯†åˆ«
        let pattern = vec![1, 0, 1, 0, 1];
        for (i, &bit) in pattern.iter().enumerate() {
            ca.cells[100 + i] = bit;
        }

        ca.evolve(30);

        // æ£€æŸ¥æ˜¯å¦äº§ç”Ÿäº†å“åº”æ¨¡å¼
        ca.cells.iter().any(|&x| x == 1)
    }

    fn test_universality(rule: u8) -> bool {
        // æ£€æŸ¥å·²çŸ¥çš„é€šç”¨è§„åˆ™
        match rule {
            110 => true,  // Rule 110æ˜¯å·²çŸ¥çš„å›¾çµå®Œå¤‡
            30 => false,  // Rule 30æ˜¯æ··æ²Œä½†ä¸é€šç”¨
            90 => false,  // Rule 90äº§ç”ŸSierpinskiä¸‰è§’å½¢
            _ => false,   // å…¶ä»–è§„åˆ™å‡è®¾ä¸é€šç”¨
        }
    }
}

#[derive(Debug)]
pub struct ComputationalPower {
    pub rule: u8,
    pub can_count: bool,
    pub can_recognize_patterns: bool,
    pub is_universal: bool,
    pub classification: WolframClass,
}
```

## åº”ç”¨é¢†åŸŸ / Application Areas

### ç‰©ç†ç³»ç»Ÿå»ºæ¨¡ / Physical System Modeling

```rust
// ç‰©ç†ç³»ç»Ÿçš„ç»†èƒè‡ªåŠ¨æœºå»ºæ¨¡
// Cellular automata modeling of physical systems

// æµä½“åŠ¨åŠ›å­¦ - Lattice Boltzmannæ–¹æ³•
#[derive(Clone, Debug)]
pub struct LatticeGasCA {
    grid: Vec<Vec<ParticleDistribution>>,
    width: usize,
    height: usize,
    generation: usize,
}

#[derive(Clone, Debug)]
pub struct ParticleDistribution {
    // 9ä¸ªæ–¹å‘çš„ç²’å­å¯†åº¦ (D2Q9æ¨¡å‹)
    densities: [f64; 9],
}

impl ParticleDistribution {
    pub fn new() -> Self {
        Self {
            densities: [0.0; 9],
        }
    }

    pub fn total_density(&self) -> f64 {
        self.densities.iter().sum()
    }

    pub fn momentum(&self) -> (f64, f64) {
        // è®¡ç®—åŠ¨é‡
        let velocities = [
            (0.0, 0.0),   // é™æ­¢
            (1.0, 0.0),   // ä¸œ
            (0.0, 1.0),   // åŒ—
            (-1.0, 0.0),  // è¥¿
            (0.0, -1.0),  // å—
            (1.0, 1.0),   // ä¸œåŒ—
            (-1.0, 1.0),  // è¥¿åŒ—
            (-1.0, -1.0), // è¥¿å—
            (1.0, -1.0),  // ä¸œå—
        ];

        let mut px = 0.0;
        let mut py = 0.0;

        for i in 0..9 {
            px += self.densities[i] * velocities[i].0;
            py += self.densities[i] * velocities[i].1;
        }

        (px, py)
    }
}

impl LatticeGasCA {
    pub fn new(width: usize, height: usize) -> Self {
        Self {
            grid: vec![vec![ParticleDistribution::new(); width]; height],
            width,
            height,
            generation: 0,
        }
    }

    pub fn set_obstacle(&mut self, x: usize, y: usize) {
        // è®¾ç½®éšœç¢ç‰©ï¼ˆè¾¹ç•Œæ¡ä»¶ï¼‰
        if x < self.width && y < self.height {
            // å°†æ‰€æœ‰æ–¹å‘çš„å¯†åº¦è®¾ä¸ºè´Ÿå€¼è¡¨ç¤ºéšœç¢
            for i in 0..9 {
                self.grid[y][x].densities[i] = -1.0;
            }
        }
    }

    pub fn add_inflow(&mut self, x: usize, y: usize, velocity: (f64, f64), density: f64) {
        if x < self.width && y < self.height {
            // åœ¨æŒ‡å®šä½ç½®æ·»åŠ æµå…¥
            let (vx, vy) = velocity;

            // æ ¹æ®é€Ÿåº¦æ–¹å‘åˆ†é…å¯†åº¦
            if vx > 0.0 {
                self.grid[y][x].densities[1] += density * vx;
            }
            if vy > 0.0 {
                self.grid[y][x].densities[2] += density * vy;
            }
            // ... å…¶ä»–æ–¹å‘
        }
    }

    pub fn step(&mut self) {
        // Lattice Boltzmannæ­¥éª¤ï¼šç¢°æ’å’Œä¼ æ’­
        self.collision_step();
        self.streaming_step();
        self.generation += 1;
    }

    fn collision_step(&mut self) {
        // BGKç¢°æ’ç®—å­
        let tau = 1.0; // æ¾å¼›æ—¶é—´

        for y in 0..self.height {
            for x in 0..self.width {
                if self.is_obstacle(x, y) {
                    continue;
                }

                let distribution = &mut self.grid[y][x];
                let rho = distribution.total_density();
                let (u, v) = distribution.momentum();

                if rho > 0.0 {
                    let u_norm = u / rho;
                    let v_norm = v / rho;

                    // è®¡ç®—å¹³è¡¡åˆ†å¸ƒ
                    let eq_dist = self.equilibrium_distribution(rho, u_norm, v_norm);

                    // BGKç¢°æ’
                    for i in 0..9 {
                        distribution.densities[i] +=
                            (eq_dist[i] - distribution.densities[i]) / tau;
                    }
                }
            }
        }
    }

    fn streaming_step(&mut self) {
        let mut new_grid = vec![vec![ParticleDistribution::new(); self.width]; self.height];

        // ç²’å­ä¼ æ’­æ–¹å‘
        let directions = [
            (0, 0),   // é™æ­¢
            (1, 0),   // ä¸œ
            (0, 1),   // åŒ—
            (-1, 0),  // è¥¿
            (0, -1),  // å—
            (1, 1),   // ä¸œåŒ—
            (-1, 1),  // è¥¿åŒ—
            (-1, -1), // è¥¿å—
            (1, -1),  // ä¸œå—
        ];

        for y in 0..self.height {
            for x in 0..self.width {
                for i in 0..9 {
                    let (dx, dy) = directions[i];
                    let nx = x as i32 + dx;
                    let ny = y as i32 + dy;

                    if nx >= 0 && ny >= 0 &&
                       (nx as usize) < self.width && (ny as usize) < self.height {
                        let density = self.grid[y][x].densities[i];
                        new_grid[ny as usize][nx as usize].densities[i] = density;
                    }
                }
            }
        }

        self.grid = new_grid;
    }

    fn equilibrium_distribution(&self, rho: f64, u: f64, v: f64) -> [f64; 9] {
        // Maxwell-Boltzmannå¹³è¡¡åˆ†å¸ƒ
        let weights = [4.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0,
                      1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0];

        let velocities = [
            (0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (-1.0, 0.0), (0.0, -1.0),
            (1.0, 1.0), (-1.0, 1.0), (-1.0, -1.0), (1.0, -1.0)
        ];

        let mut eq = [0.0; 9];
        let u_sq = u * u + v * v;

        for i in 0..9 {
            let (cx, cy) = velocities[i];
            let cu = cx * u + cy * v;

            eq[i] = weights[i] * rho * (1.0 + 3.0 * cu + 4.5 * cu * cu - 1.5 * u_sq);
        }

        eq
    }

    fn is_obstacle(&self, x: usize, y: usize) -> bool {
        x < self.width && y < self.height &&
        self.grid[y][x].densities[0] < 0.0
    }

    pub fn get_velocity_field(&self) -> Vec<Vec<(f64, f64)>> {
        let mut field = vec![vec![(0.0, 0.0); self.width]; self.height];

        for y in 0..self.height {
            for x in 0..self.width {
                if !self.is_obstacle(x, y) {
                    let rho = self.grid[y][x].total_density();
                    if rho > 0.0 {
                        let (px, py) = self.grid[y][x].momentum();
                        field[y][x] = (px / rho, py / rho);
                    }
                }
            }
        }

        field
    }
}

// ç”Ÿæ€ç³»ç»Ÿå»ºæ¨¡ - æ•é£Ÿè€…-çŒç‰©æ¨¡å‹
#[derive(Clone, Debug, PartialEq)]
pub enum EcosystemState {
    Empty,
    Prey(u8),      // çŒç‰©ï¼Œæ•°å€¼è¡¨ç¤ºå¹´é¾„
    Predator(u8),  // æ•é£Ÿè€…ï¼Œæ•°å€¼è¡¨ç¤ºé¥¥é¥¿ç¨‹åº¦
}

pub struct EcosystemCA {
    ca: CA2D<EcosystemState>,
    prey_reproduction_age: u8,
    predator_starvation_limit: u8,
    reproduction_probability: f64,
}

impl EcosystemCA {
    pub fn new(width: usize, height: usize) -> Self {
        Self {
            ca: CA2D::new(width, height, EcosystemState::Empty, NeighborhoodType::Moore),
            prey_reproduction_age: 3,
            predator_starvation_limit: 5,
            reproduction_probability: 0.3,
        }
    }

    pub fn step(&mut self) {
        let prey_repr_age = self.prey_reproduction_age;
        let pred_starv_limit = self.predator_starvation_limit;
        let repr_prob = self.reproduction_probability;

        self.ca.step(|current_state, neighbor_states| {
            match current_state {
                EcosystemState::Empty => {
                    // ç©ºä½å¯èƒ½è¢«å æ®
                    let prey_neighbors = neighbor_states.iter()
                        .filter(|s| matches!(s, EcosystemState::Prey(_)))
                        .count();

                    if prey_neighbors > 0 && rand::random::<f64>() < repr_prob {
                        EcosystemState::Prey(0)
                    } else {
                        EcosystemState::Empty
                    }
                }

                EcosystemState::Prey(age) => {
                    // æ£€æŸ¥æ˜¯å¦è¢«æ•é£Ÿ
                    let predator_neighbors = neighbor_states.iter()
                        .any(|s| matches!(s, EcosystemState::Predator(_)));

                    if predator_neighbors && rand::random::<f64>() < 0.8 {
                        EcosystemState::Empty // è¢«åƒæ‰
                    } else if *age >= prey_repr_age {
                        EcosystemState::Prey(0) // ç¹æ®–åé‡ç½®å¹´é¾„
                    } else {
                        EcosystemState::Prey(age + 1) // å¹´é¾„å¢é•¿
                    }
                }

                EcosystemState::Predator(hunger) => {
                    // æ£€æŸ¥æ˜¯å¦èƒ½æ‰¾åˆ°é£Ÿç‰©
                    let prey_neighbors = neighbor_states.iter()
                        .any(|s| matches!(s, EcosystemState::Prey(_)));

                    if prey_neighbors {
                        EcosystemState::Predator(0) // æ‰¾åˆ°é£Ÿç‰©ï¼Œé‡ç½®é¥¥é¥¿
                    } else if *hunger >= pred_starv_limit {
                        EcosystemState::Empty // é¥¿æ­»
                    } else {
                        EcosystemState::Predator(hunger + 1) // é¥¥é¥¿å¢åŠ 
                    }
                }
            }
        });
    }

    pub fn get_population_stats(&self) -> EcosystemStats {
        let mut prey_count = 0;
        let mut predator_count = 0;
        let mut empty_count = 0;

        for y in 0..self.ca.height {
            for x in 0..self.ca.width {
                match self.ca.get_state(&(x as i32, y as i32)) {
                    EcosystemState::Empty => empty_count += 1,
                    EcosystemState::Prey(_) => prey_count += 1,
                    EcosystemState::Predator(_) => predator_count += 1,
                }
            }
        }

        EcosystemStats {
            prey_count,
            predator_count,
            empty_count,
            generation: self.ca.get_generation(),
        }
    }
}

#[derive(Debug)]
pub struct EcosystemStats {
    pub prey_count: usize,
    pub predator_count: usize,
    pub empty_count: usize,
    pub generation: usize,
}
```

## æ€»ç»“ / Summary

ç»†èƒè‡ªåŠ¨æœºç†è®ºä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªå¼ºå¤§çš„å·¥å…·æ¥ç ”ç©¶å¤æ‚ç³»ç»Ÿã€æ¨¡æ‹Ÿè‡ªç„¶ç°è±¡å’Œæ¢ç´¢è®¡ç®—çš„åŸºæœ¬æ€§è´¨ã€‚é€šè¿‡ç®€å•çš„å±€éƒ¨è§„åˆ™ï¼Œç»†èƒè‡ªåŠ¨æœºèƒ½å¤Ÿäº§ç”Ÿä¸°å¯Œçš„å…¨å±€è¡Œä¸ºï¼Œå±•ç°äº†å¤æ‚æ€§ç§‘å­¦çš„æ ¸å¿ƒæ€æƒ³ã€‚

Cellular automata theory provides us with a powerful tool for studying complex systems, simulating natural phenomena, and exploring fundamental properties of computation. Through simple local rules, cellular automata can generate rich global behavior, demonstrating core ideas of complexity science.

### å…³é”®ç‰¹ç‚¹ / Key Features

1. **ç®€å•è§„åˆ™ï¼Œå¤æ‚è¡Œä¸º** / Simple Rules, Complex Behavior
   - å±€éƒ¨è§„åˆ™äº§ç”Ÿå…¨å±€æ¨¡å¼
   - æ¶Œç°ç°è±¡çš„å…¸å‹ä¾‹å­

2. **è®¡ç®—é€šç”¨æ€§** / Computational Universality
   - æŸäº›CAè§„åˆ™æ˜¯å›¾çµå®Œå¤‡çš„
   - èƒ½å¤Ÿæ¨¡æ‹Ÿä»»æ„è®¡ç®—

3. **å¹¿æ³›åº”ç”¨** / Wide Applications
   - ç‰©ç†ç³»ç»Ÿå»ºæ¨¡
   - ç”Ÿç‰©ç”Ÿæ€ç³»ç»Ÿæ¨¡æ‹Ÿ
   - ç¤¾ä¼šç°è±¡ç ”ç©¶

4. **ç†è®ºåŸºç¡€** / Theoretical Foundation
   - åŠ¨åŠ›ç³»ç»Ÿç†è®º
   - è®¡ç®—å¤æ‚æ€§ç†è®º
   - ç»Ÿè®¡ç‰©ç†å­¦

---

## å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚æ–‡çŒ®æŒ‰ç…§"ç»å…¸å¥ åŸºæ–‡çŒ® â†’ æ ‡å‡†æ•™æ"çš„å±‚æ¬¡ç»„ç»‡ã€‚

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [vonNeumann1966] von Neumann, J., & Burks, A. W. (1966). *Theory of Self-Reproducing Automata*. University of Illinois Press.
   - **von Neumannè‡ªæˆ‘å¤åˆ¶è‡ªåŠ¨æœºçš„ç»å…¸è‘—ä½œ**ï¼Œå¥ å®šäº†ç»†èƒè‡ªåŠ¨æœºç†è®ºçš„åŸºç¡€ã€‚æœ¬æ–‡æ¡£çš„åŸºç¡€æ¦‚å¿µå‚è€ƒæ­¤ä¹¦ã€‚

2. [Gardner1970] Gardner, M. (1970). "Mathematical Games: The Fantastic Combinations of John Conway's New Solitaire Game 'Life'". *Scientific American*, 223(4), 120-123.
   - **Gardnerå¯¹Conwayç”Ÿå‘½æ¸¸æˆçš„ç»å…¸ä»‹ç»**ï¼Œä½¿ç»†èƒè‡ªåŠ¨æœºå¹¿ä¸ºäººçŸ¥ã€‚æœ¬æ–‡æ¡£çš„ç”Ÿå‘½æ¸¸æˆéƒ¨åˆ†å‚è€ƒæ­¤æ–‡ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. [Wolfram2002] Wolfram, S. (2002). *A New Kind of Science*. Wolfram Media. ISBN: 978-1579550080
   - **Wolframç»†èƒè‡ªåŠ¨æœºçš„é‡Œç¨‹ç¢‘å¼è‘—ä½œ**ï¼Œç³»ç»Ÿç ”ç©¶äº†ç»†èƒè‡ªåŠ¨æœºçš„å¤æ‚æ€§ã€‚æœ¬æ–‡æ¡£çš„åŸºç¡€æ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

2. Toffoli, T., & Margolus, N. (1987). *Cellular Automata Machines: A New Environment for Modeling*. MIT Press.
   - ç»†èƒè‡ªåŠ¨æœºæœºå™¨çš„ç»å…¸æ•™æã€‚

3. Cook, M. (2004). "Universality in Elementary Cellular Automata". *Complex Systems*, 15(1), 1-40.
   - Cookå…³äºåˆç­‰ç»†èƒè‡ªåŠ¨æœºé€šç”¨æ€§çš„é‡è¦è®ºæ–‡ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Cellular Automaton**: <https://en.wikipedia.org/wiki/Cellular_automaton>
   - ç»†èƒè‡ªåŠ¨æœºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«åŸºæœ¬å®šä¹‰ã€è§„åˆ™å’Œåˆ†ç±»ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Conway's Game of Life**: <https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life>
   - Conwayç”Ÿå‘½æ¸¸æˆçš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»æœ€è‘—åçš„ç»†èƒè‡ªåŠ¨æœºï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Elementary Cellular Automaton**: <https://en.wikipedia.org/wiki/Elementary_cellular_automaton>
   - åˆç­‰ç»†èƒè‡ªåŠ¨æœºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«è§„åˆ™110ç­‰ç»å…¸ä¾‹å­ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---
