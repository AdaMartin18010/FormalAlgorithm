# 图灵机 - 深化补充与完整证明

> **说明**: 本文档是 `01-图灵机.md` 的深化补充版本，提供完整的定理证明、严格的引用和详细的数学推导。展示了按照2025年改进计划要求的学术规范标准。

**相关文档**: [`01-图灵机.md`](./01-图灵机.md)  
**创建时间**: 2025-10-11  
**版本**: 1.0-深化示例

---

## 目录

- [一、通用图灵机的存在性与构造](#一通用图灵机的存在性与构造)
- [二、停机问题的完整理论](#二停机问题的完整理论)
- [三、Rice定理与语义性质的不可判定性](#三rice定理与语义性质的不可判定性)
- [四、归约理论与完备性](#四归约理论与完备性)
- [参考文献](#参考文献)

---

## 一、通用图灵机的存在性与构造

### 1.1 图灵机编码的形式化

**定义 1.1** (图灵机的标准编码 [Sipser2012, §4.1]) 设 $M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$ 是一个图灵机，其中：

- $Q = \{q_0, q_1, \ldots, q_m\}$ 是状态集
- $\Gamma = \{\sqcup, a_1, a_2, \ldots, a_n\}$ 是带字母表
- $\Sigma \subseteq \Gamma \setminus \{\sqcup\}$ 是输入字母表

我们定义 $M$ 的编码 $\langle M \rangle$ 如下：

1. **状态编码**: 用 $0^{i+1}1$ 编码状态 $q_i$
2. **符号编码**: 用 $0^{j+1}1$ 编码符号 $a_j$（其中 $a_0 = \sqcup$）
3. **方向编码**: 用 $01$ 编码 $L$，$011$ 编码 $R$
4. **转移编码**: 对于 $\delta(q_i, a_j) = (q_k, a_l, D)$，编码为：
   $$0^{i+1}1 \; 0^{j+1}1 \; 0^{k+1}1 \; 0^{l+1}1 \; D_{enc}$$
5. **机器编码**: 将所有转移编码用 $11$ 分隔，整个编码用 $111$ 开始和结束：
   $$\langle M \rangle = 111 \; \tau_1 \; 11 \; \tau_2 \; 11 \; \cdots \; 11 \; \tau_k \; 111$$

**定义 1.2** (有效编码) 二进制串 $w$ 是一个有效的图灵机编码，如果：

1. $w$ 以 $111$ 开始和结束
2. 各部分之间用 $11$ 分隔
3. 每个转移编码格式正确
4. 转移函数对每个 $(q, a)$ 对最多定义一次（确定性）

**引用**: 编码方案基于[Turing1936]的思想，现代形式见[Sipser2012, §4.1]和[HMU2006, §9.2]。

---

### 1.2 通用图灵机的构造

**定理 1.1** (通用图灵机的存在性 [Turing1936])  
存在一个图灵机 $U$（称为通用图灵机），使得对于任意图灵机 $M$ 和输入 $x \in \Sigma^*$：
$$
U(\langle M, x \rangle) = \begin{cases}
\text{accept} & \text{if } M(x) = \text{accept} \\
\text{reject} & \text{if } M(x) = \text{reject} \\
\text{loop} & \text{if } M(x) = \text{loop}
\end{cases}
$$

其中 $\langle M, x \rangle$ 是机器 $M$ 和输入 $x$ 的编码（用特殊分隔符分隔）。

**证明**:

**第一步：多带通用图灵机的构造**:

我们首先构造一个3带通用图灵机 $U_3$：

- **带1**: 存储 $\langle M \rangle$（机器描述，只读）
- **带2**: 模拟 $M$ 的工作带，初始包含输入 $x$
- **带3**: 存储 $M$ 的当前状态编码

$U_3$ 的算法：

```text
输入: ⟨M, x⟩
1. 初始化:
   - 带1 ← ⟨M⟩
   - 带2 ← x (模拟 M 的工作带)
   - 带3 ← 0^{0+1}1 (q_0 的编码)

2. 循环 (模拟 M 的每一步):
   (a) 读取带3的当前状态编码: 0^{i+1}1
   (b) 读取带2磁头下的符号, 确定其编码: 0^{j+1}1

   (c) 在带1中搜索转移编码:
       找到 0^{i+1}1 0^{j+1}1 0^{k+1}1 0^{l+1}1 D

   (d) 如果找到转移:
       - 更新带3: 写入 0^{k+1}1 (新状态)
       - 更新带2: 写入对应于 0^{l+1}1 的符号
       - 移动带2的磁头: 根据 D (01 表示左, 011 表示右)

   (e) 如果未找到转移 (δ 未定义):
       拒绝 (M 在此配置停机并拒绝)

   (f) 检查停机条件:
       - 如果带3包含 q_accept 的编码: 接受
       - 如果带3包含 q_reject 的编码: 拒绝

   (g) 否则, 继续循环
```

**第二步：正确性论证（归纳于计算步数）**:

**归纳命题**: 对于任意 $t \geq 0$，在 $U_3$ 执行模拟循环 $t$ 次后，如果 $M$ 在输入 $x$ 上的计算未在 $t$ 步内停机，则 $U_3$ 的带2和带3正确地表示了 $M$ 在 $x$ 上运行 $t$ 步后的配置。

**基础情况** ($t = 0$):  
$U_3$ 初始化后：

- 带2 = $x$（$M$ 的初始带内容）
- 带3 = $0^{0+1}1$（$q_0$ 的编码）

这正确地表示了 $M$ 的初始配置 $(q_0, \epsilon, x)$。

**归纳步骤** ($t \to t+1$):  
假设归纳命题对 $t$ 成立。考虑 $U_3$ 模拟第 $t+1$ 步：

设 $M$ 在第 $t$ 步后的配置为 $(q_i, w, u)$，其中 $u = a_j \cdot u'$。  
根据归纳假设，$U_3$ 的带2和带3正确表示此配置：

- 带3包含 $0^{i+1}1$（$q_i$ 的编码）
- 带2的内容和磁头位置对应于 $(w, u)$
- 带2磁头下的符号是 $a_j$

在模拟循环中：

1. $U_3$ 读取带3得到 $0^{i+1}1$（正确）
2. $U_3$ 读取带2磁头下的符号，确定为 $a_j$，编码为 $0^{j+1}1$（正确）
3. $U_3$ 在带1中搜索转移 $0^{i+1}1 \; 0^{j+1}1 \; 0^{k+1}1 \; 0^{l+1}1 \; D$

**情况1**: 如果 $\delta(q_i, a_j) = (q_k, a_l, D_M)$ 在 $M$ 中有定义，则：

- $U_3$ 在带1中找到对应的转移编码
- $U_3$ 更新带3为 $0^{k+1}1$（$q_k$ 的编码）
- $U_3$ 在带2上写入 $a_l$，并按 $D_M$ 移动磁头

根据 $M$ 的语义，$M$ 从配置 $(q_i, w, a_j \cdot u')$ 转移到：

- 如果 $D_M = R$: $(q_k, w \cdot a_l, u')$
- 如果 $D_M = L$ 且 $w = w' \cdot b$: $(q_k, w', b \cdot a_l \cdot u')$

$U_3$ 的带2和带3在更新后正确地表示新配置。

**情况2**: 如果 $\delta(q_i, a_j)$ 在 $M$ 中未定义，则：

- $M$ 在此配置停机（通常为拒绝）
- $U_3$ 在带1中找不到对应的转移，根据算法步骤(e)拒绝
- $U_3$ 的行为与 $M$ 一致

**情况3**: 如果 $q_k = q_{accept}$ 或 $q_k = q_{reject}$，则：

- $M$ 在第 $t+1$ 步后停机并接受/拒绝
- $U_3$ 在更新带3后检测到停机状态，执行相应的接受/拒绝动作
- $U_3$ 的行为与 $M$ 一致

通过归纳，对于所有 $t \geq 0$，$U_3$ 正确模拟 $M$ 的前 $t$ 步。  
因此，$U_3(\langle M, x \rangle) = M(x)$。

**第三步：从3带到单带**:

根据**定理1.2**（见下），任何 $k$ 带图灵机都可以被单带图灵机模拟。因此，存在单带通用图灵机 $U$ 模拟 $U_3$。

模拟的开销是多项式的：如果 $M$ 在 $x$ 上运行 $t$ 步，$U_3$ 运行 $O(t \cdot |\langle M \rangle|)$ 步（每次模拟需要搜索转移），而 $U$ 运行 $O(t^2 \cdot |\langle M \rangle|^2)$ 步（单带模拟3带的开销）。

**结论**: 存在通用图灵机 $U$ 使得 $U(\langle M, x \rangle) = M(x)$。 $\square$

**引用**: 原始思想[Turing1936, §6]，详细证明见[Sipser2012, 定理3.21]，[HMU2006, 定理9.7]，[Rogers1987, §1.9]。

---

**定理 1.2** (多带图灵机的模拟 [Sipser2012, 定理3.13])  
设 $M_k$ 是一个 $k$ 带图灵机，在输入 $x$ 上运行时间为 $t(|x|)$。则存在单带图灵机 $M_1$ 使得：

1. $L(M_1) = L(M_k)$（识别相同语言）
2. $M_1$ 在输入 $x$ 上的运行时间为 $O(t(|x|)^2)$

**证明草图**:

**编码方案**: 单带 $M_1$ 将 $k$ 条带的内容交错存储在一条带上。使用特殊标记符号 $\dot{a}$ 表示该格子是某条带的磁头位置：
$$\# \; \underline{a_1} \; b_1 \; c_1 \; \# \; d_2 \; \underline{e_2} \; f_2 \; \# \; \cdots \; \# \; g_k \; h_k \; \underline{i_k} \; \#$$

其中 $\#$ 是分隔符，下划线表示该带的磁头位置。

**模拟算法**:

```text
初始化: 将输入 x 写在第一个区域, 其余区域为空
循环 (模拟 M_k 的每一步):
  1. 扫描整条带, 记录每条带的磁头位置和符号 (需要 O(t) 时间)
  2. 根据 M_k 的转移函数, 决定新状态、写入符号、移动方向
  3. 再次扫描, 更新每条带的内容和磁头位置 (需要 O(t) 时间)
  4. 如果需要扩展带 (某个磁头移到最右边), 整体右移 (需要 O(t) 时间)
```

每模拟 $M_k$ 的一步，$M_1$ 需要 $O(t)$ 的带扫描时间（$t$ 是此时带的使用长度）。  
如果 $M_k$ 运行 $t(n)$ 步，则 $M_1$ 的总时间为：
$$\sum_{i=1}^{t(n)} O(i) = O(t(n)^2)$$

**引用**: 详细证明见[Sipser2012, 定理3.13]，[HMU2006, §8.4]。

---

### 1.3 通用图灵机的意义与应用

**推论 1.1** (可编程计算) 通用图灵机的存在性表明：

1. **通用性**: 存在单一的计算机器可以模拟所有可计算函数
2. **存储程序**: 程序（$\langle M \rangle$）和数据（$x$）都可以存储在同一介质上
3. **自我指涉**: 图灵机可以操作其他图灵机的描述，包括自身的描述

这些性质是现代通用计算机的理论基础。

**推论 1.2** (对角化的可能性) 通用图灵机使得对角化论证成为可能，从而可以证明停机问题等不可判定性结果（见下一节）。

**引用**: 讨论见[Turing1936, §6-7]，现代观点见[Davis1958, 第1章]，哲学意义见[Copeland2003]。

---

## 二、停机问题的完整理论

### 2.1 停机问题的形式化定义

**定义 2.1** (停机问题 [Turing1936])  
停机问题是指判定以下语言的可判定性：
$$H_{TM} = \{ \langle M, x \rangle : M \text{ 是图灵机且 } M \text{ 在输入 } x \text{ 上停机} \}$$

其中"停机"指 $M(x) \in \{\text{accept}, \text{reject}\}$（不包括 $\text{loop}$）。

**定义 2.2** (可判定语言) 语言 $L \subseteq \Sigma^*$ 是可判定的（递归的），如果存在图灵机 $M$ 使得：

1. $L = L(M)$（$M$ 识别 $L$）
2. $M$ 在所有输入上停机（$\forall x: M(x) \in \{\text{accept}, \text{reject}\}$）

**定义 2.3** (递归可枚举语言) 语言 $L$ 是递归可枚举的（r.e.），如果存在图灵机 $M$ 使得 $L = L(M)$（$M$ 可能在某些输入上不停机）。

---

### 2.2 停机问题的不可判定性

**定理 2.1** (图灵定理 [Turing1936, §8])  
停机问题 $H_{TM}$ 是不可判定的。

**证明** (对角化论证):

**假设**: 假设 $H_{TM}$ 是可判定的。则存在图灵机 $H$ 使得：
$$
H(\langle M, x \rangle) = \begin{cases}
\text{accept} & \text{if } M \text{ 在 } x \text{ 上停机} \\
\text{reject} & \text{if } M \text{ 在 } x \text{ 上不停机}
\end{cases}
$$
且 $H$ 在所有输入上停机。

**构造对角机器**: 基于 $H$，构造一个新的图灵机 $D$：

```text
D 的输入: ⟨M⟩ (图灵机的编码)
D 的算法:
1. 运行 H(⟨M, ⟨M⟩⟩)
2. 如果 H 接受 (即 M 在 ⟨M⟩ 上停机):
      进入无限循环 (不停机)
   如果 H 拒绝 (即 M 在 ⟨M⟩ 上不停机):
      接受并停机
```

形式化地，$D$ 的行为可以表示为：
$$
D(\langle M \rangle) = \begin{cases}
\text{loop} & \text{if } M(\langle M \rangle) \text{ 停机} \\
\text{accept} & \text{if } M(\langle M \rangle) \text{ 不停机}
\end{cases}
$$

**对角化矛盾**: 现在考虑 $D$ 在自身编码 $\langle D \rangle$ 上的行为：

- **情况1**: 假设 $D(\langle D \rangle)$ 停机。  
  根据 $D$ 的定义（步骤2的第二分支），这意味着 $H(\langle D, \langle D \rangle \rangle)$ 拒绝，即 $D$ 在 $\langle D \rangle$ 上**不停机**。  
  这与假设矛盾！

- **情况2**: 假设 $D(\langle D \rangle)$ 不停机。  
  根据 $D$ 的定义（步骤2的第一分支），这意味着 $H(\langle D, \langle D \rangle \rangle)$ 接受，即 $D$ 在 $\langle D \rangle$ 上**停机**。  
  这与假设矛盾！

两种情况都导致矛盾。因此，假设错误，不存在这样的图灵机 $H$。  
所以 $H_{TM}$ 不可判定。 $\square$

**引用**: 原始证明[Turing1936, §8]，现代叙述见[Sipser2012, 定理4.11]，[HMU2006, 定理9.11]，详细讨论见[Rogers1987, §1.8]。

---

**定理 2.2** ($H_{TM}$ 的递归可枚举性)  
停机问题 $H_{TM}$ 是递归可枚举的。

**证明**:

构造图灵机 $M_{H}$：

```text
M_H 的输入: ⟨M, x⟩
M_H 的算法:
1. 用通用图灵机 U 模拟 M 在 x 上的运行
2. 如果 M(x) 接受或拒绝 (停机): 接受
3. 如果 M(x) 不停机: M_H 也不停机 (永远在步骤1循环)
```

显然，$L(M_H) = H_{TM}$，因为 $M_H$ 接受当且仅当 $M$ 在 $x$ 上停机。  
因此 $H_{TM}$ 是递归可枚举的。 $\square$

**推论 2.1** ($\overline{H_{TM}}$ 的非递归可枚举性)  
停机问题的补集 $\overline{H_{TM}} = \{ \langle M, x \rangle : M \text{ 在 } x \text{ 上不停机} \}$ 不是递归可枚举的。

**证明**:

假设 $\overline{H_{TM}}$ 是递归可枚举的。  
根据**定理2.2**，$H_{TM}$ 也是递归可枚举的。  
根据**引理2.1**（见下），如果 $L$ 和 $\overline{L}$ 都是递归可枚举的，则 $L$ 是可判定的。  
因此 $H_{TM}$ 可判定，这与**定理2.1**矛盾。  
所以 $\overline{H_{TM}}$ 不是递归可枚举的。 $\square$

**引理 2.1** (r.e. 完备性)  
语言 $L$ 是可判定的当且仅当 $L$ 和 $\overline{L}$ 都是递归可枚举的。

**证明**:

**方向1**: 如果 $L$ 可判定，则存在图灵机 $M$ 使得 $L = L(M)$ 且 $M$ 在所有输入上停机。  
构造识别 $\overline{L}$ 的图灵机 $M'$：运行 $M$，如果 $M$ 接受则拒绝，如果 $M$ 拒绝则接受。  
因为 $M$ 总是停机，$M'$ 也总是停机，且 $L(M') = \overline{L}$。  
所以 $L$ 和 $\overline{L}$ 都是可判定的（因此也是递归可枚举的）。

**方向2**: 如果 $L$ 和 $\overline{L}$ 都是递归可枚举的，则存在图灵机 $M_1, M_2$ 使得 $L = L(M_1), \overline{L} = L(M_2)$。  
构造判定 $L$ 的图灵机 $M$：

```text
M 的输入: x
M 的算法:
1. 并行模拟 M_1(x) 和 M_2(x) (交替运行每个机器一步)
2. 如果 M_1 接受: 接受
3. 如果 M_2 接受: 拒绝
```

对于任意输入 $x$：

- 如果 $x \in L$，则 $M_1(x)$ 最终接受，$M$ 在步骤2接受并停机
- 如果 $x \notin L$，则 $x \in \overline{L}$，$M_2(x)$ 最终接受，$M$ 在步骤3拒绝并停机

因为 $L$ 和 $\overline{L}$ 覆盖整个 $\Sigma^*$，对于任意 $x$，$M_1$ 和 $M_2$ 至少有一个接受。  
所以 $M$ 在所有输入上停机，且 $L = L(M)$，即 $L$ 可判定。 $\square$

**引用**: 引理证明见[Sipser2012, 定理4.22]，[HMU2006, 定理9.12]。

---

### 2.3 停机问题的变种

**定理 2.3** (特殊停机问题的不可判定性)  
以下问题都是不可判定的：

1. **自停机问题**: $H_{self} = \{ \langle M \rangle : M \text{ 在 } \langle M \rangle \text{ 上停机} \}$
2. **空输入停机问题**: $H_\epsilon = \{ \langle M \rangle : M \text{ 在空输入上停机} \}$
3. **特定输入停机问题**: 对于任意固定的 $w$, $H_w = \{ \langle M \rangle : M \text{ 在 } w \text{ 上停机} \}$

**证明** (通过归约):

**Part 1**: $H_{self}$ 不可判定。

假设存在图灵机 $D_{self}$ 判定 $H_{self}$。构造判定 $H_{TM}$ 的图灵机 $D_H$：

```text
D_H 的输入: ⟨M, x⟩
D_H 的算法:
1. 构造一个新图灵机 M_x:
   M_x 的输入: w (忽略实际输入)
   M_x 的算法: 模拟 M(x)
2. 运行 D_self(⟨M_x⟩)
3. 输出 D_self 的结果
```

分析：

- $M_x$ 在任意输入（包括 $\langle M_x \rangle$）上的行为都是模拟 $M(x)$
- 因此 $M_x(\langle M_x \rangle)$ 停机 $\Leftrightarrow$ $M(x)$ 停机
- 所以 $\langle M_x \rangle \in H_{self}$ $\Leftrightarrow$ $\langle M, x \rangle \in H_{TM}$
- $D_H$ 正确判定 $H_{TM}$

这与**定理2.1**矛盾，所以 $H_{self}$ 不可判定。

**Part 2**: $H_\epsilon$ 不可判定（证明类似，留作练习）。

**Part 3**: $H_w$ 不可判定（证明类似）。 $\square$

**引用**: 归约技术的系统讨论见[Sipser2012, §5.3]，[Rogers1987, 第5章]。

---

## 三、Rice定理与语义性质的不可判定性

### 3.1 语义性质的形式化

**定义 3.1** (语言性质) 图灵机的一个性质 $P$ 是一个**语言性质**（semantic property），如果：
$$\forall M_1, M_2: [L(M_1) = L(M_2) \Rightarrow (M_1 \in P \Leftrightarrow M_2 \in P)]$$

即，性质 $P$ 只依赖于图灵机识别的语言，而不依赖于其具体实现方式。

**例子**:

- **语言性质**: "$L(M)$ 是有限的"、"$L(M) = \emptyset$"、"$L(M)$ 包含回文串"
- **非语言性质**: "$M$ 有少于5个状态"、"$M$ 的第一个转移向左移动"（这些依赖于 $M$ 的实现细节）

**定义 3.2** (平凡性质) 语言性质 $P$ 是**平凡的**，如果：

- $P = \emptyset$（没有图灵机满足 $P$），或
- $P = \{\text{所有图灵机}\}$（所有图灵机都满足 $P$）

**定义 3.3** (性质的可判定性) 性质 $P$ 是可判定的，如果语言 $L_P = \{ \langle M \rangle : M \in P \}$ 是可判定的。

---

### 3.2 Rice定理

**定理 3.1** (Rice定理 [Rice1953])  
任何非平凡的语言性质都是不可判定的。

形式化地：设 $P$ 是一个语言性质，满足：

1. $P \neq \emptyset$（存在图灵机 $M$ 使得 $M \in P$）
2. $P \neq \{\text{所有图灵机}\}$（存在图灵机 $M'$ 使得 $M' \notin P$）

则性质 $P$ 是不可判定的，即 $L_P = \{ \langle M \rangle : M \in P \}$ 不可判定。

**证明**:

不失一般性，假设存在图灵机 $M_\emptyset$ 使得 $L(M_\emptyset) = \emptyset$ 且 $M_\emptyset \notin P$。  
（如果 $M_\emptyset \in P$，我们可以考虑补性质 $\overline{P} = \{\text{所有图灵机}\} \setminus P$，然后应用相同的论证。）

因为 $P$ 非平凡，存在图灵机 $M_1$ 使得 $M_1 \in P$ 且 $L(M_1) \neq \emptyset$。

**假设**: 假设 $P$ 可判定，即存在图灵机 $D_P$ 使得：
$$
D_P(\langle M \rangle) = \begin{cases}
\text{accept} & \text{if } M \in P \\
\text{reject} & \text{if } M \notin P
\end{cases}
$$
且 $D_P$ 在所有输入上停机。

**归约构造**: 我们将从 $D_P$ 构造一个判定停机问题 $H_{TM}$ 的机器 $D_H$：

```text
D_H 的输入: ⟨M, x⟩
D_H 的算法:
1. 构造一个新图灵机 M_{M,x}:
   M_{M,x} 的输入: w
   M_{M,x} 的算法:
     (a) 模拟 M(x)
     (b) 如果 M(x) 停机:
           模拟 M_1(w) (M_1 是满足 M_1 ∈ P 的固定机器)
           输出 M_1(w) 的结果
     (c) 如果 M(x) 不停机:
           M_{M,x} 不停机 (在步骤 (a) 永远循环)

2. 运行 D_P(⟨M_{M,x}⟩)
3. 输出 D_P 的结果
```

**关键观察**: $M_{M,x}$ 的行为依赖于 $M(x)$ 是否停机：

- **情况1**: 如果 $M$ 在 $x$ 上停机，则对于任意输入 $w$：
  - $M_{M,x}(w)$ 首先在步骤(a)完成（因为 $M(x)$ 停机）
  - 然后 $M_{M,x}(w)$ 模拟 $M_1(w)$
  - 因此 $L(M_{M,x}) = L(M_1)$
  - 因为 $P$ 是语言性质且 $M_1 \in P$，所以 $M_{M,x} \in P$
  - $D_P(\langle M_{M,x} \rangle)$ 接受

- **情况2**: 如果 $M$ 在 $x$ 上不停机，则对于任意输入 $w$：
  - $M_{M,x}(w)$ 在步骤(a)永远循环（模拟 $M(x)$）
  - $M_{M,x}$ 不接受任何输入
  - 因此 $L(M_{M,x}) = \emptyset = L(M_\emptyset)$
  - 因为 $P$ 是语言性质且 $M_\emptyset \notin P$，所以 $M_{M,x} \notin P$
  - $D_P(\langle M_{M,x} \rangle)$ 拒绝

**结论**: $D_H$ 正确判定 $H_{TM}$：
$$D_H(\langle M, x \rangle) = \text{accept} \Leftrightarrow M \text{ 在 } x \text{ 上停机}$$

这与**定理2.1**（停机问题不可判定）矛盾。  
因此假设错误，性质 $P$ 不可判定。 $\square$

**引用**: 原始论文[Rice1953]，现代教材处理见[Sipser2012, 定理5.28]，[HMU2006, 定理9.12]，详细讨论见[Rogers1987, 定理2-I]。

---

### 3.3 Rice定理的应用

**推论 3.1** (具体不可判定问题) 以下问题都是不可判定的：

1. **空性问题**: $E_{TM} = \{ \langle M \rangle : L(M) = \emptyset \}$
   - **说明**: 这是一个非平凡语言性质（有些图灵机识别空语言，有些不识别）

2. **正则性问题**: $REG_{TM} = \{ \langle M \rangle : L(M) \text{ 是正则语言} \}$
   - **说明**: 这是一个非平凡语言性质

3. **有限性问题**: $FIN_{TM} = \{ \langle M \rangle : L(M) \text{ 是有限语言} \}$

4. **包含性问题**: 对于固定语言 $L_0$, $\text{SUP}_{TM}(L_0) = \{ \langle M \rangle : L_0 \subseteq L(M) \}$

5. **等价性问题**: $EQ_{TM} = \{ \langle M_1, M_2 \rangle : L(M_1) = L(M_2) \}$

**证明**: 对于前4个问题，直接应用Rice定理即可。  
对于等价性问题，可以通过归约到空性问题：
$$\langle M_1, M_2 \rangle \in EQ_{TM} \Leftrightarrow L(M_1 \triangle M_2) = \emptyset$$
其中 $M_1 \triangle M_2$ 是构造的机器，识别对称差 $L(M_1) \triangle L(M_2)$。 $\square$

**引用**: 应用实例见[Sipser2012, §5.2]，[HMU2006, §9.5]。

---

### 3.4 Rice定理的局限性

**重要说明**: Rice定理**不适用于**：

1. **语法性质**（依赖于图灵机的具体实现）：
   - "$M$ 有少于10个状态" - 可判定（只需检查编码）
   - "$M$ 在输入长度≤100时停机" - 可能可判定（模拟有限步）

2. **混合性质**（部分语义、部分语法）

3. **非图灵机语言的性质**

**例子**: "$M$ 在空输入上停机"看起来是语义性质，但实际上可以重新表述为"$\langle M, \epsilon \rangle \in H_{TM}$"，这是关于特定配对的性质，不是纯粹的语言性质。Rice定理不直接适用，但这个问题仍然不可判定（通过直接归约证明，见**定理2.3**）。

**引用**: Rice定理局限性的讨论见[Sipser2012, §5.2]，[Rogers1987, §2.2]。

---

## 四、归约理论与完备性

### 4.1 多一归约

**定义 4.1** (多一归约 [Rogers1987, §7.1]) 语言 $A$ **多一归约**到语言 $B$（记作 $A \leq_m B$），如果存在可计算函数 $f: \Sigma^* \rightarrow \Sigma^*$ 使得：
$$\forall x \in \Sigma^*: x \in A \Leftrightarrow f(x) \in B$$

函数 $f$ 称为从 $A$ 到 $B$ 的**归约函数**。

**定理 4.1** (归约的传递性)  
如果 $A \leq_m B$ 且 $B \leq_m C$，则 $A \leq_m C$。

**证明**: 设 $f$ 是从 $A$ 到 $B$ 的归约，$g$ 是从 $B$ 到 $C$ 的归约。  
则 $h = g \circ f$ 是从 $A$ 到 $C$ 的归约：
$$x \in A \Leftrightarrow f(x) \in B \Leftrightarrow g(f(x)) \in C$$
因为 $f$ 和 $g$ 都是可计算的，$h$ 也是可计算的。 $\square$

**定理 4.2** (归约与可判定性)  
如果 $A \leq_m B$ 且 $B$ 可判定，则 $A$ 可判定。

**证明**: 设 $f$ 是归约函数，$M_B$ 是判定 $B$ 的图灵机。  
构造判定 $A$ 的机器 $M_A$：

```text
M_A 的输入: x
1. 计算 y = f(x)
2. 运行 M_B(y)
3. 输出 M_B 的结果
```

则 $M_A$ 判定 $A$。 $\square$

**推论 4.1** (归约与不可判定性)  
如果 $A \leq_m B$ 且 $A$ 不可判定，则 $B$ 不可判定。

---

### 4.2 递归可枚举完备性

**定义 4.2** (r.e. 完备) 语言 $B$ 是**递归可枚举完备的**，如果：

1. $B$ 是递归可枚举的
2. 对于任意递归可枚举语言 $A$，都有 $A \leq_m B$

**定理 4.3** ($H_{TM}$ 的完备性)  
停机问题 $H_{TM}$ 是递归可枚举完备的。

**证明**:

**Part 1**: $H_{TM}$ 是递归可枚举的（已在**定理2.2**中证明）。

**Part 2**: 对于任意递归可枚举语言 $A$，$A \leq_m H_{TM}$。

设 $A$ 是递归可枚举的，$M_A$ 是识别 $A$ 的图灵机（$L(M_A) = A$）。  
定义归约函数 $f$：

```text
f 的输入: x
f 的输出: ⟨M_A, x⟩
```

显然 $f$ 是可计算的（只是简单的字符串组合）。  
验证归约性质：
$$
x \in A \Leftrightarrow M_A(x) \text{ 接受} \Leftrightarrow M_A \text{ 在 } x \text{ 上停机} \Leftrightarrow \langle M_A, x \rangle \in H_{TM}
$$

（注：最后一个等价性假设 $M_A$ 在 $A$ 的补集上不停机，这对于识别机器总是成立的。）

因此 $A \leq_m H_{TM}$。 $\square$

**引用**: 完备性理论见[Rogers1987, §7.2]，[Soare2016, §3.4]。

---

### 4.3 Post问题与算术层次

**定义 4.3** (Post问题 [Post1944]) Post问题询问：是否存在递归可枚举语言 $A$ 使得：

- $A$ 不可判定
- $A$ 不是递归可枚举完备的（即存在递归可枚举语言 $B$ 使得 $B \not\leq_m A$）

**定理 4.4** (Post问题的解决 [Friedberg1957, Muchnik1956])  
Post问题的答案是肯定的：存在中间度（intermediate degree）的递归可枚举语言。

**证明方法**: 使用优先级方法（priority method）进行图灵度构造，这是一个高度技术性的证明，超出本文范围。

**引用**: 原始论文[Friedberg1957], [Muchnik1956]，现代处理见[Soare1987, §V]，简化介绍见[Cooper2004, §4]。

**定义 4.4** (算术层次 [Kleene1943]) 算术层次分类递归可枚举语言和更复杂的语言：

- $\Sigma_0^0 = \Pi_0^0 = \Delta_0^0$ = 可判定语言
- $\Sigma_1^0$ = 递归可枚举语言
- $\Pi_1^0$ = 递归可枚举语言的补集
- $\Sigma_n^0, \Pi_n^0$ 通过交替量词定义（超出本文范围）

**引用**: 算术层次的详细讨论见[Rogers1987, §14]，[Soare2016, §6]。

---

## 参考文献

### 原始论文（按年代顺序）

[Turing1936] Alan M. Turing. "On Computable Numbers, with an Application to the Entscheidungsproblem." *Proceedings of the London Mathematical Society*, s2-42(1):230-265, 1936. DOI: 10.1112/plms/s2-42.1.230  
→ 提出图灵机模型、通用图灵机、停机问题不可判定性

[Kleene1943] Stephen C. Kleene. "Recursive predicates and quantifiers." *Transactions of the American Mathematical Society*, 53:41-73, 1943.  
→ 引入算术层次

[Post1944] Emil L. Post. "Recursively enumerable sets of positive integers and their decision problems." *Bulletin of the American Mathematical Society*, 50(5):284-316, 1944.  
→ 提出Post问题、简单集、创造集等概念

[Rice1953] Henry Gordon Rice. "Classes of recursively enumerable sets and their decision problems." *Transactions of the American Mathematical Society*, 74(2):358-366, 1953.  
→ 证明Rice定理

[Friedberg1957] Richard M. Friedberg. "Two recursively enumerable sets of incomparable degrees of unsolvability." *Proceedings of the National Academy of Sciences*, 43(2):236-238, 1957.  
→ 解决Post问题（独立证明）

[Muchnik1956] Albert A. Muchnik. "On the unsolvability of the problem of reducibility in the theory of algorithms." *Doklady Akademii Nauk SSSR*, 108:194-197, 1956. (俄文)  
→ 解决Post问题（独立证明）

---

### 经典教材

[Davis1958] Martin Davis. *Computability and Unsolvability*. McGraw-Hill, 1958.  
→ 早期可计算性理论经典

[Rogers1987] Hartley Rogers Jr. *Theory of Recursive Functions and Effective Computability*. MIT Press, 1987 (原版1967). ISBN: 978-0262680523  
→ 递归论权威教材，包含归约理论、Post问题、算术层次的详细讨论

[Soare1987] Robert I. Soare. *Recursively Enumerable Sets and Degrees*. Springer, 1987. ISBN: 978-3540152996  
→ 递归可枚举集和度理论的权威参考

---

### 现代教材

[HMU2006] John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman. *Introduction to Automata Theory, Languages, and Computation* (3rd Edition). Pearson, 2006. ISBN: 978-0321455369  
→ 第8-9章讨论图灵机、不可判定性、归约

[Sipser2012] Michael Sipser. *Introduction to the Theory of Computation* (3rd Edition). Cengage Learning, 2012. ISBN: 978-1133187790  
→ 第3-5章讨论图灵机、可判定性、归约，适合入门

[Cooper2004] S. Barry Cooper. *Computability Theory*. Chapman & Hall/CRC, 2004. ISBN: 978-1584882374  
→ 现代可计算性理论教材，包含Post问题的现代处理

[Soare2016] Robert I. Soare. *Turing Computability: Theory and Applications*. Springer, 2016. ISBN: 978-3642319327  
→ Soare的新教材，更新了可计算性理论的现代观点

---

### 专题文献

[Odifreddi1989] Piergiorgio Odifreddi. *Classical Recursion Theory (Volume I)*. North-Holland, 1989. ISBN: 978-0444872951  
→ 递归论百科全书式参考

[Boolos et al.2002] George S. Boolos, John P. Burgess, and Richard C. Jeffrey. *Computability and Logic* (4th Edition). Cambridge University Press, 2002. ISBN: 978-0521007580  
→ 可计算性与逻辑的经典教材

[Copeland2003] B. Jack Copeland (editor). *The Essential Turing*. Oxford University Press, 2003. ISBN: 978-0198250791  
→ 包含Turing1936论文的详细注释和历史背景

---

### 在线资源

[SEPTuringMachine] B. Jack Copeland. "The Church-Turing Thesis." *Stanford Encyclopedia of Philosophy*, 2023. URL: <https://plato.stanford.edu/entries/church-turing/>  
→ Church-Turing论题的哲学讨论

[WikiHaltingProblem] Wikipedia contributors. "Halting problem." *Wikipedia, The Free Encyclopedia*, 2025. URL: <https://en.wikipedia.org/wiki/Halting_problem>  
→ 停机问题的综述

[WikiRiceTheorem] Wikipedia contributors. "Rice's theorem." *Wikipedia, The Free Encyclopedia*, 2025. URL: <https://en.wikipedia.org/wiki/Rice%27s_theorem>  
→ Rice定理的介绍和应用

---

## 附录：对项目其他文档的改进建议

基于本深化示例，建议对以下文档进行类似的深化处理：

1. **优先级P1（核心理论）**:
   - `02-递归理论/01-递归函数定义.md`：添加递归函数层次结构的完整理论、Ackermann函数的详细证明
   - `09-算法理论/01-算法基础/01-算法设计理论.md`：添加算法正确性证明的形式化框架（循环不变式、归纳法）
   - `04-算法复杂度/01-时间复杂度.md`：添加时间层次定理、对角化、下界证明技术

2. **优先级P2（核心主题深化）**:
   - `05-类型理论/01-简单类型论.md`：添加类型安全性（progress & preservation）的完整证明
   - `03-形式化证明/01-证明系统.md`：添加自然演绎、序列演算的完备性和可靠性证明

3. **引用规范化**:
   - 所有文档都应添加"参考文献"章节
   - 核心定义和定理必须标注出处
   - 使用 `docs/references_database.yaml` 中的标准引用

---

**文档版本**: 1.0-深化示例  
**创建日期**: 2025-10-11  
**维护者**: 项目团队  
**反馈**: 欢迎通过Issue提出改进建议

---

*本文档展示了形式化算法项目的学术规范标准：完整的定理证明、严格的引用、详细的数学推导。*
