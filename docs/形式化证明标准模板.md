# å½¢å¼åŒ–è¯æ˜æ ‡å‡†æ¨¡æ¿

> **ç‰ˆæœ¬**: 1.0
> **åˆ›å»ºæ—¥æœŸ**: 2025-01-25
> **çŠ¶æ€**: âœ… å·²å®Œæˆ
> **é€‚ç”¨èŒƒå›´**: æ‰€æœ‰ç®—æ³•æ­£ç¡®æ€§è¯æ˜

---

## ğŸ“‹ æ¨¡æ¿è¯´æ˜

æœ¬æ–‡æ¡£å®šä¹‰äº†ç®—æ³•å½¢å¼åŒ–è¯æ˜çš„æ ‡å‡†æ¨¡æ¿ï¼Œç¡®ä¿æ‰€æœ‰è¯æ˜çš„ä¸€è‡´æ€§å’Œä¸¥è°¨æ€§ã€‚

**This document defines the standard template for formal algorithm correctness proofs to ensure consistency and rigor of all proofs.**

---

## 1. è¯æ˜ç±»å‹åˆ†ç±»

### 1.1 å¾ªç¯ä¸å˜å¼è¯æ˜

é€‚ç”¨äºï¼šåŒ…å«å¾ªç¯çš„ç®—æ³•ï¼ˆå¦‚æ’åºã€æœç´¢ã€å›¾éå†ï¼‰

### 1.2 å¼ºå½’çº³æ³•è¯æ˜

é€‚ç”¨äºï¼šé€’å½’ç®—æ³•ï¼ˆå¦‚åˆ†æ²»ã€åŠ¨æ€è§„åˆ’ï¼‰

### 1.3 æœ€ä¼˜å­ç»“æ„è¯æ˜

é€‚ç”¨äºï¼šåŠ¨æ€è§„åˆ’ã€è´ªå¿ƒç®—æ³•

### 1.4 äº¤æ¢è®ºè¯è¯æ˜

é€‚ç”¨äºï¼šè´ªå¿ƒç®—æ³•

---

## 2. å¾ªç¯ä¸å˜å¼è¯æ˜æ¨¡æ¿

### 2.1 æ¨¡æ¿ç»“æ„

```markdown
**å®šç† X.X.X** (ç®—æ³•æ­£ç¡®æ€§å®šç†) ç®—æ³•èƒ½å¤Ÿæ­£ç¡®è§£å†³ç»™å®šé—®é¢˜ã€‚
**Theorem X.X.X** (Algorithm Correctness Theorem) The algorithm correctly solves the given problem.

**å½¢å¼åŒ–æ­£ç¡®æ€§è¯æ˜ / Formal Correctness Proof:**

**å‰ç½®æ¡ä»¶ / Precondition**:
- è¾“å…¥æ¡ä»¶1
- è¾“å…¥æ¡ä»¶2
**Input condition 1**
**Input condition 2**

**åç½®æ¡ä»¶ / Postcondition**:
- è¾“å‡ºæ¡ä»¶1
- è¾“å‡ºæ¡ä»¶2
**Output condition 1**
**Output condition 2**

**å¾ªç¯ä¸å˜å¼ / Loop Invariant:**

åœ¨æ¯æ¬¡å¾ªç¯è¿­ä»£å¼€å§‹æ—¶ï¼Œä»¥ä¸‹æ¡ä»¶æˆç«‹ï¼š
At the start of each loop iteration, the following conditions hold:

1. **æ¡ä»¶1 / Condition 1**:
   æè¿°æ¡ä»¶1
   Description of condition 1

2. **æ¡ä»¶2 / Condition 2**:
   æè¿°æ¡ä»¶2
   Description of condition 2

3. **æ¡ä»¶3 / Condition 3**:
   æè¿°æ¡ä»¶3
   Description of condition 3

**è¯æ˜å¾ªç¯ä¸å˜å¼ / Prove Loop Invariant:**

**åˆå§‹åŒ– / Initialization**:
åœ¨å¾ªç¯ç¬¬ä¸€æ¬¡è¿­ä»£ä¹‹å‰ï¼š
Before the first iteration of the loop:

- æ¡ä»¶1æˆç«‹ï¼Œå› ä¸º...
- æ¡ä»¶2æˆç«‹ï¼Œå› ä¸º...
- Condition 1 holds because...
- Condition 2 holds because...

**ä¿æŒ / Maintenance**:
å‡è®¾ä¸å˜å¼åœ¨è¿­ä»£ $i$ å¼€å§‹æ—¶æˆç«‹ï¼Œè¯æ˜åœ¨è¿­ä»£ $i+1$ å¼€å§‹æ—¶ä¹Ÿæˆç«‹ï¼š
Assume the invariant holds at the start of iteration $i$, prove it also holds at the start of iteration $i+1$:

- åœ¨è¿­ä»£ $i$ ä¸­ï¼Œç®—æ³•æ‰§è¡Œæ“ä½œ...
- è¿™äº›æ“ä½œä¿æŒæ¡ä»¶1ï¼Œå› ä¸º...
- è¿™äº›æ“ä½œä¿æŒæ¡ä»¶2ï¼Œå› ä¸º...
- In iteration $i$, the algorithm performs operations...
- These operations maintain condition 1 because...
- These operations maintain condition 2 because...

**ç»ˆæ­¢ / Termination**:
å½“å¾ªç¯ç»ˆæ­¢æ—¶ï¼š
When the loop terminates:

- å¾ªç¯ç»ˆæ­¢æ¡ä»¶æ»¡è¶³ï¼š...
- æ ¹æ®ä¸å˜å¼ï¼Œæ¡ä»¶1å’Œæ¡ä»¶2æˆç«‹
- ç»“åˆç»ˆæ­¢æ¡ä»¶ï¼Œå¯ä»¥æ¨å‡ºåç½®æ¡ä»¶
- Loop termination condition is satisfied:...
- By the invariant, conditions 1 and 2 hold
- Combined with termination condition, postcondition follows

**ç»ˆæ­¢æ€§è¯æ˜ / Termination Proof:**

å¾ªç¯å˜é‡åœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼š
The loop variable in each iteration:

- å•è°ƒé€’å¢/é€’å‡ï¼š...
- æœ‰ä¸Šç•Œ/ä¸‹ç•Œï¼š...
- å› æ­¤å¾ªç¯å¿…ç„¶åœ¨æœ‰é™æ­¥å†…ç»ˆæ­¢
- Monotonically increases/decreases:...
- Has upper/lower bound:...
- Therefore, the loop must terminate in finite steps
```

### 2.2 ç¤ºä¾‹ï¼šäºŒåˆ†æœç´¢å¾ªç¯ä¸å˜å¼

å‚è§ï¼š`docs/09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/04-æœç´¢ç®—æ³•ç†è®º.md` ç¬¬3.1èŠ‚

---

## 3. å¼ºå½’çº³æ³•è¯æ˜æ¨¡æ¿

### 3.1 æ¨¡æ¿ç»“æ„

```markdown
**å®šç† X.X.X** (ç®—æ³•æ­£ç¡®æ€§å®šç†) ç®—æ³•èƒ½å¤Ÿæ­£ç¡®è§£å†³ç»™å®šé—®é¢˜ã€‚
**Theorem X.X.X** (Algorithm Correctness Theorem) The algorithm correctly solves the given problem.

**å½¢å¼åŒ–æ­£ç¡®æ€§è¯æ˜ / Formal Correctness Proof:**

**å‰ç½®æ¡ä»¶ / Precondition**:
- è¾“å…¥æ¡ä»¶
- Input condition

**åç½®æ¡ä»¶ / Postcondition**:
- è¾“å‡ºæ¡ä»¶
- Output condition

**è¯æ˜æ–¹æ³•ï¼šå¼ºå½’çº³æ³• / Proof Method: Strong Induction**

**åŸºç¡€æƒ…å†µ / Base Case**:
å½“è¾“å…¥è§„æ¨¡ $n \leq n_0$ æ—¶ï¼š
When input size $n \leq n_0$:

- ç®—æ³•ç›´æ¥è¿”å›ç»“æœ
- ç»“æœæ˜¾ç„¶æ­£ç¡®
- Algorithm returns result directly
- Result is obviously correct

**å½’çº³å‡è®¾ / Inductive Hypothesis**:
å‡è®¾å¯¹äºæ‰€æœ‰ $k < n$ï¼Œç®—æ³•å¯¹è§„æ¨¡ $k$ çš„è¾“å…¥æ­£ç¡®ã€‚
Assume for all $k < n$, the algorithm is correct for input size $k$.

**å½’çº³æ­¥éª¤ / Inductive Step**:
å¯¹äºè§„æ¨¡ $n$ çš„è¾“å…¥ï¼š
For input size $n$:

1. **åˆ†è§£ / Divide**:
   å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜ï¼Œè§„æ¨¡åˆ†åˆ«ä¸º $n_1, n_2, \ldots, n_k$ï¼Œä¸” $n_i < n$
   Divide problem into subproblems of sizes $n_1, n_2, \ldots, n_k$, where $n_i < n$

2. **è§£å†³ / Conquer**:
   æ ¹æ®å½’çº³å‡è®¾ï¼Œé€’å½’æ±‚è§£å­é—®é¢˜å¾—åˆ°æ­£ç¡®ç»“æœ
   By inductive hypothesis, recursively solve subproblems to get correct results

3. **åˆå¹¶ / Combine**:
   åˆå¹¶å­é—®é¢˜çš„è§£å¾—åˆ°åŸé—®é¢˜çš„è§£
   Combine subproblem solutions to get solution to original problem

4. **æ­£ç¡®æ€§ / Correctness**:
   ç”±äºåˆ†è§£æ­£ç¡®ã€å­é—®é¢˜æ±‚è§£æ­£ç¡®ã€åˆå¹¶æ­£ç¡®ï¼Œå› æ­¤åŸé—®é¢˜æ±‚è§£æ­£ç¡®
   Since division is correct, subproblem solutions are correct, and combination is correct, the original problem solution is correct

**ç»ˆæ­¢æ€§è¯æ˜ / Termination Proof:**

- é€’å½’æ·±åº¦æœ‰é™ï¼š...
- æ¯æ¬¡é€’å½’è§„æ¨¡é€’å‡ï¼š...
- å› æ­¤ç®—æ³•å¿…ç„¶ç»ˆæ­¢
- Recursion depth is finite:...
- Problem size decreases in each recursion:...
- Therefore, the algorithm must terminate
```

### 3.2 ç¤ºä¾‹ï¼šå½’å¹¶æ’åºå¼ºå½’çº³æ³•

å‚è§ï¼š`docs/09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/03-æ’åºç®—æ³•ç†è®º.md` ç¬¬2.4èŠ‚

---

## 4. æœ€ä¼˜å­ç»“æ„è¯æ˜æ¨¡æ¿

### 4.1 æ¨¡æ¿ç»“æ„

```markdown
**å®šç† X.X.X** (æœ€ä¼˜å­ç»“æ„å®šç†) é—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å…¶å­é—®é¢˜çš„æœ€ä¼˜è§£ã€‚
**Theorem X.X.X** (Optimal Substructure Theorem) The optimal solution contains optimal solutions to its subproblems.

**è¯æ˜ / Proof:**

è®¾ $S$ ä¸ºåŸé—®é¢˜çš„æœ€ä¼˜è§£ï¼Œ$S_1, S_2, \ldots, S_k$ ä¸ºå¯¹åº”çš„å­é—®é¢˜è§£ã€‚
Let $S$ be the optimal solution to the original problem, $S_1, S_2, \ldots, S_k$ be the corresponding subproblem solutions.

**æƒ…å†µ1ï¼š$S_i$ ä¸æ˜¯å­é—®é¢˜çš„æœ€ä¼˜è§£**
**Case 1: $S_i$ is not optimal for subproblem**

å‡è®¾å­˜åœ¨å­é—®é¢˜çš„æœ€ä¼˜è§£ $S_i'$ï¼Œä½¿å¾— $cost(S_i') < cost(S_i)$ã€‚
Assume there exists optimal solution $S_i'$ to subproblem such that $cost(S_i') < cost(S_i)$.

æ„é€ æ–°è§£ $S' = S \setminus S_i \cup S_i'$ã€‚
Construct new solution $S' = S \setminus S_i \cup S_i'$.

ç”±äº $cost(S_i') < cost(S_i)$ï¼Œæˆ‘ä»¬æœ‰ $cost(S') < cost(S)$ã€‚
Since $cost(S_i') < cost(S_i)$, we have $cost(S') < cost(S)$.

è¿™ä¸ $S$ æ˜¯æœ€ä¼˜è§£çŸ›ç›¾ã€‚
This contradicts that $S$ is optimal.

å› æ­¤ $S_i$ å¿…é¡»æ˜¯å­é—®é¢˜çš„æœ€ä¼˜è§£ã€‚
Therefore $S_i$ must be optimal for the subproblem.

**æƒ…å†µ2ï¼šå…¶ä»–æƒ…å†µ**ï¼ˆæ ¹æ®å…·ä½“é—®é¢˜ï¼‰
**Case 2: Other cases** (depending on specific problem)

ç±»ä¼¼å¯è¯ã€‚
Similarly provable.

**å®šç† X.X.X+1** (åŠ¨æ€è§„åˆ’ç®—æ³•æ­£ç¡®æ€§) åŸºäºæœ€ä¼˜å­ç»“æ„çš„åŠ¨æ€è§„åˆ’ç®—æ³•äº§ç”Ÿæœ€ä¼˜è§£ã€‚
**Theorem X.X.X+1** (Dynamic Programming Correctness) Dynamic programming algorithm based on optimal substructure produces optimal solution.

**è¯æ˜ / Proof:**

ä½¿ç”¨å½’çº³æ³•è¯æ˜ $dp[i]$ ç­‰äºå­é—®é¢˜çš„æœ€ä¼˜è§£ã€‚
Use induction to prove $dp[i]$ equals the optimal solution to subproblem.

**åŸºç¡€æƒ…å†µ**: $dp[0]$ æ˜¾ç„¶æ˜¯æœ€ä¼˜è§£ã€‚
**Base case**: $dp[0]$ is obviously optimal.

**å½’çº³å‡è®¾**: å‡è®¾å¯¹äºæ‰€æœ‰ $j < i$ï¼Œ$dp[j]$ æ˜¯æœ€ä¼˜è§£ã€‚
**Inductive hypothesis**: Assume for all $j < i$, $dp[j]$ is optimal.

**å½’çº³æ­¥éª¤**:
æ ¹æ®æœ€ä¼˜å­ç»“æ„ï¼Œ$dp[i]$ é€šè¿‡ç»„åˆå­é—®é¢˜æœ€ä¼˜è§£å¾—åˆ°ï¼Œå› æ­¤ $dp[i]$ ä¹Ÿæ˜¯æœ€ä¼˜è§£ã€‚
By optimal substructure, $dp[i]$ is obtained by combining optimal subproblem solutions, so $dp[i]$ is also optimal.
```

### 4.2 ç¤ºä¾‹ï¼šLCSæœ€ä¼˜å­ç»“æ„

å‚è§ï¼š`docs/09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/06-åŠ¨æ€è§„åˆ’ç†è®º.md` ç¬¬3èŠ‚

---

## 5. äº¤æ¢è®ºè¯è¯æ˜æ¨¡æ¿ï¼ˆè´ªå¿ƒç®—æ³•ï¼‰

### 5.1 æ¨¡æ¿ç»“æ„

```markdown
**å®šç† X.X.X** (è´ªå¿ƒç®—æ³•æ­£ç¡®æ€§å®šç†) è´ªå¿ƒç®—æ³•äº§ç”Ÿæœ€ä¼˜è§£ã€‚
**Theorem X.X.X** (Greedy Algorithm Correctness Theorem) The greedy algorithm produces an optimal solution.

**è¯æ˜ / Proof:**

è®¾ $A$ ä¸ºè´ªå¿ƒç®—æ³•äº§ç”Ÿçš„è§£ï¼Œ$O$ ä¸ºæœ€ä¼˜è§£ã€‚
Let $A$ be the solution produced by the greedy algorithm, $O$ be the optimal solution.

**æƒ…å†µ1ï¼š$A = O$**
**Case 1: $A = O$**

ç»“è®ºæ˜¾ç„¶æˆç«‹ã€‚
Conclusion obviously holds.

**æƒ…å†µ2ï¼š$A \neq O$**
**Case 2: $A \neq O$**

è®¾ $i$ ä¸ºç¬¬ä¸€ä¸ªä½ç½®ï¼Œä½¿å¾— $A[i] \neq O[i]$ã€‚
Let $i$ be the first position such that $A[i] \neq O[i]$.

æ ¹æ®è´ªå¿ƒé€‰æ‹©ï¼Œ$A[i]$ æ˜¯å½“å‰æœ€ä¼˜é€‰æ‹©ã€‚
By greedy choice, $A[i]$ is the current optimal choice.

æ„é€ æ–°è§£ $O' = O \setminus \{O[i]\} \cup \{A[i]\}$ã€‚
Construct new solution $O' = O \setminus \{O[i]\} \cup \{A[i]\}$.

ç”±äº $A[i]$ æ˜¯å½“å‰æœ€ä¼˜é€‰æ‹©ï¼Œ$cost(O') \leq cost(O)$ã€‚
Since $A[i]$ is the current optimal choice, $cost(O') \leq cost(O)$.

å¦‚æœ $cost(O') < cost(O)$ï¼Œä¸ $O$ æ˜¯æœ€ä¼˜è§£çŸ›ç›¾ã€‚
If $cost(O') < cost(O)$, this contradicts that $O$ is optimal.

å› æ­¤ $cost(O') = cost(O)$ï¼Œ$O'$ ä¹Ÿæ˜¯æœ€ä¼˜è§£ã€‚
Therefore $cost(O') = cost(O)$, $O'$ is also optimal.

é‡å¤æ­¤è¿‡ç¨‹ï¼Œæœ€ç»ˆå¾—åˆ° $A$ ä¹Ÿæ˜¯æœ€ä¼˜è§£ã€‚
Repeat this process, eventually $A$ is also optimal.
```

### 5.2 ç¤ºä¾‹ï¼šæ´»åŠ¨é€‰æ‹©é—®é¢˜

å‚è§ï¼š`docs/09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/07-è´ªå¿ƒç®—æ³•ç†è®º.md` ç¬¬1èŠ‚

---

## 6. è´¨é‡æ£€æŸ¥æ¸…å•

### 6.1 è¯æ˜å®Œæ•´æ€§

- [ ] æœ‰æ˜ç¡®çš„å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶
- [ ] è¯æ˜æ–¹æ³•é€‰æ‹©æ°å½“
- [ ] è¯æ˜æ­¥éª¤å®Œæ•´ï¼Œæ²¡æœ‰è·³æ­¥
- [ ] æœ‰ç»ˆæ­¢æ€§è¯æ˜ï¼ˆå¦‚é€‚ç”¨ï¼‰

### 6.2 é€»è¾‘ä¸¥è°¨æ€§

- [ ] æ‰€æœ‰æ–­è¨€éƒ½æœ‰ç†ç”±
- [ ] æ²¡æœ‰å¾ªç¯è®ºè¯
- [ ] å½’çº³åŸºç¡€æ­£ç¡®
- [ ] å½’çº³æ­¥éª¤æ­£ç¡®

### 6.3 æ ¼å¼è§„èŒƒæ€§

- [ ] ä½¿ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·
- [ ] ä¸­è‹±æ–‡å¯¹ç…§å®Œæ•´
- [ ] å®šç†ç¼–å·æ­£ç¡®
- [ ] å­¦æœ¯å¼•ç”¨æ ¼å¼æ­£ç¡®

---

## 7. è¯æ˜æ–¹æ³•é€‰æ‹©æŒ‡å—

| ç®—æ³•ç±»å‹ | æ¨èè¯æ˜æ–¹æ³• | åŸå›  |
|---------|------------|------|
| å¾ªç¯ç®—æ³• | å¾ªç¯ä¸å˜å¼ | ç›´æ¥å¯¹åº”å¾ªç¯ç»“æ„ |
| é€’å½’ç®—æ³• | å¼ºå½’çº³æ³• | å¯¹åº”é€’å½’ç»“æ„ |
| åŠ¨æ€è§„åˆ’ | æœ€ä¼˜å­ç»“æ„ + å½’çº³æ³• | éœ€è¦è¯æ˜æœ€ä¼˜å­ç»“æ„ |
| è´ªå¿ƒç®—æ³• | äº¤æ¢è®ºè¯ | éœ€è¦è¯æ˜è´ªå¿ƒé€‰æ‹©æ­£ç¡® |
| å›¾ç®—æ³• | å¾ªç¯ä¸å˜å¼æˆ–å½’çº³æ³• | å–å†³äºç®—æ³•ç»“æ„ |

---

## 8. å‚è€ƒæ–‡æ¡£

- [æ•°å­¦ç¬¦å·è§„èŒƒ-ISO80000å¯¹é½ç‰ˆ](æ•°å­¦ç¬¦å·è§„èŒƒ-ISO80000å¯¹é½ç‰ˆ.md)
- [æ•°å­¦æ¨å¯¼æ ‡å‡†æ¨¡æ¿](æ•°å­¦æ¨å¯¼æ ‡å‡†æ¨¡æ¿.md)
- [é¡¹ç›®æ”¹è¿›ä»»åŠ¡æ¸…å•](é¡¹ç›®æ”¹è¿›ä»»åŠ¡æ¸…å•-2025.md)

---

**æ–‡æ¡£ç»´æŠ¤**: é¡¹ç›®æ”¹è¿›å·¥ä½œç»„
**æœ€åæ›´æ–°**: 2025-01-25
**ä¸‹æ¬¡å®¡æŸ¥**: 2025-04-25
