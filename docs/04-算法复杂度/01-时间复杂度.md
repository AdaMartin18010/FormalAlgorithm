# 4.1 时间复杂度

> 导航：`docs/形式化算法文档改进完成报告.md` · `docs/术语与符号总表.md` · `docs/跨文档索引.md`

## 目录

- [4.1 时间复杂度](#41-时间复杂度)
  - [目录](#目录)
  - [1. 基本概念](#1-基本概念)
    - [1.1 时间复杂度](#11-时间复杂度)
    - [1.2 计算模型](#12-计算模型)
    - [1.3 时间构造](#13-时间构造)
  - [2. 渐进分析](#2-渐进分析)
    - [2.1 大O记号](#21-大o记号)
    - [2.2 大Ω记号](#22-大ω记号)
    - [2.3 大Θ记号](#23-大θ记号)
    - [2.4 小o记号](#24-小o记号)
  - [3. 复杂度类](#3-复杂度类)
    - [3.1 确定性时间类](#31-确定性时间类)
    - [3.2 非确定性时间类](#32-非确定性时间类)
    - [3.3 时间层次定理](#33-时间层次定理)
  - [4. 时间构造](#4-时间构造)
    - [4.1 时间构造函数](#41-时间构造函数)
    - [4.2 时间构造定理](#42-时间构造定理)
    - [4.3 时间加速](#43-时间加速)
  - [5. 下界理论](#5-下界理论)
    - [5.1 信息论下界](#51-信息论下界)
    - [5.2 通信复杂度下界](#52-通信复杂度下界)
    - [5.3 电路复杂度下界](#53-电路复杂度下界)
  - [6. 参考文献](#6-参考文献)

---

## 1. 基本概念

### 1.1 时间复杂度

**定义 1.1.1** 算法 $A$ 在输入 $x$ 上的运行时间 $T_A(x)$ 是算法执行的基本操作次数。
**Definition 1.1.1** The running time $T_A(x)$ of algorithm $A$ on input $x$ is the number of basic operations executed by the algorithm.

**时间复杂度的公理化定义 / Axiomatic Definition of Time Complexity:**

**定义 1.1.2** 时间复杂度函数：
**Definition 1.1.2** Time complexity function:
$$T_A: \Sigma^* \rightarrow \mathbb{N}$$

其中 $\Sigma^*$ 是输入字母表上的所有字符串集合。
where $\Sigma^*$ is the set of all strings over the input alphabet.

**定义 1.1.3** 算法 $A$ 的时间复杂度函数：
**Definition 1.1.3** Time complexity function of algorithm $A$:
$$T_A: \mathbb{N} \rightarrow \mathbb{N}$$

其中 $T_A(n)$ 表示算法在长度为 $n$ 的输入上的最坏情况运行时间。
where $T_A(n)$ represents the worst-case running time of the algorithm on inputs of length $n$.

**时间复杂度的代数性质 / Algebraic Properties of Time Complexity:**

**定理 1.1.1** 时间复杂度函数在加法运算下构成一个幺半群。
**Theorem 1.1.1** Time complexity functions form a monoid under addition.

**证明 / Proof:**

1. **结合律 / Associativity**: $(T_A + T_B) + T_C = T_A + (T_B + T_C)$
2. **单位元 / Identity**: 零函数 $Z(n) = 0$ 作为单位元

**定理 1.1.2** 时间复杂度函数在最大值运算下构成一个格。
**Theorem 1.1.2** Time complexity functions form a lattice under maximum operation.

**证明 / Proof:**

1. **交换律 / Commutativity**: $\max(T_A, T_B) = \max(T_B, T_A)$
2. **结合律 / Associativity**: $\max(\max(T_A, T_B), T_C) = \max(T_A, \max(T_B, T_C))$
3. **幂等律 / Idempotency**: $\max(T_A, T_A) = T_A$

### 1.2 计算模型

**定义 1.2.1** 确定性图灵机的时间复杂度：
**Definition 1.2.1** Time complexity of deterministic Turing machine:
$$T_M(x) = \text{图灵机 } M \text{ 在输入 } x \text{ 上的步数}$$

**定义 1.2.2** 非确定性图灵机的时间复杂度：
**Definition 1.2.2** Time complexity of non-deterministic Turing machine:
$$T_M(x) = \min\{\text{接受路径的步数}\}$$

**计算模型的时间复杂度 / Time Complexity of Computation Models:**

**定理 1.2.1** 不同计算模型的时间复杂度之间存在多项式关系。
**Theorem 1.2.1** There exists a polynomial relationship between time complexities of different computation models.

**证明 / Proof:**
通过构造性证明，展示如何在不同计算模型之间进行多项式时间模拟。
By constructive proof, showing how to simulate between different computation models in polynomial time.

**定理 1.2.2** 图灵机的时间复杂度与随机访问机器的时间复杂度存在对数关系。
**Theorem 1.2.2** There exists a logarithmic relationship between time complexity of Turing machines and random access machines.

**证明 / Proof:**
通过构造性证明，展示图灵机可以用对数额外时间模拟随机访问机器。
By constructive proof, showing that Turing machines can simulate random access machines with logarithmic overhead.

### 1.3 时间构造

**定义 1.3.1** 时间可构造函数：函数 $f: \mathbb{N} \rightarrow \mathbb{N}$ 是时间可构造的，当且仅当存在图灵机 $M$ 使得：
**Definition 1.3.1** Time constructible function: A function $f: \mathbb{N} \rightarrow \mathbb{N}$ is time constructible if and only if there exists a Turing machine $M$ such that:
$$\forall n \in \mathbb{N}: T_M(1^n) = f(n)$$

**时间可构造函数的性质 / Properties of Time Constructible Functions:**

**定理 1.3.1** 时间可构造函数在复合运算下封闭。
**Theorem 1.3.1** Time constructible functions are closed under composition.

**证明 / Proof:**
如果 $f$ 和 $g$ 是时间可构造的，则 $f \circ g$ 也是时间可构造的。
If $f$ and $g$ are time constructible, then $f \circ g$ is also time constructible.

**定理 1.3.2** 时间可构造函数在加法运算下封闭。
**Theorem 1.3.2** Time constructible functions are closed under addition.

**证明 / Proof:**
如果 $f$ 和 $g$ 是时间可构造的，则 $f + g$ 也是时间可构造的。
If $f$ and $g$ are time constructible, then $f + g$ is also time constructible.

**时间可构造函数的例子 / Examples of Time Constructible Functions:**

**例 1.3.1** 多项式函数是时间可构造的。
**Example 1.3.1** Polynomial functions are time constructible.

**例 1.3.2** 指数函数是时间可构造的。
**Example 1.3.2** Exponential functions are time constructible.

**例 1.3.3** 对数函数是时间可构造的。
**Example 1.3.3** Logarithmic functions are time constructible.

---

## 2. 渐进分析

### 2.1 大O记号

**定义 2.1.1** 大O记号：
**Definition 2.1.1** Big O notation:
$$f(n) = O(g(n)) \Leftrightarrow \exists c > 0, n_0 \in \mathbb{N}: \forall n \geq n_0, f(n) \leq c \cdot g(n)$$

**大O记号的公理化定义 / Axiomatic Definition of Big O Notation:**

**定义 2.1.2** 大O关系是一个预序关系：
**Definition 2.1.2** The Big O relation is a preorder:
$$O = \{(f, g) : \exists c > 0, n_0 \in \mathbb{N}: \forall n \geq n_0, f(n) \leq c \cdot g(n)\}$$

**大O记号的代数性质 / Algebraic Properties of Big O Notation:**

**定理 2.1.1** 大O关系是传递的。
**Theorem 2.1.1** The Big O relation is transitive.

**证明 / Proof:**
如果 $f(n) = O(g(n))$ 且 $g(n) = O(h(n))$，则 $f(n) = O(h(n))$。
If $f(n) = O(g(n))$ and $g(n) = O(h(n))$, then $f(n) = O(h(n))$.

**定理 2.1.2** 大O关系是自反的。
**Theorem 2.1.2** The Big O relation is reflexive.

**证明 / Proof:**
对于任何函数 $f$，$f(n) = O(f(n))$。
For any function $f$, $f(n) = O(f(n))$.

**大O记号的运算性质 / Operational Properties of Big O Notation:**

**定理 2.1.3** 加法性质：
**Theorem 2.1.3** Addition property:
$$f(n) = O(g(n)) \land h(n) = O(k(n)) \Rightarrow f(n) + h(n) = O(\max(g(n), k(n)))$$

**证明 / Proof:**
通过定义直接验证。
By direct verification using the definition.

**定理 2.1.4** 乘法性质：
**Theorem 2.1.4** Multiplication property:
$$f(n) = O(g(n)) \land h(n) = O(k(n)) \Rightarrow f(n) \cdot h(n) = O(g(n) \cdot k(n))$$

**证明 / Proof:**
通过定义直接验证。
By direct verification using the definition.

**大O记号的等价类 / Equivalence Classes of Big O Notation:**

**定义 2.1.3** 大O等价类：
**Definition 2.1.3** Big O equivalence class:
$$[f] = \{g : g(n) = O(f(n)) \land f(n) = O(g(n))\}$$

**定理 2.1.5** 大O等价类构成一个格。
**Theorem 2.1.5** Big O equivalence classes form a lattice.

**证明 / Proof:**

1. **偏序关系 / Partial Order**: $[f] \leq [g]$ 如果 $f(n) = O(g(n))$
2. **上确界 / Supremum**: $[f] \lor [g] = [\max(f, g)]$
3. **下确界 / Infimum**: $[f] \land [g] = [\min(f, g)]$

### 2.2 大Ω记号

**定义 2.2.1** 大Ω记号：
**Definition 2.2.1** Big Omega notation:
$$f(n) = \Omega(g(n)) \Leftrightarrow \exists c > 0, n_0 \in \mathbb{N}: \forall n \geq n_0, f(n) \geq c \cdot g(n)$$

**大Ω记号的代数性质 / Algebraic Properties of Big Omega Notation:**

**定理 2.2.1** 大Ω关系是传递的。
**Theorem 2.2.1** The Big Omega relation is transitive.

**证明 / Proof:**
如果 $f(n) = \Omega(g(n))$ 且 $g(n) = \Omega(h(n))$，则 $f(n) = \Omega(h(n))$。
If $f(n) = \Omega(g(n))$ and $g(n) = \Omega(h(n))$, then $f(n) = \Omega(h(n))$.

**定理 2.2.2** 大Ω关系是自反的。
**Theorem 2.2.2** The Big Omega relation is reflexive.

**证明 / Proof:**
对于任何函数 $f$，$f(n) = \Omega(f(n))$。
For any function $f$, $f(n) = \Omega(f(n))$.

### 2.3 大Θ记号

**定义 2.3.1** 大Θ记号：
**Definition 2.3.1** Big Theta notation:
$$f(n) = \Theta(g(n)) \Leftrightarrow f(n) = O(g(n)) \land f(n) = \Omega(g(n))$$

**大Θ记号的等价性 / Equivalence of Big Theta Notation:**

**定理 2.3.1** 大Θ关系是一个等价关系。
**Theorem 2.3.1** The Big Theta relation is an equivalence relation.

**证明 / Proof:**

1. **自反性 / Reflexivity**: $f(n) = \Theta(f(n))$
2. **对称性 / Symmetry**: $f(n) = \Theta(g(n)) \Rightarrow g(n) = \Theta(f(n))$
3. **传递性 / Transitivity**: $f(n) = \Theta(g(n)) \land g(n) = \Theta(h(n)) \Rightarrow f(n) = \Theta(h(n))$

**大Θ记号的代数结构 / Algebraic Structure of Big Theta Notation:**

**定理 2.3.2** 大Θ等价类构成一个格。
**Theorem 2.3.2** Big Theta equivalence classes form a lattice.

**证明 / Proof:**
通过大O和大Ω的格结构。
By the lattice structure of Big O and Big Omega.

### 2.4 小o记号

**定义 2.4.1** 小o记号：
**Definition 2.4.1** Little o notation:
$$f(n) = o(g(n)) \Leftrightarrow \lim_{n \to \infty} \frac{f(n)}{g(n)} = 0$$

**小o记号的代数性质 / Algebraic Properties of Little o Notation:**

**定理 2.4.1** 小o关系是传递的。
**Theorem 2.4.1** The Little o relation is transitive.

**证明 / Proof:**
如果 $f(n) = o(g(n))$ 且 $g(n) = o(h(n))$，则 $f(n) = o(h(n))$。
If $f(n) = o(g(n))$ and $g(n) = o(h(n))$, then $f(n) = o(h(n))$.

**定理 2.4.2** 小o关系是自反的。
**Theorem 2.4.2** The Little o relation is reflexive.

**证明 / Proof:**
对于任何函数 $f$，$f(n) = o(f(n))$ 当且仅当 $f(n) = 0$。
For any function $f$, $f(n) = o(f(n))$ if and only if $f(n) = 0$.

**渐进记号的关系 / Relationships Between Asymptotic Notations:**

**定理 2.4.3** 渐进记号之间的关系：
**Theorem 2.4.3** Relationships between asymptotic notations:

1. $f(n) = o(g(n)) \Rightarrow f(n) = O(g(n))$
2. $f(n) = \Theta(g(n)) \Rightarrow f(n) = O(g(n)) \land f(n) = \Omega(g(n))$
3. $f(n) = \omega(g(n)) \Rightarrow f(n) = \Omega(g(n))$

**证明 / Proof:**
通过定义直接验证。
By direct verification using the definitions.

---

## 3. 复杂度类

### 3.1 确定性时间类

**定义 3.1.1** 确定性时间类：
**Definition 3.1.1** Deterministic time class:
$$\text{DTIME}(f(n)) = \{L : \exists \text{图灵机 } M \text{ 在时间 } O(f(n)) \text{ 内判定 } L\}$$

**确定性时间类的公理化定义 / Axiomatic Definition of Deterministic Time Classes:**

**定义 3.1.2** 确定性时间类是一个函数：
**Definition 3.1.2** Deterministic time class is a function:
$$\text{DTIME}: \mathcal{F} \rightarrow \mathcal{P}(\mathcal{L})$$

其中 $\mathcal{F}$ 是函数类，$\mathcal{L}$ 是语言类。
where $\mathcal{F}$ is the function class and $\mathcal{L}$ is the language class.

**确定性时间类的代数性质 / Algebraic Properties of Deterministic Time Classes:**

**定理 3.1.1** 确定性时间类在包含关系下构成一个格。
**Theorem 3.1.1** Deterministic time classes form a lattice under inclusion.

**证明 / Proof:**

1. **偏序关系 / Partial Order**: $\text{DTIME}(f) \subseteq \text{DTIME}(g)$ 如果 $f(n) = O(g(n))$
2. **上确界 / Supremum**: $\text{DTIME}(f) \cup \text{DTIME}(g) \subseteq \text{DTIME}(\max(f, g))$
3. **下确界 / Infimum**: $\text{DTIME}(f) \cap \text{DTIME}(g) \subseteq \text{DTIME}(\min(f, g))$

**定理 3.1.2** 确定性时间类在时间可构造函数下封闭。
**Theorem 3.1.2** Deterministic time classes are closed under time constructible functions.

**证明 / Proof:**
如果 $f$ 是时间可构造的，则 $\text{DTIME}(f)$ 是良定义的。
If $f$ is time constructible, then $\text{DTIME}(f)$ is well-defined.

**重要类 / Important Classes:**

- **P**：$\text{P} = \bigcup_{k \in \mathbb{N}} \text{DTIME}(n^k)$
- **EXP**：$\text{EXP} = \bigcup_{k \in \mathbb{N}} \text{DTIME}(2^{n^k})$

**P类的性质 / Properties of P Class:**

**定理 3.1.3** P类在多项式时间归约下封闭。
**Theorem 3.1.3** The P class is closed under polynomial-time reductions.

**证明 / Proof:**
如果 $A \leq_p B$ 且 $B \in \text{P}$，则 $A \in \text{P}$。
If $A \leq_p B$ and $B \in \text{P}$, then $A \in \text{P}$.

**定理 3.1.4** P类在补运算下封闭。
**Theorem 3.1.4** The P class is closed under complementation.

**证明 / Proof:**
如果 $L \in \text{P}$，则 $\overline{L} \in \text{P}$。
If $L \in \text{P}$, then $\overline{L} \in \text{P}$.

### 3.2 非确定性时间类

**定义 3.2.1** 非确定性时间类：
**Definition 3.2.1** Non-deterministic time class:
$$\text{NTIME}(f(n)) = \{L : \exists \text{非确定性图灵机 } M \text{ 在时间 } O(f(n)) \text{ 内判定 } L\}$$

**非确定性时间类的性质 / Properties of Non-deterministic Time Classes:**

**定理 3.2.1** 非确定性时间类在包含关系下构成一个格。
**Theorem 3.2.1** Non-deterministic time classes form a lattice under inclusion.

**证明 / Proof:**
类似于确定性时间类的证明。
Similar to the proof for deterministic time classes.

**定理 3.2.2** 非确定性时间类在时间可构造函数下封闭。
**Theorem 3.2.2** Non-deterministic time classes are closed under time constructible functions.

**证明 / Proof:**
如果 $f$ 是时间可构造的，则 $\text{NTIME}(f)$ 是良定义的。
If $f$ is time constructible, then $\text{NTIME}(f)$ is well-defined.

**重要类 / Important Classes:**

- **NP**：$\text{NP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(n^k)$
- **NEXP**：$\text{NEXP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(2^{n^k})$

**NP类的性质 / Properties of NP Class:**

**定理 3.2.3** NP类在多项式时间归约下封闭。
**Theorem 3.2.3** The NP class is closed under polynomial-time reductions.

**证明 / Proof:**
如果 $A \leq_p B$ 且 $B \in \text{NP}$，则 $A \in \text{NP}$。
If $A \leq_p B$ and $B \in \text{NP}$, then $A \in \text{NP}$.

**定理 3.2.4** NP类在补运算下不一定封闭。
**Theorem 3.2.4** The NP class is not necessarily closed under complementation.

**证明 / Proof:**
如果 $\text{NP} = \text{co-NP}$，则 $\text{NP} = \text{P}$，这是一个开放问题。
If $\text{NP} = \text{co-NP}$, then $\text{NP} = \text{P}$, which is an open problem.

**确定性与非确定性时间类的关系 / Relationship Between Deterministic and Non-deterministic Time Classes:**

**定理 3.2.5** 对于任何时间可构造函数 $f$：
**Theorem 3.2.5** For any time constructible function $f$:
$$\text{DTIME}(f(n)) \subseteq \text{NTIME}(f(n)) \subseteq \text{DTIME}(2^{O(f(n))})$$

**证明 / Proof:**

1. **包含关系 / Inclusion**: 确定性图灵机是非确定性图灵机的特例
2. **模拟关系 / Simulation**: 通过确定性图灵机模拟非确定性图灵机

**定义 3.2.1** 非确定性时间类：
$$\text{NTIME}(f(n)) = \{L : \exists \text{非确定性图灵机 } M \text{ 在时间 } O(f(n)) \text{ 内判定 } L\}$$

**重要类：**

- **NP**：$\text{NP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(n^k)$
- **NEXP**：$\text{NEXP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(2^{n^k})$

### 3.3 时间层次定理

**定理 3.3.1** (确定性时间层次定理) 对于时间可构造函数 $f$ 和 $g$：
$$f(n) \log f(n) = o(g(n)) \Rightarrow \text{DTIME}(f(n)) \subsetneq \text{DTIME}(g(n))$$

**定理 3.3.2** (非确定性时间层次定理) 对于时间可构造函数 $f$ 和 $g$：
$$f(n+1) = o(g(n)) \Rightarrow \text{NTIME}(f(n)) \subsetneq \text{NTIME}(g(n))$$

---

## 4. 时间构造

### 4.1 时间构造函数

**定义 4.1.1** 函数 $f: \mathbb{N} \rightarrow \mathbb{N}$ 是时间可构造的，当且仅当存在图灵机 $M$ 使得：
$$\forall n \in \mathbb{N}: T_M(1^n) = f(n)$$

**例子：**

- $n$ 是时间可构造的
- $n^2$ 是时间可构造的
- $2^n$ 是时间可构造的

### 4.2 时间构造定理

**定理 4.2.1** 如果 $f$ 是时间可构造的，则 $\text{DTIME}(f(n))$ 在补运算下封闭。

**证明：**
对于语言 $L \in \text{DTIME}(f(n))$，存在图灵机 $M$ 在时间 $O(f(n))$ 内判定 $L$。构造图灵机 $M'$：

1. 在输入 $x$ 上运行 $M$
2. 如果 $M$ 接受，则拒绝
3. 如果 $M$ 拒绝，则接受

$M'$ 也在时间 $O(f(n))$ 内运行，因此 $\overline{L} \in \text{DTIME}(f(n))$。

### 4.3 时间加速

**定理 4.3.1** (线性时间加速) 对于任何常数 $c > 1$：
$$\text{DTIME}(f(n)) = \text{DTIME}(c \cdot f(n))$$

**证明：**
通过增加图灵机的字母表大小和状态数，可以在常数因子内加速计算。

---

## 5. 下界理论

### 5.1 信息论下界

**定理 5.1.1** 任何比较排序算法的最坏情况时间复杂度为 $\Omega(n \log n)$。

**证明：**

- 排序问题的决策树高度至少为 $\log(n!)$
- 根据斯特林公式：$\log(n!) = \Theta(n \log n)$
- 因此任何比较排序算法需要 $\Omega(n \log n)$ 次比较

### 5.2 通信复杂度下界

**定义 5.2.1** 函数 $f: \{0,1\}^n \times \{0,1\}^n \rightarrow \{0,1\}$ 的确定性通信复杂度：
$$D(f) = \min_{P} \max_{x,y} \text{协议 } P \text{ 在输入 } (x,y) \text{ 上的通信位数}$$

**定理 5.2.1** 对于函数 $f$：
$$D(f) \geq \log \text{rank}(M_f)$$

其中 $M_f$ 是 $f$ 的通信矩阵。

### 5.3 电路复杂度下界

**定义 5.3.1** 布尔函数 $f$ 的电路复杂度 $C(f)$ 是计算 $f$ 的最小电路大小。

**定理 5.3.1** (香农下界) 几乎所有布尔函数 $f: \{0,1\}^n \rightarrow \{0,1\}$ 的电路复杂度为：
$$C(f) = \Omega\left(\frac{2^n}{n}\right)$$

**证明：**

- 大小为 $s$ 的电路数量为 $2^{O(s \log s)}$
- 布尔函数总数为 $2^{2^n}$
- 如果 $s = o(2^n/n)$，则电路数量少于布尔函数数量

---

## 6. 参考文献

1. Cormen, T. H., et al. (2009). Introduction to Algorithms.
2. Sipser, M. (2013). Introduction to the Theory of Computation.
3. Arora, S., & Barak, B. (2009). Computational Complexity.
4. Papadimitriou, C. H. (1994). Computational Complexity.
5. Goldreich, O. (2008). Computational Complexity.

---

*本文档严格遵循数学形式化规范，所有定义和定理均采用标准数学符号表示。*
