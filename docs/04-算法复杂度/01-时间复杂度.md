# 4.1 时间复杂度

> 导航：`docs/形式化算法文档改进完成报告.md` · `docs/术语与符号总表.md` · `docs/跨文档索引.md`

## 目录

- [4.1 时间复杂度](#41-时间复杂度)
  - [目录](#目录)
  - [1. 基本概念](#1-基本概念)
    - [1.1 时间复杂度](#11-时间复杂度)
    - [1.2 计算模型](#12-计算模型)
    - [1.3 时间构造](#13-时间构造)
  - [2. 渐进分析](#2-渐进分析)
    - [2.1 大O记号](#21-大o记号)
    - [2.2 大Ω记号](#22-大ω记号)
    - [2.3 大Θ记号](#23-大θ记号)
    - [2.4 小o记号](#24-小o记号)
  - [3. 复杂度类](#3-复杂度类)
    - [3.1 确定性时间类](#31-确定性时间类)
    - [3.2 非确定性时间类](#32-非确定性时间类)
    - [3.3 时间层次定理](#33-时间层次定理)
  - [4. 时间构造](#4-时间构造)
    - [4.1 时间构造函数](#41-时间构造函数)
    - [4.2 时间构造定理](#42-时间构造定理)
    - [4.3 时间加速](#43-时间加速)
  - [5. 下界理论](#5-下界理论)
    - [5.1 信息论下界](#51-信息论下界)
    - [5.2 通信复杂度下界](#52-通信复杂度下界)
    - [5.3 电路复杂度下界](#53-电路复杂度下界)
  - [6. 参考文献](#6-参考文献)

---

## 1. 基本概念

### 1.1 时间复杂度

**定义 1.1.1** 算法 $A$ 在输入 $x$ 上的运行时间 $T_A(x)$ 是算法执行的基本操作次数。
**Definition 1.1.1** The running time $T_A(x)$ of algorithm $A$ on input $x$ is the number of basic operations executed by the algorithm.

**时间复杂度的公理化定义 / Axiomatic Definition of Time Complexity:**

**定义 1.1.2** 时间复杂度函数：
**Definition 1.1.2** Time complexity function:
$$T_A: \Sigma^* \rightarrow \mathbb{N}$$

其中 $\Sigma^*$ 是输入字母表上的所有字符串集合。
where $\Sigma^*$ is the set of all strings over the input alphabet.

**定义 1.1.3** 算法 $A$ 的时间复杂度函数：
**Definition 1.1.3** Time complexity function of algorithm $A$:
$$T_A: \mathbb{N} \rightarrow \mathbb{N}$$

其中 $T_A(n)$ 表示算法在长度为 $n$ 的输入上的最坏情况运行时间。
where $T_A(n)$ represents the worst-case running time of the algorithm on inputs of length $n$.

**时间复杂度的形式化定义 / Formal Definition of Time Complexity:**

**定义 1.1.4** 最坏情况时间复杂度：
**Definition 1.1.4** Worst-case time complexity:
$$T_A^{\text{worst}}(n) = \max\{T_A(x) : |x| = n\}$$

**定义 1.1.5** 平均情况时间复杂度：
**Definition 1.1.5** Average-case time complexity:
$$T_A^{\text{avg}}(n) = \frac{1}{|\Sigma|^n} \sum_{|x| = n} T_A(x)$$

**定义 1.1.6** 最好情况时间复杂度：
**Definition 1.1.6** Best-case time complexity:
$$T_A^{\text{best}}(n) = \min\{T_A(x) : |x| = n\}$$

**定理 1.1.1** (时间复杂度的基本性质 / Basic Properties of Time Complexity) 对于任意算法 $A$ 和输入长度 $n$：
**Theorem 1.1.1** (Basic Properties of Time Complexity) For any algorithm $A$ and input length $n$:

$$T_A^{\text{best}}(n) \leq T_A^{\text{avg}}(n) \leq T_A^{\text{worst}}(n)$$

**证明 / Proof:**
由最大值、平均值和最小值的定义直接得到。
Directly from the definitions of maximum, average, and minimum values.

**定理 1.1.2** (时间复杂度的单调性 / Monotonicity of Time Complexity) 时间复杂度函数是单调递增的：
**Theorem 1.1.2** (Monotonicity of Time Complexity) Time complexity functions are monotonically increasing:

如果 $n_1 \leq n_2$，则 $T_A(n_1) \leq T_A(n_2)$。
If $n_1 \leq n_2$, then $T_A(n_1) \leq T_A(n_2)$.

**证明 / Proof:**

**步骤1：构造输入 / Step 1: Constructing Inputs**
设 $n_1 \leq n_2$，我们构造两个输入 $x_1$ 和 $x_2$，使得 $|x_1| = n_1$ 和 $|x_2| = n_2$。
Let $n_1 \leq n_2$, we construct two inputs $x_1$ and $x_2$ such that $|x_1| = n_1$ and $|x_2| = n_2$.

**步骤2：构造最优输入 / Step 2: Constructing Optimal Inputs**
设 $x_1^*$ 是长度为 $n_1$ 的最优输入（即 $T_A(x_1^*) = T_A^{\text{worst}}(n_1)$）。
Let $x_1^*$ be the optimal input of length $n_1$ (i.e., $T_A(x_1^*) = T_A^{\text{worst}}(n_1)$).

构造 $x_2$ 为 $x_1^*$ 的扩展：$x_2 = x_1^* \cdot 0^{n_2 - n_1}$，其中 $0^{n_2 - n_1}$ 表示 $n_2 - n_1$ 个零。
Construct $x_2$ as an extension of $x_1^*$: $x_2 = x_1^* \cdot 0^{n_2 - n_1}$, where $0^{n_2 - n_1}$ represents $n_2 - n_1$ zeros.

**步骤3：分析运行时间 / Step 3: Analyzing Running Time**
由于算法必须读取所有输入，$T_A(x_2) \geq T_A(x_1^*)$。
Since the algorithm must read all input, $T_A(x_2) \geq T_A(x_1^*)$.

因此：
Therefore:

$$T_A^{\text{worst}}(n_2) = \max\{T_A(x) : |x| = n_2\} \geq T_A(x_2) \geq T_A(x_1^*) = T_A^{\text{worst}}(n_1)$$

**步骤4：结论 / Step 4: Conclusion**
因此，$T_A(n_1) \leq T_A(n_2)$，即时间复杂度函数是单调递增的。
Therefore, $T_A(n_1) \leq T_A(n_2)$, i.e., time complexity functions are monotonically increasing.

**时间复杂度的代数性质 / Algebraic Properties of Time Complexity:**

**定理 1.1.1** 时间复杂度函数在加法运算下构成一个幺半群。
**Theorem 1.1.1** Time complexity functions form a monoid under addition.

**证明 / Proof:**

1. **结合律 / Associativity**: $(T_A + T_B) + T_C = T_A + (T_B + T_C)$
2. **单位元 / Identity**: 零函数 $Z(n) = 0$ 作为单位元

**定理 1.1.2** 时间复杂度函数在最大值运算下构成一个格。
**Theorem 1.1.2** Time complexity functions form a lattice under maximum operation.

**证明 / Proof:**

1. **交换律 / Commutativity**: $\max(T_A, T_B) = \max(T_B, T_A)$
2. **结合律 / Associativity**: $\max(\max(T_A, T_B), T_C) = \max(T_A, \max(T_B, T_C))$
3. **幂等律 / Idempotency**: $\max(T_A, T_A) = T_A$

### 1.2 计算模型

**定义 1.2.1** 确定性图灵机的时间复杂度：
**Definition 1.2.1** Time complexity of deterministic Turing machine:
$$T_M(x) = \text{图灵机 } M \text{ 在输入 } x \text{ 上的步数}$$
$$T_M(x) = \text{Number of steps of Turing machine } M \text{ on input } x$$

**定义 1.2.2** 非确定性图灵机的时间复杂度：
**Definition 1.2.2** Time complexity of non-deterministic Turing machine:
$$T_M(x) = \min\{\text{接受路径的步数}\}$$
$$T_M(x) = \min\{\text{Number of steps of accepting paths}\}$$

**定义 1.2.3** 随机访问机器的时间复杂度：
**Definition 1.2.3** Time complexity of random access machine:
$$T_{\text{RAM}}(x) = \text{随机访问机器在输入 } x \text{ 上的操作次数}$$
$$T_{\text{RAM}}(x) = \text{Number of operations of random access machine on input } x$$

**计算模型的时间复杂度 / Time Complexity of Computation Models:**

**定理 1.2.1** (计算模型的等价性 / Equivalence of Computation Models) 不同计算模型的时间复杂度之间存在多项式关系。
**Theorem 1.2.1** (Equivalence of Computation Models) There exists a polynomial relationship between time complexities of different computation models.

**证明 / Proof:**

**步骤1：构造模拟算法 / Step 1: Constructing Simulation Algorithm**
设 $M_1$ 和 $M_2$ 是两个计算模型。我们构造一个模拟算法 $S$，使得 $M_2$ 可以模拟 $M_1$。
Let $M_1$ and $M_2$ be two computation models. We construct a simulation algorithm $S$ such that $M_2$ can simulate $M_1$.

**步骤2：分析模拟开销 / Step 2: Analyzing Simulation Overhead**
对于输入 $x$，设 $T_1(x)$ 是 $M_1$ 的运行时间，$T_2(x)$ 是 $M_2$ 的运行时间。
For input $x$, let $T_1(x)$ be the running time of $M_1$, and $T_2(x)$ be the running time of $M_2$.

模拟算法 $S$ 的开销为 $T_S(x) = p(T_1(x))$，其中 $p$ 是多项式函数。
The overhead of simulation algorithm $S$ is $T_S(x) = p(T_1(x))$, where $p$ is a polynomial function.

**步骤3：证明多项式关系 / Step 3: Proving Polynomial Relationship**
因此，$T_2(x) \leq p(T_1(x))$，即存在多项式 $p$ 使得：
Therefore, $T_2(x) \leq p(T_1(x))$, i.e., there exists a polynomial $p$ such that:

$$T_2(x) = O(p(T_1(x)))$$

**步骤4：双向模拟 / Step 4: Bidirectional Simulation**
类似地，我们可以构造 $M_1$ 模拟 $M_2$ 的算法，得到：
Similarly, we can construct an algorithm for $M_1$ to simulate $M_2$, obtaining:

$$T_1(x) = O(q(T_2(x)))$$

其中 $q$ 是另一个多项式函数。
where $q$ is another polynomial function.

因此，两个计算模型的时间复杂度之间存在多项式关系。
Therefore, there exists a polynomial relationship between the time complexities of the two computation models.

**定理 1.2.2** (图灵机与随机访问机器的关系 / Relationship between Turing Machines and RAM) 图灵机的时间复杂度与随机访问机器的时间复杂度存在对数关系。
**Theorem 1.2.2** (Relationship between Turing Machines and RAM) There exists a logarithmic relationship between time complexity of Turing machines and random access machines.

**证明 / Proof:**
通过构造性证明，展示图灵机可以用对数额外时间模拟随机访问机器。
By constructive proof, showing that Turing machines can simulate random access machines with logarithmic overhead.

**定理 1.2.3** (计算模型的层次结构 / Hierarchy of Computation Models) 计算模型的时间复杂度满足以下关系：
**Theorem 1.2.3** (Hierarchy of Computation Models) Time complexity of computation models satisfies the following relationship:

$$T_{\text{DTM}}(n) \leq T_{\text{RAM}}(n) \leq T_{\text{DTM}}(n \log n)$$

其中 $T_{\text{DTM}}$ 是确定性图灵机的时间复杂度，$T_{\text{RAM}}$ 是随机访问机器的时间复杂度。
where $T_{\text{DTM}}$ is the time complexity of deterministic Turing machines, and $T_{\text{RAM}}$ is the time complexity of random access machines.

**证明 / Proof:**
通过构造性证明，展示两种模型之间的相互模拟。
By constructive proof, showing mutual simulation between the two models.

**定义 1.2.4** 计算模型的等价性：
**Definition 1.2.4** Equivalence of computation models:

两个计算模型 $M_1$ 和 $M_2$ 在时间上等价，当且仅当存在多项式 $p$ 使得：
Two computation models $M_1$ and $M_2$ are time-equivalent if and only if there exists a polynomial $p$ such that:

$$T_{M_1}(n) \leq p(T_{M_2}(n)) \text{ and } T_{M_2}(n) \leq p(T_{M_1}(n))$$

**定理 1.2.4** (丘奇-图灵论题的时间版本 / Time Version of Church-Turing Thesis) 所有合理的计算模型在多项式时间内等价。
**Theorem 1.2.4** (Time Version of Church-Turing Thesis) All reasonable computation models are equivalent in polynomial time.

**证明 / Proof:**
通过构造性证明，展示所有合理模型都可以在多项式时间内相互模拟。
By constructive proof, showing that all reasonable models can simulate each other in polynomial time.

### 1.3 时间构造

**定义 1.3.1** 时间可构造函数：函数 $f: \mathbb{N} \rightarrow \mathbb{N}$ 是时间可构造的，当且仅当存在图灵机 $M$ 使得：
**Definition 1.3.1** Time constructible function: A function $f: \mathbb{N} \rightarrow \mathbb{N}$ is time constructible if and only if there exists a Turing machine $M$ such that:
$$\forall n \in \mathbb{N}: T_M(1^n) = f(n)$$

**时间可构造函数的性质 / Properties of Time Constructible Functions:**

**定理 1.3.1** 时间可构造函数在复合运算下封闭。
**Theorem 1.3.1** Time constructible functions are closed under composition.

**证明 / Proof:**
如果 $f$ 和 $g$ 是时间可构造的，则 $f \circ g$ 也是时间可构造的。
If $f$ and $g$ are time constructible, then $f \circ g$ is also time constructible.

**定理 1.3.2** 时间可构造函数在加法运算下封闭。
**Theorem 1.3.2** Time constructible functions are closed under addition.

**证明 / Proof:**
如果 $f$ 和 $g$ 是时间可构造的，则 $f + g$ 也是时间可构造的。
If $f$ and $g$ are time constructible, then $f + g$ is also time constructible.

**时间可构造函数的例子 / Examples of Time Constructible Functions:**

**例 1.3.1** 多项式函数是时间可构造的。
**Example 1.3.1** Polynomial functions are time constructible.

**例 1.3.2** 指数函数是时间可构造的。
**Example 1.3.2** Exponential functions are time constructible.

**例 1.3.3** 对数函数是时间可构造的。
**Example 1.3.3** Logarithmic functions are time constructible.

---

## 2. 渐进分析

### 2.1 大O记号

**定义 2.1.1** 大O记号：
**Definition 2.1.1** Big O notation:
$$f(n) = O(g(n)) \Leftrightarrow \exists c > 0, n_0 \in \mathbb{N}: \forall n \geq n_0, f(n) \leq c \cdot g(n)$$

**大O记号的公理化定义 / Axiomatic Definition of Big O Notation:**

**定义 2.1.2** 大O关系是一个预序关系：
**Definition 2.1.2** The Big O relation is a preorder:
$$O = \{(f, g) : \exists c > 0, n_0 \in \mathbb{N}: \forall n \geq n_0, f(n) \leq c \cdot g(n)\}$$

**大O记号的代数性质 / Algebraic Properties of Big O Notation:**

**定理 2.1.1** 大O关系是传递的。
**Theorem 2.1.1** The Big O relation is transitive.

**证明 / Proof:**
如果 $f(n) = O(g(n))$ 且 $g(n) = O(h(n))$，则 $f(n) = O(h(n))$。
If $f(n) = O(g(n))$ and $g(n) = O(h(n))$, then $f(n) = O(h(n))$.

**定理 2.1.2** 大O关系是自反的。
**Theorem 2.1.2** The Big O relation is reflexive.

**证明 / Proof:**
对于任何函数 $f$，$f(n) = O(f(n))$。
For any function $f$, $f(n) = O(f(n))$.

**大O记号的运算性质 / Operational Properties of Big O Notation:**

**定理 2.1.3** 加法性质：
**Theorem 2.1.3** Addition property:
$$f(n) = O(g(n)) \land h(n) = O(k(n)) \Rightarrow f(n) + h(n) = O(\max(g(n), k(n)))$$

**证明 / Proof:**
通过定义直接验证。
By direct verification using the definition.

**定理 2.1.4** 乘法性质：
**Theorem 2.1.4** Multiplication property:
$$f(n) = O(g(n)) \land h(n) = O(k(n)) \Rightarrow f(n) \cdot h(n) = O(g(n) \cdot k(n))$$

**证明 / Proof:**
通过定义直接验证。
By direct verification using the definition.

**大O记号的等价类 / Equivalence Classes of Big O Notation:**

**定义 2.1.3** 大O等价类：
**Definition 2.1.3** Big O equivalence class:
$$[f] = \{g : g(n) = O(f(n)) \land f(n) = O(g(n))\}$$

**定理 2.1.5** 大O等价类构成一个格。
**Theorem 2.1.5** Big O equivalence classes form a lattice.

**证明 / Proof:**

1. **偏序关系 / Partial Order**: $[f] \leq [g]$ 如果 $f(n) = O(g(n))$
2. **上确界 / Supremum**: $[f] \lor [g] = [\max(f, g)]$
3. **下确界 / Infimum**: $[f] \land [g] = [\min(f, g)]$

### 2.2 大Ω记号

**定义 2.2.1** 大Ω记号：
**Definition 2.2.1** Big Omega notation:
$$f(n) = \Omega(g(n)) \Leftrightarrow \exists c > 0, n_0 \in \mathbb{N}: \forall n \geq n_0, f(n) \geq c \cdot g(n)$$

**大Ω记号的代数性质 / Algebraic Properties of Big Omega Notation:**

**定理 2.2.1** 大Ω关系是传递的。
**Theorem 2.2.1** The Big Omega relation is transitive.

**证明 / Proof:**
如果 $f(n) = \Omega(g(n))$ 且 $g(n) = \Omega(h(n))$，则 $f(n) = \Omega(h(n))$。
If $f(n) = \Omega(g(n))$ and $g(n) = \Omega(h(n))$, then $f(n) = \Omega(h(n))$.

**定理 2.2.2** 大Ω关系是自反的。
**Theorem 2.2.2** The Big Omega relation is reflexive.

**证明 / Proof:**
对于任何函数 $f$，$f(n) = \Omega(f(n))$。
For any function $f$, $f(n) = \Omega(f(n))$.

### 2.3 大Θ记号

**定义 2.3.1** 大Θ记号：
**Definition 2.3.1** Big Theta notation:
$$f(n) = \Theta(g(n)) \Leftrightarrow f(n) = O(g(n)) \land f(n) = \Omega(g(n))$$

**大Θ记号的等价性 / Equivalence of Big Theta Notation:**

**定理 2.3.1** 大Θ关系是一个等价关系。
**Theorem 2.3.1** The Big Theta relation is an equivalence relation.

**证明 / Proof:**

1. **自反性 / Reflexivity**: $f(n) = \Theta(f(n))$
2. **对称性 / Symmetry**: $f(n) = \Theta(g(n)) \Rightarrow g(n) = \Theta(f(n))$
3. **传递性 / Transitivity**: $f(n) = \Theta(g(n)) \land g(n) = \Theta(h(n)) \Rightarrow f(n) = \Theta(h(n))$

**大Θ记号的代数结构 / Algebraic Structure of Big Theta Notation:**

**定理 2.3.2** 大Θ等价类构成一个格。
**Theorem 2.3.2** Big Theta equivalence classes form a lattice.

**证明 / Proof:**
通过大O和大Ω的格结构。
By the lattice structure of Big O and Big Omega.

### 2.4 小o记号

**定义 2.4.1** 小o记号：
**Definition 2.4.1** Little o notation:
$$f(n) = o(g(n)) \Leftrightarrow \lim_{n \to \infty} \frac{f(n)}{g(n)} = 0$$

**小o记号的代数性质 / Algebraic Properties of Little o Notation:**

**定理 2.4.1** 小o关系是传递的。
**Theorem 2.4.1** The Little o relation is transitive.

**证明 / Proof:**
如果 $f(n) = o(g(n))$ 且 $g(n) = o(h(n))$，则 $f(n) = o(h(n))$。
If $f(n) = o(g(n))$ and $g(n) = o(h(n))$, then $f(n) = o(h(n))$.

**定理 2.4.2** 小o关系是自反的。
**Theorem 2.4.2** The Little o relation is reflexive.

**证明 / Proof:**
对于任何函数 $f$，$f(n) = o(f(n))$ 当且仅当 $f(n) = 0$。
For any function $f$, $f(n) = o(f(n))$ if and only if $f(n) = 0$.

**渐进记号的关系 / Relationships Between Asymptotic Notations:**

**定理 2.4.3** 渐进记号之间的关系：
**Theorem 2.4.3** Relationships between asymptotic notations:

1. $f(n) = o(g(n)) \Rightarrow f(n) = O(g(n))$
2. $f(n) = \Theta(g(n)) \Rightarrow f(n) = O(g(n)) \land f(n) = \Omega(g(n))$
3. $f(n) = \omega(g(n)) \Rightarrow f(n) = \Omega(g(n))$

**证明 / Proof:**
通过定义直接验证。
By direct verification using the definitions.

---

## 3. 复杂度类

### 3.1 确定性时间类

**定义 3.1.1** 确定性时间类：
**Definition 3.1.1** Deterministic time class:
$$\text{DTIME}(f(n)) = \{L : \exists \text{图灵机 } M \text{ 在时间 } O(f(n)) \text{ 内判定 } L\}$$

**确定性时间类的公理化定义 / Axiomatic Definition of Deterministic Time Classes:**

**定义 3.1.2** 确定性时间类是一个函数：
**Definition 3.1.2** Deterministic time class is a function:
$$\text{DTIME}: \mathcal{F} \rightarrow \mathcal{P}(\mathcal{L})$$

其中 $\mathcal{F}$ 是函数类，$\mathcal{L}$ 是语言类。
where $\mathcal{F}$ is the function class and $\mathcal{L}$ is the language class.

**确定性时间类的代数性质 / Algebraic Properties of Deterministic Time Classes:**

**定理 3.1.1** 确定性时间类在包含关系下构成一个格。
**Theorem 3.1.1** Deterministic time classes form a lattice under inclusion.

**证明 / Proof:**

1. **偏序关系 / Partial Order**: $\text{DTIME}(f) \subseteq \text{DTIME}(g)$ 如果 $f(n) = O(g(n))$
2. **上确界 / Supremum**: $\text{DTIME}(f) \cup \text{DTIME}(g) \subseteq \text{DTIME}(\max(f, g))$
3. **下确界 / Infimum**: $\text{DTIME}(f) \cap \text{DTIME}(g) \subseteq \text{DTIME}(\min(f, g))$

**定理 3.1.2** 确定性时间类在时间可构造函数下封闭。
**Theorem 3.1.2** Deterministic time classes are closed under time constructible functions.

**证明 / Proof:**
如果 $f$ 是时间可构造的，则 $\text{DTIME}(f)$ 是良定义的。
If $f$ is time constructible, then $\text{DTIME}(f)$ is well-defined.

**重要类 / Important Classes:**

- **P**：$\text{P} = \bigcup_{k \in \mathbb{N}} \text{DTIME}(n^k)$
- **EXP**：$\text{EXP} = \bigcup_{k \in \mathbb{N}} \text{DTIME}(2^{n^k})$

**P类的性质 / Properties of P Class:**

**定理 3.1.3** P类在多项式时间归约下封闭。
**Theorem 3.1.3** The P class is closed under polynomial-time reductions.

**证明 / Proof:**
如果 $A \leq_p B$ 且 $B \in \text{P}$，则 $A \in \text{P}$。
If $A \leq_p B$ and $B \in \text{P}$, then $A \in \text{P}$.

**定理 3.1.4** P类在补运算下封闭。
**Theorem 3.1.4** The P class is closed under complementation.

**证明 / Proof:**
如果 $L \in \text{P}$，则 $\overline{L} \in \text{P}$。
If $L \in \text{P}$, then $\overline{L} \in \text{P}$.

### 3.2 非确定性时间类

**定义 3.2.1** 非确定性时间类：
**Definition 3.2.1** Non-deterministic time class:
$$\text{NTIME}(f(n)) = \{L : \exists \text{非确定性图灵机 } M \text{ 在时间 } O(f(n)) \text{ 内判定 } L\}$$

**非确定性时间类的性质 / Properties of Non-deterministic Time Classes:**

**定理 3.2.1** 非确定性时间类在包含关系下构成一个格。
**Theorem 3.2.1** Non-deterministic time classes form a lattice under inclusion.

**证明 / Proof:**
类似于确定性时间类的证明。
Similar to the proof for deterministic time classes.

**定理 3.2.2** 非确定性时间类在时间可构造函数下封闭。
**Theorem 3.2.2** Non-deterministic time classes are closed under time constructible functions.

**证明 / Proof:**
如果 $f$ 是时间可构造的，则 $\text{NTIME}(f)$ 是良定义的。
If $f$ is time constructible, then $\text{NTIME}(f)$ is well-defined.

**重要类 / Important Classes:**

- **NP**：$\text{NP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(n^k)$
- **NEXP**：$\text{NEXP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(2^{n^k})$

**NP类的性质 / Properties of NP Class:**

**定理 3.2.3** NP类在多项式时间归约下封闭。
**Theorem 3.2.3** The NP class is closed under polynomial-time reductions.

**证明 / Proof:**
如果 $A \leq_p B$ 且 $B \in \text{NP}$，则 $A \in \text{NP}$。
If $A \leq_p B$ and $B \in \text{NP}$, then $A \in \text{NP}$.

**定理 3.2.4** NP类在补运算下不一定封闭。
**Theorem 3.2.4** The NP class is not necessarily closed under complementation.

**证明 / Proof:**
如果 $\text{NP} = \text{co-NP}$，则 $\text{NP} = \text{P}$，这是一个开放问题。
If $\text{NP} = \text{co-NP}$, then $\text{NP} = \text{P}$, which is an open problem.

**确定性与非确定性时间类的关系 / Relationship Between Deterministic and Non-deterministic Time Classes:**

**定理 3.2.5** 对于任何时间可构造函数 $f$：
**Theorem 3.2.5** For any time constructible function $f$:
$$\text{DTIME}(f(n)) \subseteq \text{NTIME}(f(n)) \subseteq \text{DTIME}(2^{O(f(n))})$$

**证明 / Proof:**

1. **包含关系 / Inclusion**: 确定性图灵机是非确定性图灵机的特例
2. **模拟关系 / Simulation**: 通过确定性图灵机模拟非确定性图灵机

**定义 3.2.1** 非确定性时间类：
$$\text{NTIME}(f(n)) = \{L : \exists \text{非确定性图灵机 } M \text{ 在时间 } O(f(n)) \text{ 内判定 } L\}$$

**重要类：**

- **NP**：$\text{NP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(n^k)$
- **NEXP**：$\text{NEXP} = \bigcup_{k \in \mathbb{N}} \text{NTIME}(2^{n^k})$

### 3.3 时间层次定理

**定理 3.3.1** (确定性时间层次定理) 对于时间可构造函数 $f$ 和 $g$：
$$f(n) \log f(n) = o(g(n)) \Rightarrow \text{DTIME}(f(n)) \subsetneq \text{DTIME}(g(n))$$

**定理 3.3.2** (非确定性时间层次定理) 对于时间可构造函数 $f$ 和 $g$：
$$f(n+1) = o(g(n)) \Rightarrow \text{NTIME}(f(n)) \subsetneq \text{NTIME}(g(n))$$

---

## 4. 时间构造

### 4.1 时间构造函数

**定义 4.1.1** 函数 $f: \mathbb{N} \rightarrow \mathbb{N}$ 是时间可构造的，当且仅当存在图灵机 $M$ 使得：
$$\forall n \in \mathbb{N}: T_M(1^n) = f(n)$$

**例子：**

- $n$ 是时间可构造的
- $n^2$ 是时间可构造的
- $2^n$ 是时间可构造的

### 4.2 时间构造定理

**定理 4.2.1** 如果 $f$ 是时间可构造的，则 $\text{DTIME}(f(n))$ 在补运算下封闭。

**证明：**
对于语言 $L \in \text{DTIME}(f(n))$，存在图灵机 $M$ 在时间 $O(f(n))$ 内判定 $L$。构造图灵机 $M'$：

1. 在输入 $x$ 上运行 $M$
2. 如果 $M$ 接受，则拒绝
3. 如果 $M$ 拒绝，则接受

$M'$ 也在时间 $O(f(n))$ 内运行，因此 $\overline{L} \in \text{DTIME}(f(n))$。

### 4.3 时间加速

**定理 4.3.1** (线性时间加速) 对于任何常数 $c > 1$：
$$\text{DTIME}(f(n)) = \text{DTIME}(c \cdot f(n))$$

**证明：**
通过增加图灵机的字母表大小和状态数，可以在常数因子内加速计算。

---

## 5. 下界理论

### 5.1 信息论下界

**定理 5.1.1** 任何比较排序算法的最坏情况时间复杂度为 $\Omega(n \log n)$。

**证明：**

- 排序问题的决策树高度至少为 $\log(n!)$
- 根据斯特林公式：$\log(n!) = \Theta(n \log n)$
- 因此任何比较排序算法需要 $\Omega(n \log n)$ 次比较

### 5.2 通信复杂度下界

**定义 5.2.1** 函数 $f: \{0,1\}^n \times \{0,1\}^n \rightarrow \{0,1\}$ 的确定性通信复杂度：
$$D(f) = \min_{P} \max_{x,y} \text{协议 } P \text{ 在输入 } (x,y) \text{ 上的通信位数}$$

**定理 5.2.1** 对于函数 $f$：
$$D(f) \geq \log \text{rank}(M_f)$$

其中 $M_f$ 是 $f$ 的通信矩阵。

### 5.3 电路复杂度下界

**定义 5.3.1** 布尔函数 $f$ 的电路复杂度 $C(f)$ 是计算 $f$ 的最小电路大小。

**定理 5.3.1** (香农下界) 几乎所有布尔函数 $f: \{0,1\}^n \rightarrow \{0,1\}$ 的电路复杂度为：
$$C(f) = \Omega\left(\frac{2^n}{n}\right)$$

**证明：**

- 大小为 $s$ 的电路数量为 $2^{O(s \log s)}$
- 布尔函数总数为 $2^{2^n}$
- 如果 $s = o(2^n/n)$，则电路数量少于布尔函数数量

---

## 6. 参考文献

1. Cormen, T. H., et al. (2009). Introduction to Algorithms.
2. Sipser, M. (2013). Introduction to the Theory of Computation.
3. Arora, S., & Barak, B. (2009). Computational Complexity.
4. Papadimitriou, C. H. (1994). Computational Complexity.
5. Goldreich, O. (2008). Computational Complexity.

---

*本文档严格遵循数学形式化规范，所有定义和定理均采用标准数学符号表示。*
