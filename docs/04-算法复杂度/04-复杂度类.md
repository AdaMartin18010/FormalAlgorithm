---
title: 4.4 å¤æ‚åº¦ç±» / Complexity Classes
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: å¤æ‚åº¦ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 4.4 å¤æ‚åº¦ç±» / Complexity Classes

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€å¤æ‚åº¦ç±»çš„å½¢å¼åŒ–å®šä¹‰ã€åˆ†ç±»ä½“ç³»ä¸å…³ç³»ç†è®ºã€‚
- å»ºç«‹Pã€NPã€PSPACEç­‰å¤æ‚åº¦ç±»çš„å®Œæ•´ç†è®ºæ¡†æ¶ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- å¤æ‚åº¦ç±»ã€Pç±»ã€NPç±»ã€PSPACEç±»ã€EXPç±»ã€å®Œå…¨æ€§é—®é¢˜ã€å½’çº¦æŠ€æœ¯ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- å¤æ‚åº¦ç±»ï¼ˆComplexity Classesï¼‰ï¼šæŒ‰è®¡ç®—èµ„æºéœ€æ±‚å¯¹é—®é¢˜è¿›è¡Œåˆ†ç±»ã€‚
- Pç±»ï¼ˆP Classï¼‰ï¼šå¤šé¡¹å¼æ—¶é—´å¯è§£é—®é¢˜ã€‚
- NPç±»ï¼ˆNP Classï¼‰ï¼šéç¡®å®šæ€§å¤šé¡¹å¼æ—¶é—´å¯éªŒè¯é—®é¢˜ã€‚
- PSPACEç±»ï¼ˆPSPACE Classï¼‰ï¼šå¤šé¡¹å¼ç©ºé—´å¯è§£é—®é¢˜ã€‚
- è®°å·çº¦å®šï¼š`P`ã€`NP`ã€`PSPACE`ã€`EXP` è¡¨ç¤ºä¸åŒçš„å¤æ‚åº¦ç±»ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- æ—¶é—´å¤æ‚åº¦ï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/01-æ—¶é—´å¤æ‚åº¦.md`ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/02-ç©ºé—´å¤æ‚åº¦.md`ã€‚
- æ¸è¿›åˆ†æï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/03-æ¸è¿›åˆ†æ.md`ã€‚
- ç®—æ³•å¤æ‚åº¦åŸºç¡€ï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/` ç›¸å…³æ–‡æ¡£ã€‚

### å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References

P/NP/PSPACE ç­‰å¤æ‚åº¦ç±»å¯ä¸ **MIT 18.404 Theory of Computation**ã€**CMU 15-251**ã€**Stanford CS 161**ã€**Berkeley CS 170** ç­‰è¯¾ç¨‹å¯¹æ ‡ã€‚è¯¾ç¨‹ä¸æ¨¡å—æ˜ å°„è§ [å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)ã€‚

### å¯çŸ¥è¾¹ç•Œä¸è®¤è¯†è®ºå‚è€ƒ / Knowable Boundaries and Epistemology

å¤æ‚åº¦ä¸‹ç•Œä¸å¤æ‚åº¦ç±»åˆ†ç¦»ï¼ˆå¦‚ P vs NPï¼‰åˆ»ç”»äº†**å¯çŸ¥è¾¹ç•Œ**ï¼šå“ªäº›é—®é¢˜åœ¨ç»™å®šèµ„æºä¸‹å¯åˆ¤å®šã€å“ªäº›é—®é¢˜çš„å¯è¯æ˜ä¸‹ç•Œå­˜åœ¨ã€‚ä¸ [Stanford SEP - Philosophy of Computer Science](https://plato.stanford.edu/entries/computer-science/) Â§è®¤è¯†è®ºåœ°ä½ã€å¯åˆ¤å®šæ€§ä¸éªŒè¯çš„å±€é™ å‘¼åº”ã€‚è§ [é¡¹ç›®å“²ç§‘ç»“æ„è¯´æ˜](../é¡¹ç›®å“²ç§‘ç»“æ„è¯´æ˜.md)ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- Pç±»ä¸NPç±»
- PSPACEç±»
- å¤æ‚åº¦ç±»å…³ç³»
- å®Œå…¨æ€§é—®é¢˜

## ç›®å½• (Table of Contents)

- [4.4 å¤æ‚åº¦ç±» / Complexity Classes](#44-å¤æ‚åº¦ç±»--complexity-classes)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References](#å›½é™…è¯¾ç¨‹å‚è€ƒ--international-course-references)
  - [å¯çŸ¥è¾¹ç•Œä¸è®¤è¯†è®ºå‚è€ƒ / Knowable Boundaries and Epistemology](#å¯çŸ¥è¾¹ç•Œä¸è®¤è¯†è®ºå‚è€ƒ--knowable-boundaries-and-epistemology)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.1 å¤æ‚åº¦ç±»å®šä¹‰ (Definition of Complexity Classes)](#11-å¤æ‚åº¦ç±»å®šä¹‰-definition-of-complexity-classes)
  - [1.2 å¤æ‚åº¦ç±»è®°å· (Complexity Class Notation)](#12-å¤æ‚åº¦ç±»è®°å·-complexity-class-notation)
  - [1.3 å¤æ‚åº¦ç±»å±‚æ¬¡ (Complexity Class Hierarchy)](#13-å¤æ‚åº¦ç±»å±‚æ¬¡-complexity-class-hierarchy)
- [1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#14-å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
- [2. Pç±»ä¸NPç±» (P and NP Classes)](#2-pç±»ä¸npç±»-p-and-np-classes)
  - [2.1 Pç±»å®šä¹‰ (Definition of P Class)](#21-pç±»å®šä¹‰-definition-of-p-class)
  - [2.2 NPç±»å®šä¹‰ (Definition of NP Class)](#22-npç±»å®šä¹‰-definition-of-np-class)
  - [2.3 P vs NPé—®é¢˜ (P vs NP Problem)](#23-p-vs-npé—®é¢˜-p-vs-np-problem)
  - [2.4 NPå®Œå…¨é—®é¢˜ (NP-Complete Problems)](#24-npå®Œå…¨é—®é¢˜-np-complete-problems)
- [3. PSPACEç±» (PSPACE Class)](#3-pspaceç±»-pspace-class)
  - [3.1 PSPACEç±»å®šä¹‰ (Definition of PSPACE Class)](#31-pspaceç±»å®šä¹‰-definition-of-pspace-class)
  - [3.2 PSPACEå®Œå…¨é—®é¢˜ (PSPACE-Complete Problems)](#32-pspaceå®Œå…¨é—®é¢˜-pspace-complete-problems)
  - [3.3 PSPACEä¸NPçš„å…³ç³» (Relationship between PSPACE and NP)](#33-pspaceä¸npçš„å…³ç³»-relationship-between-pspace-and-np)
- [4. EXPç±» (EXP Class)](#4-expç±»-exp-class)
  - [4.1 EXPç±»å®šä¹‰ (Definition of EXP Class)](#41-expç±»å®šä¹‰-definition-of-exp-class)
  - [4.2 EXPå®Œå…¨é—®é¢˜ (EXP-Complete Problems)](#42-expå®Œå…¨é—®é¢˜-exp-complete-problems)
  - [4.3 NEXPç±» (NEXP Class)](#43-nexpç±»-nexp-class)
- [5. å¤æ‚åº¦ç±»å…³ç³» (Complexity Class Relationships)](#5-å¤æ‚åº¦ç±»å…³ç³»-complexity-class-relationships)
  - [5.1 åŒ…å«å…³ç³» (Containment Relations)](#51-åŒ…å«å…³ç³»-containment-relations)
  - [5.2 åˆ†ç¦»é—®é¢˜ (Separation Problems)](#52-åˆ†ç¦»é—®é¢˜-separation-problems)
  - [5.3 ç›¸å¯¹åŒ–ç»“æœ (Relativization Results)](#53-ç›¸å¯¹åŒ–ç»“æœ-relativization-results)
- [6. å®Œå…¨æ€§é—®é¢˜ (Complete Problems)](#6-å®Œå…¨æ€§é—®é¢˜-complete-problems)
  - [6.1 å®Œå…¨æ€§å®šä¹‰ (Definition of Completeness)](#61-å®Œå…¨æ€§å®šä¹‰-definition-of-completeness)
  - [6.2 å„ç±»çš„å®Œå…¨é—®é¢˜ (Complete Problems for Different Classes)](#62-å„ç±»çš„å®Œå…¨é—®é¢˜-complete-problems-for-different-classes)
  - [6.3 å½’çº¦æŠ€æœ¯ (Reduction Techniques)](#63-å½’çº¦æŠ€æœ¯-reduction-techniques)
  - [ç»å…¸å½’çº¦ç¤ºä¾‹ï¼š3-SAT â†’ Vertex-Cover / Classic Reduction Example: 3-SAT â†’ Vertex-Cover](#ç»å…¸å½’çº¦ç¤ºä¾‹3-sat--vertex-cover--classic-reduction-example-3-sat--vertex-cover)
- [7. å¤æ‚åº¦ç±»åº”ç”¨ (Applications of Complexity Classes)](#7-å¤æ‚åº¦ç±»åº”ç”¨-applications-of-complexity-classes)
  - [7.1 å¯†ç å­¦åº”ç”¨ (Cryptographic Applications)](#71-å¯†ç å­¦åº”ç”¨-cryptographic-applications)
  - [7.2 ç®—æ³•è®¾è®¡åº”ç”¨ (Algorithm Design Applications)](#72-ç®—æ³•è®¾è®¡åº”ç”¨-algorithm-design-applications)
  - [7.3 ç³»ç»Ÿè®¾è®¡åº”ç”¨ (System Design Applications)](#73-ç³»ç»Ÿè®¾è®¡åº”ç”¨-system-design-applications)
- [8. å®ç°ç¤ºä¾‹ (Implementation Examples)](#8-å®ç°ç¤ºä¾‹-implementation-examples)
  - [8.1 å¤æ‚åº¦ç±»åˆ†æå·¥å…· (Complexity Class Analysis Tool)](#81-å¤æ‚åº¦ç±»åˆ†æå·¥å…·-complexity-class-analysis-tool)
  - [8.2 NPå®Œå…¨é—®é¢˜å®ç° (NP-Complete Problem Implementation)](#82-npå®Œå…¨é—®é¢˜å®ç°-np-complete-problem-implementation)
  - [8.3 PSPACEå®Œå…¨é—®é¢˜å®ç° (PSPACE-Complete Problem Implementation)](#83-pspaceå®Œå…¨é—®é¢˜å®ç°-pspace-complete-problem-implementation)
  - [8.4 å¤æ‚åº¦ç±»æµ‹è¯• (Complexity Class Testing)](#84-å¤æ‚åº¦ç±»æµ‹è¯•-complexity-class-testing)
- [9. å‚è€ƒæ–‡çŒ® / References](#9-å‚è€ƒæ–‡çŒ®--references)
- [ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
  - [ç›¸å…³æ–‡æ¡£ / Related Documents](#ç›¸å…³æ–‡æ¡£--related-documents)
  - [çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
  - [VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.1 å¤æ‚åº¦ç±»å®šä¹‰ (Definition of Complexity Classes)

**å¤æ‚åº¦ç±»å®šä¹‰ / Definition of Complexity Classes:**

å¤æ‚åº¦ç±»æ˜¯è®¡ç®—å¤æ‚æ€§ç†è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒå°†é—®é¢˜æŒ‰ç…§è§£å†³å®ƒä»¬æ‰€éœ€çš„è®¡ç®—èµ„æºè¿›è¡Œåˆ†ç±»ã€‚

Complexity classes are central concepts in computational complexity theory that categorize problems according to the computational resources required to solve them.

**å¤æ‚åº¦ç±»çš„åŸºæœ¬è¦ç´  / Basic Elements of Complexity Classes:**

1. **è®¡ç®—æ¨¡å‹ (Computational Model) / Computational Model:**
   - å›¾çµæœº / Turing machines
   - éšæœºè®¿é—®æœºå™¨ / Random access machines
   - é‡å­è®¡ç®—æœº / Quantum computers

2. **èµ„æºé™åˆ¶ (Resource Constraints) / Resource Constraints:**
   - æ—¶é—´é™åˆ¶ / Time constraints
   - ç©ºé—´é™åˆ¶ / Space constraints
   - éšæœºæ€§é™åˆ¶ / Randomness constraints

3. **é—®é¢˜ç±»å‹ (Problem Types) / Problem Types:**
   - å†³ç­–é—®é¢˜ / Decision problems
   - å‡½æ•°é—®é¢˜ / Function problems
   - ä¼˜åŒ–é—®é¢˜ / Optimization problems

### 1.2 å¤æ‚åº¦ç±»è®°å· (Complexity Class Notation)

**æ ‡å‡†è®°å· / Standard Notation:**

- **DTIME(f(n)) / DTIME(f(n)):** ç¡®å®šæ€§æ—¶é—´ç±» / Deterministic time class
- **NTIME(f(n)) / NTIME(f(n)):** éç¡®å®šæ€§æ—¶é—´ç±» / Nondeterministic time class
- **DSPACE(f(n)) / DSPACE(f(n)):** ç¡®å®šæ€§ç©ºé—´ç±» / Deterministic space class
- **NSPACE(f(n)) / NSPACE(f(n)):** éç¡®å®šæ€§ç©ºé—´ç±» / Nondeterministic space class

**å¤šé¡¹å¼è®°å· / Polynomial Notation:**

- **P:** å¤šé¡¹å¼æ—¶é—´å¯è§£é—®é¢˜ / Polynomial time solvable problems
- **NP:** éç¡®å®šæ€§å¤šé¡¹å¼æ—¶é—´å¯éªŒè¯é—®é¢˜ / Nondeterministic polynomial time verifiable problems
- **PSPACE:** å¤šé¡¹å¼ç©ºé—´å¯è§£é—®é¢˜ / Polynomial space solvable problems
- **EXP:** æŒ‡æ•°æ—¶é—´å¯è§£é—®é¢˜ / Exponential time solvable problems

### 1.3 å¤æ‚åº¦ç±»å±‚æ¬¡ (Complexity Class Hierarchy)

**åŸºæœ¬å±‚æ¬¡ç»“æ„ / Basic Hierarchy:**

```text
P âŠ† NP âŠ† PSPACE âŠ† EXP âŠ† NEXP
```

**ç©ºé—´å±‚æ¬¡ç»“æ„ / Space Hierarchy:**

```text
L âŠ† NL âŠ† P âŠ† NP âŠ† PSPACE âŠ† EXP
```

å…¶ä¸­ / where:

- **L:** å¯¹æ•°ç©ºé—´ / Logarithmic space
- **NL:** éç¡®å®šæ€§å¯¹æ•°ç©ºé—´ / Nondeterministic logarithmic space
- **P:** å¤šé¡¹å¼æ—¶é—´ / Polynomial time
- **NP:** éç¡®å®šæ€§å¤šé¡¹å¼æ—¶é—´ / Nondeterministic polynomial time
- **PSPACE:** å¤šé¡¹å¼ç©ºé—´ / Polynomial space
- **EXP:** æŒ‡æ•°æ—¶é—´ / Exponential time

---

## 1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

**è§£é‡Šä¸ç›´è§‚**ï¼šå¤æ‚åº¦ç±»ç”¨èµ„æºç•Œï¼ˆæ—¶é—´/ç©ºé—´ï¼‰åˆ’åˆ†é—®é¢˜ï¼›$P$ã€$NP$ã€$PSPACE$ã€$EXP$ ç­‰æ„æˆå±‚æ¬¡ï¼Œ$P$ vs $NP$ ä¸ºæ ¸å¿ƒå¼€æ”¾é—®é¢˜ï¼›å½’çº¦ä¸å®Œå¤‡æ€§ç”¨äºæ¯”è¾ƒç±»ä¸è¯æ˜ä¸‹ç•Œã€‚

**æ¦‚å¿µå±æ€§è¡¨**ï¼š$P$ â€” å¤šé¡¹å¼æ—¶é—´å¯åˆ¤å®šï¼›$NP$ â€” å¤šé¡¹å¼æ—¶é—´å¯éªŒè¯ï¼›$PSPACE$ â€” å¤šé¡¹å¼ç©ºé—´ï¼›$EXP$ â€” æŒ‡æ•°æ—¶é—´ï¼›å¤šä¸€å½’çº¦ $\leq_m$ â€” ä¿æŒå¯åˆ¤å®šæ€§ï¼›$NP$-å®Œå¤‡ â€” $NP$ ä¸­æœ€éš¾é—®é¢˜ã€‚

**æ¦‚å¿µå…³ç³»**ï¼šå¤æ‚åº¦ç±» â€”depends_onâ€” 01-æ—¶é—´å¤æ‚åº¦ã€02-ç©ºé—´å¤æ‚åº¦ã€03-æ¸è¿›åˆ†æï¼›$P \subseteq NP \subseteq PSPACE \subseteq EXP$ï¼›å½’çº¦ â€” å®Œå¤‡æ€§ä¸ä¸‹ç•Œã€‚

**æ¦‚å¿µä¾èµ–å›¾**ï¼š$DTIME/NTIME/DSPACE/NSPACE$ â†’ $P/NP/PSPACE$ï¼›å½’çº¦ â†’ $NP$-å®Œå¤‡ã€$NP$-å›°éš¾ï¼›Cook-Levin â†’ SAT ä¸º $NP$-å®Œå¤‡ã€‚

**æ€ç»´å¯¼å›¾**ï¼šå¤æ‚åº¦ç±» â†’ $P/NP/PSPACE/EXP$ã€å½’çº¦ã€å®Œå¤‡æ€§ã€å±‚æ¬¡å®šç† â†’ ç®—æ³•è®¾è®¡ã€ä¸‹ç•Œã€å¯†ç å­¦ã€‚

**å¤šç»´çŸ©é˜µ**ï¼š$P/NP/coNP/PSPACE$ â€” åŒ…å«ä¸æœªçŸ¥å…³ç³»ï¼›å¤šä¸€å½’çº¦/å›¾çµå½’çº¦ â€” å½’çº¦ç±»å‹ï¼›å®Œå¤‡é—®é¢˜ â€” SATã€Cliqueã€Hamilton ç­‰ã€‚

**å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘**ï¼šå®šä¹‰ $P/NP$ â†’ éªŒè¯ä¸åˆ¤å®šç­‰ä»·ï¼›Cook-Levin â†’ SAT ä¸º $NP$-å®Œå¤‡ï¼›å±‚æ¬¡å®šç† â†’ $P \subsetneq EXP$ ç­‰ã€‚

**åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘**ï¼šåˆ¤é—®é¢˜æ˜¯å¦åœ¨ $P$ â†’ ç»™å¤šé¡¹å¼ç®—æ³•ï¼›è¯ $NP$-å›°éš¾ â†’ å½’çº¦è‡ªå·²çŸ¥ $NP$-å®Œå¤‡ï¼ˆè§ Â§2â€“Â§3ï¼‰ï¼›å½¢å¼åŒ– â†’ è§ 09-è®¡ç®—å¤æ‚åº¦ç†è®ºã€‚

---

## 2. Pç±»ä¸NPç±» (P and NP Classes)

### 2.1 Pç±»å®šä¹‰ (Definition of P Class)

**Pç±»å®šä¹‰ / Definition of P Class:**

Pç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è¢«ç¡®å®šæ€§å›¾çµæœºè§£å†³çš„å†³ç­–é—®é¢˜çš„é›†åˆã€‚

The class P is the set of all decision problems that can be solved by a deterministic Turing machine in polynomial time.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$P = \bigcup_{k \geq 1} DTIME(n^k)$$

**Pç±»çš„æ€§è´¨ / Properties of P Class:**

1. **å°é—­æ€§ (Closure Properties) / Closure Properties:**
   - åœ¨è¡¥è¿ç®—ä¸‹å°é—­ / Closed under complement
   - åœ¨å¹¶è¿ç®—ä¸‹å°é—­ / Closed under union
   - åœ¨äº¤è¿ç®—ä¸‹å°é—­ / Closed under intersection

2. **åŒ…å«å…³ç³» / Containment Relations:**
   - $P \subseteq NP$
   - $P \subseteq PSPACE$
   - $P \subseteq EXP$

### 2.2 NPç±»å®šä¹‰ (Definition of NP Class)

**NPç±»å®šä¹‰ / Definition of NP Class:**

NPç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è¢«éç¡®å®šæ€§å›¾çµæœºè§£å†³çš„å†³ç­–é—®é¢˜çš„é›†åˆï¼Œæˆ–è€…ç­‰ä»·åœ°ï¼Œæ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…éªŒè¯è¯ä¹¦çš„å†³ç­–é—®é¢˜çš„é›†åˆã€‚

The class NP is the set of all decision problems that can be solved by a nondeterministic Turing machine in polynomial time, or equivalently, the set of all decision problems for which a certificate can be verified in polynomial time.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$NP = \bigcup_{k \geq 1} NTIME(n^k)$$

**NPç±»çš„ç­‰ä»·å®šä¹‰ / Equivalent Definitions of NP Class:**

1. **éç¡®å®šæ€§å›¾çµæœºå®šä¹‰ / Nondeterministic Turing Machine Definition:**
   - å­˜åœ¨éç¡®å®šæ€§å›¾çµæœºåœ¨å¤šé¡¹å¼æ—¶é—´å†…æ¥å—æ‰€æœ‰"æ˜¯"å®ä¾‹
   - There exists a nondeterministic Turing machine that accepts all "yes" instances in polynomial time

2. **è¯ä¹¦éªŒè¯å®šä¹‰ / Certificate Verification Definition:**
   - å­˜åœ¨ç¡®å®šæ€§å›¾çµæœºåœ¨å¤šé¡¹å¼æ—¶é—´å†…éªŒè¯è¯ä¹¦
   - There exists a deterministic Turing machine that verifies certificates in polynomial time

### 2.3 P vs NPé—®é¢˜ (P vs NP Problem)

**P vs NPé—®é¢˜ / P vs NP Problem:**

P vs NPé—®é¢˜æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€é‡è¦çš„æœªè§£å†³é—®é¢˜ä¹‹ä¸€ï¼Œå®ƒè¯¢é—®æ˜¯å¦æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…éªŒè¯çš„é—®é¢˜ä¹Ÿå¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è§£å†³ã€‚

The P vs NP problem is one of the most important unsolved problems in computer science, asking whether all problems that can be verified in polynomial time can also be solved in polynomial time.

**P vs NPé—®é¢˜çš„æ„ä¹‰ / Significance of P vs NP Problem:**

1. **ç†è®ºæ„ä¹‰ / Theoretical Significance:**
   - ç†è§£è®¡ç®—çš„åŸºæœ¬é™åˆ¶ / Understanding fundamental limits of computation
   - æ­ç¤ºç®—æ³•çš„æœ¬è´¨ / Revealing the nature of algorithms

2. **å®é™…æ„ä¹‰ / Practical Significance:**
   - å¯†ç å­¦çš„å½±å“ / Impact on cryptography
   - ä¼˜åŒ–é—®é¢˜çš„è§£å†³ / Solution of optimization problems

3. **å“²å­¦æ„ä¹‰ / Philosophical Significance:**
   - åˆ›é€ åŠ›ä¸éªŒè¯çš„å…³ç³» / Relationship between creativity and verification
   - äººç±»æ™ºèƒ½çš„æœ¬è´¨ / Nature of human intelligence

### 2.4 NPå®Œå…¨é—®é¢˜ (NP-Complete Problems)

**NPå®Œå…¨æ€§å®šä¹‰ / Definition of NP-Completeness:**

é—®é¢˜ $L$ æ˜¯NPå®Œå…¨çš„ï¼Œå¦‚æœï¼š

1. $L \in NP$
2. å¯¹äºæ‰€æœ‰ $A \in NP$ï¼Œ$A \leq_p L$

Problem $L$ is NP-complete if:

1. $L \in NP$
2. For all $A \in NP$, $A \leq_p L$

**è‘—åçš„NPå®Œå…¨é—®é¢˜ / Famous NP-Complete Problems:**

1. **å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜ (SAT) / Boolean Satisfiability Problem (SAT):**
   - åˆ¤æ–­å¸ƒå°”å…¬å¼æ˜¯å¦å¯æ»¡è¶³ / Determine if a boolean formula is satisfiable
   - ç¬¬ä¸€ä¸ªè¢«è¯æ˜çš„NPå®Œå…¨é—®é¢˜ / First problem proven to be NP-complete

2. **3-å¯æ»¡è¶³æ€§é—®é¢˜ (3-SAT) / 3-Satisfiability Problem (3-SAT):**
   - åˆ¤æ–­3-CNFå…¬å¼æ˜¯å¦å¯æ»¡è¶³ / Determine if a 3-CNF formula is satisfiable
   - æ¯ä¸ªå­å¥æœ€å¤š3ä¸ªæ–‡å­— / At most 3 literals per clause

3. **æ—…è¡Œå•†é—®é¢˜ (TSP) / Traveling Salesman Problem (TSP):**
   - å¯»æ‰¾æœ€çŸ­çš„å“ˆå¯†é¡¿å›è·¯ / Find shortest Hamiltonian cycle
   - ç»å…¸çš„ç»„åˆä¼˜åŒ–é—®é¢˜ / Classic combinatorial optimization problem

4. **é¡¶ç‚¹è¦†ç›–é—®é¢˜ (Vertex Cover) / Vertex Cover Problem:**
   - å¯»æ‰¾æœ€å°çš„é¡¶ç‚¹è¦†ç›– / Find minimum vertex cover
   - å›¾è®ºä¸­çš„ç»å…¸é—®é¢˜ / Classic problem in graph theory

---

## 3. PSPACEç±» (PSPACE Class)

### 3.1 PSPACEç±»å®šä¹‰ (Definition of PSPACE Class)

**PSPACEç±»å®šä¹‰ / Definition of PSPACE Class:**

PSPACEç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼ç©ºé—´å†…è¢«ç¡®å®šæ€§å›¾çµæœºè§£å†³çš„å†³ç­–é—®é¢˜çš„é›†åˆã€‚

The class PSPACE is the set of all decision problems that can be solved by a deterministic Turing machine in polynomial space.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$PSPACE = \bigcup_{k \geq 1} DSPACE(n^k)$$

**PSPACEç±»çš„æ€§è´¨ / Properties of PSPACE Class:**

1. **åŒ…å«å…³ç³» / Containment Relations:**
   - $P \subseteq PSPACE$
   - $NP \subseteq PSPACE$
   - $PSPACE \subseteq EXP$

2. **å°é—­æ€§ / Closure Properties:**
   - åœ¨è¡¥è¿ç®—ä¸‹å°é—­ / Closed under complement
   - åœ¨å¹¶è¿ç®—ä¸‹å°é—­ / Closed under union
   - åœ¨äº¤è¿ç®—ä¸‹å°é—­ / Closed under intersection

### 3.2 PSPACEå®Œå…¨é—®é¢˜ (PSPACE-Complete Problems)

**PSPACEå®Œå…¨æ€§å®šä¹‰ / Definition of PSPACE-Completeness:**

é—®é¢˜ $L$ æ˜¯PSPACEå®Œå…¨çš„ï¼Œå¦‚æœï¼š

1. $L \in PSPACE$
2. å¯¹äºæ‰€æœ‰ $A \in PSPACE$ï¼Œ$A \leq_p L$

Problem $L$ is PSPACE-complete if:

1. $L \in PSPACE$
2. For all $A \in PSPACE$, $A \leq_p L$

**è‘—åçš„PSPACEå®Œå…¨é—®é¢˜ / Famous PSPACE-Complete Problems:**

1. **çœŸé‡åŒ–å¸ƒå°”å…¬å¼é—®é¢˜ (TQBF) / True Quantified Boolean Formula Problem (TQBF):**
   - åˆ¤æ–­é‡åŒ–å¸ƒå°”å…¬å¼æ˜¯å¦ä¸ºçœŸ / Determine if a quantified boolean formula is true
   - ç¬¬ä¸€ä¸ªè¢«è¯æ˜çš„PSPACEå®Œå…¨é—®é¢˜ / First problem proven to be PSPACE-complete

2. **å¹¿ä¹‰åœ°ç†æ¸¸æˆ (Generalized Geography) / Generalized Geography:**
   - åˆ¤æ–­ç©å®¶æ˜¯å¦æœ‰å¿…èƒœç­–ç•¥ / Determine if a player has a winning strategy
   - åšå¼ˆè®ºä¸­çš„ç»å…¸é—®é¢˜ / Classic problem in game theory

3. **æ±‰è¯ºå¡”é—®é¢˜ (Towers of Hanoi) / Towers of Hanoi:**
   - åˆ¤æ–­æ˜¯å¦å¯ä»¥åœ¨ç»™å®šæ­¥æ•°å†…å®Œæˆ / Determine if can be completed in given steps
   - ç»å…¸çš„é€’å½’é—®é¢˜ / Classic recursive problem

### 3.3 PSPACEä¸NPçš„å…³ç³» (Relationship between PSPACE and NP)

**è¨ç»´å¥‡å®šç† (Savitch's Theorem) / Savitch's Theorem:**

å¯¹äºä»»ä½•ç©ºé—´å¯æ„é€ å‡½æ•° $f(n) \geq \log n$ï¼š

For any space constructible function $f(n) \geq \log n$:

$$NSPACE(f(n)) \subseteq SPACE(f^2(n))$$

**æ¨è®º / Corollary:**

$$NPSPACE = PSPACE$$

è¿™æ„å‘³ç€éç¡®å®šæ€§å¤šé¡¹å¼ç©ºé—´ç­‰äºç¡®å®šæ€§å¤šé¡¹å¼ç©ºé—´ã€‚

This means that nondeterministic polynomial space equals deterministic polynomial space.

---

## 4. EXPç±» (EXP Class)

### 4.1 EXPç±»å®šä¹‰ (Definition of EXP Class)

**EXPç±»å®šä¹‰ / Definition of EXP Class:**

EXPç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨æŒ‡æ•°æ—¶é—´å†…è¢«ç¡®å®šæ€§å›¾çµæœºè§£å†³çš„å†³ç­–é—®é¢˜çš„é›†åˆã€‚

The class EXP is the set of all decision problems that can be solved by a deterministic Turing machine in exponential time.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$EXP = \bigcup_{k \geq 1} DTIME(2^{n^k})$$

**EXPç±»çš„æ€§è´¨ / Properties of EXP Class:**

1. **åŒ…å«å…³ç³» / Containment Relations:**
   - $P \subseteq EXP$
   - $NP \subseteq EXP$
   - $PSPACE \subseteq EXP$

2. **æ—¶é—´å±‚æ¬¡å®šç† / Time Hierarchy Theorem:**
   - $P \subsetneq EXP$
   - å­˜åœ¨EXPä¸­çš„é—®é¢˜ä¸åœ¨Pä¸­ / There exist problems in EXP not in P

### 4.2 EXPå®Œå…¨é—®é¢˜ (EXP-Complete Problems)

**EXPå®Œå…¨æ€§å®šä¹‰ / Definition of EXP-Completeness:**

é—®é¢˜ $L$ æ˜¯EXPå®Œå…¨çš„ï¼Œå¦‚æœï¼š

1. $L \in EXP$
2. å¯¹äºæ‰€æœ‰ $A \in EXP$ï¼Œ$A \leq_p L$

Problem $L$ is EXP-complete if:

1. $L \in EXP$
2. For all $A \in EXP$, $A \leq_p L$

**è‘—åçš„EXPå®Œå…¨é—®é¢˜ / Famous EXP-Complete Problems:**

1. **å¹¿ä¹‰æ£‹ç±»æ¸¸æˆ (Generalized Chess) / Generalized Chess:**
   - åˆ¤æ–­ç©å®¶æ˜¯å¦æœ‰å¿…èƒœç­–ç•¥ / Determine if a player has a winning strategy
   - åœ¨nÃ—næ£‹ç›˜ä¸Šçš„å›½é™…è±¡æ£‹ / Chess on nÃ—n board

2. **å¹¿ä¹‰å›´æ£‹ (Generalized Go) / Generalized Go:**
   - åˆ¤æ–­ç©å®¶æ˜¯å¦æœ‰å¿…èƒœç­–ç•¥ / Determine if a player has a winning strategy
   - åœ¨nÃ—næ£‹ç›˜ä¸Šçš„å›´æ£‹ / Go on nÃ—n board

3. **åœæœºé—®é¢˜ (Halting Problem) / Halting Problem:**
   - åˆ¤æ–­å›¾çµæœºæ˜¯å¦åœæœº / Determine if a Turing machine halts
   - åœ¨æŒ‡æ•°æ—¶é—´é™åˆ¶ä¸‹ / Under exponential time constraint

### 4.3 NEXPç±» (NEXP Class)

**NEXPç±»å®šä¹‰ / Definition of NEXP Class:**

NEXPç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨æŒ‡æ•°æ—¶é—´å†…è¢«éç¡®å®šæ€§å›¾çµæœºè§£å†³çš„å†³ç­–é—®é¢˜çš„é›†åˆã€‚

The class NEXP is the set of all decision problems that can be solved by a nondeterministic Turing machine in exponential time.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$NEXP = \bigcup_{k \geq 1} NTIME(2^{n^k})$$

**NEXPä¸EXPçš„å…³ç³» / Relationship between NEXP and EXP:**

- $EXP \subseteq NEXP$
- æ˜¯å¦ $EXP = NEXP$ æ˜¯å¼€æ”¾é—®é¢˜ / Whether $EXP = NEXP$ is an open question

---

## 5. å¤æ‚åº¦ç±»å…³ç³» (Complexity Class Relationships)

### 5.1 åŒ…å«å…³ç³» (Containment Relations)

**å·²çŸ¥çš„åŒ…å«å…³ç³» / Known Containment Relations:**

```text
L âŠ† NL âŠ† P âŠ† NP âŠ† PSPACE âŠ† EXP âŠ† NEXP
```

**è¯æ˜æŠ€æœ¯ / Proof Techniques:**

1. **æ¨¡æ‹ŸæŠ€æœ¯ (Simulation) / Simulation:**
   - ç”¨æ›´å¼ºçš„æ¨¡å‹æ¨¡æ‹Ÿè¾ƒå¼±çš„æ¨¡å‹ / Simulate weaker model with stronger model
   - ä¾‹å¦‚ï¼šç”¨ç¡®å®šæ€§å›¾çµæœºæ¨¡æ‹Ÿéç¡®å®šæ€§å›¾çµæœº / e.g., simulate nondeterministic TM with deterministic TM

2. **å½’çº¦æŠ€æœ¯ (Reduction) / Reduction:**
   - å°†ä¸€ä¸ªé—®é¢˜å½’çº¦åˆ°å¦ä¸€ä¸ªé—®é¢˜ / Reduce one problem to another
   - ä¿æŒå¤æ‚åº¦ç±»ä¸å˜ / Preserve complexity class

3. **å±‚æ¬¡å®šç† (Hierarchy Theorems) / Hierarchy Theorems:**
   - æ—¶é—´å±‚æ¬¡å®šç† / Time hierarchy theorem
   - ç©ºé—´å±‚æ¬¡å®šç† / Space hierarchy theorem

### 5.2 åˆ†ç¦»é—®é¢˜ (Separation Problems)

**å¼€æ”¾é—®é¢˜ / Open Problems:**

1. **P vs NPé—®é¢˜ / P vs NP Problem:**
   - æ˜¯å¦ $P = NP$ï¼Ÿ/ Is $P = NP$?
   - è®¡ç®—æœºç§‘å­¦ä¸­æœ€é‡è¦çš„å¼€æ”¾é—®é¢˜ / Most important open problem in computer science

2. **NP vs PSPACEé—®é¢˜ / NP vs PSPACE Problem:**
   - æ˜¯å¦ $NP = PSPACE$ï¼Ÿ/ Is $NP = PSPACE$?
   - ä¸P vs NPé—®é¢˜ç›¸å…³ / Related to P vs NP problem

3. **EXP vs NEXPé—®é¢˜ / EXP vs NEXP Problem:**
   - æ˜¯å¦ $EXP = NEXP$ï¼Ÿ/ Is $EXP = NEXP$?
   - æŒ‡æ•°æ—¶é—´ç‰ˆæœ¬çš„P vs NP / Exponential time version of P vs NP

### 5.3 ç›¸å¯¹åŒ–ç»“æœ (Relativization Results)

**ç›¸å¯¹åŒ– / Relativization:**

ç›¸å¯¹åŒ–æ˜¯ç ”ç©¶å¤æ‚åº¦ç±»å…³ç³»çš„é‡è¦å·¥å…·ï¼Œå®ƒè€ƒè™‘å¸¦æœ‰é¢„è¨€æœºçš„å›¾çµæœºã€‚

Relativization is an important tool for studying complexity class relationships, considering Turing machines with oracles.

**Baker-Gill-Solovayå®šç† / Baker-Gill-Solovay Theorem:**

å­˜åœ¨é¢„è¨€æœº $A$ å’Œ $B$ï¼Œä½¿å¾—ï¼š

There exist oracles $A$ and $B$ such that:

- $P^A = NP^A$
- $P^B \neq NP^B$

è¿™è¡¨æ˜P vs NPé—®é¢˜ä¸èƒ½é€šè¿‡ç›¸å¯¹åŒ–æŠ€æœ¯è§£å†³ã€‚

This shows that the P vs NP problem cannot be resolved by relativization techniques.

---

## 6. å®Œå…¨æ€§é—®é¢˜ (Complete Problems)

### 6.1 å®Œå…¨æ€§å®šä¹‰ (Definition of Completeness)

**å®Œå…¨æ€§é—®é¢˜å®šä¹‰ / Definition of Complete Problems:**

é—®é¢˜ $L$ æ˜¯å¤æ‚åº¦ç±» $C$ å®Œå…¨çš„ï¼Œå¦‚æœï¼š

1. $L \in C$
2. å¯¹äºæ‰€æœ‰ $A \in C$ï¼Œ$A \leq_p L$

Problem $L$ is complete for complexity class $C$ if:

1. $L \in C$
2. For all $A \in C$, $A \leq_p L$

**å®Œå…¨æ€§çš„æ„ä¹‰ / Significance of Completeness:**

1. **ç†è®ºæ„ä¹‰ / Theoretical Significance:**
   - ç†è§£å¤æ‚åº¦ç±»çš„ç»“æ„ / Understanding structure of complexity classes
   - æä¾›å½’çº¦ç›®æ ‡ / Providing reduction targets

2. **å®é™…æ„ä¹‰ / Practical Significance:**
   - ç®—æ³•è®¾è®¡æŒ‡å¯¼ / Algorithm design guidance
   - é—®é¢˜åˆ†ç±»å·¥å…· / Problem classification tool

### 6.2 å„ç±»çš„å®Œå…¨é—®é¢˜ (Complete Problems for Different Classes)

**På®Œå…¨é—®é¢˜ / P-Complete Problems:**

1. **ç”µè·¯å€¼é—®é¢˜ (Circuit Value Problem) / Circuit Value Problem:**
   - åˆ¤æ–­å¸ƒå°”ç”µè·¯çš„å€¼ / Determine value of boolean circuit
   - ç¬¬ä¸€ä¸ªè¢«è¯æ˜çš„På®Œå…¨é—®é¢˜ / First problem proven to be P-complete

2. **çº¿æ€§è§„åˆ’é—®é¢˜ (Linear Programming) / Linear Programming:**
   - åˆ¤æ–­çº¿æ€§è§„åˆ’æ˜¯å¦å¯è¡Œ / Determine if linear program is feasible
   - åœ¨å¼ºå¤šé¡¹å¼æ—¶é—´å†…å¯è§£ / Solvable in strongly polynomial time

**NPå®Œå…¨é—®é¢˜ / NP-Complete Problems:**

1. **å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜ (SAT) / Boolean Satisfiability Problem (SAT):**
   - åˆ¤æ–­å¸ƒå°”å…¬å¼æ˜¯å¦å¯æ»¡è¶³ / Determine if boolean formula is satisfiable
   - ç¬¬ä¸€ä¸ªè¢«è¯æ˜çš„NPå®Œå…¨é—®é¢˜ / First problem proven to be NP-complete

2. **3-å¯æ»¡è¶³æ€§é—®é¢˜ (3-SAT) / 3-Satisfiability Problem (3-SAT):**
   - åˆ¤æ–­3-CNFå…¬å¼æ˜¯å¦å¯æ»¡è¶³ / Determine if 3-CNF formula is satisfiable
   - æ¯ä¸ªå­å¥æœ€å¤š3ä¸ªæ–‡å­— / At most 3 literals per clause

**PSPACEå®Œå…¨é—®é¢˜ / PSPACE-Complete Problems:**

1. **çœŸé‡åŒ–å¸ƒå°”å…¬å¼é—®é¢˜ (TQBF) / True Quantified Boolean Formula Problem (TQBF):**
   - åˆ¤æ–­é‡åŒ–å¸ƒå°”å…¬å¼æ˜¯å¦ä¸ºçœŸ / Determine if quantified boolean formula is true
   - ç¬¬ä¸€ä¸ªè¢«è¯æ˜çš„PSPACEå®Œå…¨é—®é¢˜ / First problem proven to be PSPACE-complete

2. **å¹¿ä¹‰åœ°ç†æ¸¸æˆ (Generalized Geography) / Generalized Geography:**
   - åˆ¤æ–­ç©å®¶æ˜¯å¦æœ‰å¿…èƒœç­–ç•¥ / Determine if player has winning strategy
   - åšå¼ˆè®ºä¸­çš„ç»å…¸é—®é¢˜ / Classic problem in game theory

### 6.3 å½’çº¦æŠ€æœ¯ (Reduction Techniques)

**å¤šé¡¹å¼æ—¶é—´å½’çº¦ (Polynomial Time Reduction) / Polynomial Time Reduction:**

é—®é¢˜ $A$ å¤šé¡¹å¼æ—¶é—´å½’çº¦åˆ°é—®é¢˜ $B$ï¼Œå¦‚æœå­˜åœ¨å¤šé¡¹å¼æ—¶é—´å¯è®¡ç®—çš„å‡½æ•° $f$ï¼Œä½¿å¾—ï¼š

Problem $A$ polynomial time reduces to problem $B$ if there exists a polynomial time computable function $f$ such that:

$$x \in A \Leftrightarrow f(x) \in B$$

**å½’çº¦çš„æ€§è´¨ / Properties of Reductions:**

1. **ä¼ é€’æ€§ (Transitivity) / Transitivity:**
   å¦‚æœ $A \leq_p B$ ä¸” $B \leq_p C$ï¼Œåˆ™ $A \leq_p C$

2. **è‡ªåæ€§ (Reflexivity) / Reflexivity:**
   $A \leq_p A$

3. **ä¿æŒå¤æ‚åº¦ç±» / Preserves Complexity Class:**
   å¦‚æœ $B \in P$ ä¸” $A \leq_p B$ï¼Œåˆ™ $A \in P$

### ç»å…¸å½’çº¦ç¤ºä¾‹ï¼š3-SAT â†’ Vertex-Cover / Classic Reduction Example: 3-SAT â†’ Vertex-Cover

**å®šç† 6.3.1** (3-SAT åˆ° Vertex-Cover çš„å½’çº¦) (Theorem - Reduction from 3-SAT to Vertex-Cover):
æŠŠ 3-CNF å…¬å¼ $\Phi$ è½¬åŒ–ä¸ºç­‰ä»·çš„å›¾ $G$ ä¸æ•´æ•° $k$ï¼Œä½¿å¾— $\Phi$ å¯æ»¡è¶³ $\Leftrightarrow$ $G$ æœ‰å¤§å° $\leq k$ çš„é¡¶ç‚¹è¦†ç›–ã€‚

Transform 3-CNF formula $\Phi$ into an equivalent graph $G$ and integer $k$, such that $\Phi$ is satisfiable $\Leftrightarrow$ $G$ has a vertex cover of size $\leq k$.

**æ„é€ è¦ç‚¹** (Construction Outline):

1. **å­å¥æ„é€ ** (Clause Construction):
   å¯¹æ¯ä¸ªå­å¥ $C_i = (\ell_{i1} \vee \ell_{i2} \vee \ell_{i3})$ï¼Œåˆ›å»ºä¸€ä¸ªä¸‰è§’å½¢ï¼ˆ3ä¸ªé¡¶ç‚¹å¯¹åº”ä¸‰ä¸ªæ–‡å­—ï¼‰ï¼Œä¸‰æ¡è¾¹å…¨è¿ã€‚
   For each clause $C_i = (\ell_{i1} \vee \ell_{i2} \vee \ell_{i3})$, create a triangle (3 vertices corresponding to three literals), with all three edges connected.

2. **å†²çªè¾¹æ„é€ ** (Conflict Edge Construction):
   å¯¹æ¯ä¸ªå˜é‡ $x$ï¼Œåœ¨æ‰€æœ‰å‡ºç° $x$ çš„æ–‡å­—é¡¶ç‚¹ä¸æ‰€æœ‰å‡ºç° $\neg x$ çš„æ–‡å­—é¡¶ç‚¹ä¹‹é—´è¿ä¸€æ¡ **å†²çªè¾¹**ï¼ˆé˜²æ­¢ä¸¤è€…åŒæ—¶è¢«é€‰å…¥è¦†ç›–ï¼‰ã€‚
   For each variable $x$, connect a **conflict edge** between all vertices corresponding to literal $x$ and all vertices corresponding to literal $\neg x$ (preventing both from being selected into the cover).

3. **å‚æ•°è®¾ç½®** (Parameter Setting):
   è®¾ $k = |C| + |Var|$ï¼ˆæ¯ä¸ªå­å¥é€‰å– **2** ä¸ªé¡¶ç‚¹è¦†ç›–å…¶å†…éƒ¨ 3 æ¡è¾¹ï¼Œå†ä¸ºæ¯ä¸ªå˜é‡é€‰å– **1** ä¸ªé¡¶ç‚¹è¦†ç›–å†²çªè¾¹ï¼‰ã€‚
   Set $k = |C| + |Var|$ (select **2** vertices per clause to cover its 3 internal edges, and **1** vertex per variable to cover conflict edges).

4. **æ–¹å‘ â‡’** (Direction â‡’):
   è‹¥ $\Phi$ å¯æ»¡è¶³ï¼Œåˆ™å¯¹æ¯ä¸ªå­å¥é€‰å–ä¸€ä¸ªæ»¡è¶³æ–‡å­—å¯¹åº”çš„é¡¶ç‚¹ä¸æ”¾å…¥è¦†ç›–ï¼Œå…¶ä½™ä¸¤ç‚¹æ”¾å…¥è¦†ç›–ï¼›å¯¹æ¯ä¸ªå˜é‡è‹¥ $x$ ä¸ºçœŸåˆ™åœ¨å†²çªè¾¹å¯¹åº”çš„ $\neg x$ é¡¶ç‚¹æ”¾å…¥è¦†ç›–ï¼Œå¾—åˆ°å¤§å°æ­£å¥½ $k$ çš„è¦†ç›–ã€‚
   If $\Phi$ is satisfiable, then for each clause select one vertex corresponding to a satisfying literal to exclude from the cover, and put the other two in the cover; for each variable if $x$ is true, put the $\neg x$ vertex in the cover, obtaining a cover of size exactly $k$.

5. **æ–¹å‘ â‡** (Direction â‡):
   è‹¥æœ‰å¤§å° $\leq k$ çš„è¦†ç›–ï¼Œåˆ™æ¯ä¸ªå­å¥å¿…é¡»è‡³å°‘æœ‰ **2** ä¸ªé¡¶ç‚¹åœ¨è¦†ç›–ä¸­ï¼ˆå› ä¸ºä¸‰è§’å½¢æœ‰ 3 æ¡è¾¹ï¼‰ï¼Œå‰©ä¸‹çš„é¡¶ç‚¹å¯¹åº”ä¸€ä¸ªæ»¡è¶³æ–‡å­—ï¼›å†²çªè¾¹çš„è¦†ç›–ä¿è¯åŒä¸€å˜é‡ä¸å‡ºç°çœŸ/å‡å†²çªï¼Œä»è€Œå¾—åˆ°æ»¡è¶³èµ‹å€¼ã€‚
   If there is a cover of size $\leq k$, then each clause must have at least **2** vertices in the cover (because the triangle has 3 edges), the remaining vertex corresponds to a satisfying literal; the cover of conflict edges ensures no true/false conflict for the same variable, thus obtaining a satisfying assignment.

**ç»“è®º** (Conclusion):
3-SAT $\leq_p$ Vertex-Cover $\Rightarrow$ Vertex-Cover æ˜¯ NP-Completeã€‚

3-SAT $\leq_p$ Vertex-Cover $\Rightarrow$ Vertex-Cover is NP-Complete.

---

## 7. å¤æ‚åº¦ç±»åº”ç”¨ (Applications of Complexity Classes)

### 7.1 å¯†ç å­¦åº”ç”¨ (Cryptographic Applications)

**åŸºäºå¤æ‚åº¦çš„å¯†ç å­¦ / Complexity-Based Cryptography:**

1. **å…¬é’¥å¯†ç å­¦ / Public Key Cryptography:**
   - åŸºäºNPå›°éš¾é—®é¢˜ / Based on NP-hard problems
   - RSAåŸºäºå¤§æ•´æ•°åˆ†è§£ / RSA based on integer factorization

2. **é›¶çŸ¥è¯†è¯æ˜ / Zero-Knowledge Proofs:**
   - åŸºäºNPå®Œå…¨é—®é¢˜ / Based on NP-complete problems
   - å›¾åŒæ„é—®é¢˜ / Graph isomorphism problem

3. **é‡å­å¯†ç å­¦ / Quantum Cryptography:**
   - åŸºäºé‡å­å¤æ‚åº¦ç±» / Based on quantum complexity classes
   - BQPç±»çš„é‡è¦æ€§ / Importance of BQP class

### 7.2 ç®—æ³•è®¾è®¡åº”ç”¨ (Algorithm Design Applications)

**åŸºäºå¤æ‚åº¦çš„ç®—æ³•è®¾è®¡ / Complexity-Based Algorithm Design:**

1. **è¿‘ä¼¼ç®—æ³• / Approximation Algorithms:**
   - å¯¹äºNPå›°éš¾é—®é¢˜çš„è¿‘ä¼¼è§£ / Approximate solutions for NP-hard problems
   - æ€§èƒ½ä¿è¯ / Performance guarantees

2. **éšæœºç®—æ³• / Randomized Algorithms:**
   - åŸºäºéšæœºå¤æ‚åº¦ç±» / Based on randomized complexity classes
   - BPPç±»çš„é‡è¦æ€§ / Importance of BPP class

3. **å‚æ•°åŒ–ç®—æ³• / Parameterized Algorithms:**
   - åŸºäºå‚æ•°åŒ–å¤æ‚åº¦ / Based on parameterized complexity
   - FPTç±»çš„é‡è¦æ€§ / Importance of FPT class

### 7.3 ç³»ç»Ÿè®¾è®¡åº”ç”¨ (System Design Applications)

**åŸºäºå¤æ‚åº¦çš„ç³»ç»Ÿè®¾è®¡ / Complexity-Based System Design:**

1. **ç¼–è¯‘å™¨ä¼˜åŒ– / Compiler Optimization:**
   - åŸºäºç¨‹åºåˆ†æå¤æ‚åº¦ / Based on program analysis complexity
   - é™æ€åˆ†æå·¥å…· / Static analysis tools

2. **æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ– / Database Query Optimization:**
   - åŸºäºæŸ¥è¯¢å¤æ‚åº¦ / Based on query complexity
   - æŸ¥è¯¢è®¡åˆ’é€‰æ‹© / Query plan selection

3. **ç½‘ç»œåè®®è®¾è®¡ / Network Protocol Design:**
   - åŸºäºé€šä¿¡å¤æ‚åº¦ / Based on communication complexity
   - åˆ†å¸ƒå¼ç®—æ³•è®¾è®¡ / Distributed algorithm design

---

## 8. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 8.1 å¤æ‚åº¦ç±»åˆ†æå·¥å…· (Complexity Class Analysis Tool)

```rust
use std::collections::HashMap;

/// å¤æ‚åº¦ç±»åˆ†æå™¨ / Complexity Class Analyzer
pub struct ComplexityClassAnalyzer {
    problems: HashMap<String, ProblemInfo>,
    reductions: Vec<Reduction>,
}

#[derive(Debug, Clone)]
pub struct ProblemInfo {
    name: String,
    complexity_class: ComplexityClass,
    is_complete: bool,
    description: String,
}

#[derive(Debug, Clone)]
pub enum ComplexityClass {
    P,
    NP,
    PSPACE,
    EXP,
    NEXP,
    Unknown,
}

#[derive(Debug, Clone)]
pub struct Reduction {
    from: String,
    to: String,
    reduction_type: ReductionType,
}

#[derive(Debug, Clone)]
pub enum ReductionType {
    Polynomial,
    Logarithmic,
    Linear,
}

impl ComplexityClassAnalyzer {
    /// åˆ›å»ºæ–°çš„åˆ†æå™¨ / Create new analyzer
    pub fn new() -> Self {
        ComplexityClassAnalyzer {
            problems: HashMap::new(),
            reductions: Vec::new(),
        }
    }

    /// æ·»åŠ é—®é¢˜ / Add problem
    pub fn add_problem(&mut self, name: &str, class: ComplexityClass, is_complete: bool, description: &str) {
        self.problems.insert(name.to_string(), ProblemInfo {
            name: name.to_string(),
            complexity_class: class,
            is_complete,
            description: description.to_string(),
        });
    }

    /// æ·»åŠ å½’çº¦ / Add reduction
    pub fn add_reduction(&mut self, from: &str, to: &str, reduction_type: ReductionType) {
        self.reductions.push(Reduction {
            from: from.to_string(),
            to: to.to_string(),
            reduction_type,
        });
    }

    /// åˆ†æå¤æ‚åº¦ç±»å…³ç³» / Analyze complexity class relationships
    pub fn analyze_relationships(&self) -> String {
        let mut analysis = String::new();
        analysis.push_str("Complexity Class Analysis:\n");
        analysis.push_str("========================\n\n");

        // åˆ†æPç±»é—®é¢˜ / Analyze P class problems
        analysis.push_str("P Class Problems:\n");
        for (name, info) in &self.problems {
            if matches!(info.complexity_class, ComplexityClass::P) {
                analysis.push_str(&format!("- {}: {}\n", name, info.description));
            }
        }

        // åˆ†æNPç±»é—®é¢˜ / Analyze NP class problems
        analysis.push_str("\nNP Class Problems:\n");
        for (name, info) in &self.problems {
            if matches!(info.complexity_class, ComplexityClass::NP) {
                let complete_status = if info.is_complete { " (NP-Complete)" } else { "" };
                analysis.push_str(&format!("- {}{}: {}\n", name, complete_status, info.description));
            }
        }

        // åˆ†æå½’çº¦å…³ç³» / Analyze reduction relationships
        analysis.push_str("\nReduction Relationships:\n");
        for reduction in &self.reductions {
            analysis.push_str(&format!("- {} â‰¤ {} ({:?})\n",
                reduction.from, reduction.to, reduction.reduction_type));
        }

        analysis
    }

    /// æ£€æŸ¥é—®é¢˜æ˜¯å¦åœ¨ç‰¹å®šç±»ä¸­ / Check if problem is in specific class
    pub fn is_in_class(&self, problem_name: &str, class: ComplexityClass) -> bool {
        if let Some(info) = self.problems.get(problem_name) {
            matches!(info.complexity_class, class)
        } else {
            false
        }
    }

    /// è·å–é—®é¢˜çš„å¤æ‚åº¦ç±» / Get complexity class of problem
    pub fn get_complexity_class(&self, problem_name: &str) -> Option<ComplexityClass> {
        self.problems.get(problem_name).map(|info| info.complexity_class.clone())
    }
}
```

### 8.2 NPå®Œå…¨é—®é¢˜å®ç° (NP-Complete Problem Implementation)

```rust
/// NPå®Œå…¨é—®é¢˜å®ç° / NP-Complete Problem Implementation
pub struct NPCompleteProblems;

impl NPCompleteProblems {
    /// 3-SATé—®é¢˜ / 3-SAT Problem
    pub fn three_sat_solver(clauses: &[(bool, bool, bool)]) -> bool {
        // æš´åŠ›æœç´¢æ‰€æœ‰å¯èƒ½çš„èµ‹å€¼ / Brute force search all possible assignments
        let n = clauses.len();
        for assignment in 0..(1 << n) {
            if Self::evaluate_clauses(clauses, assignment) {
                return true;
            }
        }
        false
    }

    /// è¯„ä¼°å­å¥ / Evaluate clauses
    fn evaluate_clauses(clauses: &[(bool, bool, bool)], assignment: usize) -> bool {
        for clause in clauses {
            let mut clause_satisfied = false;
            for (i, &literal) in clause.iter().enumerate() {
                let bit = (assignment >> i) & 1;
                let value = bit == 1;
                if value == literal {
                    clause_satisfied = true;
                    break;
                }
            }
            if !clause_satisfied {
                return false;
            }
        }
        true
    }

    /// é¡¶ç‚¹è¦†ç›–é—®é¢˜ / Vertex Cover Problem
    pub fn vertex_cover(graph: &[(usize, usize)], k: usize) -> bool {
        let mut vertices = std::collections::HashSet::new();
        for &(u, v) in graph {
            vertices.insert(u);
            vertices.insert(v);
        }

        // æ£€æŸ¥æ‰€æœ‰å¤§å°ä¸ºkçš„é¡¶ç‚¹å­é›† / Check all vertex subsets of size k
        let vertices: Vec<usize> = vertices.into_iter().collect();
        Self::check_vertex_cover_combinations(graph, &vertices, k)
    }

    /// æ£€æŸ¥é¡¶ç‚¹è¦†ç›–ç»„åˆ / Check vertex cover combinations
    fn check_vertex_cover_combinations(
        graph: &[(usize, usize)],
        vertices: &[usize],
        k: usize
    ) -> bool {
        if k == 0 {
            return graph.is_empty();
        }

        if vertices.len() < k {
            return false;
        }

        // é€’å½’æ£€æŸ¥åŒ…å«å’Œä¸åŒ…å«ç¬¬ä¸€ä¸ªé¡¶ç‚¹çš„æƒ…å†µ
        // Recursively check cases with and without first vertex
        let first_vertex = vertices[0];
        let remaining_vertices = &vertices[1..];

        // åŒ…å«ç¬¬ä¸€ä¸ªé¡¶ç‚¹ / Include first vertex
        let mut new_graph = Vec::new();
        for &(u, v) in graph {
            if u != first_vertex && v != first_vertex {
                new_graph.push((u, v));
            }
        }
        if Self::check_vertex_cover_combinations(&new_graph, remaining_vertices, k - 1) {
            return true;
        }

        // ä¸åŒ…å«ç¬¬ä¸€ä¸ªé¡¶ç‚¹ / Exclude first vertex
        Self::check_vertex_cover_combinations(graph, remaining_vertices, k)
    }

    /// æ—…è¡Œå•†é—®é¢˜ / Traveling Salesman Problem
    pub fn traveling_salesman(distances: &[Vec<usize>], max_distance: usize) -> bool {
        let n = distances.len();
        if n == 0 {
            return true;
        }

        // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„è·¯å¾„ / Check all possible paths
        let mut path = vec![0];
        let mut visited = vec![false; n];
        visited[0] = true;

        Self::tsp_backtrack(distances, max_distance, &mut path, &mut visited, 0)
    }

    /// TSPå›æº¯ç®—æ³• / TSP backtracking algorithm
    fn tsp_backtrack(
        distances: &[Vec<usize>],
        max_distance: usize,
        path: &mut Vec<usize>,
        visited: &mut [bool],
        current_distance: usize,
    ) -> bool {
        if path.len() == distances.len() {
            // æ£€æŸ¥æ˜¯å¦å›åˆ°èµ·ç‚¹ / Check if we can return to start
            let last = path[path.len() - 1];
            let total_distance = current_distance + distances[last][0];
            return total_distance <= max_distance;
        }

        let current = path[path.len() - 1];
        for next in 0..distances.len() {
            if !visited[next] {
                let new_distance = current_distance + distances[current][next];
                if new_distance <= max_distance {
                    path.push(next);
                    visited[next] = true;

                    if Self::tsp_backtrack(distances, max_distance, path, visited, new_distance) {
                        return true;
                    }

                    path.pop();
                    visited[next] = false;
                }
            }
        }

        false
    }
}
```

### 8.3 PSPACEå®Œå…¨é—®é¢˜å®ç° (PSPACE-Complete Problem Implementation)

```rust
/// PSPACEå®Œå…¨é—®é¢˜å®ç° / PSPACE-Complete Problem Implementation
pub struct PSPACECompleteProblems;

impl PSPACECompleteProblems {
    /// çœŸé‡åŒ–å¸ƒå°”å…¬å¼é—®é¢˜ (TQBF) / True Quantified Boolean Formula Problem (TQBF)
    pub fn tqbf_solver(formula: &QuantifiedFormula) -> bool {
        Self::evaluate_quantified_formula(formula)
    }

    /// é‡åŒ–å¸ƒå°”å…¬å¼ / Quantified Boolean Formula
    #[derive(Debug, Clone)]
    pub struct QuantifiedFormula {
        quantifiers: Vec<Quantifier>,
        matrix: BooleanFormula,
    }

    #[derive(Debug, Clone)]
    pub enum Quantifier {
        ForAll(String),
        Exists(String),
    }

    #[derive(Debug, Clone)]
    pub enum BooleanFormula {
        Variable(String),
        Not(Box<BooleanFormula>),
        And(Box<BooleanFormula>, Box<BooleanFormula>),
        Or(Box<BooleanFormula>, Box<BooleanFormula>),
    }

    /// è¯„ä¼°é‡åŒ–å…¬å¼ / Evaluate quantified formula
    fn evaluate_quantified_formula(formula: &QuantifiedFormula) -> bool {
        let mut variables = std::collections::HashMap::new();
        Self::evaluate_quantifiers(&formula.quantifiers, &mut variables, &formula.matrix)
    }

    /// è¯„ä¼°é‡è¯ / Evaluate quantifiers
    fn evaluate_quantifiers(
        quantifiers: &[Quantifier],
        variables: &mut HashMap<String, bool>,
        matrix: &BooleanFormula,
    ) -> bool {
        if quantifiers.is_empty() {
            return Self::evaluate_boolean_formula(matrix, variables);
        }

        let (current_quantifier, remaining_quantifiers) = quantifiers.split_first().unwrap();

        match current_quantifier {
            Quantifier::ForAll(var) => {
                // å…¨ç§°é‡è¯ï¼šæ‰€æœ‰èµ‹å€¼éƒ½å¿…é¡»ä¸ºçœŸ / Universal quantifier: all assignments must be true
                variables.insert(var.clone(), true);
                let result1 = Self::evaluate_quantifiers(remaining_quantifiers, variables, matrix);
                variables.insert(var.clone(), false);
                let result2 = Self::evaluate_quantifiers(remaining_quantifiers, variables, matrix);
                result1 && result2
            }
            Quantifier::Exists(var) => {
                // å­˜åœ¨é‡è¯ï¼šè‡³å°‘ä¸€ä¸ªèµ‹å€¼ä¸ºçœŸ / Existential quantifier: at least one assignment must be true
                variables.insert(var.clone(), true);
                let result1 = Self::evaluate_quantifiers(remaining_quantifiers, variables, matrix);
                variables.insert(var.clone(), false);
                let result2 = Self::evaluate_quantifiers(remaining_quantifiers, variables, matrix);
                result1 || result2
            }
        }
    }

    /// è¯„ä¼°å¸ƒå°”å…¬å¼ / Evaluate boolean formula
    fn evaluate_boolean_formula(
        formula: &BooleanFormula,
        variables: &HashMap<String, bool>,
    ) -> bool {
        match formula {
            BooleanFormula::Variable(var) => *variables.get(var).unwrap_or(&false),
            BooleanFormula::Not(subformula) => !Self::evaluate_boolean_formula(subformula, variables),
            BooleanFormula::And(left, right) => {
                Self::evaluate_boolean_formula(left, variables)
                    && Self::evaluate_boolean_formula(right, variables)
            }
            BooleanFormula::Or(left, right) => {
                Self::evaluate_boolean_formula(left, variables)
                    || Self::evaluate_boolean_formula(right, variables)
            }
        }
    }

    /// å¹¿ä¹‰åœ°ç†æ¸¸æˆ / Generalized Geography
    pub fn generalized_geography(graph: &[(String, String)]) -> bool {
        let mut game_graph = std::collections::HashMap::new();
        for (from, to) in graph {
            game_graph.entry(from.clone()).or_insert_with(Vec::new).push(to.clone());
        }

        let mut visited = std::collections::HashSet::new();
        Self::play_geography_game(&game_graph, &mut visited, None)
    }

    /// ç©åœ°ç†æ¸¸æˆ / Play geography game
    fn play_geography_game(
        graph: &HashMap<String, Vec<String>>,
        visited: &mut HashSet<String>,
        current: Option<&String>,
    ) -> bool {
        if let Some(current_word) = current {
            if visited.contains(current_word) {
                return false; // é‡å¤å•è¯ï¼Œå½“å‰ç©å®¶è¾“ / Repeated word, current player loses
            }
            visited.insert(current_word.clone());
        }

        let available_moves = if let Some(current_word) = current {
            graph.get(current_word).cloned().unwrap_or_default()
        } else {
            graph.keys().cloned().collect()
        };

        if available_moves.is_empty() {
            return false; // æ²¡æœ‰å¯ç”¨ç§»åŠ¨ï¼Œå½“å‰ç©å®¶è¾“ / No available moves, current player loses
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰å¿…èƒœç§»åŠ¨ / Check if there's a winning move
        for next_word in available_moves {
            if !visited.contains(&next_word) {
                let mut new_visited = visited.clone();
                new_visited.insert(next_word.clone());

                // å¦‚æœå¯¹æ‰‹åœ¨ä¸‹ä¸€æ­¥ä¼šè¾“ï¼Œé‚£ä¹ˆå½“å‰ç§»åŠ¨æ˜¯å¿…èƒœçš„
                // If opponent will lose in next step, current move is winning
                if !Self::play_geography_game(graph, &mut new_visited, Some(&next_word)) {
                    return true;
                }
            }
        }

        false // æ²¡æœ‰å¿…èƒœç§»åŠ¨ / No winning move
    }
}
```

### 8.4 å¤æ‚åº¦ç±»æµ‹è¯• (Complexity Class Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_complexity_class_analyzer() {
        let mut analyzer = ComplexityClassAnalyzer::new();

        // æ·»åŠ Pç±»é—®é¢˜ / Add P class problems
        analyzer.add_problem("Linear Programming", ComplexityClass::P, false, "Linear programming feasibility");
        analyzer.add_problem("Greatest Common Divisor", ComplexityClass::P, false, "Finding GCD of two numbers");

        // æ·»åŠ NPç±»é—®é¢˜ / Add NP class problems
        analyzer.add_problem("3-SAT", ComplexityClass::NP, true, "3-Satisfiability problem");
        analyzer.add_problem("Vertex Cover", ComplexityClass::NP, true, "Vertex cover problem");
        analyzer.add_problem("Traveling Salesman", ComplexityClass::NP, true, "TSP decision problem");

        // æ·»åŠ å½’çº¦ / Add reductions
        analyzer.add_reduction("3-SAT", "Vertex Cover", ReductionType::Polynomial);
        analyzer.add_reduction("Vertex Cover", "Traveling Salesman", ReductionType::Polynomial);

        let analysis = analyzer.analyze_relationships();
        assert!(analysis.contains("P Class Problems"));
        assert!(analysis.contains("NP Class Problems"));
        assert!(analysis.contains("Reduction Relationships"));
    }

    #[test]
    fn test_np_complete_problems() {
        // æµ‹è¯•3-SAT / Test 3-SAT
        let clauses = vec![
            (true, true, false),
            (false, true, true),
            (true, false, true),
        ];
        let result = NPCompleteProblems::three_sat_solver(&clauses);
        assert!(result); // è¿™ä¸ªå®ä¾‹åº”è¯¥æ˜¯å¯æ»¡è¶³çš„ / This instance should be satisfiable

        // æµ‹è¯•é¡¶ç‚¹è¦†ç›– / Test vertex cover
        let graph = vec![(0, 1), (1, 2), (2, 3), (3, 0)];
        let result = NPCompleteProblems::vertex_cover(&graph, 2);
        assert!(result); // å­˜åœ¨å¤§å°ä¸º2çš„é¡¶ç‚¹è¦†ç›– / Vertex cover of size 2 exists

        // æµ‹è¯•æ—…è¡Œå•†é—®é¢˜ / Test traveling salesman
        let distances = vec![
            vec![0, 10, 15, 20],
            vec![10, 0, 35, 25],
            vec![15, 35, 0, 30],
            vec![20, 25, 30, 0],
        ];
        let result = NPCompleteProblems::traveling_salesman(&distances, 80);
        assert!(result); // å­˜åœ¨è·ç¦»ä¸è¶…è¿‡80çš„è·¯å¾„ / Path with distance â‰¤ 80 exists
    }

    #[test]
    fn test_pspace_complete_problems() {
        // æµ‹è¯•TQBF / Test TQBF
        let formula = QuantifiedFormula {
            quantifiers: vec![
                Quantifier::ForAll("x".to_string()),
                Quantifier::Exists("y".to_string()),
            ],
            matrix: BooleanFormula::And(
                Box::new(BooleanFormula::Variable("x".to_string())),
                Box::new(BooleanFormula::Variable("y".to_string())),
            ),
        };
        let result = PSPACECompleteProblems::tqbf_solver(&formula);
        assert!(result); // è¿™ä¸ªå…¬å¼åº”è¯¥æ˜¯çœŸçš„ / This formula should be true

        // æµ‹è¯•å¹¿ä¹‰åœ°ç†æ¸¸æˆ / Test generalized geography
        let graph = vec![
            ("cat".to_string(), "tiger".to_string()),
            ("tiger".to_string(), "rabbit".to_string()),
            ("rabbit".to_string(), "tiger".to_string()),
        ];
        let result = PSPACECompleteProblems::generalized_geography(&graph);
        assert!(result); // ç¬¬ä¸€ä¸ªç©å®¶åº”è¯¥æœ‰å¿…èƒœç­–ç•¥ / First player should have winning strategy
    }
}
```

---

## 9. å‚è€ƒæ–‡çŒ® / References

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**: æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ [CITATION_STANDARD.md](../CITATION_STANDARD.md)ã€[å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md](../å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)ï¼‰ã€‚æ–‡å†…é‡‡ç”¨ [Key] æ ¼å¼å¼•ç”¨ï¼Œä¸å‚è€ƒæ–‡çŒ®åˆ—è¡¨å¯¹åº”ã€‚

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature**:

1. [Hartmanis1965] Hartmanis, J., & Stearns, R. E. (1965). "On the Computational Complexity of Algorithms". *Transactions of the American Mathematical Society*, 117: 285-306.
   - è®¡ç®—å¤æ‚æ€§ç†è®ºçš„å¥ åŸºæ€§è®ºæ–‡ï¼Œå¼•å…¥æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦æ¦‚å¿µã€‚

2. [Cook1971] Cook, S. A. (1971). "The Complexity of Theorem-Proving Procedures". *STOC '71*, 151-158. DOI: 10.1145/800157.805047.
   - NPå®Œå…¨æ€§ç†è®ºçš„å¼€åˆ›æ€§è®ºæ–‡ï¼ŒCookå®šç†ï¼Œå›¾çµå¥–å·¥ä½œã€‚æœ¬æ–‡æ¡£Â§4.2çš„NPå®Œå…¨æ€§åŸºäºæ­¤è®ºæ–‡ã€‚

3. [Karp1972] Karp, R. M. (1972). "Reducibility Among Combinatorial Problems". In *Complexity of Computer Computations*, 85-103. Springer.
   - Karpçš„21ä¸ªNPå®Œå…¨é—®é¢˜ï¼ŒNPå®Œå…¨æ€§ç†è®ºçš„ç»å…¸æ–‡çŒ®ã€‚æœ¬æ–‡æ¡£Â§4.6çš„å®Œå…¨é—®é¢˜å‚è€ƒæ­¤è®ºæ–‡ã€‚

4. [Savitch1970] Savitch, W. J. (1970). "Relationships Between Nondeterministic and Deterministic Tape Complexities". *Journal of Computer and System Sciences*, 4(2): 177-192.
   - Savitchå®šç†çš„åŸå§‹è®ºæ–‡ï¼ŒPSPACEä¸NPSPACEçš„å…³ç³»ã€‚

5. [StockmeyerMeyer1973] Stockmeyer, L. J., & Meyer, A. R. (1973). "Word Problems Requiring Exponential Time". *STOC '73*, 1-9. DOI: 10.1145/800125.804029.
   - æŒ‡æ•°æ—¶é—´å¤æ‚åº¦çš„é‡è¦ç»“æœã€‚æœ¬æ–‡æ¡£Â§4.4çš„EXPç±»å‚è€ƒæ­¤è®ºæ–‡ã€‚

6. [BakerGillSolovay1975] Baker, T., Gill, J., & Solovay, R. (1975). "Relativizations of the P =? NP Question". *SIAM Journal on Computing*, 4(4): 431-442. DOI: 10.1137/0204037.
   - P vs NPé—®é¢˜çš„ç›¸å¯¹åŒ–ç»“æœï¼Œè¯æ˜æŸäº›è¯æ˜æŠ€æœ¯æ— æ³•è§£å†³P vs NPã€‚æœ¬æ–‡æ¡£Â§4.5.3çš„ç›¸å¯¹åŒ–ç»“æœåŸºäºæ­¤è®ºæ–‡ã€‚

**æ ‡å‡†æ•™æ / Standard Textbooks**:

1. [AroraBarak2009] Arora, S., & Barak, B. (2009). *Computational Complexity: A Modern Approach*. Cambridge University Press.
   - è®¡ç®—å¤æ‚åº¦ç†è®ºçš„ç°ä»£ç»¼åˆï¼Œç³»ç»Ÿä»‹ç»å¤æ‚åº¦ç±»ã€‚æœ¬æ–‡æ¡£Â§4.1-Â§4.5çš„å†…å®¹å‚è€ƒæ­¤ä¹¦ã€‚

2. [Papadimitriou1994] Papadimitriou, C. H. (1994). *Computational Complexity*. Addison-Wesley.
   - è®¡ç®—å¤æ‚æ€§ç†è®ºçš„ç»å…¸æ•™æï¼Œæ¶µç›–å„ç§å¤æ‚åº¦ç±»ã€‚

3. [Sipser2012] Sipser, M. (2012). *Introduction to the Theory of Computation* (3rd Edition). Cengage Learning.
   - è®¡ç®—ç†è®ºå¯¼è®ºï¼ŒåŒ…å«å¤æ‚åº¦ç±»çš„ä»‹ç»ã€‚

**ç©ºé—´å¤æ‚åº¦ / Space Complexity**:

1. Immerman, N. (1988). "Nondeterministic Space is Closed Under Complementation". *SIAM Journal on Computing*, 17(5): 935-938.
    - è¯æ˜NL=coNLï¼Œç©ºé—´å¤æ‚åº¦ç†è®ºçš„é‡è¦ç»“æœã€‚

**åº”ç”¨ä¸å®è·µ / Applications and Practice**:

1. [Cormen2009] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd Edition). MIT Press.
    - ç®—æ³•å¯¼è®ºï¼ŒåŒ…å«å¤æ‚åº¦ç±»åœ¨ç®—æ³•è®¾è®¡ä¸­çš„åº”ç”¨ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Complexity Class**: <https://en.wikipedia.org/wiki/Complexity_class>
   - å¤æ‚åº¦ç±»çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«Pã€NPã€PSPACEç­‰æ ¸å¿ƒå¤æ‚åº¦ç±»ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - P versus NP Problem**: <https://en.wikipedia.org/wiki/P_versus_NP_problem>
   - Pä¸NPé—®é¢˜çš„Wikipediaæ¡ç›®ï¼Œä»‹ç»è®¡ç®—å¤æ‚åº¦ç†è®ºçš„æ ¸å¿ƒé—®é¢˜ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Computational Complexity Theory**: <https://en.wikipedia.org/wiki/Computational_complexity_theory>
   - è®¡ç®—å¤æ‚åº¦ç†è®ºçš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»å¤æ‚åº¦ç±»çš„ç†è®ºåŸºç¡€ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

4. Complexity Zoo: <https://complexityzoo.net/>
   - å¤æ‚åº¦ç±»çš„ç»¼åˆæ•°æ®åº“ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

## ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### ç›¸å…³æ–‡æ¡£ / Related Documents

- `04-ç®—æ³•å¤æ‚åº¦/01-æ—¶é—´å¤æ‚åº¦.md` - æ—¶é—´å¤æ‚åº¦ï¼ˆå¤æ‚åº¦ç±»çš„åŸºç¡€ï¼‰
- `04-ç®—æ³•å¤æ‚åº¦/02-ç©ºé—´å¤æ‚åº¦.md` - ç©ºé—´å¤æ‚åº¦ï¼ˆç©ºé—´å¤æ‚åº¦ç±»ï¼‰
- `04-ç®—æ³•å¤æ‚åº¦/03-æ¸è¿›åˆ†æ.md` - æ¸è¿›åˆ†æï¼ˆå¤æ‚åº¦ç±»çš„åˆ†æå·¥å…·ï¼‰
- `04-ç®—æ³•å¤æ‚åº¦/05-é€šä¿¡å¤æ‚åº¦.md` - é€šä¿¡å¤æ‚åº¦ï¼ˆé€šä¿¡å¤æ‚åº¦ç±»ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/01-ç®—æ³•è®¾è®¡ç†è®º.md` - ç®—æ³•è®¾è®¡ç†è®ºï¼ˆå¤æ‚åº¦ç±»åœ¨ç®—æ³•è®¾è®¡ä¸­çš„åº”ç”¨ï¼‰
- ç›¸å…³å†…å®¹å·²æ•´åˆåˆ°æœ¬æ–‡æ¡£ï¼ˆåŸ `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§2.4, Â§5ï¼‰

### çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **04-ç®—æ³•å¤æ‚åº¦** æ¨¡å—ï¼Œæ˜¯ç®—æ³•å¤æ‚åº¦åˆ†ç±»çš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºç®—æ³•ç†è®ºæä¾›å¤æ‚åº¦ç±»åˆ†ç±»æ¡†æ¶ã€‚

### VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- ç›¸å…³å†…å®¹å·²æ•´åˆåˆ°æœ¬æ–‡æ¡£ï¼ˆåŸ `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§2.4, Â§5ï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£æä¾›äº†å¤æ‚åº¦ç±»çš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€å„ç±»å®šä¹‰ã€å®Œå…¨æ€§é—®é¢˜ã€å¤æ‚åº¦ç±»å…³ç³»ã€åº”ç”¨é¢†åŸŸå’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
