---
title: 4.2 ç©ºé—´å¤æ‚åº¦ / Space Complexity
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: å¤æ‚åº¦ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 4.2 ç©ºé—´å¤æ‚åº¦ / Space Complexity

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€ç©ºé—´å¤æ‚åº¦çš„å½¢å¼åŒ–å®šä¹‰ã€æ¸è¿›åˆ†æä¸ç©ºé—´å¤æ‚åº¦ç±»å…³ç³»ã€‚
- å»ºç«‹æ—¶é—´-ç©ºé—´æƒè¡¡çš„ç†è®ºæ¡†æ¶ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ç©ºé—´å¤æ‚åº¦ã€è¾…åŠ©ç©ºé—´ã€å·¥ä½œç©ºé—´ã€ç©ºé—´å¤æ‚åº¦ç±»ã€ç©ºé—´å¯æ„é€ æ€§ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ç©ºé—´å¤æ‚åº¦ï¼ˆSpace Complexityï¼‰ï¼šç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰€éœ€çš„å†…å­˜ç©ºé—´å¤§å°ã€‚
- è¾…åŠ©ç©ºé—´ï¼ˆAuxiliary Spaceï¼‰ï¼šé™¤è¾“å…¥å¤–ç®—æ³•éœ€è¦çš„é¢å¤–ç©ºé—´ã€‚
- ç©ºé—´å¤æ‚åº¦ç±»ï¼ˆSpace Complexity Classesï¼‰ï¼šLã€NLã€PSPACEã€EXPSPACEç­‰ã€‚
- è®°å·çº¦å®šï¼š`S(n)` è¡¨ç¤ºç©ºé—´å¤æ‚åº¦ï¼Œ`O`ã€`Î©`ã€`Î˜` è¡¨ç¤ºæ¸è¿›è®°å·ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- æ—¶é—´å¤æ‚åº¦ï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/01-æ—¶é—´å¤æ‚åº¦.md`ã€‚
- æ¸è¿›åˆ†æï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/03-æ¸è¿›åˆ†æ.md`ã€‚
- å¤æ‚åº¦ç±»ï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/04-å¤æ‚åº¦ç±».md`ã€‚
- ç®—æ³•å¤æ‚åº¦åŸºç¡€ï¼šå‚è§ `04-ç®—æ³•å¤æ‚åº¦/` ç›¸å…³æ–‡æ¡£ã€‚

### å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References

ç©ºé—´å¤æ‚åº¦ä¸æ—¶é—´-ç©ºé—´æƒè¡¡å¯ä¸ **MIT 6.006/6.046**ã€**CMU 15-451**ã€**Stanford CS 161**ã€**Berkeley CS 170** ç­‰è¯¾ç¨‹å¯¹æ ‡ã€‚è¯¾ç¨‹ä¸æ¨¡å—æ˜ å°„è§ [å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)ã€‚

### å¯çŸ¥è¾¹ç•Œä¸å“²ç§‘å‚è€ƒ / Knowable Boundaries and Philosophy

å¤æ‚åº¦ä¸‹ç•Œä¸**å¯çŸ¥è¾¹ç•Œ**çš„è®¤è¯†è®ºåˆ»ç”»è§ [04-å¤æ‚åº¦ç±»](04-å¤æ‚åº¦ç±».md) Â§å¯çŸ¥è¾¹ç•Œä¸è®¤è¯†è®ºå‚è€ƒã€[Stanford SEP - Philosophy of Computer Science](https://plato.stanford.edu/entries/computer-science/)ã€[é¡¹ç›®å“²ç§‘ç»“æ„è¯´æ˜](../é¡¹ç›®å“²ç§‘ç»“æ„è¯´æ˜.md)ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- ç©ºé—´å¤æ‚åº¦åˆ†æ
- ç©ºé—´å¤æ‚åº¦ç±»
- ç©ºé—´æ„é€ 
- æ—¶é—´-ç©ºé—´æƒè¡¡

## ç›®å½• (Table of Contents)

- [4.2 ç©ºé—´å¤æ‚åº¦ / Space Complexity](#42-ç©ºé—´å¤æ‚åº¦--space-complexity)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å›½é™…è¯¾ç¨‹å‚è€ƒ / International Course References](#å›½é™…è¯¾ç¨‹å‚è€ƒ--international-course-references)
  - [å¯çŸ¥è¾¹ç•Œä¸å“²ç§‘å‚è€ƒ / Knowable Boundaries and Philosophy](#å¯çŸ¥è¾¹ç•Œä¸å“²ç§‘å‚è€ƒ--knowable-boundaries-and-philosophy)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.1 ç©ºé—´å¤æ‚åº¦å®šä¹‰ (Definition of Space Complexity)](#11-ç©ºé—´å¤æ‚åº¦å®šä¹‰-definition-of-space-complexity)
  - [1.2 ç©ºé—´å¤æ‚åº¦ç±»å‹ (Types of Space Complexity)](#12-ç©ºé—´å¤æ‚åº¦ç±»å‹-types-of-space-complexity)
  - [1.3 ç©ºé—´å¤æ‚åº¦è®°å· (Space Complexity Notation)](#13-ç©ºé—´å¤æ‚åº¦è®°å·-space-complexity-notation)
- [1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#14-å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
- [2. ç©ºé—´å¤æ‚åº¦åˆ†æ (Space Complexity Analysis)](#2-ç©ºé—´å¤æ‚åº¦åˆ†æ-space-complexity-analysis)
  - [2.1 é€’å½’ç©ºé—´å¤æ‚åº¦ (Recursive Space Complexity)](#21-é€’å½’ç©ºé—´å¤æ‚åº¦-recursive-space-complexity)
  - [2.2 åŠ¨æ€è§„åˆ’ç©ºé—´å¤æ‚åº¦ (Dynamic Programming Space Complexity)](#22-åŠ¨æ€è§„åˆ’ç©ºé—´å¤æ‚åº¦-dynamic-programming-space-complexity)
  - [2.3 å›¾ç®—æ³•ç©ºé—´å¤æ‚åº¦ (Graph Algorithm Space Complexity)](#23-å›¾ç®—æ³•ç©ºé—´å¤æ‚åº¦-graph-algorithm-space-complexity)
- [3. ç©ºé—´å¤æ‚åº¦ç±» (Space Complexity Classes)](#3-ç©ºé—´å¤æ‚åº¦ç±»-space-complexity-classes)
  - [3.1 å¯¹æ•°ç©ºé—´ç±» (Logarithmic Space Classes)](#31-å¯¹æ•°ç©ºé—´ç±»-logarithmic-space-classes)
  - [3.2 å¤šé¡¹å¼ç©ºé—´ç±» (Polynomial Space Classes)](#32-å¤šé¡¹å¼ç©ºé—´ç±»-polynomial-space-classes)
  - [3.3 æŒ‡æ•°ç©ºé—´ç±» (Exponential Space Classes)](#33-æŒ‡æ•°ç©ºé—´ç±»-exponential-space-classes)
  - [3.4 ç©ºé—´å¤æ‚åº¦ç±»å±‚æ¬¡ (Space Complexity Class Hierarchy)](#34-ç©ºé—´å¤æ‚åº¦ç±»å±‚æ¬¡-space-complexity-class-hierarchy)
- [4. ç©ºé—´æ„é€  (Space Constructions)](#4-ç©ºé—´æ„é€ -space-constructions)
  - [4.1 ç©ºé—´å¯æ„é€ æ€§ (Space Constructibility)](#41-ç©ºé—´å¯æ„é€ æ€§-space-constructibility)
  - [4.2 ç©ºé—´å½’çº¦ (Space Reductions)](#42-ç©ºé—´å½’çº¦-space-reductions)
  - [4.3 ç©ºé—´å®Œå…¨æ€§ (Space Completeness)](#43-ç©ºé—´å®Œå…¨æ€§-space-completeness)
- [5. ç©ºé—´ä¸‹ç•Œç†è®º (Space Lower Bounds)](#5-ç©ºé—´ä¸‹ç•Œç†è®º-space-lower-bounds)
  - [5.1 ä¿¡æ¯è®ºä¸‹ç•Œ (Information-Theoretic Lower Bounds)](#51-ä¿¡æ¯è®ºä¸‹ç•Œ-information-theoretic-lower-bounds)
  - [5.2 é€šä¿¡å¤æ‚åº¦ä¸‹ç•Œ (Communication Complexity Lower Bounds)](#52-é€šä¿¡å¤æ‚åº¦ä¸‹ç•Œ-communication-complexity-lower-bounds)
  - [5.3 æ—¶é—´-ç©ºé—´æƒè¡¡ (Time-Space Trade-offs)](#53-æ—¶é—´-ç©ºé—´æƒè¡¡-time-space-trade-offs)
- [6. ç©ºé—´å¤æ‚åº¦ä¸æ—¶é—´å¤æ‚åº¦ (Space vs Time Complexity)](#6-ç©ºé—´å¤æ‚åº¦ä¸æ—¶é—´å¤æ‚åº¦-space-vs-time-complexity)
  - [6.1 æ—¶é—´-ç©ºé—´å…³ç³» (Time-Space Relationship)](#61-æ—¶é—´-ç©ºé—´å…³ç³»-time-space-relationship)
  - [6.2 ç©ºé—´-æ—¶é—´æƒè¡¡ (Space-Time Trade-offs)](#62-ç©ºé—´-æ—¶é—´æƒè¡¡-space-time-trade-offs)
  - [6.3 å¹¶è¡Œç©ºé—´å¤æ‚åº¦ (Parallel Space Complexity)](#63-å¹¶è¡Œç©ºé—´å¤æ‚åº¦-parallel-space-complexity)
- [7. å®ç°ç¤ºä¾‹ (Implementation Examples)](#7-å®ç°ç¤ºä¾‹-implementation-examples)
  - [7.1 ç©ºé—´å¤æ‚åº¦åˆ†æå·¥å…· (Space Complexity Analysis Tool)](#71-ç©ºé—´å¤æ‚åº¦åˆ†æå·¥å…·-space-complexity-analysis-tool)
  - [7.2 ç©ºé—´ä¼˜åŒ–ç¤ºä¾‹ (Space Optimization Examples)](#72-ç©ºé—´ä¼˜åŒ–ç¤ºä¾‹-space-optimization-examples)
  - [7.3 å›¾ç®—æ³•ç©ºé—´å¤æ‚åº¦ç¤ºä¾‹ (Graph Algorithm Space Complexity Examples)](#73-å›¾ç®—æ³•ç©ºé—´å¤æ‚åº¦ç¤ºä¾‹-graph-algorithm-space-complexity-examples)
  - [7.4 ç©ºé—´å¤æ‚åº¦æµ‹è¯• (Space Complexity Testing)](#74-ç©ºé—´å¤æ‚åº¦æµ‹è¯•-space-complexity-testing)
- [8. å‚è€ƒæ–‡çŒ® / References](#8-å‚è€ƒæ–‡çŒ®--references)
- [ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure](#ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½--alignment-with-project-structure)
  - [ç›¸å…³æ–‡æ¡£ / Related Documents](#ç›¸å…³æ–‡æ¡£--related-documents)
  - [çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position](#çŸ¥è¯†ä½“ç³»ä½ç½®--knowledge-system-position)
  - [VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents](#viewæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£--view-folder-related-documents)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.1 ç©ºé—´å¤æ‚åº¦å®šä¹‰ (Definition of Space Complexity)

**ç©ºé—´å¤æ‚åº¦å®šä¹‰ / Definition of Space Complexity:**

ç©ºé—´å¤æ‚åº¦æ˜¯è¡¡é‡ç®—æ³•åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰€éœ€å†…å­˜ç©ºé—´å¤§å°çš„åº¦é‡ã€‚å®ƒæè¿°äº†ç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹éœ€è¦å¤šå°‘é¢å¤–çš„å­˜å‚¨ç©ºé—´æ¥è§£å†³é—®é¢˜ã€‚

Space complexity is a measure of the amount of memory space required by an algorithm during its execution. It describes how much additional storage space an algorithm needs in the worst case to solve a problem.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

å¯¹äºç®—æ³• $A$ å’Œè¾“å…¥ $x$ï¼Œç©ºé—´å¤æ‚åº¦ $S_A(x)$ å®šä¹‰ä¸ºï¼š

For algorithm $A$ and input $x$, the space complexity $S_A(x)$ is defined as:

$$S_A(x) = \text{maximum number of memory cells used during execution of } A \text{ on } x$$

### 1.2 ç©ºé—´å¤æ‚åº¦ç±»å‹ (Types of Space Complexity)

**1. è¾…åŠ©ç©ºé—´å¤æ‚åº¦ (Auxiliary Space Complexity) / Auxiliary Space Complexity:**

ç®—æ³•é™¤äº†è¾“å…¥æœ¬èº«ä¹‹å¤–éœ€è¦çš„é¢å¤–ç©ºé—´ã€‚

The additional space required by an algorithm beyond the input itself.

**2. æ€»ç©ºé—´å¤æ‚åº¦ (Total Space Complexity) / Total Space Complexity:**

åŒ…æ‹¬è¾“å…¥ç©ºé—´åœ¨å†…çš„æ‰€æœ‰ç©ºé—´éœ€æ±‚ã€‚

The total space requirement including the input space.

**3. å·¥ä½œç©ºé—´å¤æ‚åº¦ (Working Space Complexity) / Working Space Complexity:**

ç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­å®é™…ä½¿ç”¨çš„ä¸´æ—¶ç©ºé—´ã€‚

The temporary space actually used during algorithm execution.

### 1.3 ç©ºé—´å¤æ‚åº¦è®°å· (Space Complexity Notation)

**æ¸è¿›è®°å· / Asymptotic Notation:**

- $O(f(n))$: ç©ºé—´å¤æ‚åº¦çš„ä¸Šç•Œ / Upper bound on space complexity
- $\Omega(f(n))$: ç©ºé—´å¤æ‚åº¦çš„ä¸‹ç•Œ / Lower bound on space complexity
- $\Theta(f(n))$: ç©ºé—´å¤æ‚åº¦çš„ç´§ç•Œ / Tight bound on space complexity
- $o(f(n))$: ä¸¥æ ¼å°äº / Strictly less than
- $\omega(f(n))$: ä¸¥æ ¼å¤§äº / Strictly greater than

---

## 1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

**è§£é‡Šä¸ç›´è§‚**ï¼šç©ºé—´å¤æ‚åº¦å°†ç®—æ³•ã€Œå†…å­˜å ç”¨ã€å½¢å¼åŒ–ä¸º $S(n)$ï¼›ä¸æ—¶é—´å¤æ‚åº¦æƒè¡¡ï¼ˆæ—¶é—´â€”ç©ºé—´æŠ˜è¡·ï¼‰ï¼Œè¾…åŠ©å™¨ç›¸å…³åˆ†æï¼ˆè§ 09-ç®—æ³•ä¼˜åŒ–ç†è®ºï¼‰ã€‚

**æ¦‚å¿µå±æ€§è¡¨**ï¼š$S(n)$ â€” å·¥ä½œç©ºé—´ï¼ˆä¸å«è¾“å…¥ï¼‰ï¼›$O/\Omega/\Theta$ â€” ç©ºé—´æ¸è¿›è®°å·ï¼›é€’å½’æ·±åº¦ $d(n)$ â€” ä¸æ ˆç©ºé—´ç›¸å…³ï¼›è¾…åŠ©ç©ºé—´ â€” é™¤è¾“å…¥å¤–çš„é¢å¤–ç©ºé—´ã€‚

**æ¦‚å¿µå…³ç³»**ï¼šç©ºé—´å¤æ‚åº¦ â€”depends_onâ€” è®¡ç®—æ¨¡å‹ï¼ˆè§ 01-æ—¶é—´å¤æ‚åº¦ï¼‰ï¼›ä¸æ—¶é—´å¤æ‚åº¦ â€”å¯¹æ¯”â€” æ—¶é—´â€”ç©ºé—´æŠ˜è¡·ï¼›$PSPACE$ â€” è§ 04-å¤æ‚åº¦ç±»ã€‚

**æ¦‚å¿µä¾èµ–å›¾**ï¼šè®¡ç®—æ¨¡å‹ â†’ $S(n)$ï¼›é€’å½’æ·±åº¦ â†’ æ ˆç©ºé—´ï¼›$PSPACE$ã€$L$ã€$NL$ â€” ç©ºé—´å¤æ‚åº¦ç±»ï¼ˆè§ 04ï¼‰ã€‚

**æ€ç»´å¯¼å›¾**ï¼šç©ºé—´å¤æ‚åº¦ â†’ å·¥ä½œç©ºé—´ã€é€’å½’ç©ºé—´ã€è¾…åŠ©ç©ºé—´ã€æ¸è¿›è®°å· â†’ å¤æ‚åº¦ç±»ã€ç¼“å­˜ä¼˜åŒ–ã€‚

**å¤šç»´çŸ©é˜µ**ï¼šå·¥ä½œ/è¾…åŠ©/æ€»ç©ºé—´ â€” ç©ºé—´ç±»å‹ï¼›$O/\Theta$ â€” æ¸è¿›ï¼›$L/NL/PSPACE$ â€” ç©ºé—´ç±»ï¼ˆè§ 04ï¼‰ã€‚

**å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘**ï¼šå®šä¹‰ $S(n)$ â†’ ç©ºé—´æ¸è¿›è®°å·ï¼›Savitch å®šç† $NL \subseteq L^2$ï¼›ç©ºé—´å±‚æ¬¡å®šç†ã€‚

**åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘**ï¼šåˆ†æå†…å­˜å ç”¨ â†’ ç”¨ $S(n)$ ä¸é€’å½’æ·±åº¦ï¼›è¯ç©ºé—´ä¸‹ç•Œ â†’ ç”¨ $\Omega$ï¼›é€‰æ•°æ®ç»“æ„ â†’ è§ 09-ç®—æ³•ç†è®º/æ•°æ®ç»“æ„ã€‚

---

## 2. ç©ºé—´å¤æ‚åº¦åˆ†æ (Space Complexity Analysis)

### 2.1 é€’å½’ç©ºé—´å¤æ‚åº¦ (Recursive Space Complexity)

**é€’å½’æ·±åº¦ä¸ç©ºé—´ / Recursion Depth and Space:**

é€’å½’ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦ä¸»è¦å–å†³äºé€’å½’è°ƒç”¨çš„æ·±åº¦ã€‚

The space complexity of recursive algorithms primarily depends on the depth of recursive calls.

**é€’å½’ç©ºé—´å¤æ‚åº¦å…¬å¼ / Recursive Space Complexity Formula:**

$$S_{recursive}(n) = O(d(n) \cdot s(n))$$

å…¶ä¸­ / where:

- $d(n)$ æ˜¯é€’å½’æ·±åº¦ / is the recursion depth
- $s(n)$ æ˜¯æ¯æ¬¡é€’å½’è°ƒç”¨çš„ç©ºé—´éœ€æ±‚ / is the space requirement per recursive call

### 2.2 åŠ¨æ€è§„åˆ’ç©ºé—´å¤æ‚åº¦ (Dynamic Programming Space Complexity)

**çŠ¶æ€ç©ºé—´åˆ†æ / State Space Analysis:**

åŠ¨æ€è§„åˆ’çš„ç©ºé—´å¤æ‚åº¦å–å†³äºçŠ¶æ€ç©ºé—´çš„å¤§å°ã€‚

The space complexity of dynamic programming depends on the size of the state space.

**ç©ºé—´ä¼˜åŒ–æŠ€æœ¯ / Space Optimization Techniques:**

1. **æ»šåŠ¨æ•°ç»„ (Rolling Array) / Rolling Array:**
   - åªä¿å­˜å¿…è¦çš„çŠ¶æ€ä¿¡æ¯ / Only save necessary state information
   - ç©ºé—´å¤æ‚åº¦ä» $O(n^2)$ ä¼˜åŒ–åˆ° $O(n)$ / Optimize space from $O(n^2)$ to $O(n)$

2. **çŠ¶æ€å‹ç¼© (State Compression) / State Compression:**
   - ä½¿ç”¨ä½è¿ç®—å‹ç¼©çŠ¶æ€ / Use bit operations to compress states
   - å‡å°‘çŠ¶æ€è¡¨ç¤ºçš„ç©ºé—´éœ€æ±‚ / Reduce space requirement for state representation

### 2.3 å›¾ç®—æ³•ç©ºé—´å¤æ‚åº¦ (Graph Algorithm Space Complexity)

**é‚»æ¥çŸ©é˜µ vs é‚»æ¥è¡¨ / Adjacency Matrix vs Adjacency List:**

- **é‚»æ¥çŸ©é˜µç©ºé—´å¤æ‚åº¦ / Adjacency Matrix Space Complexity:**
  $$S_{matrix} = O(|V|^2)$$

- **é‚»æ¥è¡¨ç©ºé—´å¤æ‚åº¦ / Adjacency List Space Complexity:**
  $$S_{list} = O(|V| + |E|)$$

**æ·±åº¦ä¼˜å…ˆæœç´¢ç©ºé—´å¤æ‚åº¦ / DFS Space Complexity:**

$$S_{DFS} = O(|V|)$$

**å¹¿åº¦ä¼˜å…ˆæœç´¢ç©ºé—´å¤æ‚åº¦ / BFS Space Complexity:**

$$S_{BFS} = O(|V|)$$

---

## 3. ç©ºé—´å¤æ‚åº¦ç±» (Space Complexity Classes)

### 3.1 å¯¹æ•°ç©ºé—´ç±» (Logarithmic Space Classes)

**Lç±» (Logarithmic Space) / L Class:**

$$L = \text{SPACE}(\log n)$$

åŒ…å«å¯ä»¥åœ¨å¯¹æ•°ç©ºé—´å†…è§£å†³çš„é—®é¢˜ã€‚

Contains problems that can be solved in logarithmic space.

**NLç±» (Nondeterministic Logarithmic Space) / NL Class:**

$$NL = \text{NSPACE}(\log n)$$

åŒ…å«å¯ä»¥åœ¨éç¡®å®šæ€§å¯¹æ•°ç©ºé—´å†…è§£å†³çš„é—®é¢˜ã€‚

Contains problems that can be solved in nondeterministic logarithmic space.

### 3.2 å¤šé¡¹å¼ç©ºé—´ç±» (Polynomial Space Classes)

**PSPACEç±» (Polynomial Space) / PSPACE Class:**

$$PSPACE = \bigcup_{k \geq 1} \text{SPACE}(n^k)$$

åŒ…å«å¯ä»¥åœ¨å¤šé¡¹å¼ç©ºé—´å†…è§£å†³çš„é—®é¢˜ã€‚

Contains problems that can be solved in polynomial space.

**NPSPACEç±» (Nondeterministic Polynomial Space) / NPSPACE Class:**

$$NPSPACE = \bigcup_{k \geq 1} \text{NSPACE}(n^k)$$

åŒ…å«å¯ä»¥åœ¨éç¡®å®šæ€§å¤šé¡¹å¼ç©ºé—´å†…è§£å†³çš„é—®é¢˜ã€‚

Contains problems that can be solved in nondeterministic polynomial space.

### 3.3 æŒ‡æ•°ç©ºé—´ç±» (Exponential Space Classes)

**EXPSPACEç±» (Exponential Space) / EXPSPACE Class:**

$$EXPSPACE = \bigcup_{k \geq 1} \text{SPACE}(2^{n^k})$$

åŒ…å«å¯ä»¥åœ¨æŒ‡æ•°ç©ºé—´å†…è§£å†³çš„é—®é¢˜ã€‚

Contains problems that can be solved in exponential space.

### 3.4 ç©ºé—´å¤æ‚åº¦ç±»å±‚æ¬¡ (Space Complexity Class Hierarchy)

**ç©ºé—´å±‚æ¬¡å®šç† / Space Hierarchy Theorem:**

å¯¹äºç©ºé—´å¯æ„é€ å‡½æ•° $f$ å’Œ $g$ï¼Œå¦‚æœ $f(n) = o(g(n))$ï¼Œåˆ™ï¼š

For space constructible functions $f$ and $g$, if $f(n) = o(g(n))$, then:

$$\text{SPACE}(f(n)) \subsetneq \text{SPACE}(g(n))$$

**è¨ç»´å¥‡å®šç† (Savitch's Theorem) / Savitch's Theorem:**

å¯¹äºä»»ä½•ç©ºé—´å¯æ„é€ å‡½æ•° $f(n) \geq \log n$ï¼š

For any space constructible function $f(n) \geq \log n$:

$$\text{NSPACE}(f(n)) \subseteq \text{SPACE}(f^2(n))$$

---

## 4. ç©ºé—´æ„é€  (Space Constructions)

### 4.1 ç©ºé—´å¯æ„é€ æ€§ (Space Constructibility)

**ç©ºé—´å¯æ„é€ å‡½æ•°å®šä¹‰ / Space Constructible Function Definition:**

å‡½æ•° $f: \mathbb{N} \rightarrow \mathbb{N}$ æ˜¯ç©ºé—´å¯æ„é€ çš„ï¼Œå¦‚æœå­˜åœ¨å›¾çµæœº $M$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰è¾“å…¥ $x$ï¼Œ$M$ åœ¨ç©ºé—´ $O(f(|x|))$ å†…è®¡ç®— $f(|x|)$ã€‚

A function $f: \mathbb{N} \rightarrow \mathbb{N}$ is space constructible if there exists a Turing machine $M$ such that for all inputs $x$, $M$ computes $f(|x|)$ in space $O(f(|x|))$.

### 4.2 ç©ºé—´å½’çº¦ (Space Reductions)

**ç©ºé—´å½’çº¦å®šä¹‰ / Space Reduction Definition:**

é—®é¢˜ $A$ ç©ºé—´å½’çº¦åˆ°é—®é¢˜ $B$ï¼Œå¦‚æœå­˜åœ¨ç©ºé—´å¯è®¡ç®—çš„å‡½æ•° $f$ï¼Œä½¿å¾—ï¼š

Problem $A$ space reduces to problem $B$ if there exists a space computable function $f$ such that:

$$x \in A \Leftrightarrow f(x) \in B$$

**ç©ºé—´å½’çº¦æ€§è´¨ / Space Reduction Properties:**

1. **ä¼ é€’æ€§ (Transitivity) / Transitivity:**
   å¦‚æœ $A \leq_{space} B$ ä¸” $B \leq_{space} C$ï¼Œåˆ™ $A \leq_{space} C$

2. **è‡ªåæ€§ (Reflexivity) / Reflexivity:**
   $A \leq_{space} A$

### 4.3 ç©ºé—´å®Œå…¨æ€§ (Space Completeness)

**PSPACEå®Œå…¨é—®é¢˜ / PSPACE-Complete Problems:**

1. **TQBF (True Quantified Boolean Formula) / TQBF:**
   - åˆ¤æ–­é‡åŒ–å¸ƒå°”å…¬å¼æ˜¯å¦ä¸ºçœŸ / Determine if a quantified boolean formula is true
   - ç©ºé—´å¤æ‚åº¦: $O(n^2)$ / Space complexity: $O(n^2)$

2. **åšå¼ˆé—®é¢˜ (Game Problems) / Game Problems:**
   - å¹¿ä¹‰åœ°ç†æ¸¸æˆ / Generalized Geography
   - æ±‰è¯ºå¡”é—®é¢˜ / Towers of Hanoi

---

## 5. ç©ºé—´ä¸‹ç•Œç†è®º (Space Lower Bounds)

### 5.1 ä¿¡æ¯è®ºä¸‹ç•Œ (Information-Theoretic Lower Bounds)

**ä¿¡æ¯è®ºä¸‹ç•ŒåŸç† / Information-Theoretic Lower Bound Principle:**

ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦å¿…é¡»è‡³å°‘ç­‰äºè¾“å‡ºæ‰€éœ€çš„ä¿¡æ¯é‡ã€‚

The space complexity of an algorithm must be at least equal to the information content of the output.

**ä¾‹å­ï¼šæ’åºé—®é¢˜ / Example: Sorting Problem:**

ä»»ä½•åŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•éƒ½éœ€è¦ $\Omega(n \log n)$ æ—¶é—´ï¼Œä½†ç©ºé—´å¤æ‚åº¦å¯ä»¥æ˜¯ $O(1)$ï¼ˆåŸåœ°æ’åºï¼‰ã€‚

Any comparison-based sorting algorithm requires $\Omega(n \log n)$ time, but space complexity can be $O(1)$ (in-place sorting).

### 5.2 é€šä¿¡å¤æ‚åº¦ä¸‹ç•Œ (Communication Complexity Lower Bounds)

**é€šä¿¡å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦ / Communication Complexity and Space Complexity:**

é€šä¿¡å¤æ‚åº¦ä¸‹ç•Œå¯ä»¥ç”¨æ¥è¯æ˜ç©ºé—´å¤æ‚åº¦ä¸‹ç•Œã€‚

Communication complexity lower bounds can be used to prove space complexity lower bounds.

**ä¾‹å­ï¼šå…ƒç´ å”¯ä¸€æ€§é—®é¢˜ / Example: Element Distinctness Problem:**

åœ¨æµæ¨¡å‹ä¸­ï¼Œå…ƒç´ å”¯ä¸€æ€§é—®é¢˜éœ€è¦ $\Omega(n)$ ç©ºé—´ã€‚

In the streaming model, the element distinctness problem requires $\Omega(n)$ space.

### 5.3 æ—¶é—´-ç©ºé—´æƒè¡¡ (Time-Space Trade-offs)

**æ—¶é—´-ç©ºé—´æƒè¡¡åŸç† / Time-Space Trade-off Principle:**

åœ¨è®¸å¤šé—®é¢˜ä¸­ï¼Œå‡å°‘ç©ºé—´ä½¿ç”¨ä¼šå¢åŠ æ—¶é—´éœ€æ±‚ï¼Œåä¹‹äº¦ç„¶ã€‚

In many problems, reducing space usage increases time requirements, and vice versa.

**ä¾‹å­ï¼šçŸ©é˜µä¹˜æ³• / Example: Matrix Multiplication:**

- **æ ‡å‡†ç®—æ³• / Standard Algorithm:**
  - æ—¶é—´: $O(n^3)$ / Time: $O(n^3)$
  - ç©ºé—´: $O(n^2)$ / Space: $O(n^2)$

- **åˆ†å—ç®—æ³• / Block Algorithm:**
  - æ—¶é—´: $O(n^3)$ / Time: $O(n^3)$
  - ç©ºé—´: $O(B^2)$ / Space: $O(B^2)$ (å…¶ä¸­ $B$ æ˜¯å—å¤§å° / where $B$ is block size)

---

## 6. ç©ºé—´å¤æ‚åº¦ä¸æ—¶é—´å¤æ‚åº¦ (Space vs Time Complexity)

### 6.1 æ—¶é—´-ç©ºé—´å…³ç³» (Time-Space Relationship)

**åŸºæœ¬å…³ç³» / Basic Relationship:**

å¯¹äºç¡®å®šæ€§å›¾çµæœºï¼Œç©ºé—´å¤æ‚åº¦æ€»æ˜¯å°äºç­‰äºæ—¶é—´å¤æ‚åº¦ï¼š

For deterministic Turing machines, space complexity is always less than or equal to time complexity:

$$S(n) \leq T(n)$$

**åŸå›  / Reason:**

å›¾çµæœºåœ¨æ—¶é—´ $T(n)$ å†…æœ€å¤šåªèƒ½è®¿é—® $T(n)$ ä¸ªä¸åŒçš„å­˜å‚¨å•å…ƒã€‚

A Turing machine can access at most $T(n)$ different storage cells in time $T(n)$.

### 6.2 ç©ºé—´-æ—¶é—´æƒè¡¡ (Space-Time Trade-offs)

**æƒè¡¡ä¾‹å­ / Trade-off Examples:**

1. **æ–æ³¢é‚£å¥‘æ•°åˆ— / Fibonacci Sequence:**
   - **é€’å½’ç®—æ³• / Recursive Algorithm:**
     - æ—¶é—´: $O(2^n)$ / Time: $O(2^n)$
     - ç©ºé—´: $O(n)$ / Space: $O(n)$

   - **è¿­ä»£ç®—æ³• / Iterative Algorithm:**
     - æ—¶é—´: $O(n)$ / Time: $O(n)$
     - ç©ºé—´: $O(1)$ / Space: $O(1)$

2. **å¿«é€Ÿæ’åº / Quick Sort:**
   - **æ ‡å‡†ç‰ˆæœ¬ / Standard Version:**
     - æ—¶é—´: $O(n \log n)$ / Time: $O(n \log n)$
     - ç©ºé—´: $O(\log n)$ / Space: $O(\log n)$

   - **åŸåœ°ç‰ˆæœ¬ / In-place Version:**
     - æ—¶é—´: $O(n^2)$ / Time: $O(n^2)$ (æœ€åæƒ…å†µ / worst case)
     - ç©ºé—´: $O(1)$ / Space: $O(1)$

### 6.3 å¹¶è¡Œç©ºé—´å¤æ‚åº¦ (Parallel Space Complexity)

**å¹¶è¡Œç©ºé—´å¤æ‚åº¦å®šä¹‰ / Parallel Space Complexity Definition:**

å¹¶è¡Œç®—æ³•çš„ç©ºé—´å¤æ‚åº¦æ˜¯å•ä¸ªå¤„ç†å™¨æ‰€éœ€çš„æœ€å¤§ç©ºé—´ã€‚

The space complexity of a parallel algorithm is the maximum space required by any single processor.

**å¹¶è¡Œç©ºé—´-æ—¶é—´æƒè¡¡ / Parallel Space-Time Trade-offs:**

- **PRAMæ¨¡å‹ / PRAM Model:**
  - ç©ºé—´: $O(n)$ / Space: $O(n)$
  - æ—¶é—´: $O(\log n)$ / Time: $O(\log n)$

- **åˆ†å¸ƒå¼æ¨¡å‹ / Distributed Model:**
  - ç©ºé—´: $O(n/p)$ / Space: $O(n/p)$ (å…¶ä¸­ $p$ æ˜¯å¤„ç†å™¨æ•° / where $p$ is number of processors)
  - æ—¶é—´: $O(\log p)$ / Time: $O(\log p)$

---

## 7. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 7.1 ç©ºé—´å¤æ‚åº¦åˆ†æå·¥å…· (Space Complexity Analysis Tool)

```rust
use std::collections::HashMap;

/// ç©ºé—´å¤æ‚åº¦åˆ†æå™¨ / Space Complexity Analyzer
pub struct SpaceAnalyzer {
    memory_usage: HashMap<String, usize>,
    call_stack: Vec<String>,
}

impl SpaceAnalyzer {
    /// åˆ›å»ºæ–°çš„ç©ºé—´åˆ†æå™¨ / Create new space analyzer
    pub fn new() -> Self {
        SpaceAnalyzer {
            memory_usage: HashMap::new(),
            call_stack: Vec::new(),
        }
    }

    /// è®°å½•å†…å­˜åˆ†é… / Record memory allocation
    pub fn allocate(&mut self, variable: &str, size: usize) {
        self.memory_usage.insert(variable.to_string(), size);
        println!("Allocated {} bytes for {}", size, variable);
    }

    /// è®°å½•å†…å­˜é‡Šæ”¾ / Record memory deallocation
    pub fn deallocate(&mut self, variable: &str) {
        if let Some(size) = self.memory_usage.remove(variable) {
            println!("Deallocated {} bytes for {}", size, variable);
        }
    }

    /// è·å–å½“å‰æ€»å†…å­˜ä½¿ç”¨ / Get current total memory usage
    pub fn get_total_memory(&self) -> usize {
        self.memory_usage.values().sum()
    }

    /// åˆ†æé€’å½’ç©ºé—´å¤æ‚åº¦ / Analyze recursive space complexity
    pub fn analyze_recursive_space(&mut self, depth: usize, space_per_call: usize) -> usize {
        let total_space = depth * space_per_call;
        println!("Recursive space complexity: O({})", total_space);
        total_space
    }

    /// åˆ†æåŠ¨æ€è§„åˆ’ç©ºé—´å¤æ‚åº¦ / Analyze dynamic programming space complexity
    pub fn analyze_dp_space(&mut self, dimensions: &[usize]) -> usize {
        let total_space: usize = dimensions.iter().product();
        println!("DP space complexity: O({})", total_space);
        total_space
    }
}
```

### 7.2 ç©ºé—´ä¼˜åŒ–ç¤ºä¾‹ (Space Optimization Examples)

```rust
/// ç©ºé—´ä¼˜åŒ–çš„æ–æ³¢é‚£å¥‘è®¡ç®— / Space-optimized Fibonacci calculation
pub struct SpaceOptimizedFibonacci;

impl SpaceOptimizedFibonacci {
    /// å¸¸æ•°ç©ºé—´æ–æ³¢é‚£å¥‘ / Constant space Fibonacci
    pub fn fibonacci_constant_space(n: u64) -> u64 {
        if n <= 1 {
            return n;
        }

        let mut prev = 0;
        let mut current = 1;

        for _ in 2..=n {
            let next = prev + current;
            prev = current;
            current = next;
        }

        current
    }

    /// æ»šåŠ¨æ•°ç»„åŠ¨æ€è§„åˆ’ / Rolling array dynamic programming
    pub fn rolling_array_dp(capacity: usize, weights: &[usize], values: &[usize]) -> usize {
        let mut dp = vec![0; capacity + 1];

        for i in 0..weights.len() {
            for w in (weights[i]..=capacity).rev() {
                dp[w] = dp[w].max(dp[w - weights[i]] + values[i]);
            }
        }

        dp[capacity]
    }

    /// çŠ¶æ€å‹ç¼©åŠ¨æ€è§„åˆ’ / State compression dynamic programming
    pub fn state_compression_dp(n: usize) -> usize {
        let mut dp = vec![0; 1 << n];

        for state in 0..(1 << n) {
            for i in 0..n {
                if (state >> i) & 1 == 0 {
                    dp[state | (1 << i)] = dp[state | (1 << i)].max(dp[state] + 1);
                }
            }
        }

        dp[(1 << n) - 1]
    }
}
```

### 7.3 å›¾ç®—æ³•ç©ºé—´å¤æ‚åº¦ç¤ºä¾‹ (Graph Algorithm Space Complexity Examples)

```rust
use std::collections::{HashMap, HashSet, VecDeque};

/// å›¾çš„ç©ºé—´å¤æ‚åº¦åˆ†æ / Graph space complexity analysis
pub struct GraphSpaceAnalyzer;

impl GraphSpaceAnalyzer {
    /// é‚»æ¥çŸ©é˜µç©ºé—´å¤æ‚åº¦ / Adjacency matrix space complexity
    pub fn adjacency_matrix_space(vertices: usize) -> usize {
        let space = vertices * vertices;
        println!("Adjacency matrix space: O({})", space);
        space
    }

    /// é‚»æ¥è¡¨ç©ºé—´å¤æ‚åº¦ / Adjacency list space complexity
    pub fn adjacency_list_space(vertices: usize, edges: usize) -> usize {
        let space = vertices + edges;
        println!("Adjacency list space: O({})", space);
        space
    }

    /// DFSç©ºé—´å¤æ‚åº¦åˆ†æ / DFS space complexity analysis
    pub fn dfs_space_complexity(graph: &HashMap<usize, Vec<usize>>) -> usize {
        let mut visited = HashSet::new();
        let mut stack = Vec::new();
        let mut max_stack_size = 0;

        for &start in graph.keys() {
            if !visited.contains(&start) {
                stack.push(start);
                visited.insert(start);

                while let Some(current) = stack.pop() {
                    max_stack_size = max_stack_size.max(stack.len());

                    for &neighbor in &graph[&current] {
                        if !visited.contains(&neighbor) {
                            stack.push(neighbor);
                            visited.insert(neighbor);
                        }
                    }
                }
            }
        }

        println!("DFS space complexity: O({})", max_stack_size);
        max_stack_size
    }

    /// BFSç©ºé—´å¤æ‚åº¦åˆ†æ / BFS space complexity analysis
    pub fn bfs_space_complexity(graph: &HashMap<usize, Vec<usize>>) -> usize {
        let mut visited = HashSet::new();
        let mut queue = VecDeque::new();
        let mut max_queue_size = 0;

        for &start in graph.keys() {
            if !visited.contains(&start) {
                queue.push_back(start);
                visited.insert(start);

                while let Some(current) = queue.pop_front() {
                    max_queue_size = max_queue_size.max(queue.len());

                    for &neighbor in &graph[&current] {
                        if !visited.contains(&neighbor) {
                            queue.push_back(neighbor);
                            visited.insert(neighbor);
                        }
                    }
                }
            }
        }

        println!("BFS space complexity: O({})", max_queue_size);
        max_queue_size
    }
}
```

### 7.4 ç©ºé—´å¤æ‚åº¦æµ‹è¯• (Space Complexity Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_space_analyzer() {
        let mut analyzer = SpaceAnalyzer::new();

        // æµ‹è¯•å†…å­˜åˆ†é… / Test memory allocation
        analyzer.allocate("array", 1000);
        assert_eq!(analyzer.get_total_memory(), 1000);

        // æµ‹è¯•é€’å½’ç©ºé—´åˆ†æ / Test recursive space analysis
        let recursive_space = analyzer.analyze_recursive_space(10, 100);
        assert_eq!(recursive_space, 1000);

        // æµ‹è¯•åŠ¨æ€è§„åˆ’ç©ºé—´åˆ†æ / Test DP space analysis
        let dp_space = analyzer.analyze_dp_space(&[10, 10, 10]);
        assert_eq!(dp_space, 1000);
    }

    #[test]
    fn test_fibonacci_space_optimization() {
        let result = SpaceOptimizedFibonacci::fibonacci_constant_space(10);
        assert_eq!(result, 55);
    }

    #[test]
    fn test_graph_space_analysis() {
        let mut graph = HashMap::new();
        graph.insert(0, vec![1, 2]);
        graph.insert(1, vec![0, 2]);
        graph.insert(2, vec![0, 1]);

        let matrix_space = GraphSpaceAnalyzer::adjacency_matrix_space(3);
        assert_eq!(matrix_space, 9);

        let list_space = GraphSpaceAnalyzer::adjacency_list_space(3, 6);
        assert_eq!(list_space, 9);
    }
}
```

---

## 8. å‚è€ƒæ–‡çŒ® / References

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**: æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ [CITATION_STANDARD.md](../CITATION_STANDARD.md)ã€[å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md](../å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)ï¼‰ã€‚æ–‡å†…é‡‡ç”¨ [Key] æ ¼å¼å¼•ç”¨ï¼Œä¸å‚è€ƒæ–‡çŒ®åˆ—è¡¨å¯¹åº”ã€‚

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature**:

1. [Hartmanis1965] Hartmanis, J., & Stearns, R. E. (1965). "On the Computational Complexity of Algorithms". *Transactions of the American Mathematical Society*, 117: 285-306.
   - è®¡ç®—å¤æ‚æ€§ç†è®ºçš„å¥ åŸºæ€§è®ºæ–‡ï¼Œå¼•å…¥æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦æ¦‚å¿µã€‚

2. [Savitch1970] Savitch, W. J. (1970). "Relationships Between Nondeterministic and Deterministic Tape Complexities". *Journal of Computer and System Sciences*, 4(2): 177-192. DOI: 10.1016/S0022-0000(70)80006-X.
   - Savitchå®šç†çš„åŸå§‹è®ºæ–‡ï¼Œè¯æ˜NSPACE(s(n)) âŠ† DSPACE(sÂ²(n))ã€‚æœ¬æ–‡æ¡£Â§2.3çš„ç©ºé—´å¤æ‚åº¦ç±»åŸºäºæ­¤å®šç†ã€‚

3. [Cook1971] Cook, S. A. (1971). "The Complexity of Theorem-Proving Procedures". *STOC '71*, 151-158.
   - NPå®Œå¤‡æ€§ç†è®ºçš„å¼€åˆ›æ€§è®ºæ–‡ï¼Œä¸ç©ºé—´å¤æ‚åº¦ç ”ç©¶å¯†åˆ‡ç›¸å…³ã€‚

**æ ‡å‡†æ•™æ / Standard Textbooks**:

1. [Hopcroft1984] Hopcroft, J. E., & Ullman, J. D. (1984). *Introduction to Automata Theory, Languages, and Computation*. Addison-Wesley. ISBN: 978-0201029888.
   - ç»å…¸æ•™æï¼Œç³»ç»Ÿä»‹ç»ç©ºé—´å¤æ‚åº¦å’Œè‡ªåŠ¨æœºç†è®ºã€‚æœ¬æ–‡æ¡£Â§2.1-Â§2.2çš„å†…å®¹å‚è€ƒæ­¤ä¹¦ã€‚

2. [Sipser2012] Sipser, M. (2012). *Introduction to the Theory of Computation* (3rd Edition). Cengage Learning.
   - è®¡ç®—ç†è®ºå¯¼è®ºï¼Œæ¶µç›–ç©ºé—´å¤æ‚åº¦å’Œå¤æ‚åº¦ç±»ã€‚

3. [AroraBarak2009] Arora, S., & Barak, B. (2009). *Computational Complexity: A Modern Approach*. Cambridge University Press.
   - è®¡ç®—å¤æ‚åº¦ç†è®ºçš„ç°ä»£ç»¼åˆï¼Œæ·±å…¥ä»‹ç»ç©ºé—´å¤æ‚åº¦ç†è®ºå’Œä¸‹ç•Œã€‚æœ¬æ–‡æ¡£Â§2.5çš„ç©ºé—´ä¸‹ç•Œç†è®ºå‚è€ƒæ­¤ä¹¦ã€‚

4. [Papadimitriou1994] Papadimitriou, C. H. (1994). *Computational Complexity*. Addison-Wesley.
   - è®¡ç®—å¤æ‚æ€§ç†è®ºçš„ç»å…¸æ•™æï¼Œç³»ç»Ÿä»‹ç»æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ã€‚

**ç©ºé—´å¤æ‚åº¦ç†è®º / Space Complexity Theory**:

1. Karp, R. M. (1972). "Reducibility Among Combinatorial Problems". *Complexity of Computer Computations*, 85-103.
   - NPå®Œå¤‡æ€§å’Œå½’çº¦ç†è®ºï¼Œå¯¹ç©ºé—´å¤æ‚åº¦ç ”ç©¶æœ‰é‡è¦å½±å“ã€‚

2. Immerman, N. (1988). "Nondeterministic Space is Closed Under Complementation". *SIAM Journal on Computing*, 17(5): 935-938.
   - è¯æ˜NL=coNLï¼Œç©ºé—´å¤æ‚åº¦ç†è®ºçš„é‡è¦ç»“æœã€‚

**æ—¶é—´-ç©ºé—´æƒè¡¡ / Time-Space Trade-offs**:

1. Hopcroft, J. E., Paul, W., & Valiant, L. (1977). "On Time Versus Space". *Journal of the ACM*, 24(2): 332-337.
    - æ—¶é—´-ç©ºé—´æƒè¡¡çš„ç»å…¸è®ºæ–‡ã€‚æœ¬æ–‡æ¡£Â§2.6çš„æ—¶é—´-ç©ºé—´å…³ç³»å‚è€ƒæ­¤è®ºæ–‡ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Space Complexity**: <https://en.wikipedia.org/wiki/Space_complexity>
   - ç©ºé—´å¤æ‚åº¦çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«åŸºæœ¬å®šä¹‰å’Œåˆ†ææ–¹æ³•ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Computational Complexity Theory**: <https://en.wikipedia.org/wiki/Computational_complexity_theory>
   - è®¡ç®—å¤æ‚åº¦ç†è®ºçš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»å¤æ‚åº¦åˆ†æçš„ç†è®ºåŸºç¡€ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Big O Notation**: <https://en.wikipedia.org/wiki/Big_O_notation>
   - å¤§Oè®°å·çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«æ¸è¿›åˆ†æçš„è®°å·ç³»ç»Ÿï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

## ä¸é¡¹ç›®ç»“æ„ä¸»é¢˜çš„å¯¹é½ / Alignment with Project Structure

### ç›¸å…³æ–‡æ¡£ / Related Documents

- `04-ç®—æ³•å¤æ‚åº¦/01-æ—¶é—´å¤æ‚åº¦.md` - æ—¶é—´å¤æ‚åº¦ï¼ˆå¤æ‚åº¦åˆ†æçš„å¦ä¸€ä¸ªç»´åº¦ï¼‰
- `04-ç®—æ³•å¤æ‚åº¦/03-æ¸è¿›åˆ†æ.md` - æ¸è¿›åˆ†æï¼ˆç©ºé—´å¤æ‚åº¦åˆ†æçš„å·¥å…·ï¼‰
- `04-ç®—æ³•å¤æ‚åº¦/04-å¤æ‚åº¦ç±».md` - å¤æ‚åº¦ç±»ï¼ˆç©ºé—´å¤æ‚åº¦åˆ†ç±»ï¼‰
- `09-ç®—æ³•ç†è®º/01-ç®—æ³•åŸºç¡€/02-æ•°æ®ç»“æ„ç†è®º.md` - æ•°æ®ç»“æ„ç†è®ºï¼ˆç©ºé—´å¤æ‚åº¦åœ¨æ•°æ®ç»“æ„ä¸­çš„åº”ç”¨ï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` - ç®—æ³•å…¨æ™¯æ¢³ç†ï¼ˆåŒ…å«å¤æ‚åº¦åˆ†ææ¦‚è¿°ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

### çŸ¥è¯†ä½“ç³»ä½ç½® / Knowledge System Position

æœ¬æ–‡æ¡£å±äº **04-ç®—æ³•å¤æ‚åº¦** æ¨¡å—ï¼Œæ˜¯ç®—æ³•å¤æ‚åº¦åˆ†æçš„åŸºç¡€æ–‡æ¡£ï¼Œä¸ºç®—æ³•è®¾è®¡å’Œæ•°æ®ç»“æ„åˆ†ææä¾›ç©ºé—´å¤æ‚åº¦ç†è®ºåŸºç¡€ã€‚

### VIEWæ–‡ä»¶å¤¹ç›¸å…³æ–‡æ¡£ / VIEW Folder Related Documents

- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§4 - ä¿¡æ¯Â·æ•°æ®Â·æ•°æ®ç»“æ„ï¼ˆå¤æ‚åº¦åˆ†æï¼‰
- `view/ç®—æ³•å…¨æ™¯æ¢³ç†-2025-01-11.md` Â§5 - ä¿¡æ¯é€šä¿¡ä¸­çš„ç®—æ³•å¤æ‚åº¦ï¼ˆç©ºé—´å¤æ‚åº¦ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` Â§4 - å†…å®¹ä¸»é¢˜ç´¢å¼•ï¼ˆç®—æ³•å¤æ‚åº¦ï¼‰
- `view/VIEWå†…å®¹æ€»ç´¢å¼•-2025-01-11.md` - VIEWæ–‡ä»¶å¤¹å®Œæ•´ç´¢å¼•

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£æä¾›äº†ç©ºé—´å¤æ‚åº¦çš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€åˆ†ææ–¹æ³•ã€å¤æ‚åº¦ç±»ã€æ„é€ æŠ€æœ¯ã€ä¸‹ç•Œç†è®ºå’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
