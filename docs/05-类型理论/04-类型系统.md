---
title: 5.4 ç±»å‹ç³»ç»Ÿ / Type Systems
version: 1.1
status: maintained
last_updated: 2025-02-02
owner: ç±»å‹ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 5.4 ç±»å‹ç³»ç»Ÿ / Type Systems

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€ç±»å‹ç³»ç»Ÿçš„åˆ†ç±»ä¸å®ç°ï¼Œå»ºç«‹ç±»å‹æ£€æŸ¥ã€ç±»å‹æ¨å¯¼ä¸ç±»å‹å®‰å…¨çš„ç®—æ³•æ¡†æ¶ã€‚
- è¿æ¥ç±»å‹ç†è®ºä¸ç¨‹åºè®¾è®¡è¯­è¨€å®è·µï¼Œä¸ºç±»å‹ç³»ç»Ÿè®¾è®¡æä¾›æ–¹æ³•è®ºæŒ‡å¯¼ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ç±»å‹ç³»ç»Ÿã€ç±»å‹æ£€æŸ¥ã€ç±»å‹æ¨å¯¼ã€ç±»å‹å®‰å…¨ã€å¤šæ€ç±»å‹ã€å­ç±»å‹ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ç±»å‹æ£€æŸ¥ï¼ˆType Checkingï¼‰ï¼šéªŒè¯ç¨‹åºæ˜¯å¦ç¬¦åˆç±»å‹è§„åˆ™ï¼Œé™æ€æˆ–åŠ¨æ€è¿›è¡Œã€‚
- ç±»å‹æ¨å¯¼ï¼ˆType Inferenceï¼‰ï¼šè‡ªåŠ¨æ¨æ–­è¡¨è¾¾å¼çš„ç±»å‹ï¼Œå¦‚Hindley-Milnerç®—æ³•ã€‚
- ç±»å‹å®‰å…¨ï¼ˆType Safetyï¼‰ï¼šåŒ…å«è¿›å±•ï¼ˆProgressï¼‰ä¸ä¿æŒï¼ˆPreservationï¼‰ä¸¤ä¸ªæ€§è´¨ã€‚
- è®°å·çº¦å®šï¼š`âŠ¢` è¡¨ç¤ºç±»å‹æ¨å¯¼ï¼Œ`âŠ¨` è¡¨ç¤ºç±»å‹æ»¡è¶³ï¼Œ`<:` è¡¨ç¤ºå­ç±»å‹å…³ç³»ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- ç®€å•ç±»å‹è®ºåŸºç¡€ï¼šå‚è§ `05-ç±»å‹ç†è®º/01-ç®€å•ç±»å‹è®º.md`ã€‚
- ç®—æ³•ç±»å‹ç†è®ºï¼šå‚è§ `05-ç±»å‹ç†è®º/06-ç®—æ³•ç±»å‹ç†è®º.md`ã€‚
- ç±»å‹ç³»ç»Ÿå®ç°ç¤ºä¾‹ï¼šå‚è§ `08-å®ç°ç¤ºä¾‹/` ç›¸å…³æ–‡æ¡£ã€‚
- ç¨‹åºè®¾è®¡è¯­è¨€ç±»å‹ç³»ç»Ÿï¼šå‚è§ç›¸å…³å®ç°æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- ç±»å‹æ£€æŸ¥
- ç±»å‹æ¨å¯¼
- ç±»å‹å®‰å…¨
- å¤šæ€ç±»å‹

## ç›®å½• (Table of Contents)

- [5.4 ç±»å‹ç³»ç»Ÿ / Type Systems](#54-ç±»å‹ç³»ç»Ÿ--type-systems)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [4.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#41-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [4.1.1 ç±»å‹ç³»ç»Ÿå®šä¹‰ (Definition of Type Systems)](#411-ç±»å‹ç³»ç»Ÿå®šä¹‰-definition-of-type-systems)
  - [4.1.2 ç±»å‹ç³»ç»Ÿåˆ†ç±» (Classification of Type Systems)](#412-ç±»å‹ç³»ç»Ÿåˆ†ç±»-classification-of-type-systems)
  - [4.1.3 ç±»å‹ç³»ç»Ÿå±‚æ¬¡ (Type System Hierarchy)](#413-ç±»å‹ç³»ç»Ÿå±‚æ¬¡-type-system-hierarchy)
- [4.1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#414-å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
- [4.2 ç±»å‹æ£€æŸ¥ (Type Checking)](#42-ç±»å‹æ£€æŸ¥-type-checking)
  - [4.2.1 ç±»å‹æ£€æŸ¥ç®—æ³• (Type Checking Algorithm)](#421-ç±»å‹æ£€æŸ¥ç®—æ³•-type-checking-algorithm)
  - [4.2.2 ç±»å‹ç¯å¢ƒ (Type Environment)](#422-ç±»å‹ç¯å¢ƒ-type-environment)
  - [4.2.3 ç±»å‹é”™è¯¯ (Type Errors)](#423-ç±»å‹é”™è¯¯-type-errors)
- [4.3 ç±»å‹æ¨å¯¼ (Type Inference)](#43-ç±»å‹æ¨å¯¼-type-inference)
  - [4.3.1 ç±»å‹æ¨å¯¼ç®—æ³• (Type Inference Algorithm)](#431-ç±»å‹æ¨å¯¼ç®—æ³•-type-inference-algorithm)
  - [4.3.2 ç»Ÿä¸€ç®—æ³• (Unification Algorithm)](#432-ç»Ÿä¸€ç®—æ³•-unification-algorithm)
  - [4.3.3 å¤šæ€ç±»å‹æ¨å¯¼ (Polymorphic Type Inference)](#433-å¤šæ€ç±»å‹æ¨å¯¼-polymorphic-type-inference)
- [4.4 ç±»å‹å®‰å…¨ (Type Safety)](#44-ç±»å‹å®‰å…¨-type-safety)
  - [4.4.1 ç±»å‹å®‰å…¨å®šä¹‰ (Definition of Type Safety)](#441-ç±»å‹å®‰å…¨å®šä¹‰-definition-of-type-safety)
  - [4.4.2 ç±»å‹å®‰å…¨è¯æ˜ (Type Safety Proofs)](#442-ç±»å‹å®‰å…¨è¯æ˜-type-safety-proofs)
  - [4.4.3 ç±»å‹å®‰å…¨ä¸ç¨‹åºéªŒè¯ (Type Safety and Program Verification)](#443-ç±»å‹å®‰å…¨ä¸ç¨‹åºéªŒè¯-type-safety-and-program-verification)
- [4.5 å®ç°ç¤ºä¾‹ (Implementation Examples)](#45-å®ç°ç¤ºä¾‹-implementation-examples)
  - [4.5.1 ç±»å‹ç³»ç»Ÿå®ç° (Type System Implementation)](#451-ç±»å‹ç³»ç»Ÿå®ç°-type-system-implementation)
  - [4.5.2 ç±»å‹å®‰å…¨æ£€æŸ¥å™¨ (Type Safety Checker)](#452-ç±»å‹å®‰å…¨æ£€æŸ¥å™¨-type-safety-checker)
  - [4.5.3 ç±»å‹ç³»ç»Ÿæµ‹è¯• (Type System Testing)](#453-ç±»å‹ç³»ç»Ÿæµ‹è¯•-type-system-testing)
- [4.6 å‚è€ƒæ–‡çŒ® / References](#46-å‚è€ƒæ–‡çŒ®--references)

---

## 4.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 4.1.1 ç±»å‹ç³»ç»Ÿå®šä¹‰ (Definition of Type Systems)

**ç±»å‹ç³»ç»Ÿå®šä¹‰ / Definition of Type Systems:**

ç±»å‹ç³»ç»Ÿæ˜¯ç¼–ç¨‹è¯­è¨€ä¸­ç”¨äºåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥ç¨‹åºæ­£ç¡®æ€§çš„å½¢å¼åŒ–ç³»ç»Ÿ [CardelliWegner1985]ã€‚å®ƒé€šè¿‡ç±»å‹è§„åˆ™ç¡®ä¿ç¨‹åºçš„è¡Œä¸ºç¬¦åˆé¢„æœŸã€‚

A type system is a formal system in programming languages used to check program correctness at compile time [CardelliWegner1985]. It ensures program behavior meets expectations through type rules.

**ç±»å‹ç³»ç»Ÿçš„ä½œç”¨ / Role of Type Systems:**

1. **é”™è¯¯æ£€æµ‹ (Error Detection) / Error Detection:**
   - ç¼–è¯‘æ—¶å‘ç°ç±»å‹é”™è¯¯ / Detect type errors at compile time
   - å‡å°‘è¿è¡Œæ—¶é”™è¯¯ / Reduce runtime errors

2. **ç¨‹åºæ–‡æ¡£ (Program Documentation) / Program Documentation:**
   - ç±»å‹ä½œä¸ºç¨‹åºæ–‡æ¡£ / Types as program documentation
   - æé«˜ä»£ç å¯è¯»æ€§ / Improve code readability

3. **ä¼˜åŒ–æŒ‡å¯¼ (Optimization Guidance) / Optimization Guidance:**
   - ä¸ºç¼–è¯‘å™¨æä¾›ä¼˜åŒ–ä¿¡æ¯ / Provide optimization information for compiler
   - æé«˜ç¨‹åºæ€§èƒ½ / Improve program performance

### 4.1.2 ç±»å‹ç³»ç»Ÿåˆ†ç±» (Classification of Type Systems)

**é™æ€ç±»å‹ç³»ç»Ÿ (Static Type Systems) / Static Type Systems:**

1. **å¼ºç±»å‹ (Strong Typing) / Strong Typing:**
   - ä¸å…è®¸éšå¼ç±»å‹è½¬æ¢ / No implicit type conversion
   - ä¸¥æ ¼çš„ç±»å‹æ£€æŸ¥ / Strict type checking

2. **å¼±ç±»å‹ (Weak Typing) / Weak Typing:**
   - å…è®¸éšå¼ç±»å‹è½¬æ¢ / Allow implicit type conversion
   - å®½æ¾çš„ç±»å‹æ£€æŸ¥ / Loose type checking

**åŠ¨æ€ç±»å‹ç³»ç»Ÿ (Dynamic Type Systems) / Dynamic Type Systems:**

1. **è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥ / Runtime Type Checking:**
   - åœ¨ç¨‹åºæ‰§è¡Œæ—¶æ£€æŸ¥ç±»å‹ / Check types during program execution
   - çµæ´»ä½†å¯èƒ½å‡ºé”™ / Flexible but error-prone

2. **ç±»å‹æ³¨è§£ (Type Annotations) / Type Annotations:**
   - å¯é€‰çš„ç±»å‹å£°æ˜ / Optional type declarations
   - æé«˜ä»£ç å¯è¯»æ€§ / Improve code readability

### 4.1.3 ç±»å‹ç³»ç»Ÿå±‚æ¬¡ (Type System Hierarchy)

**ç±»å‹ç³»ç»Ÿå±‚æ¬¡ç»“æ„ / Type System Hierarchy:**

```text
æ— ç±»å‹ (Untyped)
    â†“
åŠ¨æ€ç±»å‹ (Dynamic Typing)
    â†“
é™æ€ç±»å‹ (Static Typing)
    â†“
å¼ºç±»å‹ (Strong Typing)
    â†“
ä¾èµ–ç±»å‹ (Dependent Typing)
    â†“
åŒä¼¦ç±»å‹ (Homotopy Type Theory)
```

**è¡¨è¾¾èƒ½åŠ›é€’å¢ / Increasing Expressiveness:**

- **æ— ç±»å‹**: æ— ç±»å‹æ£€æŸ¥ / No type checking
- **åŠ¨æ€ç±»å‹**: è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥ / Runtime type checking
- **é™æ€ç±»å‹**: ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ / Compile-time type checking
- **å¼ºç±»å‹**: ä¸¥æ ¼ç±»å‹æ£€æŸ¥ / Strict type checking
- **ä¾èµ–ç±»å‹**: ç±»å‹å¯ä»¥åŒ…å«å€¼ / Types can contain values
- **åŒä¼¦ç±»å‹**: ç±»å‹ä½œä¸ºç©ºé—´ / Types as spaces

---

## 4.1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

**è§£é‡Šä¸ç›´è§‚**ï¼šç±»å‹ç³»ç»Ÿé€šè¿‡ç±»å‹è§„åˆ™åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥ç¨‹åºï¼›ç±»å‹å®‰å…¨ç”±è¿›å±•ï¼ˆwell-typed é¡¹ä¸å¡ä½ï¼‰ä¸ä¿æŒï¼ˆè§„çº¦ä¿æŒç±»å‹ï¼‰åˆ»ç”»ï¼›Hindley-Milner ç­‰å®ç°ç±»å‹æ¨å¯¼ï¼Œè§ 01-ç®€å•ç±»å‹è®ºã€‚

**æ¦‚å¿µå±æ€§è¡¨**ï¼šç±»å‹æ£€æŸ¥ â€” åˆ¤å®š $\Gamma \vdash e : \tau$ï¼›ç±»å‹æ¨å¯¼ â€” æ¨æ–­ $\tau$ ä½¿ $\Gamma \vdash e : \tau$ï¼›ç±»å‹å®‰å…¨ â€” è¿›å±•+ä¿æŒï¼›å­ç±»å‹ â€” $S <: T$ã€‚

**æ¦‚å¿µå…³ç³»**ï¼šç±»å‹ç³»ç»Ÿ â€”depends_onâ€” 01-ç®€å•ç±»å‹è®ºã€02-ä¾èµ–ç±»å‹è®ºï¼›ä¸ 08-å®ç°ç¤ºä¾‹ â€” ç±»å‹æ£€æŸ¥å™¨/æ¨å¯¼å®ç°ï¼›ä¸ 03-å½¢å¼åŒ–è¯æ˜ â€” Curry-Howardã€‚

**æ¦‚å¿µä¾èµ–å›¾**ï¼šç±»å‹è§„åˆ™ â†’ ç±»å‹æ£€æŸ¥ï¼›ç»Ÿä¸€ç®—æ³• â†’ ç±»å‹æ¨å¯¼ï¼›è¿›å±•ä¸ä¿æŒ â†’ ç±»å‹å®‰å…¨è¯æ˜ï¼›è§ 01ã€02ã€06-ç®—æ³•ç±»å‹ç†è®ºã€‚

**æ€ç»´å¯¼å›¾**ï¼šç±»å‹ç³»ç»Ÿ â†’ ç±»å‹æ£€æŸ¥ã€ç±»å‹æ¨å¯¼ã€ç±»å‹å®‰å…¨ã€å¤šæ€ä¸å­ç±»å‹ â†’ ç¨‹åºè®¾è®¡è¯­è¨€ã€è¯æ˜åŠ©æ‰‹ã€‚

**å¤šç»´çŸ©é˜µ**ï¼šé™æ€/åŠ¨æ€ã€å¼º/å¼± â€” ç±»å‹ç³»ç»Ÿåˆ†ç±»ï¼›Hindley-Milner/å­ç±»å‹ â€” æ¨å¯¼ä¸æ£€æŸ¥ï¼›è¿›å±•/ä¿æŒ â€” ç±»å‹å®‰å…¨ï¼ˆè§ Â§4.4ï¼‰ã€‚

**å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘**ï¼šç±»å‹è§„åˆ™ â†’ å¯åˆ¤å®šæ€§ï¼ˆæ£€æŸ¥ï¼‰ï¼›ç»Ÿä¸€ä¸æ¨å¯¼ â†’ ç±»å‹æ¨å¯¼ç®—æ³•ï¼›è¿›å±•ä¸ä¿æŒå®šç† â†’ ç±»å‹å®‰å…¨ï¼ˆè§ Â§4.4ï¼‰ã€‚

**åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘**ï¼šå®ç°ç±»å‹æ£€æŸ¥/æ¨å¯¼ â†’ è§ Â§4.5ã€08-å®ç°ç¤ºä¾‹ï¼›è¯ç¨‹åºæ€§è´¨ â†’ ç±»å‹å®‰å…¨+ä¾èµ–ç±»å‹ï¼ˆè§ 02ã€08ï¼‰ã€‚

---

## 4.2 ç±»å‹æ£€æŸ¥ (Type Checking)

### 4.2.1 ç±»å‹æ£€æŸ¥ç®—æ³• (Type Checking Algorithm)

**ç±»å‹æ£€æŸ¥å®šä¹‰ / Definition of Type Checking:**

ç±»å‹æ£€æŸ¥æ˜¯éªŒè¯ç¨‹åºé¡¹æ˜¯å¦å…·æœ‰æ­£ç¡®ç±»å‹çš„è¿‡ç¨‹ã€‚

Type checking is the process of verifying that program terms have correct types.

**åŸºæœ¬ç±»å‹æ£€æŸ¥è§„åˆ™ / Basic Type Checking Rules:**

1. **å˜é‡è§„åˆ™ (Variable Rule) / Variable Rule:**
   $$\frac{x: A \in \Gamma}{\Gamma \vdash x: A}$$

2. **å‡½æ•°æŠ½è±¡è§„åˆ™ (Function Abstraction Rule) / Function Abstraction Rule:**
   $$\frac{\Gamma, x: A \vdash e: B}{\Gamma \vdash \lambda x: A. e: A \rightarrow B}$$

3. **å‡½æ•°åº”ç”¨è§„åˆ™ (Function Application Rule) / Function Application Rule:**
   $$\frac{\Gamma \vdash e_1: A \rightarrow B \quad \Gamma \vdash e_2: A}{\Gamma \vdash e_1(e_2): B}$$

4. **æ¡ä»¶è§„åˆ™ (Conditional Rule) / Conditional Rule:**
   $$\frac{\Gamma \vdash e_1: \text{Bool} \quad \Gamma \vdash e_2: A \quad \Gamma \vdash e_3: A}{\Gamma \vdash \text{if } e_1 \text{ then } e_2 \text{ else } e_3: A}$$

### 4.2.2 ç±»å‹ç¯å¢ƒ (Type Environment)

**ç±»å‹ç¯å¢ƒå®šä¹‰ / Definition of Type Environment:**

ç±»å‹ç¯å¢ƒ $\Gamma$ æ˜¯ä»å˜é‡åˆ°ç±»å‹çš„æ˜ å°„ï¼š

Type environment $\Gamma$ is a mapping from variables to types:

$$\Gamma: \text{Var} \rightarrow \text{Type}$$

**ç¯å¢ƒæ“ä½œ (Environment Operations) / Environment Operations:**

1. **ç¯å¢ƒæ‰©å±• (Environment Extension) / Environment Extension:**
   $$\Gamma, x: A = \Gamma \cup \{x \mapsto A\}$$

2. **ç¯å¢ƒæŸ¥æ‰¾ (Environment Lookup) / Environment Lookup:**
   $$\Gamma(x) = A \quad \text{if } x \mapsto A \in \Gamma$$

3. **ç¯å¢ƒæ›´æ–° (Environment Update) / Environment Update:**
   $$\Gamma[x \mapsto A] = (\Gamma \setminus \{x \mapsto B\}) \cup \{x \mapsto A\}$$

### 4.2.3 ç±»å‹é”™è¯¯ (Type Errors)

**ç±»å‹é”™è¯¯ç±»å‹ / Types of Type Errors:**

1. **ç±»å‹ä¸åŒ¹é… (Type Mismatch) / Type Mismatch:**
   - æœŸæœ›ç±»å‹ä¸å®é™…ç±»å‹ä¸ç¬¦ / Expected type differs from actual type
   - ä¾‹å¦‚ï¼šå°†æ•´æ•°èµ‹å€¼ç»™å­—ç¬¦ä¸²å˜é‡ / e.g., assigning integer to string variable

2. **æœªå®šä¹‰å˜é‡ (Undefined Variable) / Undefined Variable:**
   - ä½¿ç”¨æœªå£°æ˜çš„å˜é‡ / Using undeclared variable
   - ä¾‹å¦‚ï¼šä½¿ç”¨æœªå®šä¹‰çš„å‡½æ•° / e.g., using undefined function

3. **ç±»å‹ä¸å…¼å®¹ (Type Incompatibility) / Type Incompatibility:**
   - æ“ä½œæ•°ç±»å‹ä¸å…¼å®¹ / Incompatible operand types
   - ä¾‹å¦‚ï¼šå­—ç¬¦ä¸²ä¸æ•´æ•°ç›¸åŠ  / e.g., adding string and integer

**é”™è¯¯æ¢å¤ç­–ç•¥ (Error Recovery Strategies) / Error Recovery Strategies:**

1. **é”™è¯¯æŠ¥å‘Š (Error Reporting) / Error Reporting:**
   - æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ / Provide detailed error messages
   - æŒ‡å‡ºé”™è¯¯ä½ç½® / Point out error location

2. **é”™è¯¯ä¿®å¤å»ºè®® (Error Fix Suggestions) / Error Fix Suggestions:**
   - æä¾›å¯èƒ½çš„ä¿®å¤æ–¹æ¡ˆ / Provide possible fixes
   - è‡ªåŠ¨ç±»å‹è½¬æ¢å»ºè®® / Automatic type conversion suggestions

---

## 4.3 ç±»å‹æ¨å¯¼ (Type Inference)

### 4.3.1 ç±»å‹æ¨å¯¼ç®—æ³• (Type Inference Algorithm)

**ç±»å‹æ¨å¯¼å®šä¹‰ / Definition of Type Inference:**

ç±»å‹æ¨å¯¼æ˜¯è‡ªåŠ¨æ¨å¯¼è¡¨è¾¾å¼ç±»å‹çš„è¿‡ç¨‹ï¼Œæ— éœ€æ˜¾å¼ç±»å‹æ³¨è§£ã€‚

Type inference is the process of automatically deducing expression types without explicit type annotations.

**Hindley-Milnerç®—æ³• (Hindley-Milner Algorithm) / Hindley-Milner Algorithm:**

1. **ç±»å‹å˜é‡ç”Ÿæˆ (Type Variable Generation) / Type Variable Generation:**
   - ä¸ºæœªæ³¨è§£çš„è¡¨è¾¾å¼ç”Ÿæˆç±»å‹å˜é‡ / Generate type variables for unannotated expressions

2. **çº¦æŸç”Ÿæˆ (Constraint Generation) / Constraint Generation:**
   - æ ¹æ®ç±»å‹è§„åˆ™ç”Ÿæˆçº¦æŸ / Generate constraints based on type rules

3. **çº¦æŸæ±‚è§£ (Constraint Solving) / Constraint Solving:**
   - ä½¿ç”¨ç»Ÿä¸€ç®—æ³•æ±‚è§£çº¦æŸ / Solve constraints using unification algorithm

4. **æœ€ä¸€èˆ¬ç±»å‹ (Most General Type) / Most General Type:**
   - æ¨å¯¼æœ€ä¸€èˆ¬çš„ç±»å‹ / Derive the most general type

### 4.3.2 ç»Ÿä¸€ç®—æ³• (Unification Algorithm)

**ç»Ÿä¸€ç®—æ³•å®šä¹‰ / Definition of Unification Algorithm:**

ç»Ÿä¸€ç®—æ³•ç”¨äºæ±‚è§£ç±»å‹æ–¹ç¨‹ï¼Œæ˜¯ç±»å‹æ¨å¯¼çš„æ ¸å¿ƒã€‚

The unification algorithm is used to solve type equations and is the core of type inference.

**åŸºæœ¬ç»Ÿä¸€è§„åˆ™ (Basic Unification Rules) / Basic Unification Rules:**

1. **å˜é‡ç»Ÿä¸€ (Variable Unification) / Variable Unification:**
   - $X \sim X$ (ç›¸åŒå˜é‡)
   - $X \sim T$ (å˜é‡ä¸ç±»å‹)

2. **æ„é€ å‡½æ•°ç»Ÿä¸€ (Constructor Unification) / Constructor Unification:**
   - $C(T_1, \ldots, T_n) \sim C(U_1, \ldots, U_n)$
   - å½“ä¸”ä»…å½“ $T_i \sim U_i$ å¯¹æ‰€æœ‰ $i$

3. **å‡½æ•°ç±»å‹ç»Ÿä¸€ (Function Type Unification) / Function Type Unification:**
   - $T_1 \rightarrow T_2 \sim U_1 \rightarrow U_2$
   - å½“ä¸”ä»…å½“ $T_1 \sim U_1$ ä¸” $T_2 \sim U_2$

### 4.3.3 å¤šæ€ç±»å‹æ¨å¯¼ (Polymorphic Type Inference)

**å¤šæ€ç±»å‹å®šä¹‰ / Definition of Polymorphic Types:**

å¤šæ€ç±»å‹åŒ…å«ç±»å‹å˜é‡ï¼Œå¯ä»¥å®ä¾‹åŒ–ä¸ºå¤šç§ç±»å‹ã€‚

Polymorphic types contain type variables and can be instantiated to multiple types.

**é€šç”¨ç±»å‹ (Universal Types) / Universal Types:**

$$\forall X. T[X]$$

å…¶ä¸­ $X$ æ˜¯ç±»å‹å˜é‡ï¼Œ$T[X]$ æ˜¯åŒ…å« $X$ çš„ç±»å‹ã€‚

where $X$ is a type variable and $T[X]$ is a type containing $X$.

**ç±»å‹å®ä¾‹åŒ– (Type Instantiation) / Type Instantiation:**

$$\frac{\Gamma \vdash e: \forall X. T[X]}{\Gamma \vdash e: T[U]}$$

å…¶ä¸­ $U$ æ˜¯å…·ä½“ç±»å‹ã€‚

where $U$ is a concrete type.

---

## 4.4 ç±»å‹å®‰å…¨ (Type Safety)

### 4.4.1 ç±»å‹å®‰å…¨å®šä¹‰ (Definition of Type Safety)

**ç±»å‹å®‰å…¨å®šä¹‰ / Definition of Type Safety:**

ç±»å‹å®‰å…¨æ˜¯æŒ‡ç±»å‹ç³»ç»Ÿèƒ½å¤Ÿé˜²æ­¢æŸäº›ç±»å‹çš„è¿è¡Œæ—¶é”™è¯¯ï¼›Wright ä¸ Felleisen çš„è¯­æ³•æ–¹æ³•ï¼ˆProgress ä¸ Preservationï¼‰æ˜¯ç±»å‹å¯é æ€§è¯æ˜çš„æ ‡å‡†æ¡†æ¶ [WrightFelleisen1994]ã€‚

Type safety means that the type system can prevent certain types of runtime errors; the syntactic approach of Wright and Felleisen (Progress and Preservation) is the standard framework for type soundness proofs [WrightFelleisen1994].

**ç±»å‹å®‰å…¨æ€§è´¨ (Type Safety Properties) / Type Safety Properties:**

1. **è¿›å±•æ€§ (Progress) / Progress:**
   - è‰¯ç±»å‹çš„é¡¹è¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå¯ä»¥ç»§ç»­æ±‚å€¼
   - Well-typed terms are either values or can continue evaluation

2. **ä¿æŒæ€§ (Preservation) / Preservation:**
   - æ±‚å€¼ä¿æŒç±»å‹
   - Evaluation preserves types

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

å¯¹äºç±»å‹å®‰å…¨çš„è¯­è¨€ï¼Œæ»¡è¶³ï¼š

For type-safe languages, the following holds:

$$\text{If } \vdash e: T \text{ and } e \rightarrow e', \text{ then } \vdash e': T$$

### 4.4.2 ç±»å‹å®‰å…¨è¯æ˜ (Type Safety Proofs)

**è¿›å±•æ€§è¯æ˜ (Progress Proof) / Progress Proof:**

å¯¹äºè‰¯ç±»å‹çš„é¡¹ $e$ï¼Œå¦‚æœ $\vdash e: T$ï¼Œåˆ™ï¼š

For well-typed term $e$, if $\vdash e: T$, then:

1. $e$ æ˜¯å€¼ï¼Œæˆ–è€… / $e$ is a value, or
2. å­˜åœ¨ $e'$ ä½¿å¾— $e \rightarrow e'$ / there exists $e'$ such that $e \rightarrow e'$

**ä¿æŒæ€§è¯æ˜ (Preservation Proof) / Preservation Proof:**

å¦‚æœ $\vdash e: T$ ä¸” $e \rightarrow e'$ï¼Œåˆ™ $\vdash e': T$

If $\vdash e: T$ and $e \rightarrow e'$, then $\vdash e': T$

### 4.4.3 ç±»å‹å®‰å…¨ä¸ç¨‹åºéªŒè¯ (Type Safety and Program Verification)

**ç±»å‹å®‰å…¨ä½œä¸ºéªŒè¯å·¥å…· / Type Safety as Verification Tool:**

1. **ç¼–è¯‘æ—¶éªŒè¯ / Compile-time Verification:**
   - ç±»å‹æ£€æŸ¥ä½œä¸ºç¨‹åºéªŒè¯ / Type checking as program verification
   - å‡å°‘è¿è¡Œæ—¶é”™è¯¯ / Reduce runtime errors

2. **å½¢å¼åŒ–è¯æ˜ / Formal Proofs:**
   - ç±»å‹ç³»ç»Ÿæä¾›å½¢å¼åŒ–åŸºç¡€ / Type systems provide formal foundation
   - æ”¯æŒç¨‹åºæ­£ç¡®æ€§è¯æ˜ / Support program correctness proofs

3. **æŠ½è±¡ä¿è¯ / Abstraction Guarantees:**
   - ç±»å‹ç³»ç»Ÿæä¾›æŠ½è±¡ä¿è¯ / Type systems provide abstraction guarantees
   - ç¡®ä¿æ¥å£æ­£ç¡®æ€§ / Ensure interface correctness

---

## 4.5 å®ç°ç¤ºä¾‹ (Implementation Examples)

### 4.5.1 ç±»å‹ç³»ç»Ÿå®ç° (Type System Implementation)

```rust
use std::collections::HashMap;

/// ç±»å‹ç³»ç»Ÿå®ç° / Type System Implementation
pub struct TypeSystem {
    environment: HashMap<String, Type>,
    type_definitions: HashMap<String, TypeDefinition>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Bool,
    Int,
    String,
    Function(Box<Type>, Box<Type>),
    Variable(String),
    Generic(String, Vec<Type>),
}

#[derive(Debug, Clone)]
pub enum Term {
    Variable(String),
    Boolean(bool),
    Integer(i32),
    String(String),
    Lambda(String, Type, Box<Term>),
    Application(Box<Term>, Box<Term>),
    If(Box<Term>, Box<Term>, Box<Term>),
}

#[derive(Debug, Clone)]
pub struct TypeDefinition {
    pub name: String,
    pub parameters: Vec<String>,
    pub constructors: Vec<Constructor>,
}

#[derive(Debug, Clone)]
pub struct Constructor {
    pub name: String,
    pub arguments: Vec<Type>,
}

impl TypeSystem {
    /// åˆ›å»ºæ–°çš„ç±»å‹ç³»ç»Ÿ / Create new type system
    pub fn new() -> Self {
        TypeSystem {
            environment: HashMap::new(),
            type_definitions: HashMap::new(),
        }
    }

    /// ç±»å‹æ£€æŸ¥ / Type checking
    pub fn type_check(&mut self, term: &Term) -> Result<Type, String> {
        match term {
            Term::Variable(name) => {
                self.environment.get(name)
                    .cloned()
                    .ok_or_else(|| format!("Undefined variable: {}", name))
            }
            Term::Boolean(_) => Ok(Type::Bool),
            Term::Integer(_) => Ok(Type::Int),
            Term::String(_) => Ok(Type::String),
            Term::Lambda(param, param_type, body) => {
                self.environment.insert(param.clone(), param_type.clone());
                let body_type = self.type_check(body)?;
                self.environment.remove(param);
                Ok(Type::Function(param_type.clone(), Box::new(body_type)))
            }
            Term::Application(func, arg) => {
                let func_type = self.type_check(func)?;
                let arg_type = self.type_check(arg)?;

                match func_type {
                    Type::Function(input_type, output_type) => {
                        if self.type_equal(&arg_type, &input_type) {
                            Ok(*output_type)
                        } else {
                            Err(format!("Type mismatch: expected {}, got {}", input_type, arg_type))
                        }
                    }
                    _ => Err("Expected function type".to_string()),
                }
            }
            Term::If(condition, then_branch, else_branch) => {
                let condition_type = self.type_check(condition)?;
                if condition_type != Type::Bool {
                    return Err("Condition must be boolean".to_string());
                }

                let then_type = self.type_check(then_branch)?;
                let else_type = self.type_check(else_branch)?;

                if self.type_equal(&then_type, &else_type) {
                    Ok(then_type)
                } else {
                    Err(format!("Branches must have same type: {} vs {}", then_type, else_type))
                }
            }
        }
    }

    /// ç±»å‹æ¨å¯¼ / Type inference
    pub fn type_inference(&mut self, term: &Term) -> Result<Type, String> {
        let mut constraints = Vec::new();
        let mut type_vars = HashMap::new();

        self.generate_constraints(term, &mut constraints, &mut type_vars)?;
        self.solve_constraints(&constraints)
    }

    /// ç”Ÿæˆçº¦æŸ / Generate constraints
    fn generate_constraints(
        &self,
        term: &Term,
        constraints: &mut Vec<Constraint>,
        type_vars: &mut HashMap<String, Type>,
    ) -> Result<Type, String> {
        match term {
            Term::Variable(name) => {
                if let Some(var_type) = type_vars.get(name) {
                    Ok(var_type.clone())
                } else {
                    let new_var = Type::Variable(format!("T{}", type_vars.len()));
                    type_vars.insert(name.clone(), new_var.clone());
                    Ok(new_var)
                }
            }
            Term::Boolean(_) => Ok(Type::Bool),
            Term::Integer(_) => Ok(Type::Int),
            Term::String(_) => Ok(Type::String),
            Term::Lambda(param, param_type, body) => {
                let body_type = self.generate_constraints(body, constraints, type_vars)?;
                let func_type = Type::Function(param_type.clone(), Box::new(body_type));
                Ok(func_type)
            }
            Term::Application(func, arg) => {
                let func_type = self.generate_constraints(func, constraints, type_vars)?;
                let arg_type = self.generate_constraints(arg, constraints, type_vars)?;
                let result_var = Type::Variable(format!("R{}", constraints.len()));

                constraints.push(Constraint::Equal(
                    func_type,
                    Type::Function(Box::new(arg_type), Box::new(result_var.clone())),
                ));

                Ok(result_var)
            }
            Term::If(condition, then_branch, else_branch) => {
                let condition_type = self.generate_constraints(condition, constraints, type_vars)?;
                let then_type = self.generate_constraints(then_branch, constraints, type_vars)?;
                let else_type = self.generate_constraints(else_branch, constraints, type_vars)?;

                constraints.push(Constraint::Equal(condition_type, Type::Bool));
                constraints.push(Constraint::Equal(then_type.clone(), else_type));

                Ok(then_type)
            }
        }
    }

    /// æ±‚è§£çº¦æŸ / Solve constraints
    fn solve_constraints(&self, constraints: &[Constraint]) -> Result<Type, String> {
        let mut substitution = HashMap::new();

        for constraint in constraints {
            match constraint {
                Constraint::Equal(t1, t2) => {
                    self.unify(t1, t2, &mut substitution)?;
                }
            }
        }

        // åº”ç”¨æ›¿æ¢ / Apply substitution
        self.apply_substitution(&Type::Variable("result".to_string()), &substitution)
    }

    /// ç»Ÿä¸€ç®—æ³• / Unification algorithm
    fn unify(&self, t1: &Type, t2: &Type, substitution: &mut HashMap<String, Type>) -> Result<(), String> {
        match (t1, t2) {
            (Type::Bool, Type::Bool) | (Type::Int, Type::Int) | (Type::String, Type::String) => Ok(()),
            (Type::Variable(var), t) | (t, Type::Variable(var)) => {
                if let Some(existing) = substitution.get(var) {
                    self.unify(existing, t, substitution)
                } else {
                    substitution.insert(var.clone(), t.clone());
                    Ok(())
                }
            }
            (Type::Function(a1, b1), Type::Function(a2, b2)) => {
                self.unify(a1, a2, substitution)?;
                self.unify(b1, b2, substitution)
            }
            _ => Err(format!("Cannot unify {} and {}", t1, t2)),
        }
    }

    /// åº”ç”¨æ›¿æ¢ / Apply substitution
    fn apply_substitution(&self, t: &Type, substitution: &HashMap<String, Type>) -> Result<Type, String> {
        match t {
            Type::Variable(var) => {
                substitution.get(var).cloned().unwrap_or(t.clone())
            }
            Type::Function(input, output) => {
                let new_input = self.apply_substitution(input, substitution)?;
                let new_output = self.apply_substitution(output, substitution)?;
                Ok(Type::Function(Box::new(new_input), Box::new(new_output)))
            }
            _ => Ok(t.clone()),
        }
    }

    /// ç±»å‹ç›¸ç­‰æ€§æ£€æŸ¥ / Type equality checking
    pub fn type_equal(&self, t1: &Type, t2: &Type) -> bool {
        t1 == t2
    }
}

#[derive(Debug, Clone)]
pub enum Constraint {
    Equal(Type, Type),
}
```

### 4.5.2 ç±»å‹å®‰å…¨æ£€æŸ¥å™¨ (Type Safety Checker)

```rust
/// ç±»å‹å®‰å…¨æ£€æŸ¥å™¨ / Type Safety Checker
pub struct TypeSafetyChecker;

impl TypeSafetyChecker {
    /// æ£€æŸ¥è¿›å±•æ€§ / Check progress
    pub fn check_progress(&self, term: &Term, term_type: &Type) -> bool {
        match term {
            Term::Boolean(_) | Term::Integer(_) | Term::String(_) => true,
            Term::Variable(_) => true,
            Term::Lambda(_, _, _) => true,
            Term::Application(func, arg) => {
                // æ£€æŸ¥å‡½æ•°å’Œå‚æ•°æ˜¯å¦éƒ½æ˜¯å€¼ï¼Œæˆ–è€…å¯ä»¥ç»§ç»­æ±‚å€¼
                // Check if function and argument are values or can continue evaluation
                self.check_progress(func, term_type) && self.check_progress(arg, term_type)
            }
            Term::If(condition, then_branch, else_branch) => {
                // æ£€æŸ¥æ¡ä»¶æ˜¯å¦ä¸ºå¸ƒå°”å€¼ï¼Œåˆ†æ”¯æ˜¯å¦éƒ½æ˜¯å€¼æˆ–å¯æ±‚å€¼
                // Check if condition is boolean, branches are values or evaluable
                self.check_progress(condition, &Type::Bool) &&
                self.check_progress(then_branch, term_type) &&
                self.check_progress(else_branch, term_type)
            }
        }
    }

    /// æ£€æŸ¥ä¿æŒæ€§ / Check preservation
    pub fn check_preservation(&self, term: &Term, term_type: &Type, step: &EvaluationStep) -> bool {
        match step {
            EvaluationStep::BetaReduction(func, arg, result) => {
                // æ£€æŸ¥å‡½æ•°åº”ç”¨çš„ç±»å‹ä¿æŒæ€§
                // Check type preservation for function application
                if let Type::Function(input_type, output_type) = term_type {
                    // æ£€æŸ¥å‚æ•°ç±»å‹åŒ¹é… / Check argument type matches
                    self.type_equal(&arg.get_type(), input_type) &&
                    // æ£€æŸ¥ç»“æœç±»å‹åŒ¹é… / Check result type matches
                    self.type_equal(&result.get_type(), output_type)
                } else {
                    false
                }
            }
            EvaluationStep::Conditional(condition, then_branch, else_branch, result) => {
                // æ£€æŸ¥æ¡ä»¶è¡¨è¾¾å¼çš„ç±»å‹ä¿æŒæ€§
                // Check type preservation for conditional expression
                self.type_equal(&condition.get_type(), &Type::Bool) &&
                self.type_equal(&then_branch.get_type(), term_type) &&
                self.type_equal(&else_branch.get_type(), term_type) &&
                self.type_equal(&result.get_type(), term_type)
            }
        }
    }

    /// ç±»å‹ç›¸ç­‰æ€§æ£€æŸ¥ / Type equality checking
    fn type_equal(&self, t1: &Type, t2: &Type) -> bool {
        t1 == t2
    }
}

#[derive(Debug, Clone)]
pub enum EvaluationStep {
    BetaReduction(Term, Term, Term),
    Conditional(Term, Term, Term, Term),
}

impl Term {
    /// è·å–é¡¹çš„ç±»å‹ / Get term type
    pub fn get_type(&self) -> Type {
        match self {
            Term::Boolean(_) => Type::Bool,
            Term::Integer(_) => Type::Int,
            Term::String(_) => Type::String,
            Term::Variable(_) => Type::Variable("unknown".to_string()),
            Term::Lambda(_, param_type, _) => Type::Function(param_type.clone(), Box::new(Type::Variable("unknown".to_string()))),
            Term::Application(_, _) => Type::Variable("unknown".to_string()),
            Term::If(_, then_branch, _) => then_branch.get_type(),
        }
    }
}
```

### 4.5.3 ç±»å‹ç³»ç»Ÿæµ‹è¯• (Type System Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_type_checking() {
        let mut type_system = TypeSystem::new();

        // æµ‹è¯•åŸºæœ¬ç±»å‹ / Test basic types
        let bool_term = Term::Boolean(true);
        let result = type_system.type_check(&bool_term);
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), Type::Bool));

        let int_term = Term::Integer(42);
        let result = type_system.type_check(&int_term);
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), Type::Int));

        let string_term = Term::String("hello".to_string());
        let result = type_system.type_check(&string_term);
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), Type::String));
    }

    #[test]
    fn test_function_type_checking() {
        let mut type_system = TypeSystem::new();

        // æµ‹è¯•å‡½æ•°ç±»å‹ / Test function type
        let lambda_term = Term::Lambda(
            "x".to_string(),
            Type::Bool,
            Box::new(Term::Variable("x".to_string())),
        );
        let result = type_system.type_check(&lambda_term);
        assert!(result.is_ok());

        if let Ok(Type::Function(input, output)) = result {
            assert!(matches!(*input, Type::Bool));
            assert!(matches!(*output, Type::Bool));
        } else {
            panic!("Expected function type");
        }
    }

    #[test]
    fn test_type_inference() {
        let mut type_system = TypeSystem::new();

        // æµ‹è¯•ç±»å‹æ¨å¯¼ / Test type inference
        let lambda_term = Term::Lambda(
            "x".to_string(),
            Type::Variable("T".to_string()),
            Box::new(Term::Variable("x".to_string())),
        );
        let result = type_system.type_inference(&lambda_term);
        assert!(result.is_ok());
    }

    #[test]
    fn test_type_safety() {
        let safety_checker = TypeSafetyChecker();

        // æµ‹è¯•è¿›å±•æ€§ / Test progress
        let bool_term = Term::Boolean(true);
        assert!(safety_checker.check_progress(&bool_term, &Type::Bool));

        let int_term = Term::Integer(42);
        assert!(safety_checker.check_progress(&int_term, &Type::Int));

        // æµ‹è¯•ä¿æŒæ€§ / Test preservation
        let func = Term::Lambda("x".to_string(), Type::Bool, Box::new(Term::Variable("x".to_string())));
        let arg = Term::Boolean(true);
        let result = Term::Boolean(true);

        let step = EvaluationStep::BetaReduction(func, arg, result);
        assert!(safety_checker.check_preservation(&Term::Boolean(true), &Type::Bool, &step));
    }

    #[test]
    fn test_type_errors() {
        let mut type_system = TypeSystem::new();

        // æµ‹è¯•ç±»å‹é”™è¯¯ / Test type errors
        let invalid_application = Term::Application(
            Box::new(Term::Integer(42)),
            Box::new(Term::Boolean(true)),
        );
        let result = type_system.type_check(&invalid_application);
        assert!(result.is_err());

        let invalid_conditional = Term::If(
            Box::new(Term::Integer(42)),
            Box::new(Term::Boolean(true)),
            Box::new(Term::Integer(0)),
        );
        let result = type_system.type_check(&invalid_conditional);
        assert!(result.is_err());
    }
}
```

---

## 4.6 å‚è€ƒæ–‡çŒ® / References

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature**:

1. [CardelliWegner1985] Cardelli, L., & Wegner, P. (1985). "On Understanding Types, Data Abstraction, and Polymorphism". *ACM Computing Surveys*, 17(4): 471-522. DOI: 10.1145/6041.6042.
   - ç±»å‹ç³»ç»Ÿçš„ç»å…¸ç»¼è¿°è®ºæ–‡ï¼Œç³»ç»Ÿä»‹ç»ç±»å‹ã€æŠ½è±¡å’Œå¤šæ€ã€‚æœ¬æ–‡æ¡£Â§4.1-Â§4.2çš„å†…å®¹åŸºäºæ­¤è®ºæ–‡ã€‚

2. [Milner1978] Milner, R. (1978). "A Theory of Type Polymorphism in Programming". *Journal of Computer and System Sciences*, 17(3): 348-375.
   - ç±»å‹å¤šæ€çš„ç†è®ºåŸºç¡€ï¼ŒHindley-Milnerç±»å‹ç³»ç»Ÿã€‚

3. [DamasMilner1982] Damas, L., & Milner, R. (1982). "Principal Type-Schemes for Functional Programs". *POPL '82*, 207-212. DOI: 10.1145/582153.582176.
   - Damas-Milnerç±»å‹æ¨å¯¼ç®—æ³•ï¼ŒHindley-Milnerç³»ç»Ÿçš„å®Œæ•´æ€§è¯æ˜ã€‚æœ¬æ–‡æ¡£Â§4.3çš„ç±»å‹æ¨å¯¼åŸºäºæ­¤è®ºæ–‡ã€‚

4. [WrightFelleisen1994] Wright, A. K., & Felleisen, M. (1994). "A Syntactic Approach to Type Soundness". *Information and Computation*, 115(1): 38-94. DOI: 10.1006/inco.1994.1093.
   - ç±»å‹å¯é æ€§çš„è¯­æ³•è¯æ˜æ–¹æ³•ï¼ŒProgresså’ŒPreservationå®šç†ã€‚æœ¬æ–‡æ¡£Â§4.4çš„ç±»å‹å®‰å…¨åŸºäºæ­¤è®ºæ–‡ã€‚

**æ ‡å‡†æ•™æ / Standard Textbooks**:

1. [Pierce2002] Pierce, B. C. (2002). *Types and Programming Languages*. MIT Press. ISBN: 978-0262162098.
   - ç±»å‹ä¸ç¨‹åºè®¾è®¡è¯­è¨€çš„æ ‡å‡†æ•™æï¼Œå…¨é¢ä»‹ç»ç±»å‹ç³»ç»Ÿã€‚æœ¬æ–‡æ¡£çš„ä¸»è¦å‚è€ƒæ•™æã€‚

2. Harper, R. (2016). *Practical Foundations for Programming Languages* (2nd Edition). Cambridge University Press.
   - ç¨‹åºè®¾è®¡è¯­è¨€çš„å®ç”¨åŸºç¡€ï¼Œç³»ç»Ÿä»‹ç»ç±»å‹ç³»ç»Ÿã€‚

**é«˜çº§ç±»å‹ç†è®º / Advanced Type Theory**:

1. Reynolds, J. C. (1983). "Types, Abstraction, and Parametric Polymorphism". *Information Processing '83*, 513-523.
   - å‚æ•°åŒ–å¤šæ€å’Œç±»å‹æŠ½è±¡çš„ç†è®ºåŸºç¡€ã€‚

2. Wadler, P. (1989). "Theorems for Free!". *FPCA '89*, 347-359.
   - ä»ç±»å‹æ¨å¯¼å®šç†ï¼Œå‚æ•°åŒ–çš„é‡è¦æ€§è´¨ã€‚

3. Girard, J. Y. (1972). *InterprÃ©tation fonctionnelle et Ã©limination des coupures de l'arithmÃ©tique d'ordre supÃ©rieur*. PhD thesis, UniversitÃ© Paris 7.
   - System Fçš„å¼€åˆ›æ€§å·¥ä½œï¼Œå¤šæ€Î»æ¼”ç®—çš„åŸºç¡€ã€‚

**ç±»å‹æ¨å¯¼ / Type Inference**:

1. [Hindley1969] Hindley, R. (1969). "The Principal Type-Scheme of an Object in Combinatory Logic". *Transactions of the American Mathematical Society*, 146: 29-60.
    - Hindleyç±»å‹æ¨å¯¼çš„åŸå§‹è®ºæ–‡ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. Types and Programming Languages - Companion Website: <https://www.cis.upenn.edu/~bcpierce/tapl/>
   - TAPLæ•™æçš„é…å¥—èµ„æºã€‚

2. nLab - Type System: <https://ncatlab.org/nlab/show/type+system>
   - ç±»å‹ç³»ç»Ÿçš„èŒƒç•´è®ºè§†è§’ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ [CITATION_STANDARD.md](../CITATION_STANDARD.md)ã€[å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md](../å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)ï¼‰ã€‚æ–‡å†…é‡‡ç”¨ [Key] æ ¼å¼å¼•ç”¨ï¼Œä¸å‚è€ƒæ–‡çŒ®åˆ—è¡¨å¯¹åº”ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§ Wikipedia ç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.2
**æœ€åæ›´æ–° / Last Updated**: 2025-02-02
**çŠ¶æ€ / Status**: å·²è¡¥å……å­¦æœ¯å¼•ç”¨ä¸æ–‡å†…å¼•ç”¨ / Academic citations and in-text references added (P1)

---

*æœ¬æ–‡æ¡£æä¾›äº†ç±»å‹ç³»ç»Ÿçš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€ç±»å‹æ£€æŸ¥ã€ç±»å‹æ¨å¯¼ã€ç±»å‹å®‰å…¨å’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
