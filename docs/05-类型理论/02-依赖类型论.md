---
title: 5.2 ä¾èµ–ç±»å‹è®º / Dependent Type Theory
version: 1.1
status: maintained
last_updated: 2025-02-02
owner: ç±»å‹ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 5.2 ä¾èµ–ç±»å‹è®º / Dependent Type Theory

### æ‘˜è¦ / Executive Summary

- å»ºç«‹ä¾èµ–ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–å®šä¹‰ï¼Œç»Ÿä¸€æ„é€ æ¼”ç®—ä¸å½’çº³ç±»å‹çš„ç†è®ºåŸºç¡€ã€‚
- è¿æ¥ç±»å‹è®ºä¸æ•°ç†é€»è¾‘ï¼Œä¸ºå½¢å¼åŒ–éªŒè¯æä¾›ç±»å‹å±‚é¢çš„æ”¯æŒã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ä¾èµ–ç±»å‹ã€æ„é€ æ¼”ç®—ã€å½’çº³ç±»å‹ã€ä¾èµ–å¯¹ç±»å‹ã€Martin-LÃ¶fç±»å‹è®ºã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ä¾èµ–ç±»å‹ï¼ˆDependent Typesï¼‰ï¼šç±»å‹å¯ä»¥ä¾èµ–äºå€¼çš„ç±»å‹ï¼Œå¦‚ `Î (x:A).B(x)`ã€‚
- æ„é€ æ¼”ç®—ï¼ˆCalculus of Constructions, CoCï¼‰ï¼šé«˜é˜¶ä¾èµ–ç±»å‹ç³»ç»Ÿï¼ŒCoqçš„åŸºç¡€ã€‚
- å½’çº³ç±»å‹ï¼ˆInductive Typesï¼‰ï¼šé€šè¿‡æ„é€ å­å®šä¹‰çš„é€’å½’ç±»å‹ï¼Œå¦‚è‡ªç„¶æ•°ã€åˆ—è¡¨ã€‚
- è®°å·çº¦å®šï¼š`Î ` è¡¨ç¤ºä¾èµ–å‡½æ•°ç±»å‹ï¼Œ`Î£` è¡¨ç¤ºä¾èµ–å¯¹ç±»å‹ï¼Œ`âŠ¢` è¡¨ç¤ºç±»å‹æ¨å¯¼ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

#### å‰ç½®çŸ¥è¯† (Prerequisites)

- **ç®€å•ç±»å‹è®ºåŸºç¡€**: `05-ç±»å‹ç†è®º/01-ç®€å•ç±»å‹è®º.md` Â§3.2 - å¼ºä¾èµ–
- **æ„é€ æ€§è¯æ˜**: `03-å½¢å¼åŒ–è¯æ˜/03-æ„é€ æ€§è¯æ˜.md` Â§3.1-Â§3.2 - ä¸­ä¾èµ–

#### ç›¸å…³ç†è®º (Related)

- **åŒä¼¦ç±»å‹è®º**: `05-ç±»å‹ç†è®º/03-åŒä¼¦ç±»å‹è®º.md` Â§2-Â§4 - æ‰©å±•å…³ç³»
- **ä¾èµ–ç±»å‹ä¸æ•°ç†é€»è¾‘**: `05-ç±»å‹ç†è®º/05-ä¾èµ–ç±»å‹ç³»ç»Ÿä¸æ•°ç†é€»è¾‘.md` Â§5.2-Â§5.3 - åº”ç”¨å…³ç³»

#### åå‘é“¾æ¥ (Backward Links)

æœ¬æ–‡æ¡£è¢«ä»¥ä¸‹æ–‡æ¡£å¼•ç”¨ï¼š

- `05-ç±»å‹ç†è®º/05-ä¾èµ–ç±»å‹ç³»ç»Ÿä¸æ•°ç†é€»è¾‘.md` Â§äº¤å‰å¼•ç”¨å¯¼èˆª
- `05-ç±»å‹ç†è®º/03-åŒä¼¦ç±»å‹è®º.md` Â§äº¤å‰å¼•ç”¨å¯¼èˆª

### å¿«é€Ÿå¯¼èˆª / Quick Links

- ä¾èµ–ç±»å‹ç³»ç»Ÿ
- æ„é€ æ¼”ç®—
- å½’çº³ç±»å‹
- ç±»å‹æ¨å¯¼

## ç›®å½• (Table of Contents)

- [5.2 ä¾èµ–ç±»å‹è®º / Dependent Type Theory](#52-ä¾èµ–ç±»å‹è®º--dependent-type-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
    - [å‰ç½®çŸ¥è¯† (Prerequisites)](#å‰ç½®çŸ¥è¯†-prerequisites)
    - [ç›¸å…³ç†è®º (Related)](#ç›¸å…³ç†è®º-related)
    - [åå‘é“¾æ¥ (Backward Links)](#åå‘é“¾æ¥-backward-links)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [2.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#21-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [2.1.1 ä¾èµ–ç±»å‹å®šä¹‰ (Definition of Dependent Types)](#211-ä¾èµ–ç±»å‹å®šä¹‰-definition-of-dependent-types)
  - [2.1.2 ä¾èµ–ç±»å‹çš„ç‰¹ç‚¹ (Characteristics of Dependent Types)](#212-ä¾èµ–ç±»å‹çš„ç‰¹ç‚¹-characteristics-of-dependent-types)
  - [2.1.3 ä¾èµ–ç±»å‹ä¸ç®€å•ç±»å‹è®ºçš„åŒºåˆ« (Difference from Simple Type Theory)](#213-ä¾èµ–ç±»å‹ä¸ç®€å•ç±»å‹è®ºçš„åŒºåˆ«-difference-from-simple-type-theory)
- [2.1.1 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#211-å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
- [2.2 ä¾èµ–ç±»å‹ç³»ç»Ÿ (Dependent Type Systems)](#22-ä¾èµ–ç±»å‹ç³»ç»Ÿ-dependent-type-systems)
  - [2.2.1 æ„é€ æ¼”ç®— (Calculus of Constructions)](#221-æ„é€ æ¼”ç®—-calculus-of-constructions)
  - [2.2.2 å½’çº³ç±»å‹ (Inductive Types)](#222-å½’çº³ç±»å‹-inductive-types)
  - [2.2.3 ä¾èµ–å¯¹ç±»å‹ (Dependent Pair Types)](#223-ä¾èµ–å¯¹ç±»å‹-dependent-pair-types)
- [2.3 ç±»å‹æ¨å¯¼ (Type Inference)](#23-ç±»å‹æ¨å¯¼-type-inference)
  - [2.3.1 ç»Ÿä¸€ç®—æ³• (Unification Algorithm)](#231-ç»Ÿä¸€ç®—æ³•-unification-algorithm)
  - [2.3.2 Hindley-Milnerç±»å‹ç³»ç»Ÿ (Hindley-Milner Type System)](#232-hindley-milnerç±»å‹ç³»ç»Ÿ-hindley-milner-type-system)
  - [2.3.3 ä¾èµ–ç±»å‹æ¨å¯¼ (Dependent Type Inference)](#233-ä¾èµ–ç±»å‹æ¨å¯¼-dependent-type-inference)
- [2.4 è¯­ä¹‰ (Semantics)](#24-è¯­ä¹‰-semantics)
  - [2.4.1 æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)](#241-æŒ‡ç§°è¯­ä¹‰-denotational-semantics)
  - [2.4.2 æ“ä½œè¯­ä¹‰ (Operational Semantics)](#242-æ“ä½œè¯­ä¹‰-operational-semantics)
  - [2.4.3 é€»è¾‘å…³ç³» (Logical Relations)](#243-é€»è¾‘å…³ç³»-logical-relations)
- [2.5 å®ç°ç¤ºä¾‹ (Implementation Examples)](#25-å®ç°ç¤ºä¾‹-implementation-examples)
  - [2.5.1 ä¾èµ–ç±»å‹æ£€æŸ¥å™¨ (Dependent Type Checker)](#251-ä¾èµ–ç±»å‹æ£€æŸ¥å™¨-dependent-type-checker)
  - [2.5.2 å½’çº³ç±»å‹å®ç° (Inductive Type Implementation)](#252-å½’çº³ç±»å‹å®ç°-inductive-type-implementation)
  - [2.5.3 ä¾èµ–ç±»å‹æµ‹è¯• (Dependent Type Testing)](#253-ä¾èµ–ç±»å‹æµ‹è¯•-dependent-type-testing)
- [2.8 æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Recent Research Progress](#28-æœ€æ–°ç ”ç©¶è¿›å±•2024-2025-recent-research-progress)
- [2.9 å…ƒç†è®ºå½¢å¼åŒ– / Metatheory Formalization](#29-å…ƒç†è®ºå½¢å¼åŒ–--metatheory-formalization)
- [2.6 å‚è€ƒæ–‡çŒ® / References](#26-å‚è€ƒæ–‡çŒ®--references)

---

## 2.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 2.1.1 ä¾èµ–ç±»å‹å®šä¹‰ (Definition of Dependent Types)

**ä¾èµ–ç±»å‹å®šä¹‰ / Definition of Dependent Types:**

ä¾èµ–ç±»å‹æ˜¯ç±»å‹ä¾èµ–äºå€¼çš„ç±»å‹ç³»ç»Ÿ [MartinLof1975]ã€‚åœ¨ä¾èµ–ç±»å‹ä¸­ï¼Œç±»å‹å¯ä»¥åŒ…å«å€¼ï¼Œè¿™ä½¿å¾—ç±»å‹ç³»ç»Ÿæ›´åŠ è¡¨è¾¾èƒ½åŠ›å¼ºã€‚

Dependent types are type systems where types can depend on values [MartinLof1975]. In dependent types, types can contain values, making the type system more expressive.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

å¯¹äºç±»å‹ $A$ å’Œå‡½æ•° $B: A \rightarrow \text{Type}$ï¼Œä¾èµ–ç±»å‹ $\Pi_{x:A} B(x)$ è¡¨ç¤ºï¼š

For type $A$ and function $B: A \rightarrow \text{Type}$, the dependent type $\Pi_{x:A} B(x)$ represents:

$$\Pi_{x:A} B(x) = \{f : \forall x \in A, f(x) \in B(x)\}$$

### 2.1.2 ä¾èµ–ç±»å‹çš„ç‰¹ç‚¹ (Characteristics of Dependent Types)

**è¡¨è¾¾èƒ½åŠ› / Expressiveness:**

1. **ç±»å‹å®‰å…¨ / Type Safety:**
   - ç¼–è¯‘æ—¶é”™è¯¯æ£€æŸ¥ / Compile-time error checking
   - è¿è¡Œæ—¶å®‰å…¨ä¿éšœ / Runtime safety guarantees

2. **ç¨‹åºéªŒè¯ / Program Verification:**
   - å½¢å¼åŒ–è¯æ˜ / Formal proofs
   - ç¨‹åºæ­£ç¡®æ€§ / Program correctness

3. **æŠ½è±¡èƒ½åŠ› / Abstraction Capability:**
   - é«˜é˜¶æŠ½è±¡ / Higher-order abstraction
   - å‚æ•°åŒ–ç±»å‹ / Parametric types

### 2.1.3 ä¾èµ–ç±»å‹ä¸ç®€å•ç±»å‹è®ºçš„åŒºåˆ« (Difference from Simple Type Theory)

**ç®€å•ç±»å‹è®ºé™åˆ¶ / Simple Type Theory Limitations:**

- ç±»å‹ä¸èƒ½åŒ…å«å€¼ / Types cannot contain values
- è¡¨è¾¾èƒ½åŠ›æœ‰é™ / Limited expressiveness
- æ— æ³•è¡¨è¾¾å¤æ‚çº¦æŸ / Cannot express complex constraints

**ä¾èµ–ç±»å‹è®ºä¼˜åŠ¿ / Dependent Type Theory Advantages:**

- ç±»å‹å¯ä»¥åŒ…å«å€¼ / Types can contain values
- æ›´å¼ºçš„è¡¨è¾¾èƒ½åŠ› / Stronger expressiveness
- å¯ä»¥è¡¨è¾¾å¤æ‚çº¦æŸ / Can express complex constraints

---

## 2.1.1 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

**è§£é‡Šä¸ç›´è§‚**ï¼šä¾èµ–ç±»å‹è®ºä¸­ç±»å‹å¯ä¾èµ–å€¼ï¼ˆå¦‚ $\Pi_{x:A} B$ï¼‰ï¼›å‘½é¢˜å³ç±»å‹ã€è¯æ˜å³ç¨‹åºï¼ˆCurry-Howardï¼‰ï¼Œä¸º Coq/Agda/Lean ç­‰è¯æ˜åŠ©æ‰‹æä¾›åŸºç¡€ï¼›ä¸åŒä¼¦ç±»å‹è®ºï¼ˆè§ 03ï¼‰è¡”æ¥ã€‚

**æ¦‚å¿µå±æ€§è¡¨**ï¼š$\Pi$ ç±»å‹ â€” ä¾èµ–ç§¯ï¼›$\Sigma$ ç±»å‹ â€” ä¾èµ–å’Œï¼›æ„é€ æ¼”ç®— â€” Coq åŸºç¡€ï¼›å‘½é¢˜å³ç±»å‹ â€” Curry-Howardã€‚

**æ¦‚å¿µå…³ç³»**ï¼šä¾èµ–ç±»å‹è®º â€”extendsâ€” ç®€å•ç±»å‹è®ºï¼ˆè§ 01ï¼‰ï¼›ä¸åŒä¼¦ç±»å‹è®º â€” åè€…åŠ æ’ç­‰ç±»å‹ä¸å•å€¼å…¬ç†ï¼›ä¸ 03-å½¢å¼åŒ–è¯æ˜ã€08-å®ç°ç¤ºä¾‹ â€” è¯æ˜åŠ©æ‰‹ã€‚

**æ¦‚å¿µä¾èµ–å›¾**ï¼šç®€å•ç±»å‹ â†’ ä¾èµ–ç§¯/å’Œ â†’ æ„é€ æ¼”ç®—ï¼›Curry-Howard â†’ å½’çº³ç±»å‹ã€è¯æ˜å³ç¨‹åºï¼›è§ 05-ä¾èµ–ç±»å‹ç³»ç»Ÿä¸æ•°ç†é€»è¾‘ã€‚

**æ€ç»´å¯¼å›¾**ï¼šä¾èµ–ç±»å‹è®º â†’ $\Pi/\Sigma$ã€æ„é€ æ¼”ç®—ã€å½’çº³ç±»å‹ â†’ è¯æ˜åŠ©æ‰‹ã€åŒä¼¦ç±»å‹è®ºã€å½¢å¼åŒ–éªŒè¯ã€‚

**å¤šç»´çŸ©é˜µ**ï¼šç®€å•/å¤šæ€/ä¾èµ– â€” è¡¨è¾¾èƒ½åŠ›ï¼›Coq/Agda/Lean â€” å®ç°ï¼›å‘½é¢˜å³ç±»å‹ â€” è¯æ˜ä¸ç¨‹åºç»Ÿä¸€ã€‚

**å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘**ï¼š$\Pi/\Sigma$ å½¢æˆè§„åˆ™ â†’ ç±»å‹æ£€æŸ¥ï¼›æ„é€ æ¼”ç®— â†’ å½’çº³ä¸é€’å½’ï¼›å¯é æ€§ â†’ è§„èŒƒå½¢å¼ä¸ä¸€è‡´æ€§ã€‚

**åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘**ï¼šå½¢å¼åŒ–è¯æ˜ â†’ Coq/Agda/Leanï¼ˆè§ 08ï¼‰ï¼›ç¨‹åºéªŒè¯ â†’ ä¾èµ–ç±»å‹+æå–ï¼›åŒä¼¦ç±»å‹è®º â†’ è§ 03-åŒä¼¦ç±»å‹è®ºã€‚

---

## 2.2 ä¾èµ–ç±»å‹ç³»ç»Ÿ (Dependent Type Systems)

### 2.2.1 æ„é€ æ¼”ç®— (Calculus of Constructions)

**æ„é€ æ¼”ç®—å®šä¹‰ / Definition of Calculus of Constructions:**

æ„é€ æ¼”ç®—æ˜¯ä¸€ä¸ªé«˜é˜¶ä¾èµ–ç±»å‹ç³»ç»Ÿï¼Œå®ƒç»“åˆäº†å¤šæ€Î»æ¼”ç®—å’Œä¾èµ–ç±»å‹ [Coquand1988]ï¼Œæ˜¯ Coq è¯æ˜åŠ©æ‰‹çš„ç†è®ºåŸºç¡€ã€‚

The Calculus of Constructions is a higher-order dependent type system that combines polymorphic lambda calculus with dependent types [Coquand1988], and forms the basis of the Coq proof assistant.

**è¯­æ³•è§„åˆ™ / Syntax Rules:**

1. **ç±»å‹æ„é€  / Type Formation:**
   $$\frac{\Gamma \vdash A : \text{Type} \quad \Gamma, x:A \vdash B : \text{Type}}{\Gamma \vdash \Pi_{x:A} B : \text{Type}}$$

2. **å‡½æ•°æŠ½è±¡ / Function Abstraction:**
   $$\frac{\Gamma, x:A \vdash b : B}{\Gamma \vdash \lambda x:A. b : \Pi_{x:A} B}$$

3. **å‡½æ•°åº”ç”¨ / Function Application:**
   $$\frac{\Gamma \vdash f : \Pi_{x:A} B \quad \Gamma \vdash a : A}{\Gamma \vdash f(a) : B[a/x]}$$

### 2.2.2 å½’çº³ç±»å‹ (Inductive Types)

**å½’çº³ç±»å‹å®šä¹‰ / Definition of Inductive Types:**

å½’çº³ç±»å‹æ˜¯é€šè¿‡æ„é€ å‡½æ•°å®šä¹‰çš„é€’å½’ç±»å‹ã€‚

Inductive types are recursive types defined through constructors.

**è‡ªç„¶æ•°ç±»å‹ / Natural Number Type:**

```rust
// è‡ªç„¶æ•°ç±»å‹å®šä¹‰ / Natural number type definition
pub enum Nat {
    Zero,
    Succ(Box<Nat>),
}

// é€’å½’å‡½æ•° / Recursive function
pub fn add(m: &Nat, n: &Nat) -> Nat {
    match m {
        Nat::Zero => n.clone(),
        Nat::Succ(pred_m) => Nat::Succ(Box::new(add(pred_m, n))),
    }
}
```

### 2.2.3 ä¾èµ–å¯¹ç±»å‹ (Dependent Pair Types)

**ä¾èµ–å¯¹ç±»å‹å®šä¹‰ / Definition of Dependent Pair Types:**

ä¾èµ–å¯¹ç±»å‹ $\Sigma_{x:A} B(x)$ è¡¨ç¤ºå€¼å¯¹ï¼Œå…¶ä¸­ç¬¬äºŒä¸ªå€¼çš„ç±»å‹ä¾èµ–äºç¬¬ä¸€ä¸ªå€¼ã€‚

The dependent pair type $\Sigma_{x:A} B(x)$ represents value pairs where the type of the second value depends on the first value.

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$\Sigma_{x:A} B(x) = \{(a, b) : a \in A \land b \in B(a)\}$$

**å®ç°ç¤ºä¾‹ / Implementation Example:**

```rust
// ä¾èµ–å¯¹ç±»å‹ / Dependent pair type
pub struct DependentPair<A, B> {
    pub first: A,
    pub second: B,
}

// å‘é‡ç±»å‹ / Vector type
pub struct Vector<T> {
    pub length: usize,
    pub elements: Vec<T>,
}

// å®‰å…¨ç´¢å¼•å‡½æ•° / Safe indexing function
pub fn safe_index<T>(vec: &Vector<T>, index: usize) -> Option<&T> {
    if index < vec.length {
        vec.elements.get(index)
    } else {
        None
    }
}
```

---

## 2.3 ç±»å‹æ¨å¯¼ (Type Inference)

### 2.3.1 ç»Ÿä¸€ç®—æ³• (Unification Algorithm)

**ç»Ÿä¸€ç®—æ³•å®šä¹‰ / Definition of Unification Algorithm:**

ç»Ÿä¸€ç®—æ³•ç”¨äºæ±‚è§£ç±»å‹æ–¹ç¨‹ï¼Œæ˜¯ç±»å‹æ¨å¯¼çš„æ ¸å¿ƒã€‚

The unification algorithm is used to solve type equations and is the core of type inference.

**åŸºæœ¬è§„åˆ™ / Basic Rules:**

1. **å˜é‡ç»Ÿä¸€ / Variable Unification:**
   - $X \sim X$ (ç›¸åŒå˜é‡)
   - $X \sim T$ (å˜é‡ä¸ç±»å‹)

2. **æ„é€ å‡½æ•°ç»Ÿä¸€ / Constructor Unification:**
   - $C(T_1, \ldots, T_n) \sim C(U_1, \ldots, U_n)$
   - å½“ä¸”ä»…å½“ $T_i \sim U_i$ å¯¹æ‰€æœ‰ $i$

3. **å‡½æ•°ç±»å‹ç»Ÿä¸€ / Function Type Unification:**
   - $T_1 \rightarrow T_2 \sim U_1 \rightarrow U_2$
   - å½“ä¸”ä»…å½“ $T_1 \sim U_1$ ä¸” $T_2 \sim U_2$

### 2.3.2 Hindley-Milnerç±»å‹ç³»ç»Ÿ (Hindley-Milner Type System)

**Hindley-Milnerç±»å‹ç³»ç»Ÿå®šä¹‰ / Definition of Hindley-Milner Type System:**

Hindley-Milnerç±»å‹ç³»ç»Ÿæ˜¯ä¸€ä¸ªå¤šæ€ç±»å‹ç³»ç»Ÿï¼Œæ”¯æŒç±»å‹æ¨å¯¼ã€‚

The Hindley-Milner type system is a polymorphic type system that supports type inference.

**ä¸»è¦ç‰¹å¾ / Main Features:**

1. **å¤šæ€æ€§ / Polymorphism:**
   - é€šç”¨ç±»å‹ / Universal types
   - ç±»å‹å˜é‡ / Type variables

2. **ç±»å‹æ¨å¯¼ / Type Inference:**
   - è‡ªåŠ¨æ¨å¯¼ç±»å‹ / Automatic type deduction
   - æœ€ä¸€èˆ¬ç±»å‹ / Most general type

3. **ç±»å‹å®‰å…¨ / Type Safety:**
   - ç¼–è¯‘æ—¶æ£€æŸ¥ / Compile-time checking
   - ç±»å‹é”™è¯¯æ£€æµ‹ / Type error detection

### 2.3.3 ä¾èµ–ç±»å‹æ¨å¯¼ (Dependent Type Inference)

**ä¾èµ–ç±»å‹æ¨å¯¼æŒ‘æˆ˜ / Challenges of Dependent Type Inference:**

1. **ç±»å‹ä¾èµ– / Type Dependencies:**
   - ç±»å‹åŒ…å«å€¼ / Types contain values
   - å¤æ‚çš„ç±»å‹æ–¹ç¨‹ / Complex type equations

2. **è¯æ˜ä¹‰åŠ¡ / Proof Obligations:**
   - éœ€è¦æ„é€ è¯æ˜ / Need to construct proofs
   - ç±»å‹æ£€æŸ¥å¤æ‚æ€§ / Type checking complexity

3. **å¯åˆ¤å®šæ€§ / Decidability:**
   - ç±»å‹æ£€æŸ¥ä¸å¯åˆ¤å®š / Type checking undecidable
   - éœ€è¦å¯å‘å¼æ–¹æ³• / Need heuristic methods

---

## 2.4 è¯­ä¹‰ (Semantics)

### 2.4.1 æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)

**æŒ‡ç§°è¯­ä¹‰å®šä¹‰ / Definition of Denotational Semantics:**

æŒ‡ç§°è¯­ä¹‰é€šè¿‡æ•°å­¦å¯¹è±¡è§£é‡Šç¨‹åºçš„å«ä¹‰ã€‚

Denotational semantics interprets program meaning through mathematical objects.

**ç±»å‹è¯­ä¹‰ / Type Semantics:**

1. **åŸºæœ¬ç±»å‹ / Basic Types:**
   - $\llbracket \text{Bool} \rrbracket = \{true, false\}$
   - $\llbracket \text{Nat} \rrbracket = \mathbb{N}$

2. **å‡½æ•°ç±»å‹ / Function Types:**
   - $\llbracket A \rightarrow B \rrbracket = \llbracket B \rrbracket^{\llbracket A \rrbracket}$

3. **ä¾èµ–ç±»å‹ / Dependent Types:**
   - $\llbracket \Pi_{x:A} B(x) \rrbracket = \prod_{a \in \llbracket A \rrbracket} \llbracket B(a) \rrbracket$

### 2.4.2 æ“ä½œè¯­ä¹‰ (Operational Semantics)

**æ“ä½œè¯­ä¹‰å®šä¹‰ / Definition of Operational Semantics:**

æ“ä½œè¯­ä¹‰é€šè¿‡è®¡ç®—è§„åˆ™å®šä¹‰ç¨‹åºçš„æ‰§è¡Œã€‚

Operational semantics defines program execution through computation rules.

**æ±‚å€¼è§„åˆ™ / Evaluation Rules:**

1. **å‡½æ•°åº”ç”¨ / Function Application:**
   $$\frac{e_1 \Downarrow \lambda x. e \quad e_2 \Downarrow v \quad e[v/x] \Downarrow v'}{e_1(e_2) \Downarrow v'}$$

2. **æ¡ä»¶è¡¨è¾¾å¼ / Conditional Expression:**
   $$\frac{e_1 \Downarrow true \quad e_2 \Downarrow v}{\text{if } e_1 \text{ then } e_2 \text{ else } e_3 \Downarrow v}$$

3. **é€’å½’å‡½æ•° / Recursive Function:**
   $$\frac{e[\text{fix } f. e/f] \Downarrow v}{\text{fix } f. e \Downarrow v}$$

### 2.4.3 é€»è¾‘å…³ç³» (Logical Relations)

**é€»è¾‘å…³ç³»å®šä¹‰ / Definition of Logical Relations:**

é€»è¾‘å…³ç³»ç”¨äºè¯æ˜ç±»å‹ç³»ç»Ÿçš„æ€§è´¨ã€‚

Logical relations are used to prove properties of type systems.

**å‚æ•°æ€§ / Parametricity:**

å¯¹äºç±»å‹ $\forall X. T[X]$ï¼Œå‚æ•°æ€§è¦æ±‚ï¼š

For type $\forall X. T[X]$, parametricity requires:

$$\forall R \subseteq A \times B. \text{rel}_T(R) \subseteq T[A] \times T[B]$$

---

## 2.5 å®ç°ç¤ºä¾‹ (Implementation Examples)

### 2.5.1 ä¾èµ–ç±»å‹æ£€æŸ¥å™¨ (Dependent Type Checker)

```rust
use std::collections::HashMap;

/// ä¾èµ–ç±»å‹æ£€æŸ¥å™¨ / Dependent Type Checker
pub struct DependentTypeChecker {
    context: HashMap<String, Type>,
    type_definitions: HashMap<String, TypeDefinition>,
}

#[derive(Debug, Clone)]
pub enum Type {
    Bool,
    Nat,
    Function(Box<Type>, Box<Type>),
    DependentFunction(String, Box<Type>, Box<Type>),
    DependentPair(String, Box<Type>, Box<Type>),
    Variable(String),
}

#[derive(Debug, Clone)]
pub struct TypeDefinition {
    pub name: String,
    pub constructors: Vec<Constructor>,
}

#[derive(Debug, Clone)]
pub struct Constructor {
    pub name: String,
    pub arguments: Vec<Type>,
}

impl DependentTypeChecker {
    /// åˆ›å»ºæ–°çš„ç±»å‹æ£€æŸ¥å™¨ / Create new type checker
    pub fn new() -> Self {
        DependentTypeChecker {
            context: HashMap::new(),
            type_definitions: HashMap::new(),
        }
    }

    /// ç±»å‹æ£€æŸ¥ / Type checking
    pub fn type_check(&mut self, term: &Term) -> Result<Type, String> {
        match term {
            Term::Variable(name) => {
                self.context.get(name)
                    .cloned()
                    .ok_or_else(|| format!("Undefined variable: {}", name))
            }
            Term::Lambda(param, param_type, body) => {
                self.context.insert(param.clone(), param_type.clone());
                let body_type = self.type_check(body)?;
                self.context.remove(param);
                Ok(Type::Function(param_type.clone(), Box::new(body_type)))
            }
            Term::Application(func, arg) => {
                let func_type = self.type_check(func)?;
                let arg_type = self.type_check(arg)?;

                match func_type {
                    Type::Function(input_type, output_type) => {
                        if self.type_equal(&arg_type, &input_type) {
                            Ok(*output_type)
                        } else {
                            Err("Type mismatch in function application".to_string())
                        }
                    }
                    _ => Err("Expected function type".to_string()),
                }
            }
            Term::DependentLambda(param, param_type, body) => {
                self.context.insert(param.clone(), param_type.clone());
                let body_type = self.type_check(body)?;
                self.context.remove(param);
                Ok(Type::DependentFunction(
                    param.clone(),
                    param_type.clone(),
                    Box::new(body_type),
                ))
            }
            Term::DependentApplication(func, arg) => {
                let func_type = self.type_check(func)?;
                let arg_type = self.type_check(arg)?;

                match func_type {
                    Type::DependentFunction(param, param_type, output_type) => {
                        if self.type_equal(&arg_type, &param_type) {
                            self.substitute_type(&output_type, param, &arg_type)
                        } else {
                            Err("Type mismatch in dependent function application".to_string())
                        }
                    }
                    _ => Err("Expected dependent function type".to_string()),
                }
            }
        }
    }

    /// ç±»å‹ç›¸ç­‰æ€§æ£€æŸ¥ / Type equality checking
    pub fn type_equal(&self, t1: &Type, t2: &Type) -> bool {
        match (t1, t2) {
            (Type::Bool, Type::Bool) => true,
            (Type::Nat, Type::Nat) => true,
            (Type::Function(a1, b1), Type::Function(a2, b2)) => {
                self.type_equal(a1, a2) && self.type_equal(b1, b2)
            }
            (Type::DependentFunction(p1, pt1, bt1), Type::DependentFunction(p2, pt2, bt2)) => {
                p1 == p2 && self.type_equal(pt1, pt2) && self.type_equal(bt1, bt2)
            }
            _ => false,
        }
    }

    /// ç±»å‹æ›¿æ¢ / Type substitution
    pub fn substitute_type(&self, t: &Type, var: &str, replacement: &Type) -> Result<Type, String> {
        match t {
            Type::Variable(name) if name == var => Ok(replacement.clone()),
            Type::Variable(name) => Ok(Type::Variable(name.clone())),
            Type::Bool => Ok(Type::Bool),
            Type::Nat => Ok(Type::Nat),
            Type::Function(input, output) => {
                let new_input = self.substitute_type(input, var, replacement)?;
                let new_output = self.substitute_type(output, var, replacement)?;
                Ok(Type::Function(Box::new(new_input), Box::new(new_output)))
            }
            Type::DependentFunction(param, param_type, body_type) => {
                if param == var {
                    Ok(t.clone())
                } else {
                    let new_param_type = self.substitute_type(param_type, var, replacement)?;
                    let new_body_type = self.substitute_type(body_type, var, replacement)?;
                    Ok(Type::DependentFunction(
                        param.clone(),
                        Box::new(new_param_type),
                        Box::new(new_body_type),
                    ))
                }
            }
            Type::DependentPair(param, first_type, second_type) => {
                if param == var {
                    Ok(t.clone())
                } else {
                    let new_first_type = self.substitute_type(first_type, var, replacement)?;
                    let new_second_type = self.substitute_type(second_type, var, replacement)?;
                    Ok(Type::DependentPair(
                        param.clone(),
                        Box::new(new_first_type),
                        Box::new(new_second_type),
                    ))
                }
            }
        }
    }
}

#[derive(Debug, Clone)]
pub enum Term {
    Variable(String),
    Lambda(String, Type, Box<Term>),
    Application(Box<Term>, Box<Term>),
    DependentLambda(String, Type, Box<Term>),
    DependentApplication(Box<Term>, Box<Term>),
}
```

### 2.5.2 å½’çº³ç±»å‹å®ç° (Inductive Type Implementation)

```rust
/// å½’çº³ç±»å‹å®ç° / Inductive Type Implementation
pub struct InductiveTypeSystem;

impl InductiveTypeSystem {
    /// è‡ªç„¶æ•°ç±»å‹ / Natural number type
    pub fn define_nat() -> TypeDefinition {
        TypeDefinition {
            name: "Nat".to_string(),
            constructors: vec![
                Constructor {
                    name: "Zero".to_string(),
                    arguments: vec![],
                },
                Constructor {
                    name: "Succ".to_string(),
                    arguments: vec![Type::Variable("Nat".to_string())],
                },
            ],
        }
    }

    /// åˆ—è¡¨ç±»å‹ / List type
    pub fn define_list() -> TypeDefinition {
        TypeDefinition {
            name: "List".to_string(),
            constructors: vec![
                Constructor {
                    name: "Nil".to_string(),
                    arguments: vec![],
                },
                Constructor {
                    name: "Cons".to_string(),
                    arguments: vec![
                        Type::Variable("A".to_string()),
                        Type::Variable("List".to_string()),
                    ],
                },
            ],
        }
    }

    /// å‘é‡ç±»å‹ / Vector type
    pub fn define_vector() -> TypeDefinition {
        TypeDefinition {
            name: "Vector".to_string(),
            constructors: vec![
                Constructor {
                    name: "VNil".to_string(),
                    arguments: vec![],
                },
                Constructor {
                    name: "VCons".to_string(),
                    arguments: vec![
                        Type::Variable("A".to_string()),
                        Type::Variable("Vector".to_string()),
                    ],
                },
            ],
        }
    }
}
```

### 2.5.3 ä¾èµ–ç±»å‹æµ‹è¯• (Dependent Type Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_type_checking() {
        let mut checker = DependentTypeChecker::new();

        // æµ‹è¯•å˜é‡ / Test variable
        let var_term = Term::Variable("x".to_string());
        checker.context.insert("x".to_string(), Type::Bool);
        let result = checker.type_check(&var_term);
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), Type::Bool));
    }

    #[test]
    fn test_function_type_checking() {
        let mut checker = DependentTypeChecker::new();

        // æµ‹è¯•å‡½æ•°ç±»å‹ / Test function type
        let lambda_term = Term::Lambda(
            "x".to_string(),
            Type::Bool,
            Box::new(Term::Variable("x".to_string())),
        );
        let result = checker.type_check(&lambda_term);
        assert!(result.is_ok());

        if let Ok(Type::Function(input, output)) = result {
            assert!(matches!(*input, Type::Bool));
            assert!(matches!(*output, Type::Bool));
        } else {
            panic!("Expected function type");
        }
    }

    #[test]
    fn test_dependent_type_checking() {
        let mut checker = DependentTypeChecker::new();

        // æµ‹è¯•ä¾èµ–ç±»å‹ / Test dependent type
        let dep_lambda = Term::DependentLambda(
            "n".to_string(),
            Type::Nat,
            Box::new(Term::Variable("n".to_string())),
        );
        let result = checker.type_check(&dep_lambda);
        assert!(result.is_ok());

        if let Ok(Type::DependentFunction(param, param_type, body_type)) = result {
            assert_eq!(param, "n");
            assert!(matches!(*param_type, Type::Nat));
            assert!(matches!(*body_type, Type::Variable(_)));
        } else {
            panic!("Expected dependent function type");
        }
    }

    #[test]
    fn test_inductive_types() {
        // æµ‹è¯•å½’çº³ç±»å‹å®šä¹‰ / Test inductive type definitions
        let nat_def = InductiveTypeSystem::define_nat();
        assert_eq!(nat_def.name, "Nat");
        assert_eq!(nat_def.constructors.len(), 2);

        let list_def = InductiveTypeSystem::define_list();
        assert_eq!(list_def.name, "List");
        assert_eq!(list_def.constructors.len(), 2);

        let vector_def = InductiveTypeSystem::define_vector();
        assert_eq!(vector_def.name, "Vector");
        assert_eq!(vector_def.constructors.len(), 2);
    }
}
```

---

## 2.8 æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Recent Research Progress

æœ¬èŠ‚è¡¥å……ä¾èµ–ç±»å‹ç³»ç»Ÿä¸è¯æ˜åŠ©æ‰‹åœ¨ 2024-2025 å¹´çš„ä»£è¡¨æ€§è¿›å±•ï¼Œä¾¿äºå­¦ä¹ è€…è·Ÿè¸ªå‰æ²¿ã€‚

**å…ƒç†è®ºæœºæ¢°åŒ– / Metatheory Mechanization**:

- Martin-LÃ¶f ç±»å‹è®ºå…ƒç†è®ºåœ¨è¯æ˜åŠ©æ‰‹ä¸­çš„æœºæ¢°åŒ–ï¼ˆ2024ï¼‰ï¼Œç±»å‹æ£€æŸ¥å¯åˆ¤å®šæ€§ç­‰å½¢å¼åŒ–è¯æ˜ã€‚
- è¯­ä¹‰ç±»å‹å¯é æ€§æ–¹æ³•ï¼šIris æ¡†æ¶ï¼ˆ2024ï¼‰ç­‰åœ¨ Coq/Lean ä¸­çš„å¹¶å‘åˆ†ç¦»é€»è¾‘ä¸å¯é æ€§è¯æ˜ã€‚

**è¯æ˜åŠ©æ‰‹æ–°ç‰¹æ€§ / Proof Assistant Updates**:

- **Lean 4.8.0**ï¼ˆ2024 å¹´ 6 æœˆï¼‰ï¼šæ”¹è¿›çš„å®ç³»ç»Ÿã€æ€§èƒ½ä¼˜åŒ–ã€åº“æ‰©å±•ã€‚
- **Coq**ï¼šæ’åºå¤šæ€æ€§ï¼ˆSorts polymorphismï¼‰ç›¸å…³è¿›å±•ï¼ŒPOPL 2025 ç­‰é¡¶ä¼šè®ºæ–‡ã€‚
- **å®šä¹‰å±•å¼€æ§åˆ¶**ï¼šå®šä¹‰å±•å¼€æ§åˆ¶æœºåˆ¶ï¼ˆ2024-2025ï¼‰ï¼Œç”¨äºæ§åˆ¶è®¡ç®—ä¸å±•å¼€ç­–ç•¥ã€‚

**å»¶ä¼¸é˜…è¯»**ï¼šè§ [å¹´åº¦æ–‡çŒ®æ¸…å•-2024-2025](../å¹´åº¦æ–‡çŒ®æ¸…å•-2024-2025.md)ã€[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md) ç¬¬å…­èŠ‚ã€‚

---

## 2.9 å…ƒç†è®ºå½¢å¼åŒ– / Metatheory Formalization

æœ¬èŠ‚æ¦‚è¿°ä¾èµ–ç±»å‹ç³»ç»Ÿå…ƒç†è®ºåœ¨è¯æ˜åŠ©æ‰‹ä¸­çš„å½¢å¼åŒ–æ–¹æ³•ã€‚

**ç±»å‹æ£€æŸ¥å¯åˆ¤å®šæ€§ / Decidability of Type Checking**:

- åœ¨ Coq/Agda ä¸­å¯¹ç®€å•ä¾èµ–ç±»å‹ç³»ç»Ÿçš„ç±»å‹æ£€æŸ¥å¯åˆ¤å®šæ€§è¿›è¡Œå½¢å¼åŒ–è¯æ˜ã€‚
- ä¸å¼ºæ­£è§„åŒ–ã€å­ç±»å‹ç­‰æ€§è´¨åœ¨å…ƒå±‚é¢çš„ä¸€è‡´æ€§ã€‚

**å¯é æ€§è¯æ˜çš„è¯­ä¹‰æ–¹æ³• / Semantic Approaches to Soundness**:

- é€»è¾‘å…³ç³»ï¼ˆLogical Relationsï¼‰åœ¨ Coq ä¸­çš„æœºæ¢°åŒ–ã€‚
- è§„èŒƒåŒ–è¯æ˜ï¼ˆNormalization by Evaluation, NbEï¼‰çš„å½¢å¼åŒ–ã€‚

**å…ƒç†è®ºåœ¨ Coq ä¸­çš„å®è·µ**:

- ä½¿ç”¨ Coq å¯¹ Mini-TT ç­‰å°å‹ä¾èµ–ç±»å‹ç³»ç»Ÿè¿›è¡Œå…ƒç†è®ºéªŒè¯ã€‚
- ä¸ [08-å®ç°ç¤ºä¾‹/06-Coqå®ç°](../08-å®ç°ç¤ºä¾‹/06-Coqå®ç°.md)ã€[03-å½¢å¼åŒ–è¯æ˜](../03-å½¢å¼åŒ–è¯æ˜/) çš„äº¤å‰å‚è€ƒã€‚

---

## 2.6 å‚è€ƒæ–‡çŒ® / References

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature**:

1. [MartinLof1975] Martin-LÃ¶f, P. (1975). "An Intuitionistic Theory of Types: Predicative Part". *Logic Colloquium '73*, 73-118. North-Holland.
   - Martin-LÃ¶fç±»å‹è®ºçš„æ—©æœŸè®ºæ–‡ï¼Œä¾èµ–ç±»å‹ç†è®ºçš„å¥ åŸºä¹‹ä½œã€‚æœ¬æ–‡æ¡£Â§2.1-Â§2.2çš„ä¾èµ–ç±»å‹åŸºç¡€æºè‡ªæ­¤è®ºæ–‡ã€‚

2. [MartinLof1984] Martin-LÃ¶f, P. (1984). *Intuitionistic Type Theory*. Bibliopolis.
   - ç›´è§‰ä¸»ä¹‰ç±»å‹è®ºçš„ç³»ç»Ÿé˜è¿°ï¼Œä¾èµ–ç±»å‹ç†è®ºçš„æ ¸å¿ƒæ–‡çŒ®ã€‚

3. [Coquand1988] Coquand, T., & Huet, G. (1988). "The Calculus of Constructions". *Information and Computation*, 76(2-3): 95-120. DOI: 10.1016/0890-5401(88)90005-3.
   - æ„é€ æ¼”ç®—çš„å®Œæ•´æè¿°ï¼ŒCoqè¯æ˜åŠ©æ‰‹çš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£Â§2.2.1çš„æ„é€ æ¼”ç®—åŸºäºæ­¤è®ºæ–‡ã€‚

4. [Girard1972] Girard, J. Y. (1972). *InterprÃ©tation fonctionnelle et Ã©limination des coupures de l'arithmÃ©tique d'ordre supÃ©rieur*. PhD thesis, UniversitÃ© Paris 7.
   - System Fçš„å¼€åˆ›æ€§å·¥ä½œï¼Œå¤šæ€Î»æ¼”ç®—çš„åŸºç¡€ã€‚

**æ ‡å‡†æ•™æ / Standard Textbooks**:

1. [Nordstrom1990] NordstrÃ¶m, B., Petersson, K., & Smith, J. M. (1990). *Programming in Martin-LÃ¶f's Type Theory*. Oxford University Press. ISBN: 978-0198538141.
   - Martin-LÃ¶fç±»å‹è®ºçš„å®ç”¨æŒ‡å—ï¼ŒåŒ…å«å¤§é‡ç¼–ç¨‹ç¤ºä¾‹ã€‚æœ¬æ–‡æ¡£Â§2.5çš„å®ç°ç¤ºä¾‹å‚è€ƒæ­¤ä¹¦ã€‚

2. [Pierce2002] Pierce, B. C. (2002). *Types and Programming Languages*. MIT Press. ISBN: 978-0262162098.
   - ç±»å‹ä¸ç¨‹åºè®¾è®¡è¯­è¨€çš„æ ‡å‡†æ•™æï¼ŒåŒ…å«ä¾èµ–ç±»å‹çš„ä»‹ç»ã€‚

3. Harper, R. (2016). *Practical Foundations for Programming Languages* (2nd Edition). Cambridge University Press.
   - ç¨‹åºè®¾è®¡è¯­è¨€çš„å®ç”¨åŸºç¡€ï¼Œç³»ç»Ÿä»‹ç»ä¾èµ–ç±»å‹ã€‚

4. Thompson, S. (1991). *Type Theory and Functional Programming*. Addison-Wesley.
   - ç±»å‹è®ºä¸å‡½æ•°å¼ç¼–ç¨‹ï¼Œä»‹ç»ä¾èµ–ç±»å‹çš„å®ç”¨æ–¹é¢ã€‚

5. Barendregt, H. P. (1992). "Lambda Calculi with Types". *Handbook of Logic in Computer Science*, Vol. 2, 117-309.
   - ç±»å‹åŒ–Î»æ¼”ç®—çš„ç»¼åˆæ‰‹å†Œç« èŠ‚ï¼ŒåŒ…å«ä¾èµ–ç±»å‹ã€‚

**é«˜çº§ç†è®º / Advanced Theory**:

1. Reynolds, J. C. (1983). "Types, Abstraction, and Parametric Polymorphism". *Information Processing '83*, 513-523.
    - å‚æ•°åŒ–å¤šæ€å’Œç±»å‹æŠ½è±¡çš„ç†è®ºåŸºç¡€ã€‚

2. Wadler, P. (1989). "Theorems for Free!". *FPCA '89*, 347-359.
    - ä»ç±»å‹æ¨å¯¼å®šç†ï¼Œå‚æ•°åŒ–çš„é‡è¦æ€§è´¨ã€‚

**è¯æ˜åŠ©æ‰‹ä¸å®ç° / Proof Assistants and Implementation**:

1. [Coq] The Coq Development Team. *The Coq Proof Assistant*. <https://coq.inria.fr/>
    - åŸºäºæ„é€ æ¼”ç®—çš„è¯æ˜åŠ©æ‰‹ã€‚

2. [Agda] Norell, U. (2007). "Towards a Practical Programming Language Based on Dependent Type Theory". PhD thesis, Chalmers University.
    - Agdaè¯­è¨€ï¼Œä¾èµ–ç±»å‹çš„å®ç”¨åŒ–ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Dependent Type**: <https://en.wikipedia.org/wiki/Dependent_type>
   - ä¾èµ–ç±»å‹çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«åŸºæœ¬å®šä¹‰ã€ä¾èµ–ç§¯ç±»å‹å’Œä¾èµ–å’Œç±»å‹ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Type Theory**: <https://en.wikipedia.org/wiki/Type_theory>
   - ç±»å‹è®ºçš„Wikipediaæ¡ç›®ï¼Œä»‹ç»ä¾èµ–ç±»å‹è®ºåœ¨ç±»å‹ç†è®ºä¸­çš„åœ°ä½ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Calculus of Constructions**: <https://en.wikipedia.org/wiki/Calculus_of_constructions>
   - æ„é€ æ¼”ç®—çš„Wikipediaæ¡ç›®ï¼ŒCoqè¯æ˜åŠ©æ‰‹çš„ç†è®ºåŸºç¡€ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

4. **Wikipedia - Martin-LÃ¶f Type Theory**: <https://en.wikipedia.org/wiki/Martin-L%C3%B6f_type_theory>
   - Martin-LÃ¶fç±»å‹è®ºçš„Wikipediaæ¡ç›®ï¼Œä¾èµ–ç±»å‹è®ºçš„é‡è¦åŸºç¡€ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ [CITATION_STANDARD.md](../CITATION_STANDARD.md)ã€[å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md](../å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)ï¼‰ã€‚æ–‡å†…é‡‡ç”¨ [Key] æ ¼å¼å¼•ç”¨ï¼Œä¸å‚è€ƒæ–‡çŒ®åˆ—è¡¨å¯¹åº”ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§ Wikipedia ç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.2
**æœ€åæ›´æ–° / Last Updated**: 2025-02-02
**çŠ¶æ€ / Status**: å·²è¡¥å……å­¦æœ¯å¼•ç”¨ä¸æ–‡å†…å¼•ç”¨ / Academic citations and in-text references added (P1)

---

*æœ¬æ–‡æ¡£æä¾›äº†ä¾èµ–ç±»å‹è®ºçš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€ä¾èµ–ç±»å‹ç³»ç»Ÿã€ç±»å‹æ¨å¯¼ã€è¯­ä¹‰å’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
