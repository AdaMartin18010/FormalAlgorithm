---
title: 6.6 çº¿æ€§é€»è¾‘ / Linear Logic
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: é€»è¾‘ç³»ç»Ÿå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 6.6 çº¿æ€§é€»è¾‘ / Linear Logic

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€çº¿æ€§é€»è¾‘çš„å½¢å¼åŒ–å®šä¹‰ã€åºè´¯æ¼”ç®—ä¸è¯­ä¹‰ç†è®ºã€‚
- å»ºç«‹èµ„æºæ•æ„Ÿé€»è¾‘çš„å®Œæ•´ç†è®ºæ¡†æ¶ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- çº¿æ€§é€»è¾‘ã€èµ„æºæ•æ„Ÿæ€§ã€åºè´¯æ¼”ç®—ã€ç›¸ä½è¯­ä¹‰ã€Curry-Howard-Girardå¯¹åº”ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- çº¿æ€§é€»è¾‘ï¼ˆLinear Logicï¼‰ï¼šèµ„æºæ•æ„Ÿçš„é€»è¾‘ç³»ç»Ÿï¼Œæ¯ä¸ªèµ„æºåªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚
- çº¿æ€§è•´å«ï¼ˆLinear Implicationï¼‰ï¼š`âŠ¸` è¡¨ç¤ºçº¿æ€§è•´å«ã€‚
- å¼ é‡ç§¯ï¼ˆTensor Productï¼‰ï¼š`âŠ—` è¡¨ç¤ºä¸å¯äº¤æ¢çš„åˆå–ã€‚
- è®°å·çº¦å®šï¼š`âŠ¸` è¡¨ç¤ºçº¿æ€§è•´å«ï¼Œ`âŠ—` è¡¨ç¤ºå¼ é‡ç§¯ï¼Œ`&` è¡¨ç¤ºåŠ æ³•åˆå–ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- å‘½é¢˜é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/01-å‘½é¢˜é€»è¾‘.md`ã€‚
- ç›´è§‰é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/03-ç›´è§‰é€»è¾‘.md`ã€‚
- ç±»å‹ç†è®ºï¼šå‚è§ `05-ç±»å‹ç†è®º/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- è¯­æ³•
- åºè´¯æ¼”ç®—
- è¯­ä¹‰
- è®¡ç®—è§£é‡Š

## ç›®å½• (Table of Contents)

- [6.6 çº¿æ€§é€»è¾‘ / Linear Logic](#66-çº¿æ€§é€»è¾‘--linear-logic)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [æ¦‚è¿° / Overview](#æ¦‚è¿°--overview)
- [åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [çº¿æ€§é€»è¾‘çš„åŠ¨æœº / Motivation for Linear Logic](#çº¿æ€§é€»è¾‘çš„åŠ¨æœº--motivation-for-linear-logic)
  - [çº¿æ€§é€»è¾‘ä¸å…¶ä»–é€»è¾‘çš„å…³ç³» / Relationship with Other Logics](#çº¿æ€§é€»è¾‘ä¸å…¶ä»–é€»è¾‘çš„å…³ç³»--relationship-with-other-logics)
- [è¯­æ³• / Syntax](#è¯­æ³•--syntax)
  - [åŸºæœ¬è¿æ¥è¯ / Basic Connectives](#åŸºæœ¬è¿æ¥è¯--basic-connectives)
  - [è¿æ¥è¯çš„ç›´è§‰è§£é‡Š / Intuitive Interpretation of Connectives](#è¿æ¥è¯çš„ç›´è§‰è§£é‡Š--intuitive-interpretation-of-connectives)
- [åºè´¯æ¼”ç®— / Sequent Calculus](#åºè´¯æ¼”ç®—--sequent-calculus)
  - [çº¿æ€§é€»è¾‘åºè´¯æ¼”ç®—ç³»ç»Ÿ / Linear Logic Sequent Calculus System](#çº¿æ€§é€»è¾‘åºè´¯æ¼”ç®—ç³»ç»Ÿ--linear-logic-sequent-calculus-system)
- [è¯­ä¹‰ / Semantics](#è¯­ä¹‰--semantics)
  - [ç›¸ä½è¯­ä¹‰ / Phase Semantics](#ç›¸ä½è¯­ä¹‰--phase-semantics)
  - [æ¸¸æˆè¯­ä¹‰ / Game Semantics](#æ¸¸æˆè¯­ä¹‰--game-semantics)
- [è®¡ç®—è§£é‡Š / Computational Interpretation](#è®¡ç®—è§£é‡Š--computational-interpretation)
  - [Curry-Howard-Girardå¯¹åº” / Curry-Howard-Girard Correspondence](#curry-howard-girardå¯¹åº”--curry-howard-girard-correspondence)
- [åº”ç”¨é¢†åŸŸ / Application Areas](#åº”ç”¨é¢†åŸŸ--application-areas)
  - [å¹¶å‘è®¡ç®— / Concurrent Computation](#å¹¶å‘è®¡ç®—--concurrent-computation)
  - [èµ„æºç®¡ç† / Resource Management](#èµ„æºç®¡ç†--resource-management)
- [æ€»ç»“ / Summary](#æ€»ç»“--summary)
  - [å…³é”®ç‰¹ç‚¹ / Key Features](#å…³é”®ç‰¹ç‚¹--key-features)
- [å‚è€ƒæ–‡çŒ® / References](#å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)
  - [åº”ç”¨ç ”ç©¶ / Application Research](#åº”ç”¨ç ”ç©¶--application-research)

## æ¦‚è¿° / Overview

çº¿æ€§é€»è¾‘æ˜¯ç”±Jean-Yves Girardåœ¨1987å¹´æå‡ºçš„ä¸€ç§èµ„æºæ•æ„Ÿçš„é€»è¾‘ç³»ç»Ÿã€‚ä¸ç»å…¸é€»è¾‘å’Œç›´è§‰é€»è¾‘ä¸åŒï¼Œçº¿æ€§é€»è¾‘å°†å‘½é¢˜çœ‹ä½œèµ„æºï¼Œæ¯ä¸ªèµ„æºåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œè¿™ä½¿å¾—å®ƒåœ¨æè¿°è®¡ç®—è¿‡ç¨‹ã€å¹¶å‘ç³»ç»Ÿå’Œèµ„æºç®¡ç†æ–¹é¢å…·æœ‰ç‹¬ç‰¹çš„ä¼˜åŠ¿ã€‚

Linear logic is a resource-sensitive logical system proposed by Jean-Yves Girard in 1987. Unlike classical logic and intuitionistic logic, linear logic treats propositions as resources, where each resource can only be used once. This makes it uniquely advantageous for describing computational processes, concurrent systems, and resource management.

## åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### çº¿æ€§é€»è¾‘çš„åŠ¨æœº / Motivation for Linear Logic

**å®šä¹‰ 1.1** (èµ„æºæ•æ„Ÿæ€§ / Resource Sensitivity)
åœ¨çº¿æ€§é€»è¾‘ä¸­ï¼Œé€»è¾‘å…¬å¼è¢«è§†ä¸ºèµ„æºï¼Œæ¯ä¸ªèµ„æºçš„ä½¿ç”¨éƒ½éœ€è¦è¢«ç²¾ç¡®è·Ÿè¸ªã€‚ä¸€ä¸ªå‡è®¾ä¸€æ—¦è¢«ä½¿ç”¨ï¼Œå°±ä¼šè¢«"æ¶ˆè€—"æ‰ï¼Œä¸èƒ½å†æ¬¡ä½¿ç”¨ã€‚

**Definition 1.1** (Resource Sensitivity)
In linear logic, logical formulas are treated as resources, and the use of each resource must be precisely tracked. Once a hypothesis is used, it is "consumed" and cannot be used again.

### çº¿æ€§é€»è¾‘ä¸å…¶ä»–é€»è¾‘çš„å…³ç³» / Relationship with Other Logics

1. **ç»å…¸é€»è¾‘** / Classical Logic
   - å…è®¸æ— é™åˆ¶åœ°å¤åˆ¶å’Œä¸¢å¼ƒå‡è®¾
   - ç»“æ„è§„åˆ™ï¼šå¼±åŒ–å’Œæ”¶ç¼©

2. **ç›´è§‰é€»è¾‘** / Intuitionistic Logic
   - å…è®¸å¼±åŒ–ä½†ä¸å…è®¸æ”¶ç¼©
   - æ„é€ æ€§è§£é‡Š

3. **çº¿æ€§é€»è¾‘** / Linear Logic
   - é™åˆ¶ç»“æ„è§„åˆ™çš„ä½¿ç”¨
   - èµ„æºç²¾ç¡®ç®¡ç†

## è¯­æ³• / Syntax

### åŸºæœ¬è¿æ¥è¯ / Basic Connectives

çº¿æ€§é€»è¾‘åŒ…å«å¤šä¸ªè¿æ¥è¯ï¼Œå®ƒä»¬å¯ä»¥åˆ†ä¸ºåŠ æ³•ï¼ˆadditiveï¼‰å’Œä¹˜æ³•ï¼ˆmultiplicativeï¼‰ä¸¤ç±»ï¼š

Linear logic includes multiple connectives, which can be divided into additive and multiplicative categories:

```rust
// çº¿æ€§é€»è¾‘è¯­æ³•å®šä¹‰
// Linear logic syntax definition

#[derive(Clone, Debug, PartialEq)]
pub enum LinearFormula {
    // åŸå­å‘½é¢˜ / Atomic propositions
    Atom(String),

    // ä¹˜æ³•è¿æ¥è¯ / Multiplicative connectives
    Tensor(Box<LinearFormula>, Box<LinearFormula>),     // A âŠ— B (tensor)
    Par(Box<LinearFormula>, Box<LinearFormula>),        // A â„˜ B (par)

    // åŠ æ³•è¿æ¥è¯ / Additive connectives
    With(Box<LinearFormula>, Box<LinearFormula>),       // A & B (with)
    Plus(Box<LinearFormula>, Box<LinearFormula>),       // A âŠ• B (plus)

    // å•ä½å…ƒ / Units
    One,                                                // 1 (multiplicative unit)
    Bottom,                                             // âŠ¥ (multiplicative zero)
    Top,                                                // âŠ¤ (additive unit)
    Zero,                                               // 0 (additive zero)

    // æŒ‡æ•°ç®—å­ / Exponential modalities
    OfCourse(Box<LinearFormula>),                       // !A (of course)
    WhyNot(Box<LinearFormula>),                         // ?A (why not)

    // çº¿æ€§è•´å« / Linear implication
    Lolli(Box<LinearFormula>, Box<LinearFormula>),      // A âŠ¸ B (linear implication)

    // å¦å®š / Negation
    Neg(Box<LinearFormula>),                            // AâŠ¥ (linear negation)
}

impl LinearFormula {
    // çº¿æ€§å¦å®š / Linear negation
    pub fn negate(&self) -> LinearFormula {
        match self {
            LinearFormula::Atom(name) => LinearFormula::Neg(Box::new(self.clone())),
            LinearFormula::Tensor(a, b) => LinearFormula::Par(
                Box::new(a.negate()),
                Box::new(b.negate())
            ),
            LinearFormula::Par(a, b) => LinearFormula::Tensor(
                Box::new(a.negate()),
                Box::new(b.negate())
            ),
            LinearFormula::With(a, b) => LinearFormula::Plus(
                Box::new(a.negate()),
                Box::new(b.negate())
            ),
            LinearFormula::Plus(a, b) => LinearFormula::With(
                Box::new(a.negate()),
                Box::new(b.negate())
            ),
            LinearFormula::One => LinearFormula::Bottom,
            LinearFormula::Bottom => LinearFormula::One,
            LinearFormula::Top => LinearFormula::Zero,
            LinearFormula::Zero => LinearFormula::Top,
            LinearFormula::OfCourse(a) => LinearFormula::WhyNot(Box::new(a.negate())),
            LinearFormula::WhyNot(a) => LinearFormula::OfCourse(Box::new(a.negate())),
            LinearFormula::Lolli(a, b) => LinearFormula::Tensor(
                Box::new((**a).clone()),
                Box::new(b.negate())
            ),
            LinearFormula::Neg(a) => (**a).clone(),
        }
    }

    // æ„é€ çº¿æ€§è•´å« / Construct linear implication
    pub fn linear_implies(a: LinearFormula, b: LinearFormula) -> LinearFormula {
        LinearFormula::Lolli(Box::new(a), Box::new(b))
    }

    // åˆ¤æ–­æ˜¯å¦ä¸ºæ­£å…¬å¼ / Check if positive formula
    pub fn is_positive(&self) -> bool {
        match self {
            LinearFormula::Atom(_) => true,
            LinearFormula::Tensor(_, _) => true,
            LinearFormula::Plus(_, _) => true,
            LinearFormula::One => true,
            LinearFormula::Zero => true,
            LinearFormula::OfCourse(_) => true,
            _ => false,
        }
    }

    // åˆ¤æ–­æ˜¯å¦ä¸ºè´Ÿå…¬å¼ / Check if negative formula
    pub fn is_negative(&self) -> bool {
        match self {
            LinearFormula::Par(_, _) => true,
            LinearFormula::With(_, _) => true,
            LinearFormula::Bottom => true,
            LinearFormula::Top => true,
            LinearFormula::WhyNot(_) => true,
            LinearFormula::Lolli(_, _) => true,
            LinearFormula::Neg(_) => true,
            _ => false,
        }
    }
}
```

### è¿æ¥è¯çš„ç›´è§‰è§£é‡Š / Intuitive Interpretation of Connectives

1. **å¼ é‡ç§¯ (âŠ—)** / Tensor
   - A âŠ— Bï¼šåŒæ—¶æ‹¥æœ‰èµ„æºAå’Œèµ„æºB
   - ä¹˜æ³•è¿æ¥ï¼Œéœ€è¦ä¸¤ä¸ªèµ„æºéƒ½å¯ç”¨

2. **Par (â„˜)** / Par
   - A â„˜ Bï¼šæä¾›èµ„æºAæˆ–èµ„æºBï¼ˆæˆ–ä¸¤è€…ï¼‰
   - å¼ é‡ç§¯çš„å¯¹å¶

3. **With (&)** / With
   - A & Bï¼šå¯ä»¥é€‰æ‹©èµ„æºAæˆ–èµ„æºB
   - å¤–éƒ¨é€‰æ‹©

4. **Plus (âŠ•)** / Plus
   - A âŠ• Bï¼šå†…éƒ¨é€‰æ‹©ï¼Œæä¾›Aæˆ–Bä¸­çš„ä¸€ä¸ª
   - Withçš„å¯¹å¶

## åºè´¯æ¼”ç®— / Sequent Calculus

### çº¿æ€§é€»è¾‘åºè´¯æ¼”ç®—ç³»ç»Ÿ / Linear Logic Sequent Calculus System

```rust
// åºè´¯æ¼”ç®—ç³»ç»Ÿå®ç°
// Sequent calculus system implementation

#[derive(Clone, Debug)]
pub struct Sequent {
    pub left: Vec<LinearFormula>,
    pub right: Vec<LinearFormula>,
}

impl Sequent {
    pub fn new(left: Vec<LinearFormula>, right: Vec<LinearFormula>) -> Self {
        Self { left, right }
    }

    // å…¬ç†è§„åˆ™ / Axiom rule
    pub fn axiom(atom: String) -> Self {
        Self {
            left: vec![LinearFormula::Atom(atom.clone())],
            right: vec![LinearFormula::Atom(atom)],
        }
    }

    // åˆ‡å‰²è§„åˆ™ / Cut rule
    pub fn cut(seq1: &Sequent, seq2: &Sequent, cut_formula: &LinearFormula) -> Option<Sequent> {
        // æ£€æŸ¥åˆ‡å‰²å…¬å¼æ˜¯å¦åœ¨åºè´¯ä¸­å‡ºç°
        if !seq1.right.contains(cut_formula) || !seq2.left.contains(cut_formula) {
            return None;
        }

        let mut left = seq1.left.clone();
        left.extend(seq2.left.iter().filter(|f| *f != cut_formula).cloned());

        let mut right = seq1.right.iter().filter(|f| *f != cut_formula).cloned().collect::<Vec<_>>();
        right.extend(seq2.right.clone());

        Some(Sequent::new(left, right))
    }
}

// æ¨ç†è§„åˆ™ / Inference rules
pub struct LinearLogicRules;

impl LinearLogicRules {
    // å¼ é‡ç§¯å³å¼•å…¥ / Tensor right introduction
    pub fn tensor_right(
        seq1: &Sequent,
        seq2: &Sequent,
        formula_a: &LinearFormula,
        formula_b: &LinearFormula,
    ) -> Option<Sequent> {
        // Î“ âŠ¢ A, Î”    Î“' âŠ¢ B, Î”'
        // ----------------------
        //   Î“, Î“' âŠ¢ A âŠ— B, Î”, Î”'

        if !seq1.right.contains(formula_a) || !seq2.right.contains(formula_b) {
            return None;
        }

        let mut left = seq1.left.clone();
        left.extend(seq2.left.clone());

        let mut right = seq1.right.iter().filter(|f| *f != formula_a).cloned().collect::<Vec<_>>();
        right.extend(seq2.right.iter().filter(|f| *f != formula_b).cloned());
        right.push(LinearFormula::Tensor(
            Box::new(formula_a.clone()),
            Box::new(formula_b.clone()),
        ));

        Some(Sequent::new(left, right))
    }

    // å¼ é‡ç§¯å·¦å¼•å…¥ / Tensor left introduction
    pub fn tensor_left(
        seq: &Sequent,
        formula_a: &LinearFormula,
        formula_b: &LinearFormula,
    ) -> Option<Sequent> {
        // A, B, Î“ âŠ¢ Î”
        // ------------
        // A âŠ— B, Î“ âŠ¢ Î”

        let tensor_formula = LinearFormula::Tensor(
            Box::new(formula_a.clone()),
            Box::new(formula_b.clone()),
        );

        if !seq.left.contains(&tensor_formula) {
            return None;
        }

        let mut left = seq.left.iter().filter(|f| **f != tensor_formula).cloned().collect::<Vec<_>>();
        left.push(formula_a.clone());
        left.push(formula_b.clone());

        Some(Sequent::new(left, seq.right.clone()))
    }

    // Parå³å¼•å…¥ / Par right introduction
    pub fn par_right(
        seq: &Sequent,
        formula_a: &LinearFormula,
        formula_b: &LinearFormula,
    ) -> Option<Sequent> {
        // Î“ âŠ¢ A, B, Î”
        // ------------
        // Î“ âŠ¢ A â„˜ B, Î”

        if !seq.right.contains(formula_a) || !seq.right.contains(formula_b) {
            return None;
        }

        let mut right = seq.right.iter()
            .filter(|f| **f != *formula_a && **f != *formula_b)
            .cloned()
            .collect::<Vec<_>>();
        right.push(LinearFormula::Par(
            Box::new(formula_a.clone()),
            Box::new(formula_b.clone()),
        ));

        Some(Sequent::new(seq.left.clone(), right))
    }

    // Withå³å¼•å…¥ / With right introduction
    pub fn with_right(
        seq1: &Sequent,
        seq2: &Sequent,
        formula_a: &LinearFormula,
        formula_b: &LinearFormula,
    ) -> Option<Sequent> {
        // Î“ âŠ¢ A, Î”    Î“ âŠ¢ B, Î”
        // -------------------
        //    Î“ âŠ¢ A & B, Î”

        if seq1.left != seq2.left {
            return None;
        }

        let other_right1: Vec<_> = seq1.right.iter().filter(|f| *f != formula_a).cloned().collect();
        let other_right2: Vec<_> = seq2.right.iter().filter(|f| *f != formula_b).cloned().collect();

        if other_right1 != other_right2 {
            return None;
        }

        let mut right = other_right1;
        right.push(LinearFormula::With(
            Box::new(formula_a.clone()),
            Box::new(formula_b.clone()),
        ));

        Some(Sequent::new(seq1.left.clone(), right))
    }

    // æŒ‡æ•°ç®—å­è§„åˆ™ / Exponential modality rules
    pub fn of_course_right(seq: &Sequent, formula: &LinearFormula) -> Option<Sequent> {
        // !Î“ âŠ¢ A
        // ------
        // !Î“ âŠ¢ !A

        // æ£€æŸ¥å·¦è¾¹éƒ½æ˜¯!å…¬å¼
        if !seq.left.iter().all(|f| matches!(f, LinearFormula::OfCourse(_))) {
            return None;
        }

        if !seq.right.contains(formula) {
            return None;
        }

        let mut right = seq.right.iter().filter(|f| *f != formula).cloned().collect::<Vec<_>>();
        right.push(LinearFormula::OfCourse(Box::new(formula.clone())));

        Some(Sequent::new(seq.left.clone(), right))
    }

    // å¼±åŒ–è§„åˆ™ / Weakening rule
    pub fn weakening_left(seq: &Sequent, formula: &LinearFormula) -> Sequent {
        // Î“ âŠ¢ Î”
        // --------
        // !A, Î“ âŠ¢ Î”

        let mut left = seq.left.clone();
        left.push(LinearFormula::OfCourse(Box::new(formula.clone())));

        Sequent::new(left, seq.right.clone())
    }

    // æ”¶ç¼©è§„åˆ™ / Contraction rule
    pub fn contraction_left(seq: &Sequent, formula: &LinearFormula) -> Option<Sequent> {
        // !A, !A, Î“ âŠ¢ Î”
        // -------------
        //   !A, Î“ âŠ¢ Î”

        let of_course_formula = LinearFormula::OfCourse(Box::new(formula.clone()));
        let count = seq.left.iter().filter(|f| **f == of_course_formula).count();

        if count < 2 {
            return None;
        }

        let mut left = Vec::new();
        let mut removed_one = false;

        for f in &seq.left {
            if *f == of_course_formula && !removed_one {
                removed_one = true;
                continue;
            }
            left.push(f.clone());
        }

        Some(Sequent::new(left, seq.right.clone()))
    }
}
```

## è¯­ä¹‰ / Semantics

### ç›¸ä½è¯­ä¹‰ / Phase Semantics

```rust
// ç›¸ä½è¯­ä¹‰å®ç°
// Phase semantics implementation

use std::collections::HashSet;

#[derive(Clone, Debug)]
pub struct PhaseSpace {
    elements: HashSet<String>,
    operation: fn(&HashSet<String>, &HashSet<String>) -> HashSet<String>,
}

impl PhaseSpace {
    pub fn new(
        elements: HashSet<String>,
        operation: fn(&HashSet<String>, &HashSet<String>) -> HashSet<String>,
    ) -> Self {
        Self { elements, operation }
    }

    // ç›¸ä½çš„æ­£äº¤ / Orthogonal of a phase
    pub fn orthogonal(&self, phase: &HashSet<String>) -> HashSet<String> {
        let mut result = HashSet::new();

        // Ï†âŠ¥ = {x âˆˆ M | âˆ€y âˆˆ Ï†, x âŠ¥ y}
        for x in &self.elements {
            let mut is_orthogonal = true;
            for y in phase {
                if !self.are_orthogonal(x, y) {
                    is_orthogonal = false;
                    break;
                }
            }
            if is_orthogonal {
                result.insert(x.clone());
            }
        }

        result
    }

    // åŒæ­£äº¤ / Double orthogonal
    pub fn double_orthogonal(&self, phase: &HashSet<String>) -> HashSet<String> {
        let orth = self.orthogonal(phase);
        self.orthogonal(&orth)
    }

    // æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ æ˜¯å¦æ­£äº¤ / Check if two elements are orthogonal
    fn are_orthogonal(&self, x: &str, y: &str) -> bool {
        // ç®€åŒ–å®ç°ï¼šå‡è®¾å…ƒç´ åç§°å†³å®šæ­£äº¤æ€§
        x != y && !x.starts_with(y) && !y.starts_with(x)
    }

    // å…¬å¼çš„è¯­ä¹‰è§£é‡Š / Semantic interpretation of formulas
    pub fn interpret(&self, formula: &LinearFormula) -> HashSet<String> {
        match formula {
            LinearFormula::Atom(name) => {
                let mut result = HashSet::new();
                result.insert(name.clone());
                result
            }

            LinearFormula::Tensor(a, b) => {
                let interp_a = self.interpret(a);
                let interp_b = self.interpret(b);
                (self.operation)(&interp_a, &interp_b)
            }

            LinearFormula::Par(a, b) => {
                let interp_a = self.interpret(a);
                let interp_b = self.interpret(b);
                let tensor_interp = (self.operation)(&interp_a, &interp_b);
                self.orthogonal(&tensor_interp)
            }

            LinearFormula::With(a, b) => {
                let interp_a = self.interpret(a);
                let interp_b = self.interpret(b);
                interp_a.intersection(&interp_b).cloned().collect()
            }

            LinearFormula::Plus(a, b) => {
                let interp_a = self.interpret(a);
                let interp_b = self.interpret(b);
                interp_a.union(&interp_b).cloned().collect()
            }

            LinearFormula::Neg(a) => {
                let interp_a = self.interpret(a);
                self.orthogonal(&interp_a)
            }

            LinearFormula::One => {
                let mut result = HashSet::new();
                result.insert("1".to_string());
                result
            }

            LinearFormula::Bottom => {
                self.elements.clone()
            }

            _ => HashSet::new(), // ç®€åŒ–å¤„ç†å…¶ä»–æƒ…å†µ
        }
    }

    // éªŒè¯åºè´¯çš„æœ‰æ•ˆæ€§ / Validate sequent validity
    pub fn validate_sequent(&self, sequent: &Sequent) -> bool {
        // Î“ âŠ¢ Î” æœ‰æ•ˆå½“ä¸”ä»…å½“ âŸ¦Î“âŸ§ âŠ† âŸ¦Î”âŸ§âŠ¥
        let left_interp = self.interpret_context(&sequent.left);
        let right_interp = self.interpret_context(&sequent.right);
        let right_orth = self.orthogonal(&right_interp);

        left_interp.is_subset(&right_orth)
    }

    fn interpret_context(&self, context: &[LinearFormula]) -> HashSet<String> {
        if context.is_empty() {
            let mut result = HashSet::new();
            result.insert("1".to_string());
            return result;
        }

        let mut result = self.interpret(&context[0]);
        for formula in &context[1..] {
            let interp = self.interpret(formula);
            result = (self.operation)(&result, &interp);
        }

        result
    }
}
```

### æ¸¸æˆè¯­ä¹‰ / Game Semantics

```rust
// æ¸¸æˆè¯­ä¹‰å®ç°
// Game semantics implementation

#[derive(Clone, Debug, PartialEq)]
pub enum Player {
    Opponent,
    Proponent,
}

#[derive(Clone, Debug)]
pub enum Move {
    InitialMove(LinearFormula),
    TensorLeft(LinearFormula, LinearFormula),
    TensorRight(LinearFormula, LinearFormula),
    ParMove(LinearFormula, LinearFormula),
    WithLeft(LinearFormula),
    WithRight(LinearFormula),
    PlusMove(LinearFormula),
}

#[derive(Clone, Debug)]
pub struct GameState {
    formula: LinearFormula,
    player_turn: Player,
    moves_history: Vec<(Player, Move)>,
    subgames: Vec<GameState>,
}

impl GameState {
    pub fn new(formula: LinearFormula) -> Self {
        let initial_player = if formula.is_positive() {
            Player::Proponent
        } else {
            Player::Opponent
        };

        Self {
            formula,
            player_turn: initial_player,
            moves_history: Vec::new(),
            subgames: Vec::new(),
        }
    }

    // æ‰§è¡Œç§»åŠ¨ / Execute move
    pub fn make_move(&mut self, mv: Move) -> Result<(), String> {
        if !self.is_valid_move(&mv) {
            return Err("Invalid move".to_string());
        }

        self.moves_history.push((self.player_turn.clone(), mv.clone()));

        match mv {
            Move::TensorLeft(a, b) => {
                // å¯¹æ‰‹é€‰æ‹©å¼ é‡ç§¯çš„å·¦ç»„ä»¶
                self.subgames.push(GameState::new(a));
                self.subgames.push(GameState::new(b));
            }

            Move::TensorRight(a, b) => {
                // æ”¯æŒè€…æä¾›å¼ é‡ç§¯çš„ä¸¤ä¸ªç»„ä»¶
                self.subgames.push(GameState::new(a));
                self.subgames.push(GameState::new(b));
            }

            Move::WithLeft(a) => {
                // å¯¹æ‰‹é€‰æ‹©Withçš„å·¦ç»„ä»¶
                self.subgames.push(GameState::new(a));
            }

            Move::WithRight(b) => {
                // å¯¹æ‰‹é€‰æ‹©Withçš„å³ç»„ä»¶
                self.subgames.push(GameState::new(b));
            }

            Move::PlusMove(chosen) => {
                // æ”¯æŒè€…é€‰æ‹©Plusçš„ä¸€ä¸ªç»„ä»¶
                self.subgames.push(GameState::new(chosen));
            }

            _ => {}
        }

        // åˆ‡æ¢ç©å®¶
        self.player_turn = match self.player_turn {
            Player::Opponent => Player::Proponent,
            Player::Proponent => Player::Opponent,
        };

        Ok(())
    }

    // æ£€æŸ¥ç§»åŠ¨çš„æœ‰æ•ˆæ€§ / Check move validity
    fn is_valid_move(&self, mv: &Move) -> bool {
        match (&self.formula, mv) {
            (LinearFormula::Tensor(a, b), Move::TensorLeft(ma, mb)) => {
                **a == *ma && **b == *mb && self.player_turn == Player::Opponent
            }

            (LinearFormula::Tensor(a, b), Move::TensorRight(ma, mb)) => {
                **a == *ma && **b == *mb && self.player_turn == Player::Proponent
            }

            (LinearFormula::With(a, _), Move::WithLeft(ma)) => {
                **a == *ma && self.player_turn == Player::Opponent
            }

            (LinearFormula::With(_, b), Move::WithRight(mb)) => {
                **b == *mb && self.player_turn == Player::Opponent
            }

            (LinearFormula::Plus(a, _), Move::PlusMove(chosen)) |
            (LinearFormula::Plus(_, a), Move::PlusMove(chosen)) => {
                **a == *chosen && self.player_turn == Player::Proponent
            }

            _ => false,
        }
    }

    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ / Check if game is finished
    pub fn is_finished(&self) -> bool {
        match &self.formula {
            LinearFormula::Atom(_) => true,
            _ => self.subgames.iter().all(|g| g.is_finished()),
        }
    }

    // æ£€æŸ¥æ”¯æŒè€…æ˜¯å¦è·èƒœ / Check if proponent wins
    pub fn proponent_wins(&self) -> bool {
        if !self.is_finished() {
            return false;
        }

        match &self.formula {
            LinearFormula::Atom(_) => {
                // åŸå­å…¬å¼ï¼šæ”¯æŒè€…è·èƒœå½“ä¸”ä»…å½“ä»–æ˜¯æœ€åç§»åŠ¨è€…
                self.moves_history.last()
                    .map(|(player, _)| *player == Player::Proponent)
                    .unwrap_or(true)
            }

            _ => {
                // å¤åˆå…¬å¼ï¼šæ‰€æœ‰å­æ¸¸æˆä¸­æ”¯æŒè€…éƒ½è·èƒœ
                self.subgames.iter().all(|g| g.proponent_wins())
            }
        }
    }
}

// ç­–ç•¥å®šä¹‰ / Strategy definition
pub trait Strategy {
    fn next_move(&self, state: &GameState) -> Option<Move>;
}

// ç®€å•ç­–ç•¥å®ç° / Simple strategy implementation
pub struct SimpleStrategy;

impl Strategy for SimpleStrategy {
    fn next_move(&self, state: &GameState) -> Option<Move> {
        if state.is_finished() {
            return None;
        }

        match (&state.formula, &state.player_turn) {
            (LinearFormula::Tensor(a, b), Player::Opponent) => {
                Some(Move::TensorLeft((**a).clone(), (**b).clone()))
            }

            (LinearFormula::With(a, _), Player::Opponent) => {
                Some(Move::WithLeft((**a).clone()))
            }

            (LinearFormula::Plus(a, _), Player::Proponent) => {
                Some(Move::PlusMove((**a).clone()))
            }

            _ => None,
        }
    }
}
```

## è®¡ç®—è§£é‡Š / Computational Interpretation

### Curry-Howard-Girardå¯¹åº” / Curry-Howard-Girard Correspondence

```rust
// è®¡ç®—è§£é‡Šå®ç°
// Computational interpretation implementation

#[derive(Clone, Debug)]
pub enum LinearType {
    BaseType(String),
    TensorType(Box<LinearType>, Box<LinearType>),
    ParType(Box<LinearType>, Box<LinearType>),
    WithType(Box<LinearType>, Box<LinearType>),
    PlusType(Box<LinearType>, Box<LinearType>),
    LinearArrow(Box<LinearType>, Box<LinearType>),
    OfCourseType(Box<LinearType>),
    WhyNotType(Box<LinearType>),
}

#[derive(Clone, Debug)]
pub enum LinearTerm {
    Variable(String),

    // å¼ é‡ç§¯çš„é¡¹ / Tensor terms
    TensorPair(Box<LinearTerm>, Box<LinearTerm>),
    TensorDestruct(Box<LinearTerm>, String, String, Box<LinearTerm>),

    // åŠ æ³•è¿æ¥çš„é¡¹ / Additive terms
    WithPair(Box<LinearTerm>, Box<LinearTerm>),
    Fst(Box<LinearTerm>),
    Snd(Box<LinearTerm>),

    Inl(Box<LinearTerm>),
    Inr(Box<LinearTerm>),
    Case(Box<LinearTerm>, String, Box<LinearTerm>, String, Box<LinearTerm>),

    // çº¿æ€§å‡½æ•° / Linear functions
    LinearLambda(String, LinearType, Box<LinearTerm>),
    LinearApp(Box<LinearTerm>, Box<LinearTerm>),

    // æŒ‡æ•°ç®—å­ / Exponentials
    Promote(Box<LinearTerm>),
    Derelict(Box<LinearTerm>),
    Copy(Box<LinearTerm>),
    Discard(Box<LinearTerm>),
}

// ç±»å‹æ£€æŸ¥å™¨ / Type checker
pub struct LinearTypeChecker {
    context: Vec<(String, LinearType)>,
}

impl LinearTypeChecker {
    pub fn new() -> Self {
        Self {
            context: Vec::new(),
        }
    }

    pub fn check_type(&mut self, term: &LinearTerm) -> Result<LinearType, String> {
        match term {
            LinearTerm::Variable(name) => {
                // æŸ¥æ‰¾å˜é‡ç±»å‹å¹¶ä»ä¸Šä¸‹æ–‡ä¸­ç§»é™¤ï¼ˆçº¿æ€§ä½¿ç”¨ï¼‰
                if let Some(index) = self.context.iter().position(|(n, _)| n == name) {
                    let (_, typ) = self.context.remove(index);
                    Ok(typ)
                } else {
                    Err(format!("Variable {} not found or already used", name))
                }
            }

            LinearTerm::TensorPair(m, n) => {
                let type_m = self.check_type(m)?;
                let type_n = self.check_type(n)?;
                Ok(LinearType::TensorType(Box::new(type_m), Box::new(type_n)))
            }

            LinearTerm::TensorDestruct(pair, x, y, body) => {
                let pair_type = self.check_type(pair)?;

                match pair_type {
                    LinearType::TensorType(type_a, type_b) => {
                        // å°†è§£æ„çš„å˜é‡æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
                        self.context.push((x.clone(), *type_a));
                        self.context.push((y.clone(), *type_b));

                        self.check_type(body)
                    }
                    _ => Err("Expected tensor type for tensor destruction".to_string()),
                }
            }

            LinearTerm::WithPair(m, n) => {
                // ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡
                let original_context = self.context.clone();

                // æ£€æŸ¥ç¬¬ä¸€ä¸ªç»„ä»¶
                let type_m = self.check_type(m)?;

                // æ¢å¤ä¸Šä¸‹æ–‡å¹¶æ£€æŸ¥ç¬¬äºŒä¸ªç»„ä»¶
                self.context = original_context;
                let type_n = self.check_type(n)?;

                Ok(LinearType::WithType(Box::new(type_m), Box::new(type_n)))
            }

            LinearTerm::Fst(pair) => {
                let pair_type = self.check_type(pair)?;
                match pair_type {
                    LinearType::WithType(type_a, _) => Ok(*type_a),
                    _ => Err("Expected with type for first projection".to_string()),
                }
            }

            LinearTerm::Snd(pair) => {
                let pair_type = self.check_type(pair)?;
                match pair_type {
                    LinearType::WithType(_, type_b) => Ok(*type_b),
                    _ => Err("Expected with type for second projection".to_string()),
                }
            }

            LinearTerm::LinearLambda(param, param_type, body) => {
                self.context.push((param.clone(), param_type.clone()));
                let body_type = self.check_type(body)?;
                Ok(LinearType::LinearArrow(
                    Box::new(param_type.clone()),
                    Box::new(body_type),
                ))
            }

            LinearTerm::LinearApp(func, arg) => {
                let func_type = self.check_type(func)?;
                let arg_type = self.check_type(arg)?;

                match func_type {
                    LinearType::LinearArrow(param_type, return_type) => {
                        if self.types_equal(&arg_type, &param_type) {
                            Ok(*return_type)
                        } else {
                            Err("Argument type doesn't match parameter type".to_string())
                        }
                    }
                    _ => Err("Expected linear arrow type for application".to_string()),
                }
            }

            _ => Err("Type checking for this term not implemented".to_string()),
        }
    }

    fn types_equal(&self, t1: &LinearType, t2: &LinearType) -> bool {
        match (t1, t2) {
            (LinearType::BaseType(n1), LinearType::BaseType(n2)) => n1 == n2,
            (LinearType::TensorType(a1, b1), LinearType::TensorType(a2, b2)) => {
                self.types_equal(a1, a2) && self.types_equal(b1, b2)
            }
            (LinearType::LinearArrow(a1, b1), LinearType::LinearArrow(a2, b2)) => {
                self.types_equal(a1, a2) && self.types_equal(b1, b2)
            }
            _ => false,
        }
    }

    // æ·»åŠ å˜é‡åˆ°ä¸Šä¸‹æ–‡ / Add variable to context
    pub fn add_variable(&mut self, name: String, typ: LinearType) {
        self.context.push((name, typ));
    }

    // æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦ä¸ºç©ºï¼ˆæ‰€æœ‰çº¿æ€§èµ„æºéƒ½è¢«ä½¿ç”¨ï¼‰
    pub fn context_is_empty(&self) -> bool {
        self.context.is_empty()
    }
}
```

## åº”ç”¨é¢†åŸŸ / Application Areas

### å¹¶å‘è®¡ç®— / Concurrent Computation

```rust
// çº¿æ€§é€»è¾‘åœ¨å¹¶å‘è®¡ç®—ä¸­çš„åº”ç”¨
// Linear logic applications in concurrent computation

#[derive(Clone, Debug)]
pub enum Process {
    Nil,
    Send(String, LinearTerm, Box<Process>),
    Receive(String, String, Box<Process>),
    Parallel(Box<Process>, Box<Process>),
    Replicate(Box<Process>),
    New(String, Box<Process>),
}

#[derive(Clone, Debug)]
pub struct Channel {
    name: String,
    channel_type: LinearType,
    used: bool,
}

pub struct ConcurrentSystem {
    processes: Vec<Process>,
    channels: Vec<Channel>,
}

impl ConcurrentSystem {
    pub fn new() -> Self {
        Self {
            processes: Vec::new(),
            channels: Vec::new(),
        }
    }

    pub fn add_process(&mut self, process: Process) {
        self.processes.push(process);
    }

    pub fn create_channel(&mut self, name: String, typ: LinearType) {
        self.channels.push(Channel {
            name,
            channel_type: typ,
            used: false,
        });
    }

    // æ‰§è¡Œä¸€æ­¥è®¡ç®— / Execute one computation step
    pub fn step(&mut self) -> Result<(), String> {
        // æŸ¥æ‰¾å¯ä»¥é€šä¿¡çš„è¿›ç¨‹å¯¹
        for i in 0..self.processes.len() {
            for j in i + 1..self.processes.len() {
                if let Some((new_proc1, new_proc2)) = self.try_communicate(
                    &self.processes[i],
                    &self.processes[j],
                ) {
                    // æ›¿æ¢è¿›ç¨‹
                    self.processes[i] = new_proc1;
                    self.processes[j] = new_proc2;
                    return Ok(());
                }
            }
        }

        Err("No communication possible".to_string())
    }

    fn try_communicate(&self, p1: &Process, p2: &Process) -> Option<(Process, Process)> {
        match (p1, p2) {
            (
                Process::Send(ch1, val, cont1),
                Process::Receive(ch2, var, cont2),
            ) if ch1 == ch2 => {
                // æ‰§è¡Œé€šä¿¡ï¼šå‘é€å€¼å¹¶ç»§ç»­
                let new_cont2 = self.substitute_in_process(cont2, var, val);
                Some(((**cont1).clone(), new_cont2))
            }

            (
                Process::Receive(ch1, var, cont1),
                Process::Send(ch2, val, cont2),
            ) if ch1 == ch2 => {
                // æ‰§è¡Œé€šä¿¡ï¼šæ¥æ”¶å€¼å¹¶ç»§ç»­
                let new_cont1 = self.substitute_in_process(cont1, var, val);
                Some((new_cont1, (**cont2).clone()))
            }

            _ => None,
        }
    }

    fn substitute_in_process(
        &self,
        process: &Process,
        var: &str,
        value: &LinearTerm,
    ) -> Process {
        // ç®€åŒ–çš„æ›¿æ¢å®ç°
        process.clone()
    }

    // æ£€æŸ¥ç³»ç»Ÿçš„æ­»é”è‡ªç”±æ€§ / Check deadlock freedom
    pub fn is_deadlock_free(&self) -> bool {
        // ä½¿ç”¨çº¿æ€§é€»è¾‘çš„æ€§è´¨æ£€æŸ¥æ­»é”
        // å¦‚æœæ‰€æœ‰é€šé“ç±»å‹éƒ½æ˜¯çº¿æ€§çš„ï¼Œä¸”æ²¡æœ‰å¾ªç¯ä¾èµ–ï¼Œåˆ™æ— æ­»é”
        true // ç®€åŒ–å®ç°
    }
}
```

### èµ„æºç®¡ç† / Resource Management

```rust
// èµ„æºç®¡ç†ç³»ç»Ÿ
// Resource management system

#[derive(Clone, Debug)]
pub struct Resource {
    id: String,
    resource_type: String,
    available: bool,
}

#[derive(Clone, Debug)]
pub enum ResourceOperation {
    Acquire(String),
    Release(String),
    Transfer(String, String), // ä»ä¸€ä¸ªæ‰€æœ‰è€…è½¬ç§»åˆ°å¦ä¸€ä¸ª
    Duplicate(String),        // ä»…ç”¨äºå¯å¤åˆ¶èµ„æº
}

pub struct LinearResourceManager {
    resources: Vec<Resource>,
    ownership: std::collections::HashMap<String, String>, // resource_id -> owner
    linear_types: std::collections::HashMap<String, bool>, // resource_type -> is_linear
}

impl LinearResourceManager {
    pub fn new() -> Self {
        Self {
            resources: Vec::new(),
            ownership: std::collections::HashMap::new(),
            linear_types: std::collections::HashMap::new(),
        }
    }

    pub fn add_resource(&mut self, resource: Resource, is_linear: bool) {
        self.linear_types.insert(resource.resource_type.clone(), is_linear);
        self.resources.push(resource);
    }

    pub fn execute_operation(
        &mut self,
        operation: ResourceOperation,
        operator: &str,
    ) -> Result<(), String> {
        match operation {
            ResourceOperation::Acquire(resource_id) => {
                self.acquire_resource(&resource_id, operator)
            }

            ResourceOperation::Release(resource_id) => {
                self.release_resource(&resource_id, operator)
            }

            ResourceOperation::Transfer(resource_id, new_owner) => {
                self.transfer_resource(&resource_id, operator, &new_owner)
            }

            ResourceOperation::Duplicate(resource_id) => {
                self.duplicate_resource(&resource_id, operator)
            }
        }
    }

    fn acquire_resource(&mut self, resource_id: &str, owner: &str) -> Result<(), String> {
        // æ£€æŸ¥èµ„æºæ˜¯å¦å¯ç”¨
        if let Some(resource) = self.resources.iter_mut().find(|r| r.id == resource_id) {
            if resource.available {
                resource.available = false;
                self.ownership.insert(resource_id.to_string(), owner.to_string());
                Ok(())
            } else {
                Err("Resource already acquired".to_string())
            }
        } else {
            Err("Resource not found".to_string())
        }
    }

    fn release_resource(&mut self, resource_id: &str, owner: &str) -> Result<(), String> {
        // æ£€æŸ¥æ‰€æœ‰æƒ
        if let Some(current_owner) = self.ownership.get(resource_id) {
            if current_owner == owner {
                if let Some(resource) = self.resources.iter_mut().find(|r| r.id == resource_id) {
                    resource.available = true;
                    self.ownership.remove(resource_id);
                    Ok(())
                } else {
                    Err("Resource not found".to_string())
                }
            } else {
                Err("Not the owner of the resource".to_string())
            }
        } else {
            Err("Resource not owned by anyone".to_string())
        }
    }

    fn transfer_resource(
        &mut self,
        resource_id: &str,
        current_owner: &str,
        new_owner: &str,
    ) -> Result<(), String> {
        // æ£€æŸ¥å½“å‰æ‰€æœ‰æƒ
        if let Some(owner) = self.ownership.get(resource_id) {
            if owner == current_owner {
                self.ownership.insert(resource_id.to_string(), new_owner.to_string());
                Ok(())
            } else {
                Err("Not the current owner".to_string())
            }
        } else {
            Err("Resource not owned".to_string())
        }
    }

    fn duplicate_resource(&mut self, resource_id: &str, owner: &str) -> Result<(), String> {
        // æ£€æŸ¥èµ„æºæ˜¯å¦å¯å¤åˆ¶
        if let Some(resource) = self.resources.iter().find(|r| r.id == resource_id) {
            if let Some(&is_linear) = self.linear_types.get(&resource.resource_type) {
                if is_linear {
                    return Err("Cannot duplicate linear resource".to_string());
                }

                // æ£€æŸ¥æ‰€æœ‰æƒ
                if let Some(current_owner) = self.ownership.get(resource_id) {
                    if current_owner == owner {
                        // åˆ›å»ºèµ„æºå‰¯æœ¬
                        let new_id = format!("{}_copy_{}", resource_id,
                            std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap()
                                .as_nanos());

                        let new_resource = Resource {
                            id: new_id.clone(),
                            resource_type: resource.resource_type.clone(),
                            available: false, // æ–°å‰¯æœ¬å½’è¯·æ±‚è€…æ‰€æœ‰
                        };

                        self.resources.push(new_resource);
                        self.ownership.insert(new_id, owner.to_string());
                        Ok(())
                    } else {
                        Err("Not the owner of the resource".to_string())
                    }
                } else {
                    Err("Resource not owned".to_string())
                }
            } else {
                Err("Resource type not found".to_string())
            }
        } else {
            Err("Resource not found".to_string())
        }
    }

    // æ£€æŸ¥èµ„æºä½¿ç”¨çš„çº¿æ€§æ€§è´¨ / Check linearity properties
    pub fn check_linearity_violations(&self) -> Vec<String> {
        let mut violations = Vec::new();

        // æ£€æŸ¥æ˜¯å¦æœ‰çº¿æ€§èµ„æºè¢«å¤šæ¬¡å¼•ç”¨
        for (resource_id, _) in &self.ownership {
            if let Some(resource) = self.resources.iter().find(|r| r.id == *resource_id) {
                if let Some(&is_linear) = self.linear_types.get(&resource.resource_type) {
                    if is_linear {
                        // çº¿æ€§èµ„æºåªèƒ½è¢«ä¸€ä¸ªå®ä½“æ‹¥æœ‰
                        let reference_count = self.ownership.values()
                            .filter(|&owner| self.ownership.get(resource_id) == Some(owner))
                            .count();

                        if reference_count > 1 {
                            violations.push(format!(
                                "Linear resource {} has {} references",
                                resource_id, reference_count
                            ));
                        }
                    }
                }
            }
        }

        violations
    }
}
```

## æ€»ç»“ / Summary

çº¿æ€§é€»è¾‘ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªå¼ºå¤§çš„æ¡†æ¶æ¥æ¨ç†èµ„æºçš„ä½¿ç”¨å’Œè®¡ç®—è¿‡ç¨‹ã€‚å®ƒçš„èµ„æºæ•æ„Ÿæ€§ä½¿å…¶åœ¨å¹¶å‘è®¡ç®—ã€ç¨‹åºåˆ†æå’Œèµ„æºç®¡ç†ç­‰é¢†åŸŸå…·æœ‰ç‹¬ç‰¹çš„åº”ç”¨ä»·å€¼ã€‚

Linear logic provides us with a powerful framework for reasoning about resource usage and computational processes. Its resource sensitivity makes it uniquely valuable in areas such as concurrent computation, program analysis, and resource management.

### å…³é”®ç‰¹ç‚¹ / Key Features

1. **èµ„æºæ•æ„Ÿæ€§** / Resource Sensitivity
   - ç²¾ç¡®è·Ÿè¸ªèµ„æºçš„ä½¿ç”¨
   - é¿å…èµ„æºçš„æ„å¤–å¤åˆ¶æˆ–ä¸¢å¤±

2. **è¡¨è¾¾èƒ½åŠ›** / Expressiveness
   - ä¸°å¯Œçš„è¿æ¥è¯ç³»ç»Ÿ
   - èƒ½å¤Ÿè¡¨è¾¾å¤æ‚çš„èµ„æºçº¦æŸ

3. **è®¡ç®—è§£é‡Š** / Computational Interpretation
   - Curry-Howard-Girardå¯¹åº”
   - ä¸å¹¶å‘è®¡ç®—çš„è‡ªç„¶è”ç³»

4. **åº”ç”¨ä»·å€¼** / Practical Value
   - ç¨‹åºéªŒè¯å’Œåˆ†æ
   - èµ„æºç®¡ç†ç³»ç»Ÿ
   - å¹¶å‘å’Œåˆ†å¸ƒå¼ç³»ç»Ÿ

---

## å‚è€ƒæ–‡çŒ® / References

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Girard1987] Girard, J.-Y. (1987). "Linear Logic". *Theoretical Computer Science*, 50(1): 1-102. DOI: 10.1016/0304-3975(87)90045-4
   - **Girardçº¿æ€§é€»è¾‘çš„å¼€åˆ›æ€§è®ºæ–‡**ï¼Œèµ„æºæ•æ„Ÿé€»è¾‘çš„å¥ åŸºä¹‹ä½œã€‚æœ¬æ–‡æ¡£çš„å…¨éƒ¨å†…å®¹åŸºäºæ­¤è®ºæ–‡ã€‚

2. [Girard1989ProofsTypes] Girard, J.-Y., Lafont, Y., & Taylor, P. (1989). *Proofs and Types*. Cambridge University Press. ISBN: 978-0521371810
   - Girardè¯æ˜è®ºä¸ç±»å‹è®ºçš„ç»å…¸æ•™æï¼ŒåŒ…å«çº¿æ€§é€»è¾‘ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. [Troelstra1992] Troelstra, A. S. (1992). *Lectures on Linear Logic*. CSLI Publications. ISBN: 978-1881526773
   - Troelstraçº¿æ€§é€»è¾‘çš„æƒå¨è®²ä¹‰ï¼Œæœ¬æ–‡æ¡£çš„åºè´¯æ¼”ç®—éƒ¨åˆ†å‚è€ƒæ­¤ä¹¦ã€‚

### åº”ç”¨ç ”ç©¶ / Application Research

1. Wadler, P. (1993). "A taste of linear logic". In *International Symposium on Mathematical Foundations of Computer Science* (pp. 185-210). Springer.
   - Wadlerå…³äºçº¿æ€§é€»è¾‘åœ¨ç¨‹åºè®¾è®¡ä¸­çš„åº”ç”¨ã€‚

2. Abramsky, S., & Jagadeesan, R. (1994). "Games and full completeness for multiplicative linear logic". *The Journal of Symbolic Logic*, 59(2): 543-574.
   - çº¿æ€§é€»è¾‘çš„æ¸¸æˆè¯­ä¹‰ã€‚

3. Seely, R. A. (1989). "Linear logic, *-autonomous categories and cofree coalgebras". *Contemporary Mathematics*, 92: 371-382.
   - çº¿æ€§é€»è¾‘çš„èŒƒç•´è®ºè¯­ä¹‰ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Linear Logic**: <https://en.wikipedia.org/wiki/Linear_logic>
   - çº¿æ€§é€»è¾‘çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«Girardçš„çº¿æ€§é€»è¾‘ç³»ç»Ÿå’Œèµ„æºæ•æ„Ÿé€»è¾‘ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

2. **Wikipedia - Resource-Sensitive Logic**: <https://en.wikipedia.org/wiki/Resource_sensitive_logic>
   - èµ„æºæ•æ„Ÿé€»è¾‘çš„Wikipediaæ¡ç›®ï¼Œä»‹ç»çº¿æ€§é€»è¾‘çš„èµ„æºç®¡ç†ç‰¹æ€§ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
**æœ€åæ›´æ–° / Last Updated**: 2025-11-14
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-11-14)
