# 线性逻辑 / Linear Logic

## 概述 / Overview

线性逻辑是由Jean-Yves Girard在1987年提出的一种资源敏感的逻辑系统。与经典逻辑和直觉逻辑不同，线性逻辑将命题看作资源，每个资源只能被使用一次，这使得它在描述计算过程、并发系统和资源管理方面具有独特的优势。

Linear logic is a resource-sensitive logical system proposed by Jean-Yves Girard in 1987. Unlike classical logic and intuitionistic logic, linear logic treats propositions as resources, where each resource can only be used once. This makes it uniquely advantageous for describing computational processes, concurrent systems, and resource management.

## 基本概念 / Basic Concepts

### 线性逻辑的动机 / Motivation for Linear Logic

**定义 1.1** (资源敏感性 / Resource Sensitivity)
在线性逻辑中，逻辑公式被视为资源，每个资源的使用都需要被精确跟踪。一个假设一旦被使用，就会被"消耗"掉，不能再次使用。

**Definition 1.1** (Resource Sensitivity)
In linear logic, logical formulas are treated as resources, and the use of each resource must be precisely tracked. Once a hypothesis is used, it is "consumed" and cannot be used again.

### 线性逻辑与其他逻辑的关系 / Relationship with Other Logics

1. **经典逻辑** / Classical Logic
   - 允许无限制地复制和丢弃假设
   - 结构规则：弱化和收缩

2. **直觉逻辑** / Intuitionistic Logic
   - 允许弱化但不允许收缩
   - 构造性解释

3. **线性逻辑** / Linear Logic
   - 限制结构规则的使用
   - 资源精确管理

## 语法 / Syntax

### 基本连接词 / Basic Connectives

线性逻辑包含多个连接词，它们可以分为加法（additive）和乘法（multiplicative）两类：

Linear logic includes multiple connectives, which can be divided into additive and multiplicative categories:

```rust
// 线性逻辑语法定义
// Linear logic syntax definition

#[derive(Clone, Debug, PartialEq)]
pub enum LinearFormula {
    // 原子命题 / Atomic propositions
    Atom(String),
    
    // 乘法连接词 / Multiplicative connectives
    Tensor(Box<LinearFormula>, Box<LinearFormula>),     // A ⊗ B (tensor)
    Par(Box<LinearFormula>, Box<LinearFormula>),        // A ℘ B (par)
    
    // 加法连接词 / Additive connectives
    With(Box<LinearFormula>, Box<LinearFormula>),       // A & B (with)
    Plus(Box<LinearFormula>, Box<LinearFormula>),       // A ⊕ B (plus)
    
    // 单位元 / Units
    One,                                                // 1 (multiplicative unit)
    Bottom,                                             // ⊥ (multiplicative zero)
    Top,                                                // ⊤ (additive unit)
    Zero,                                               // 0 (additive zero)
    
    // 指数算子 / Exponential modalities
    OfCourse(Box<LinearFormula>),                       // !A (of course)
    WhyNot(Box<LinearFormula>),                         // ?A (why not)
    
    // 线性蕴含 / Linear implication
    Lolli(Box<LinearFormula>, Box<LinearFormula>),      // A ⊸ B (linear implication)
    
    // 否定 / Negation
    Neg(Box<LinearFormula>),                            // A⊥ (linear negation)
}

impl LinearFormula {
    // 线性否定 / Linear negation
    pub fn negate(&self) -> LinearFormula {
        match self {
            LinearFormula::Atom(name) => LinearFormula::Neg(Box::new(self.clone())),
            LinearFormula::Tensor(a, b) => LinearFormula::Par(
                Box::new(a.negate()),
                Box::new(b.negate())
            ),
            LinearFormula::Par(a, b) => LinearFormula::Tensor(
                Box::new(a.negate()),
                Box::new(b.negate())
            ),
            LinearFormula::With(a, b) => LinearFormula::Plus(
                Box::new(a.negate()),
                Box::new(b.negate())
            ),
            LinearFormula::Plus(a, b) => LinearFormula::With(
                Box::new(a.negate()),
                Box::new(b.negate())
            ),
            LinearFormula::One => LinearFormula::Bottom,
            LinearFormula::Bottom => LinearFormula::One,
            LinearFormula::Top => LinearFormula::Zero,
            LinearFormula::Zero => LinearFormula::Top,
            LinearFormula::OfCourse(a) => LinearFormula::WhyNot(Box::new(a.negate())),
            LinearFormula::WhyNot(a) => LinearFormula::OfCourse(Box::new(a.negate())),
            LinearFormula::Lolli(a, b) => LinearFormula::Tensor(
                Box::new((**a).clone()),
                Box::new(b.negate())
            ),
            LinearFormula::Neg(a) => (**a).clone(),
        }
    }
    
    // 构造线性蕴含 / Construct linear implication
    pub fn linear_implies(a: LinearFormula, b: LinearFormula) -> LinearFormula {
        LinearFormula::Lolli(Box::new(a), Box::new(b))
    }
    
    // 判断是否为正公式 / Check if positive formula
    pub fn is_positive(&self) -> bool {
        match self {
            LinearFormula::Atom(_) => true,
            LinearFormula::Tensor(_, _) => true,
            LinearFormula::Plus(_, _) => true,
            LinearFormula::One => true,
            LinearFormula::Zero => true,
            LinearFormula::OfCourse(_) => true,
            _ => false,
        }
    }
    
    // 判断是否为负公式 / Check if negative formula
    pub fn is_negative(&self) -> bool {
        match self {
            LinearFormula::Par(_, _) => true,
            LinearFormula::With(_, _) => true,
            LinearFormula::Bottom => true,
            LinearFormula::Top => true,
            LinearFormula::WhyNot(_) => true,
            LinearFormula::Lolli(_, _) => true,
            LinearFormula::Neg(_) => true,
            _ => false,
        }
    }
}
```

### 连接词的直觉解释 / Intuitive Interpretation of Connectives

1. **张量积 (⊗)** / Tensor
   - A ⊗ B：同时拥有资源A和资源B
   - 乘法连接，需要两个资源都可用

2. **Par (℘)** / Par
   - A ℘ B：提供资源A或资源B（或两者）
   - 张量积的对偶

3. **With (&)** / With
   - A & B：可以选择资源A或资源B
   - 外部选择

4. **Plus (⊕)** / Plus
   - A ⊕ B：内部选择，提供A或B中的一个
   - With的对偶

## 序贯演算 / Sequent Calculus

### 线性逻辑序贯演算系统 / Linear Logic Sequent Calculus System

```rust
// 序贯演算系统实现
// Sequent calculus system implementation

#[derive(Clone, Debug)]
pub struct Sequent {
    pub left: Vec<LinearFormula>,
    pub right: Vec<LinearFormula>,
}

impl Sequent {
    pub fn new(left: Vec<LinearFormula>, right: Vec<LinearFormula>) -> Self {
        Self { left, right }
    }
    
    // 公理规则 / Axiom rule
    pub fn axiom(atom: String) -> Self {
        Self {
            left: vec![LinearFormula::Atom(atom.clone())],
            right: vec![LinearFormula::Atom(atom)],
        }
    }
    
    // 切割规则 / Cut rule
    pub fn cut(seq1: &Sequent, seq2: &Sequent, cut_formula: &LinearFormula) -> Option<Sequent> {
        // 检查切割公式是否在序贯中出现
        if !seq1.right.contains(cut_formula) || !seq2.left.contains(cut_formula) {
            return None;
        }
        
        let mut left = seq1.left.clone();
        left.extend(seq2.left.iter().filter(|f| *f != cut_formula).cloned());
        
        let mut right = seq1.right.iter().filter(|f| *f != cut_formula).cloned().collect::<Vec<_>>();
        right.extend(seq2.right.clone());
        
        Some(Sequent::new(left, right))
    }
}

// 推理规则 / Inference rules
pub struct LinearLogicRules;

impl LinearLogicRules {
    // 张量积右引入 / Tensor right introduction
    pub fn tensor_right(
        seq1: &Sequent,
        seq2: &Sequent,
        formula_a: &LinearFormula,
        formula_b: &LinearFormula,
    ) -> Option<Sequent> {
        // Γ ⊢ A, Δ    Γ' ⊢ B, Δ'
        // ----------------------
        //   Γ, Γ' ⊢ A ⊗ B, Δ, Δ'
        
        if !seq1.right.contains(formula_a) || !seq2.right.contains(formula_b) {
            return None;
        }
        
        let mut left = seq1.left.clone();
        left.extend(seq2.left.clone());
        
        let mut right = seq1.right.iter().filter(|f| *f != formula_a).cloned().collect::<Vec<_>>();
        right.extend(seq2.right.iter().filter(|f| *f != formula_b).cloned());
        right.push(LinearFormula::Tensor(
            Box::new(formula_a.clone()),
            Box::new(formula_b.clone()),
        ));
        
        Some(Sequent::new(left, right))
    }
    
    // 张量积左引入 / Tensor left introduction
    pub fn tensor_left(
        seq: &Sequent,
        formula_a: &LinearFormula,
        formula_b: &LinearFormula,
    ) -> Option<Sequent> {
        // A, B, Γ ⊢ Δ
        // ------------
        // A ⊗ B, Γ ⊢ Δ
        
        let tensor_formula = LinearFormula::Tensor(
            Box::new(formula_a.clone()),
            Box::new(formula_b.clone()),
        );
        
        if !seq.left.contains(&tensor_formula) {
            return None;
        }
        
        let mut left = seq.left.iter().filter(|f| **f != tensor_formula).cloned().collect::<Vec<_>>();
        left.push(formula_a.clone());
        left.push(formula_b.clone());
        
        Some(Sequent::new(left, seq.right.clone()))
    }
    
    // Par右引入 / Par right introduction
    pub fn par_right(
        seq: &Sequent,
        formula_a: &LinearFormula,
        formula_b: &LinearFormula,
    ) -> Option<Sequent> {
        // Γ ⊢ A, B, Δ
        // ------------
        // Γ ⊢ A ℘ B, Δ
        
        if !seq.right.contains(formula_a) || !seq.right.contains(formula_b) {
            return None;
        }
        
        let mut right = seq.right.iter()
            .filter(|f| **f != *formula_a && **f != *formula_b)
            .cloned()
            .collect::<Vec<_>>();
        right.push(LinearFormula::Par(
            Box::new(formula_a.clone()),
            Box::new(formula_b.clone()),
        ));
        
        Some(Sequent::new(seq.left.clone(), right))
    }
    
    // With右引入 / With right introduction
    pub fn with_right(
        seq1: &Sequent,
        seq2: &Sequent,
        formula_a: &LinearFormula,
        formula_b: &LinearFormula,
    ) -> Option<Sequent> {
        // Γ ⊢ A, Δ    Γ ⊢ B, Δ
        // -------------------
        //    Γ ⊢ A & B, Δ
        
        if seq1.left != seq2.left {
            return None;
        }
        
        let other_right1: Vec<_> = seq1.right.iter().filter(|f| *f != formula_a).cloned().collect();
        let other_right2: Vec<_> = seq2.right.iter().filter(|f| *f != formula_b).cloned().collect();
        
        if other_right1 != other_right2 {
            return None;
        }
        
        let mut right = other_right1;
        right.push(LinearFormula::With(
            Box::new(formula_a.clone()),
            Box::new(formula_b.clone()),
        ));
        
        Some(Sequent::new(seq1.left.clone(), right))
    }
    
    // 指数算子规则 / Exponential modality rules
    pub fn of_course_right(seq: &Sequent, formula: &LinearFormula) -> Option<Sequent> {
        // !Γ ⊢ A
        // ------
        // !Γ ⊢ !A
        
        // 检查左边都是!公式
        if !seq.left.iter().all(|f| matches!(f, LinearFormula::OfCourse(_))) {
            return None;
        }
        
        if !seq.right.contains(formula) {
            return None;
        }
        
        let mut right = seq.right.iter().filter(|f| *f != formula).cloned().collect::<Vec<_>>();
        right.push(LinearFormula::OfCourse(Box::new(formula.clone())));
        
        Some(Sequent::new(seq.left.clone(), right))
    }
    
    // 弱化规则 / Weakening rule
    pub fn weakening_left(seq: &Sequent, formula: &LinearFormula) -> Sequent {
        // Γ ⊢ Δ
        // --------
        // !A, Γ ⊢ Δ
        
        let mut left = seq.left.clone();
        left.push(LinearFormula::OfCourse(Box::new(formula.clone())));
        
        Sequent::new(left, seq.right.clone())
    }
    
    // 收缩规则 / Contraction rule
    pub fn contraction_left(seq: &Sequent, formula: &LinearFormula) -> Option<Sequent> {
        // !A, !A, Γ ⊢ Δ
        // -------------
        //   !A, Γ ⊢ Δ
        
        let of_course_formula = LinearFormula::OfCourse(Box::new(formula.clone()));
        let count = seq.left.iter().filter(|f| **f == of_course_formula).count();
        
        if count < 2 {
            return None;
        }
        
        let mut left = Vec::new();
        let mut removed_one = false;
        
        for f in &seq.left {
            if *f == of_course_formula && !removed_one {
                removed_one = true;
                continue;
            }
            left.push(f.clone());
        }
        
        Some(Sequent::new(left, seq.right.clone()))
    }
}
```

## 语义 / Semantics

### 相位语义 / Phase Semantics

```rust
// 相位语义实现
// Phase semantics implementation

use std::collections::HashSet;

#[derive(Clone, Debug)]
pub struct PhaseSpace {
    elements: HashSet<String>,
    operation: fn(&HashSet<String>, &HashSet<String>) -> HashSet<String>,
}

impl PhaseSpace {
    pub fn new(
        elements: HashSet<String>,
        operation: fn(&HashSet<String>, &HashSet<String>) -> HashSet<String>,
    ) -> Self {
        Self { elements, operation }
    }
    
    // 相位的正交 / Orthogonal of a phase
    pub fn orthogonal(&self, phase: &HashSet<String>) -> HashSet<String> {
        let mut result = HashSet::new();
        
        // φ⊥ = {x ∈ M | ∀y ∈ φ, x ⊥ y}
        for x in &self.elements {
            let mut is_orthogonal = true;
            for y in phase {
                if !self.are_orthogonal(x, y) {
                    is_orthogonal = false;
                    break;
                }
            }
            if is_orthogonal {
                result.insert(x.clone());
            }
        }
        
        result
    }
    
    // 双正交 / Double orthogonal
    pub fn double_orthogonal(&self, phase: &HashSet<String>) -> HashSet<String> {
        let orth = self.orthogonal(phase);
        self.orthogonal(&orth)
    }
    
    // 检查两个元素是否正交 / Check if two elements are orthogonal
    fn are_orthogonal(&self, x: &str, y: &str) -> bool {
        // 简化实现：假设元素名称决定正交性
        x != y && !x.starts_with(y) && !y.starts_with(x)
    }
    
    // 公式的语义解释 / Semantic interpretation of formulas
    pub fn interpret(&self, formula: &LinearFormula) -> HashSet<String> {
        match formula {
            LinearFormula::Atom(name) => {
                let mut result = HashSet::new();
                result.insert(name.clone());
                result
            }
            
            LinearFormula::Tensor(a, b) => {
                let interp_a = self.interpret(a);
                let interp_b = self.interpret(b);
                (self.operation)(&interp_a, &interp_b)
            }
            
            LinearFormula::Par(a, b) => {
                let interp_a = self.interpret(a);
                let interp_b = self.interpret(b);
                let tensor_interp = (self.operation)(&interp_a, &interp_b);
                self.orthogonal(&tensor_interp)
            }
            
            LinearFormula::With(a, b) => {
                let interp_a = self.interpret(a);
                let interp_b = self.interpret(b);
                interp_a.intersection(&interp_b).cloned().collect()
            }
            
            LinearFormula::Plus(a, b) => {
                let interp_a = self.interpret(a);
                let interp_b = self.interpret(b);
                interp_a.union(&interp_b).cloned().collect()
            }
            
            LinearFormula::Neg(a) => {
                let interp_a = self.interpret(a);
                self.orthogonal(&interp_a)
            }
            
            LinearFormula::One => {
                let mut result = HashSet::new();
                result.insert("1".to_string());
                result
            }
            
            LinearFormula::Bottom => {
                self.elements.clone()
            }
            
            _ => HashSet::new(), // 简化处理其他情况
        }
    }
    
    // 验证序贯的有效性 / Validate sequent validity
    pub fn validate_sequent(&self, sequent: &Sequent) -> bool {
        // Γ ⊢ Δ 有效当且仅当 ⟦Γ⟧ ⊆ ⟦Δ⟧⊥
        let left_interp = self.interpret_context(&sequent.left);
        let right_interp = self.interpret_context(&sequent.right);
        let right_orth = self.orthogonal(&right_interp);
        
        left_interp.is_subset(&right_orth)
    }
    
    fn interpret_context(&self, context: &[LinearFormula]) -> HashSet<String> {
        if context.is_empty() {
            let mut result = HashSet::new();
            result.insert("1".to_string());
            return result;
        }
        
        let mut result = self.interpret(&context[0]);
        for formula in &context[1..] {
            let interp = self.interpret(formula);
            result = (self.operation)(&result, &interp);
        }
        
        result
    }
}
```

### 游戏语义 / Game Semantics

```rust
// 游戏语义实现
// Game semantics implementation

#[derive(Clone, Debug, PartialEq)]
pub enum Player {
    Opponent,
    Proponent,
}

#[derive(Clone, Debug)]
pub enum Move {
    InitialMove(LinearFormula),
    TensorLeft(LinearFormula, LinearFormula),
    TensorRight(LinearFormula, LinearFormula),
    ParMove(LinearFormula, LinearFormula),
    WithLeft(LinearFormula),
    WithRight(LinearFormula),
    PlusMove(LinearFormula),
}

#[derive(Clone, Debug)]
pub struct GameState {
    formula: LinearFormula,
    player_turn: Player,
    moves_history: Vec<(Player, Move)>,
    subgames: Vec<GameState>,
}

impl GameState {
    pub fn new(formula: LinearFormula) -> Self {
        let initial_player = if formula.is_positive() {
            Player::Proponent
        } else {
            Player::Opponent
        };
        
        Self {
            formula,
            player_turn: initial_player,
            moves_history: Vec::new(),
            subgames: Vec::new(),
        }
    }
    
    // 执行移动 / Execute move
    pub fn make_move(&mut self, mv: Move) -> Result<(), String> {
        if !self.is_valid_move(&mv) {
            return Err("Invalid move".to_string());
        }
        
        self.moves_history.push((self.player_turn.clone(), mv.clone()));
        
        match mv {
            Move::TensorLeft(a, b) => {
                // 对手选择张量积的左组件
                self.subgames.push(GameState::new(a));
                self.subgames.push(GameState::new(b));
            }
            
            Move::TensorRight(a, b) => {
                // 支持者提供张量积的两个组件
                self.subgames.push(GameState::new(a));
                self.subgames.push(GameState::new(b));
            }
            
            Move::WithLeft(a) => {
                // 对手选择With的左组件
                self.subgames.push(GameState::new(a));
            }
            
            Move::WithRight(b) => {
                // 对手选择With的右组件
                self.subgames.push(GameState::new(b));
            }
            
            Move::PlusMove(chosen) => {
                // 支持者选择Plus的一个组件
                self.subgames.push(GameState::new(chosen));
            }
            
            _ => {}
        }
        
        // 切换玩家
        self.player_turn = match self.player_turn {
            Player::Opponent => Player::Proponent,
            Player::Proponent => Player::Opponent,
        };
        
        Ok(())
    }
    
    // 检查移动的有效性 / Check move validity
    fn is_valid_move(&self, mv: &Move) -> bool {
        match (&self.formula, mv) {
            (LinearFormula::Tensor(a, b), Move::TensorLeft(ma, mb)) => {
                **a == *ma && **b == *mb && self.player_turn == Player::Opponent
            }
            
            (LinearFormula::Tensor(a, b), Move::TensorRight(ma, mb)) => {
                **a == *ma && **b == *mb && self.player_turn == Player::Proponent
            }
            
            (LinearFormula::With(a, _), Move::WithLeft(ma)) => {
                **a == *ma && self.player_turn == Player::Opponent
            }
            
            (LinearFormula::With(_, b), Move::WithRight(mb)) => {
                **b == *mb && self.player_turn == Player::Opponent
            }
            
            (LinearFormula::Plus(a, _), Move::PlusMove(chosen)) |
            (LinearFormula::Plus(_, a), Move::PlusMove(chosen)) => {
                **a == *chosen && self.player_turn == Player::Proponent
            }
            
            _ => false,
        }
    }
    
    // 检查游戏是否结束 / Check if game is finished
    pub fn is_finished(&self) -> bool {
        match &self.formula {
            LinearFormula::Atom(_) => true,
            _ => self.subgames.iter().all(|g| g.is_finished()),
        }
    }
    
    // 检查支持者是否获胜 / Check if proponent wins
    pub fn proponent_wins(&self) -> bool {
        if !self.is_finished() {
            return false;
        }
        
        match &self.formula {
            LinearFormula::Atom(_) => {
                // 原子公式：支持者获胜当且仅当他是最后移动者
                self.moves_history.last()
                    .map(|(player, _)| *player == Player::Proponent)
                    .unwrap_or(true)
            }
            
            _ => {
                // 复合公式：所有子游戏中支持者都获胜
                self.subgames.iter().all(|g| g.proponent_wins())
            }
        }
    }
}

// 策略定义 / Strategy definition
pub trait Strategy {
    fn next_move(&self, state: &GameState) -> Option<Move>;
}

// 简单策略实现 / Simple strategy implementation
pub struct SimpleStrategy;

impl Strategy for SimpleStrategy {
    fn next_move(&self, state: &GameState) -> Option<Move> {
        if state.is_finished() {
            return None;
        }
        
        match (&state.formula, &state.player_turn) {
            (LinearFormula::Tensor(a, b), Player::Opponent) => {
                Some(Move::TensorLeft((**a).clone(), (**b).clone()))
            }
            
            (LinearFormula::With(a, _), Player::Opponent) => {
                Some(Move::WithLeft((**a).clone()))
            }
            
            (LinearFormula::Plus(a, _), Player::Proponent) => {
                Some(Move::PlusMove((**a).clone()))
            }
            
            _ => None,
        }
    }
}
```

## 计算解释 / Computational Interpretation

### Curry-Howard-Girard对应 / Curry-Howard-Girard Correspondence

```rust
// 计算解释实现
// Computational interpretation implementation

#[derive(Clone, Debug)]
pub enum LinearType {
    BaseType(String),
    TensorType(Box<LinearType>, Box<LinearType>),
    ParType(Box<LinearType>, Box<LinearType>),
    WithType(Box<LinearType>, Box<LinearType>),
    PlusType(Box<LinearType>, Box<LinearType>),
    LinearArrow(Box<LinearType>, Box<LinearType>),
    OfCourseType(Box<LinearType>),
    WhyNotType(Box<LinearType>),
}

#[derive(Clone, Debug)]
pub enum LinearTerm {
    Variable(String),
    
    // 张量积的项 / Tensor terms
    TensorPair(Box<LinearTerm>, Box<LinearTerm>),
    TensorDestruct(Box<LinearTerm>, String, String, Box<LinearTerm>),
    
    // 加法连接的项 / Additive terms
    WithPair(Box<LinearTerm>, Box<LinearTerm>),
    Fst(Box<LinearTerm>),
    Snd(Box<LinearTerm>),
    
    Inl(Box<LinearTerm>),
    Inr(Box<LinearTerm>),
    Case(Box<LinearTerm>, String, Box<LinearTerm>, String, Box<LinearTerm>),
    
    // 线性函数 / Linear functions
    LinearLambda(String, LinearType, Box<LinearTerm>),
    LinearApp(Box<LinearTerm>, Box<LinearTerm>),
    
    // 指数算子 / Exponentials
    Promote(Box<LinearTerm>),
    Derelict(Box<LinearTerm>),
    Copy(Box<LinearTerm>),
    Discard(Box<LinearTerm>),
}

// 类型检查器 / Type checker
pub struct LinearTypeChecker {
    context: Vec<(String, LinearType)>,
}

impl LinearTypeChecker {
    pub fn new() -> Self {
        Self {
            context: Vec::new(),
        }
    }
    
    pub fn check_type(&mut self, term: &LinearTerm) -> Result<LinearType, String> {
        match term {
            LinearTerm::Variable(name) => {
                // 查找变量类型并从上下文中移除（线性使用）
                if let Some(index) = self.context.iter().position(|(n, _)| n == name) {
                    let (_, typ) = self.context.remove(index);
                    Ok(typ)
                } else {
                    Err(format!("Variable {} not found or already used", name))
                }
            }
            
            LinearTerm::TensorPair(m, n) => {
                let type_m = self.check_type(m)?;
                let type_n = self.check_type(n)?;
                Ok(LinearType::TensorType(Box::new(type_m), Box::new(type_n)))
            }
            
            LinearTerm::TensorDestruct(pair, x, y, body) => {
                let pair_type = self.check_type(pair)?;
                
                match pair_type {
                    LinearType::TensorType(type_a, type_b) => {
                        // 将解构的变量添加到上下文
                        self.context.push((x.clone(), *type_a));
                        self.context.push((y.clone(), *type_b));
                        
                        self.check_type(body)
                    }
                    _ => Err("Expected tensor type for tensor destruction".to_string()),
                }
            }
            
            LinearTerm::WithPair(m, n) => {
                // 保存原始上下文
                let original_context = self.context.clone();
                
                // 检查第一个组件
                let type_m = self.check_type(m)?;
                
                // 恢复上下文并检查第二个组件
                self.context = original_context;
                let type_n = self.check_type(n)?;
                
                Ok(LinearType::WithType(Box::new(type_m), Box::new(type_n)))
            }
            
            LinearTerm::Fst(pair) => {
                let pair_type = self.check_type(pair)?;
                match pair_type {
                    LinearType::WithType(type_a, _) => Ok(*type_a),
                    _ => Err("Expected with type for first projection".to_string()),
                }
            }
            
            LinearTerm::Snd(pair) => {
                let pair_type = self.check_type(pair)?;
                match pair_type {
                    LinearType::WithType(_, type_b) => Ok(*type_b),
                    _ => Err("Expected with type for second projection".to_string()),
                }
            }
            
            LinearTerm::LinearLambda(param, param_type, body) => {
                self.context.push((param.clone(), param_type.clone()));
                let body_type = self.check_type(body)?;
                Ok(LinearType::LinearArrow(
                    Box::new(param_type.clone()),
                    Box::new(body_type),
                ))
            }
            
            LinearTerm::LinearApp(func, arg) => {
                let func_type = self.check_type(func)?;
                let arg_type = self.check_type(arg)?;
                
                match func_type {
                    LinearType::LinearArrow(param_type, return_type) => {
                        if self.types_equal(&arg_type, &param_type) {
                            Ok(*return_type)
                        } else {
                            Err("Argument type doesn't match parameter type".to_string())
                        }
                    }
                    _ => Err("Expected linear arrow type for application".to_string()),
                }
            }
            
            _ => Err("Type checking for this term not implemented".to_string()),
        }
    }
    
    fn types_equal(&self, t1: &LinearType, t2: &LinearType) -> bool {
        match (t1, t2) {
            (LinearType::BaseType(n1), LinearType::BaseType(n2)) => n1 == n2,
            (LinearType::TensorType(a1, b1), LinearType::TensorType(a2, b2)) => {
                self.types_equal(a1, a2) && self.types_equal(b1, b2)
            }
            (LinearType::LinearArrow(a1, b1), LinearType::LinearArrow(a2, b2)) => {
                self.types_equal(a1, a2) && self.types_equal(b1, b2)
            }
            _ => false,
        }
    }
    
    // 添加变量到上下文 / Add variable to context
    pub fn add_variable(&mut self, name: String, typ: LinearType) {
        self.context.push((name, typ));
    }
    
    // 检查上下文是否为空（所有线性资源都被使用）
    pub fn context_is_empty(&self) -> bool {
        self.context.is_empty()
    }
}
```

## 应用领域 / Application Areas

### 并发计算 / Concurrent Computation

```rust
// 线性逻辑在并发计算中的应用
// Linear logic applications in concurrent computation

#[derive(Clone, Debug)]
pub enum Process {
    Nil,
    Send(String, LinearTerm, Box<Process>),
    Receive(String, String, Box<Process>),
    Parallel(Box<Process>, Box<Process>),
    Replicate(Box<Process>),
    New(String, Box<Process>),
}

#[derive(Clone, Debug)]
pub struct Channel {
    name: String,
    channel_type: LinearType,
    used: bool,
}

pub struct ConcurrentSystem {
    processes: Vec<Process>,
    channels: Vec<Channel>,
}

impl ConcurrentSystem {
    pub fn new() -> Self {
        Self {
            processes: Vec::new(),
            channels: Vec::new(),
        }
    }
    
    pub fn add_process(&mut self, process: Process) {
        self.processes.push(process);
    }
    
    pub fn create_channel(&mut self, name: String, typ: LinearType) {
        self.channels.push(Channel {
            name,
            channel_type: typ,
            used: false,
        });
    }
    
    // 执行一步计算 / Execute one computation step
    pub fn step(&mut self) -> Result<(), String> {
        // 查找可以通信的进程对
        for i in 0..self.processes.len() {
            for j in i + 1..self.processes.len() {
                if let Some((new_proc1, new_proc2)) = self.try_communicate(
                    &self.processes[i],
                    &self.processes[j],
                ) {
                    // 替换进程
                    self.processes[i] = new_proc1;
                    self.processes[j] = new_proc2;
                    return Ok(());
                }
            }
        }
        
        Err("No communication possible".to_string())
    }
    
    fn try_communicate(&self, p1: &Process, p2: &Process) -> Option<(Process, Process)> {
        match (p1, p2) {
            (
                Process::Send(ch1, val, cont1),
                Process::Receive(ch2, var, cont2),
            ) if ch1 == ch2 => {
                // 执行通信：发送值并继续
                let new_cont2 = self.substitute_in_process(cont2, var, val);
                Some(((**cont1).clone(), new_cont2))
            }
            
            (
                Process::Receive(ch1, var, cont1),
                Process::Send(ch2, val, cont2),
            ) if ch1 == ch2 => {
                // 执行通信：接收值并继续
                let new_cont1 = self.substitute_in_process(cont1, var, val);
                Some((new_cont1, (**cont2).clone()))
            }
            
            _ => None,
        }
    }
    
    fn substitute_in_process(
        &self,
        process: &Process,
        var: &str,
        value: &LinearTerm,
    ) -> Process {
        // 简化的替换实现
        process.clone()
    }
    
    // 检查系统的死锁自由性 / Check deadlock freedom
    pub fn is_deadlock_free(&self) -> bool {
        // 使用线性逻辑的性质检查死锁
        // 如果所有通道类型都是线性的，且没有循环依赖，则无死锁
        true // 简化实现
    }
}
```

### 资源管理 / Resource Management

```rust
// 资源管理系统
// Resource management system

#[derive(Clone, Debug)]
pub struct Resource {
    id: String,
    resource_type: String,
    available: bool,
}

#[derive(Clone, Debug)]
pub enum ResourceOperation {
    Acquire(String),
    Release(String),
    Transfer(String, String), // 从一个所有者转移到另一个
    Duplicate(String),        // 仅用于可复制资源
}

pub struct LinearResourceManager {
    resources: Vec<Resource>,
    ownership: std::collections::HashMap<String, String>, // resource_id -> owner
    linear_types: std::collections::HashMap<String, bool>, // resource_type -> is_linear
}

impl LinearResourceManager {
    pub fn new() -> Self {
        Self {
            resources: Vec::new(),
            ownership: std::collections::HashMap::new(),
            linear_types: std::collections::HashMap::new(),
        }
    }
    
    pub fn add_resource(&mut self, resource: Resource, is_linear: bool) {
        self.linear_types.insert(resource.resource_type.clone(), is_linear);
        self.resources.push(resource);
    }
    
    pub fn execute_operation(
        &mut self,
        operation: ResourceOperation,
        operator: &str,
    ) -> Result<(), String> {
        match operation {
            ResourceOperation::Acquire(resource_id) => {
                self.acquire_resource(&resource_id, operator)
            }
            
            ResourceOperation::Release(resource_id) => {
                self.release_resource(&resource_id, operator)
            }
            
            ResourceOperation::Transfer(resource_id, new_owner) => {
                self.transfer_resource(&resource_id, operator, &new_owner)
            }
            
            ResourceOperation::Duplicate(resource_id) => {
                self.duplicate_resource(&resource_id, operator)
            }
        }
    }
    
    fn acquire_resource(&mut self, resource_id: &str, owner: &str) -> Result<(), String> {
        // 检查资源是否可用
        if let Some(resource) = self.resources.iter_mut().find(|r| r.id == resource_id) {
            if resource.available {
                resource.available = false;
                self.ownership.insert(resource_id.to_string(), owner.to_string());
                Ok(())
            } else {
                Err("Resource already acquired".to_string())
            }
        } else {
            Err("Resource not found".to_string())
        }
    }
    
    fn release_resource(&mut self, resource_id: &str, owner: &str) -> Result<(), String> {
        // 检查所有权
        if let Some(current_owner) = self.ownership.get(resource_id) {
            if current_owner == owner {
                if let Some(resource) = self.resources.iter_mut().find(|r| r.id == resource_id) {
                    resource.available = true;
                    self.ownership.remove(resource_id);
                    Ok(())
                } else {
                    Err("Resource not found".to_string())
                }
            } else {
                Err("Not the owner of the resource".to_string())
            }
        } else {
            Err("Resource not owned by anyone".to_string())
        }
    }
    
    fn transfer_resource(
        &mut self,
        resource_id: &str,
        current_owner: &str,
        new_owner: &str,
    ) -> Result<(), String> {
        // 检查当前所有权
        if let Some(owner) = self.ownership.get(resource_id) {
            if owner == current_owner {
                self.ownership.insert(resource_id.to_string(), new_owner.to_string());
                Ok(())
            } else {
                Err("Not the current owner".to_string())
            }
        } else {
            Err("Resource not owned".to_string())
        }
    }
    
    fn duplicate_resource(&mut self, resource_id: &str, owner: &str) -> Result<(), String> {
        // 检查资源是否可复制
        if let Some(resource) = self.resources.iter().find(|r| r.id == resource_id) {
            if let Some(&is_linear) = self.linear_types.get(&resource.resource_type) {
                if is_linear {
                    return Err("Cannot duplicate linear resource".to_string());
                }
                
                // 检查所有权
                if let Some(current_owner) = self.ownership.get(resource_id) {
                    if current_owner == owner {
                        // 创建资源副本
                        let new_id = format!("{}_copy_{}", resource_id, 
                            std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap()
                                .as_nanos());
                        
                        let new_resource = Resource {
                            id: new_id.clone(),
                            resource_type: resource.resource_type.clone(),
                            available: false, // 新副本归请求者所有
                        };
                        
                        self.resources.push(new_resource);
                        self.ownership.insert(new_id, owner.to_string());
                        Ok(())
                    } else {
                        Err("Not the owner of the resource".to_string())
                    }
                } else {
                    Err("Resource not owned".to_string())
                }
            } else {
                Err("Resource type not found".to_string())
            }
        } else {
            Err("Resource not found".to_string())
        }
    }
    
    // 检查资源使用的线性性质 / Check linearity properties
    pub fn check_linearity_violations(&self) -> Vec<String> {
        let mut violations = Vec::new();
        
        // 检查是否有线性资源被多次引用
        for (resource_id, _) in &self.ownership {
            if let Some(resource) = self.resources.iter().find(|r| r.id == *resource_id) {
                if let Some(&is_linear) = self.linear_types.get(&resource.resource_type) {
                    if is_linear {
                        // 线性资源只能被一个实体拥有
                        let reference_count = self.ownership.values()
                            .filter(|&owner| self.ownership.get(resource_id) == Some(owner))
                            .count();
                        
                        if reference_count > 1 {
                            violations.push(format!(
                                "Linear resource {} has {} references",
                                resource_id, reference_count
                            ));
                        }
                    }
                }
            }
        }
        
        violations
    }
}
```

## 总结 / Summary

线性逻辑为我们提供了一个强大的框架来推理资源的使用和计算过程。它的资源敏感性使其在并发计算、程序分析和资源管理等领域具有独特的应用价值。

Linear logic provides us with a powerful framework for reasoning about resource usage and computational processes. Its resource sensitivity makes it uniquely valuable in areas such as concurrent computation, program analysis, and resource management.

### 关键特点 / Key Features

1. **资源敏感性** / Resource Sensitivity
   - 精确跟踪资源的使用
   - 避免资源的意外复制或丢失

2. **表达能力** / Expressiveness
   - 丰富的连接词系统
   - 能够表达复杂的资源约束

3. **计算解释** / Computational Interpretation
   - Curry-Howard-Girard对应
   - 与并发计算的自然联系

4. **应用价值** / Practical Value
   - 程序验证和分析
   - 资源管理系统
   - 并发和分布式系统

---

**参考文献 / References**:

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Troelstra, A. S. (1992). Lectures on linear logic. CSLI Publications.
3. Wadler, P. (1993). A taste of linear logic. In International Symposium on Mathematical Foundations of Computer Science (pp. 185-210).
4. Abramsky, S., & Jagadeesan, R. (1994). Games and full completeness for multiplicative linear logic. The Journal of Symbolic Logic, 59(2), 543-574.
5. Seely, R. A. (1989). Linear logic,*-autonomous categories and cofree coalgebras. Contemporary Mathematics, 92, 371-382.
