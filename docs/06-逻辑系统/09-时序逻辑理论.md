---
title: 6.9 æ—¶åºé€»è¾‘ç†è®º / Temporal Logic Theory
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: é€»è¾‘ç³»ç»Ÿå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 6.9 æ—¶åºé€»è¾‘ç†è®º / Temporal Logic Theory

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€æ—¶åºé€»è¾‘ç†è®ºçš„å½¢å¼åŒ–å®šä¹‰ã€æ¨å¯¼ç³»ç»Ÿä¸è¯­ä¹‰ç†è®ºã€‚
- å»ºç«‹æ—¶åºé€»è¾‘åœ¨ç¨‹åºéªŒè¯ã€ç¡¬ä»¶éªŒè¯ä¸­çš„åº”ç”¨æ¡†æ¶ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- æ—¶åºé€»è¾‘ã€LTLã€CTLã€æ¨¡å‹æ£€æŸ¥ã€æ—¶åºé€»è¾‘è¯æ˜ç³»ç»Ÿã€Kripkeè¯­ä¹‰ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- æ—¶åºé€»è¾‘ï¼ˆTemporal Logicï¼‰ï¼šç ”ç©¶æ—¶é—´ç›¸å…³å‘½é¢˜çš„é€»è¾‘ç³»ç»Ÿã€‚
- LTLï¼ˆLinear Temporal Logicï¼‰ï¼šçº¿æ€§æ—¶åºé€»è¾‘ã€‚
- CTLï¼ˆComputation Tree Logicï¼‰ï¼šåˆ†æ”¯æ—¶åºé€»è¾‘ã€‚
- è®°å·çº¦å®šï¼š`G`ã€`F`ã€`X`ã€`U` è¡¨ç¤ºæ—¶åºç®—å­ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- æ—¶åºé€»è¾‘åŸºç¡€ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/07-æ—¶åºé€»è¾‘.md`ã€‚
- æ¨¡æ€é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/04-æ¨¡æ€é€»è¾‘.md`ã€‚
- ç¨‹åºéªŒè¯ï¼šå‚è§ `08-å®ç°ç¤ºä¾‹/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- æ—¶åºé€»è¾‘ç³»ç»Ÿ
- æ—¶åºé€»è¾‘æ¨å¯¼
- æ—¶åºé€»è¾‘è¯­ä¹‰

## ç›®å½• (Table of Contents)

- [6.9 æ—¶åºé€»è¾‘ç†è®º / Temporal Logic Theory](#69-æ—¶åºé€»è¾‘ç†è®º--temporal-logic-theory)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [æ—¶åºé€»è¾‘å®šä¹‰ / Definition of Temporal Logic](#æ—¶åºé€»è¾‘å®šä¹‰--definition-of-temporal-logic)
  - [æ—¶åºé€»è¾‘åˆ†ç±» / Classification of Temporal Logic](#æ—¶åºé€»è¾‘åˆ†ç±»--classification-of-temporal-logic)
- [æ—¶åºé€»è¾‘ç³»ç»Ÿ / Temporal Logic System](#æ—¶åºé€»è¾‘ç³»ç»Ÿ--temporal-logic-system)
  - [çº¿æ€§æ—¶åºé€»è¾‘ (LTL) / Linear Temporal Logic](#çº¿æ€§æ—¶åºé€»è¾‘-ltl--linear-temporal-logic)
  - [åˆ†æ”¯æ—¶åºé€»è¾‘ (CTL) / Computation Tree Logic](#åˆ†æ”¯æ—¶åºé€»è¾‘-ctl--computation-tree-logic)
- [æ—¶åºé€»è¾‘æ¨å¯¼ / Temporal Logic Inference](#æ—¶åºé€»è¾‘æ¨å¯¼--temporal-logic-inference)
  - [æ¨¡å‹æ£€æŸ¥ç®—æ³• / Model Checking Algorithm](#æ¨¡å‹æ£€æŸ¥ç®—æ³•--model-checking-algorithm)
  - [æ—¶åºé€»è¾‘è¯æ˜ç³»ç»Ÿ / Temporal Logic Proof System](#æ—¶åºé€»è¾‘è¯æ˜ç³»ç»Ÿ--temporal-logic-proof-system)
- [æ—¶åºé€»è¾‘è¯­ä¹‰ / Temporal Logic Semantics](#æ—¶åºé€»è¾‘è¯­ä¹‰--temporal-logic-semantics)
  - [å…‹é‡Œæ™®å…‹è¯­ä¹‰ / Kripke Semantics](#å…‹é‡Œæ™®å…‹è¯­ä¹‰--kripke-semantics)
- [åº”ç”¨é¢†åŸŸ / Application Domains](#åº”ç”¨é¢†åŸŸ--application-domains)
  - [ç¨‹åºéªŒè¯ / Program Verification](#ç¨‹åºéªŒè¯--program-verification)
  - [ç¡¬ä»¶éªŒè¯ / Hardware Verification](#ç¡¬ä»¶éªŒè¯--hardware-verification)
  - [å®æ—¶ç³»ç»ŸéªŒè¯ / Real-Time System Verification](#å®æ—¶ç³»ç»ŸéªŒè¯--real-time-system-verification)
- [å®ç°ç¤ºä¾‹ / Implementation Examples](#å®ç°ç¤ºä¾‹--implementation-examples)
  - [äº’æ–¥ç®—æ³•éªŒè¯ / Mutual Exclusion Algorithm Verification](#äº’æ–¥ç®—æ³•éªŒè¯--mutual-exclusion-algorithm-verification)
  - [ç¼“å­˜ä¸€è‡´æ€§åè®®éªŒè¯ / Cache Coherence Protocol Verification](#ç¼“å­˜ä¸€è‡´æ€§åè®®éªŒè¯--cache-coherence-protocol-verification)
- [æœªæ¥å‘å±•æ–¹å‘ / Future Developments](#æœªæ¥å‘å±•æ–¹å‘--future-developments)
  - [å®æ—¶æ—¶åºé€»è¾‘ / Real-Time Temporal Logic](#å®æ—¶æ—¶åºé€»è¾‘--real-time-temporal-logic)
  - [æ¦‚ç‡æ—¶åºé€»è¾‘ / Probabilistic Temporal Logic](#æ¦‚ç‡æ—¶åºé€»è¾‘--probabilistic-temporal-logic)
- [å‚è€ƒæ–‡çŒ® / References](#å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)

## åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### æ—¶åºé€»è¾‘å®šä¹‰ / Definition of Temporal Logic

æ—¶åºé€»è¾‘æ˜¯ç ”ç©¶æ—¶é—´ç›¸å…³å‘½é¢˜çš„é€»è¾‘ç³»ç»Ÿï¼Œç”¨äºæè¿°å’Œæ¨ç†å…³äºæ—¶é—´å˜åŒ–çš„è¡Œä¸ºã€‚

**å½¢å¼åŒ–å®šä¹‰** / **Formal Definition**:

ç»™å®šæ—¶é—´ç‚¹ $t$ å’Œå‘½é¢˜ $\phi$ï¼Œæ—¶åºé€»è¾‘å…¬å¼å®šä¹‰ä¸ºï¼š

$$\mathcal{M}, t \models \phi \iff \text{åœ¨æ—¶é—´ç‚¹ } t \text{ æ¨¡å‹ } \mathcal{M} \text{ æ»¡è¶³ } \phi$$

å…¶ä¸­ $\mathcal{M}$ æ˜¯æ—¶åºæ¨¡å‹ã€‚

### æ—¶åºé€»è¾‘åˆ†ç±» / Classification of Temporal Logic

1. **çº¿æ€§æ—¶åºé€»è¾‘** / **Linear Temporal Logic (LTL)**
2. **åˆ†æ”¯æ—¶åºé€»è¾‘** / **Computation Tree Logic (CTL)**
3. **CTL*** / **Computation Tree Logic Star**
4. **åŒºé—´æ—¶åºé€»è¾‘** / **Interval Temporal Logic**
5. **å®æ—¶æ—¶åºé€»è¾‘** / **Real-Time Temporal Logic**

## æ—¶åºé€»è¾‘ç³»ç»Ÿ / Temporal Logic System

### çº¿æ€§æ—¶åºé€»è¾‘ (LTL) / Linear Temporal Logic

```rust
pub enum LTLFormula {
    // åŸå­å‘½é¢˜
    Atom(String),

    // é€»è¾‘è¿æ¥è¯
    And(Box<LTLFormula>, Box<LTLFormula>),
    Or(Box<LTLFormula>, Box<LTLFormula>),
    Implies(Box<LTLFormula>, Box<LTLFormula>),
    Not(Box<LTLFormula>),

    // æ—¶åºæ“ä½œç¬¦
    Next(Box<LTLFormula>),           // X Ï†
    Until(Box<LTLFormula>, Box<LTLFormula>), // Ï† U Ïˆ
    Release(Box<LTLFormula>, Box<LTLFormula>), // Ï† R Ïˆ
    Eventually(Box<LTLFormula>),     // F Ï†
    Always(Box<LTLFormula>),         // G Ï†

    // æ´¾ç”Ÿæ“ä½œç¬¦
    WeakUntil(Box<LTLFormula>, Box<LTLFormula>), // Ï† W Ïˆ
    StrongRelease(Box<LTLFormula>, Box<LTLFormula>), // Ï† M Ïˆ
}

pub struct LTLSemantics {
    model: LinearTimeModel,
}

impl LTLSemantics {
    pub fn satisfies(&self, formula: &LTLFormula, state: State) -> bool {
        match formula {
            LTLFormula::Atom(prop) => {
                self.model.valuation(state, prop)
            },

            LTLFormula::And(left, right) => {
                self.satisfies(left, state) && self.satisfies(right, state)
            },

            LTLFormula::Or(left, right) => {
                self.satisfies(left, state) || self.satisfies(right, state)
            },

            LTLFormula::Implies(left, right) => {
                !self.satisfies(left, state) || self.satisfies(right, state)
            },

            LTLFormula::Not(formula) => {
                !self.satisfies(formula, state)
            },

            LTLFormula::Next(formula) => {
                if let Some(next_state) = self.model.next_state(state) {
                    self.satisfies(formula, next_state)
                } else {
                    false
                }
            },

            LTLFormula::Until(left, right) => {
                self.satisfies_until(left, right, state)
            },

            LTLFormula::Release(left, right) => {
                self.satisfies_release(left, right, state)
            },

            LTLFormula::Eventually(formula) => {
                self.satisfies_eventually(formula, state)
            },

            LTLFormula::Always(formula) => {
                self.satisfies_always(formula, state)
            },

            LTLFormula::WeakUntil(left, right) => {
                self.satisfies_weak_until(left, right, state)
            },

            LTLFormula::StrongRelease(left, right) => {
                self.satisfies_strong_release(left, right, state)
            },
        }
    }

    fn satisfies_until(&self, left: &LTLFormula, right: &LTLFormula, state: State) -> bool {
        let mut current_state = state;

        loop {
            if self.satisfies(right, current_state) {
                return true;
            }

            if !self.satisfies(left, current_state) {
                return false;
            }

            if let Some(next_state) = self.model.next_state(current_state) {
                current_state = next_state;
            } else {
                return false;
            }
        }
    }

    fn satisfies_release(&self, left: &LTLFormula, right: &LTLFormula, state: State) -> bool {
        let mut current_state = state;

        loop {
            if self.satisfies(left, current_state) {
                return true;
            }

            if !self.satisfies(right, current_state) {
                return false;
            }

            if let Some(next_state) = self.model.next_state(current_state) {
                current_state = next_state;
            } else {
                return self.satisfies(left, current_state);
            }
        }
    }

    fn satisfies_eventually(&self, formula: &LTLFormula, state: State) -> bool {
        let mut current_state = state;

        loop {
            if self.satisfies(formula, current_state) {
                return true;
            }

            if let Some(next_state) = self.model.next_state(current_state) {
                current_state = next_state;
            } else {
                return false;
            }
        }
    }

    fn satisfies_always(&self, formula: &LTLFormula, state: State) -> bool {
        let mut current_state = state;

        loop {
            if !self.satisfies(formula, current_state) {
                return false;
            }

            if let Some(next_state) = self.model.next_state(current_state) {
                current_state = next_state;
            } else {
                return true;
            }
        }
    }
}

pub struct LinearTimeModel {
    states: Vec<State>,
    transitions: Vec<(State, State)>,
    valuations: HashMap<State, HashSet<String>>,
}

impl LinearTimeModel {
    pub fn new() -> Self {
        LinearTimeModel {
            states: Vec::new(),
            transitions: Vec::new(),
            valuations: HashMap::new(),
        }
    }

    pub fn add_state(&mut self, state: State) {
        self.states.push(state);
    }

    pub fn add_transition(&mut self, from: State, to: State) {
        self.transitions.push((from, to));
    }

    pub fn set_valuation(&mut self, state: State, proposition: String, value: bool) {
        let state_valuations = self.valuations.entry(state).or_insert_with(HashSet::new);
        if value {
            state_valuations.insert(proposition);
        } else {
            state_valuations.remove(&proposition);
        }
    }

    pub fn valuation(&self, state: State, proposition: &str) -> bool {
        self.valuations.get(&state)
            .map(|props| props.contains(proposition))
            .unwrap_or(false)
    }

    pub fn next_state(&self, state: State) -> Option<State> {
        self.transitions.iter()
            .find(|(from, _)| *from == state)
            .map(|(_, to)| *to)
    }
}
```

### åˆ†æ”¯æ—¶åºé€»è¾‘ (CTL) / Computation Tree Logic

```rust
pub enum CTLFormula {
    // åŸå­å‘½é¢˜
    Atom(String),

    // é€»è¾‘è¿æ¥è¯
    And(Box<CTLFormula>, Box<CTLFormula>),
    Or(Box<CTLFormula>, Box<CTLFormula>),
    Implies(Box<CTLFormula>, Box<CTLFormula>),
    Not(Box<CTLFormula>),

    // è·¯å¾„é‡è¯
    ExistsPath(Box<PathFormula>),    // E Ï†
    AllPaths(Box<PathFormula>),      // A Ï†

    // æ—¶åºæ“ä½œç¬¦
    Next(Box<CTLFormula>),           // X Ï†
    Until(Box<CTLFormula>, Box<CTLFormula>), // Ï† U Ïˆ
    Release(Box<CTLFormula>, Box<CTLFormula>), // Ï† R Ïˆ
    Eventually(Box<CTLFormula>),     // F Ï†
    Always(Box<CTLFormula>),         // G Ï†
}

pub enum PathFormula {
    Next(Box<CTLFormula>),
    Until(Box<CTLFormula>, Box<CTLFormula>),
    Release(Box<CTLFormula>, Box<CTLFormula>),
    Eventually(Box<CTLFormula>),
    Always(Box<CTLFormula>),
}

pub struct CTLSemantics {
    model: KripkeStructure,
}

impl CTLSemantics {
    pub fn satisfies(&self, formula: &CTLFormula, state: State) -> bool {
        match formula {
            CTLFormula::Atom(prop) => {
                self.model.valuation(state, prop)
            },

            CTLFormula::And(left, right) => {
                self.satisfies(left, state) && self.satisfies(right, state)
            },

            CTLFormula::Or(left, right) => {
                self.satisfies(left, state) || self.satisfies(right, state)
            },

            CTLFormula::Implies(left, right) => {
                !self.satisfies(left, state) || self.satisfies(right, state)
            },

            CTLFormula::Not(formula) => {
                !self.satisfies(formula, state)
            },

            CTLFormula::ExistsPath(path_formula) => {
                self.satisfies_exists_path(path_formula, state)
            },

            CTLFormula::AllPaths(path_formula) => {
                self.satisfies_all_paths(path_formula, state)
            },

            CTLFormula::Next(formula) => {
                self.satisfies_next(formula, state)
            },

            CTLFormula::Until(left, right) => {
                self.satisfies_until(left, right, state)
            },

            CTLFormula::Release(left, right) => {
                self.satisfies_release(left, right, state)
            },

            CTLFormula::Eventually(formula) => {
                self.satisfies_eventually(formula, state)
            },

            CTLFormula::Always(formula) => {
                self.satisfies_always(formula, state)
            },
        }
    }

    fn satisfies_exists_path(&self, path_formula: &PathFormula, state: State) -> bool {
        let paths = self.model.get_paths_from(state);
        paths.iter().any(|path| self.satisfies_path(path_formula, path))
    }

    fn satisfies_all_paths(&self, path_formula: &PathFormula, state: State) -> bool {
        let paths = self.model.get_paths_from(state);
        paths.iter().all(|path| self.satisfies_path(path_formula, path))
    }

    fn satisfies_path(&self, path_formula: &PathFormula, path: &Path) -> bool {
        match path_formula {
            PathFormula::Next(formula) => {
                if let Some(next_state) = path.next_state() {
                    self.satisfies(formula, next_state)
                } else {
                    false
                }
            },

            PathFormula::Until(left, right) => {
                self.satisfies_path_until(left, right, path)
            },

            PathFormula::Release(left, right) => {
                self.satisfies_path_release(left, right, path)
            },

            PathFormula::Eventually(formula) => {
                path.states().iter().any(|state| self.satisfies(formula, *state))
            },

            PathFormula::Always(formula) => {
                path.states().iter().all(|state| self.satisfies(formula, *state))
            },
        }
    }
}

pub struct KripkeStructure {
    states: Vec<State>,
    transitions: Vec<(State, State)>,
    valuations: HashMap<State, HashSet<String>>,
}

impl KripkeStructure {
    pub fn get_paths_from(&self, state: State) -> Vec<Path> {
        // ç”Ÿæˆä»ç»™å®šçŠ¶æ€å¼€å§‹çš„æ‰€æœ‰å¯èƒ½è·¯å¾„
        let mut paths = Vec::new();
        self.generate_paths(state, &mut Vec::new(), &mut paths);
        paths
    }

    fn generate_paths(&self, current_state: State, current_path: &mut Vec<State>, paths: &mut Vec<Path>) {
        current_path.push(current_state);

        // æ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯
        if current_path.contains(&current_state) {
            // æ‰¾åˆ°å¾ªç¯è·¯å¾„
            let cycle_start = current_path.iter().position(|&s| s == current_state).unwrap();
            let cycle = current_path[cycle_start..].to_vec();
            paths.push(Path::new(cycle));
        } else {
            // ç»§ç»­ç”Ÿæˆè·¯å¾„
            let successors = self.get_successors(current_state);
            if successors.is_empty() {
                // åˆ°è¾¾ç»ˆæ­¢çŠ¶æ€
                paths.push(Path::new(current_path.clone()));
            } else {
                for successor in successors {
                    self.generate_paths(successor, current_path, paths);
                }
            }
        }

        current_path.pop();
    }

    fn get_successors(&self, state: State) -> Vec<State> {
        self.transitions.iter()
            .filter(|(from, _)| *from == state)
            .map(|(_, to)| *to)
            .collect()
    }
}

pub struct Path {
    states: Vec<State>,
    current_index: usize,
}

impl Path {
    pub fn new(states: Vec<State>) -> Self {
        Path {
            states,
            current_index: 0,
        }
    }

    pub fn states(&self) -> &[State] {
        &self.states
    }

    pub fn next_state(&mut self) -> Option<State> {
        if self.current_index < self.states.len() {
            let state = self.states[self.current_index];
            self.current_index += 1;
            Some(state)
        } else {
            None
        }
    }
}
```

## æ—¶åºé€»è¾‘æ¨å¯¼ / Temporal Logic Inference

### æ¨¡å‹æ£€æŸ¥ç®—æ³• / Model Checking Algorithm

```rust
pub struct ModelChecker {
    model: KripkeStructure,
    algorithm: ModelCheckingAlgorithm,
}

impl ModelChecker {
    pub fn check_formula(&self, formula: &CTLFormula) -> ModelCheckingResult {
        match self.algorithm {
            ModelCheckingAlgorithm::ExplicitState => {
                self.explicit_state_check(formula)
            },
            ModelCheckingAlgorithm::Symbolic => {
                self.symbolic_check(formula)
            },
            ModelCheckingAlgorithm::Bounded => {
                self.bounded_check(formula)
            },
        }
    }

    fn explicit_state_check(&self, formula: &CTLFormula) -> ModelCheckingResult {
        let mut result = ModelCheckingResult::new();

        for state in &self.model.states {
            if self.satisfies(formula, *state) {
                result.add_satisfying_state(*state);
            } else {
                result.add_violating_state(*state);
            }
        }

        result
    }

    fn symbolic_check(&self, formula: &CTLFormula) -> ModelCheckingResult {
        // ä½¿ç”¨BDDè¿›è¡Œç¬¦å·æ¨¡å‹æ£€æŸ¥
        let bdd_manager = BDDManager::new();
        let formula_bdd = self.formula_to_bdd(formula, &bdd_manager);
        let model_bdd = self.model_to_bdd(&bdd_manager);

        let intersection = bdd_manager.and(&formula_bdd, &model_bdd);

        if bdd_manager.is_empty(&intersection) {
            ModelCheckingResult::unsatisfiable()
        } else {
            ModelCheckingResult::satisfiable()
        }
    }

    fn bounded_check(&self, formula: &CTLFormula) -> ModelCheckingResult {
        let mut bound = 0;
        let max_bound = 100; // è®¾ç½®æœ€å¤§ç•Œé™

        while bound < max_bound {
            let result = self.check_with_bound(formula, bound);
            if result.is_conclusive() {
                return result;
            }
            bound += 1;
        }

        ModelCheckingResult::unknown()
    }

    fn satisfies(&self, formula: &CTLFormula, state: State) -> bool {
        let semantics = CTLSemantics { model: self.model.clone() };
        semantics.satisfies(formula, state)
    }
}

pub enum ModelCheckingAlgorithm {
    ExplicitState,
    Symbolic,
    Bounded,
}

pub struct ModelCheckingResult {
    satisfying_states: Vec<State>,
    violating_states: Vec<State>,
    counterexamples: Vec<Counterexample>,
    status: ModelCheckingStatus,
}

impl ModelCheckingResult {
    pub fn new() -> Self {
        ModelCheckingResult {
            satisfying_states: Vec::new(),
            violating_states: Vec::new(),
            counterexamples: Vec::new(),
            status: ModelCheckingStatus::Unknown,
        }
    }

    pub fn add_satisfying_state(&mut self, state: State) {
        self.satisfying_states.push(state);
    }

    pub fn add_violating_state(&mut self, state: State) {
        self.violating_states.push(state);
    }

    pub fn is_conclusive(&self) -> bool {
        matches!(self.status, ModelCheckingStatus::Satisfiable | ModelCheckingStatus::Unsatisfiable)
    }

    pub fn satisfiable() -> Self {
        ModelCheckingResult {
            satisfying_states: Vec::new(),
            violating_states: Vec::new(),
            counterexamples: Vec::new(),
            status: ModelCheckingStatus::Satisfiable,
        }
    }

    pub fn unsatisfiable() -> Self {
        ModelCheckingResult {
            satisfying_states: Vec::new(),
            violating_states: Vec::new(),
            counterexamples: Vec::new(),
            status: ModelCheckingStatus::Unsatisfiable,
        }
    }

    pub fn unknown() -> Self {
        ModelCheckingResult {
            satisfying_states: Vec::new(),
            violating_states: Vec::new(),
            counterexamples: Vec::new(),
            status: ModelCheckingStatus::Unknown,
        }
    }
}

pub enum ModelCheckingStatus {
    Satisfiable,
    Unsatisfiable,
    Unknown,
}

pub struct Counterexample {
    path: Path,
    violation_point: State,
    violation_formula: CTLFormula,
}
```

### æ—¶åºé€»è¾‘è¯æ˜ç³»ç»Ÿ / Temporal Logic Proof System

```rust
pub struct TemporalLogicProofSystem {
    axioms: Vec<TemporalAxiom>,
    rules: Vec<TemporalRule>,
}

impl TemporalLogicProofSystem {
    pub fn prove(&self, formula: &CTLFormula) -> Option<TemporalProof> {
        let mut proof_tree = TemporalProofTree::new(formula.clone());
        self.search_proof(&mut proof_tree)
    }

    fn search_proof(&self, proof_tree: &mut TemporalProofTree) -> Option<TemporalProof> {
        let current_formula = proof_tree.current_formula();

        // æ£€æŸ¥æ˜¯å¦æ˜¯å…¬ç†
        for axiom in &self.axioms {
            if axiom.matches(current_formula) {
                return Some(proof_tree.build_proof());
            }
        }

        // å°è¯•åº”ç”¨æ¨ç†è§„åˆ™
        for rule in &self.rules {
            if let Some(premises) = rule.apply(current_formula) {
                for premise in premises {
                    proof_tree.add_premise(premise);
                }

                if let Some(subproof) = self.search_proof(proof_tree) {
                    return Some(subproof);
                }

                proof_tree.backtrack();
            }
        }

        None
    }
}

pub trait TemporalAxiom {
    fn matches(&self, formula: &CTLFormula) -> bool;
    fn name(&self) -> &str;
}

pub trait TemporalRule {
    fn apply(&self, formula: &CTLFormula) -> Option<Vec<CTLFormula>>;
    fn name(&self) -> &str;
}

// æ—¶åºé€»è¾‘å…¬ç†
pub struct NextDistributivityAxiom;
pub struct UntilDistributivityAxiom;
pub struct ReleaseDistributivityAxiom;

impl TemporalAxiom for NextDistributivityAxiom {
    fn matches(&self, formula: &CTLFormula) -> bool {
        // X(Ï† âˆ§ Ïˆ) â†” XÏ† âˆ§ XÏˆ
        matches!(formula, CTLFormula::Next(CTLFormula::And(_, _)))
    }

    fn name(&self) -> &str {
        "NextDistributivity"
    }
}

impl TemporalAxiom for UntilDistributivityAxiom {
    fn matches(&self, formula: &CTLFormula) -> bool {
        // Ï† U (Ïˆ âˆ¨ Ï‡) â†” (Ï† U Ïˆ) âˆ¨ (Ï† U Ï‡)
        matches!(formula, CTLFormula::Until(_, CTLFormula::Or(_, _)))
    }

    fn name(&self) -> &str {
        "UntilDistributivity"
    }
}

// æ—¶åºé€»è¾‘æ¨ç†è§„åˆ™
pub struct NextGeneralizationRule;
pub struct AlwaysGeneralizationRule;
pub struct UntilIntroductionRule;

impl TemporalRule for NextGeneralizationRule {
    fn apply(&self, formula: &CTLFormula) -> Option<Vec<CTLFormula>> {
        // ä» Ï† æ¨å¯¼å‡º A X Ï†
        if let CTLFormula::AllPaths(PathFormula::Next(inner)) = formula {
            Some(vec![*inner.clone()])
        } else {
            None
        }
    }

    fn name(&self) -> &str {
        "NextGeneralization"
    }
}

impl TemporalRule for AlwaysGeneralizationRule {
    fn apply(&self, formula: &CTLFormula) -> Option<Vec<CTLFormula>> {
        // ä» Ï† æ¨å¯¼å‡º A G Ï†
        if let CTLFormula::AllPaths(PathFormula::Always(inner)) = formula {
            Some(vec![*inner.clone()])
        } else {
            None
        }
    }

    fn name(&self) -> &str {
        "AlwaysGeneralization"
    }
}
```

## æ—¶åºé€»è¾‘è¯­ä¹‰ / Temporal Logic Semantics

### å…‹é‡Œæ™®å…‹è¯­ä¹‰ / Kripke Semantics

```rust
pub struct KripkeSemantics {
    frame: KripkeFrame,
    valuation: Valuation,
}

impl KripkeSemantics {
    pub fn satisfies(&self, formula: &CTLFormula, state: State) -> bool {
        match formula {
            CTLFormula::Atom(prop) => {
                self.valuation.get(state, prop)
            },

            CTLFormula::And(left, right) => {
                self.satisfies(left, state) && self.satisfies(right, state)
            },

            CTLFormula::Or(left, right) => {
                self.satisfies(left, state) || self.satisfies(right, state)
            },

            CTLFormula::Implies(left, right) => {
                !self.satisfies(left, state) || self.satisfies(right, state)
            },

            CTLFormula::Not(formula) => {
                !self.satisfies(formula, state)
            },

            CTLFormula::ExistsPath(path_formula) => {
                self.satisfies_exists_path(path_formula, state)
            },

            CTLFormula::AllPaths(path_formula) => {
                self.satisfies_all_paths(path_formula, state)
            },

            _ => false,
        }
    }

    fn satisfies_exists_path(&self, path_formula: &PathFormula, state: State) -> bool {
        let paths = self.frame.get_paths_from(state);
        paths.iter().any(|path| self.satisfies_path(path_formula, path))
    }

    fn satisfies_all_paths(&self, path_formula: &PathFormula, state: State) -> bool {
        let paths = self.frame.get_paths_from(state);
        paths.iter().all(|path| self.satisfies_path(path_formula, path))
    }

    fn satisfies_path(&self, path_formula: &PathFormula, path: &Path) -> bool {
        match path_formula {
            PathFormula::Next(formula) => {
                if let Some(next_state) = path.next_state() {
                    self.satisfies(formula, next_state)
                } else {
                    false
                }
            },

            PathFormula::Until(left, right) => {
                self.satisfies_path_until(left, right, path)
            },

            PathFormula::Release(left, right) => {
                self.satisfies_path_release(left, right, path)
            },

            PathFormula::Eventually(formula) => {
                path.states().iter().any(|state| self.satisfies(formula, *state))
            },

            PathFormula::Always(formula) => {
                path.states().iter().all(|state| self.satisfies(formula, *state))
            },
        }
    }
}

pub struct KripkeFrame {
    states: Vec<State>,
    accessibility: Vec<(State, State)>,
}

impl KripkeFrame {
    pub fn new() -> Self {
        KripkeFrame {
            states: Vec::new(),
            accessibility: Vec::new(),
        }
    }

    pub fn add_state(&mut self, state: State) {
        self.states.push(state);
    }

    pub fn add_accessibility(&mut self, from: State, to: State) {
        self.accessibility.push((from, to));
    }

    pub fn get_paths_from(&self, state: State) -> Vec<Path> {
        let mut paths = Vec::new();
        self.generate_paths(state, &mut Vec::new(), &mut paths);
        paths
    }

    fn generate_paths(&self, current_state: State, current_path: &mut Vec<State>, paths: &mut Vec<Path>) {
        current_path.push(current_state);

        let successors = self.get_successors(current_state);
        if successors.is_empty() {
            paths.push(Path::new(current_path.clone()));
        } else {
            for successor in successors {
                self.generate_paths(successor, current_path, paths);
            }
        }

        current_path.pop();
    }

    fn get_successors(&self, state: State) -> Vec<State> {
        self.accessibility.iter()
            .filter(|(from, _)| *from == state)
            .map(|(_, to)| *to)
            .collect()
    }
}

pub struct Valuation {
    assignments: HashMap<State, HashSet<String>>,
}

impl Valuation {
    pub fn new() -> Self {
        Valuation {
            assignments: HashMap::new(),
        }
    }

    pub fn set(&mut self, state: State, proposition: String, value: bool) {
        let state_props = self.assignments.entry(state).or_insert_with(HashSet::new);
        if value {
            state_props.insert(proposition);
        } else {
            state_props.remove(&proposition);
        }
    }

    pub fn get(&self, state: State, proposition: &str) -> bool {
        self.assignments.get(&state)
            .map(|props| props.contains(proposition))
            .unwrap_or(false)
    }
}
```

## åº”ç”¨é¢†åŸŸ / Application Domains

### ç¨‹åºéªŒè¯ / Program Verification

```rust
pub struct ProgramVerification {
    model_checker: ModelChecker,
    program_analyzer: ProgramAnalyzer,
}

impl ProgramVerification {
    pub fn verify_program(&self, program: &Program, specification: &TemporalSpecification) -> VerificationResult {
        // ä»ç¨‹åºç”ŸæˆKripkeç»“æ„
        let kripke_structure = self.program_analyzer.generate_kripke_structure(program);

        // ä»è§„èŒƒç”Ÿæˆæ—¶åºé€»è¾‘å…¬å¼
        let formula = self.program_analyzer.generate_formula(specification);

        // æ¨¡å‹æ£€æŸ¥
        let result = self.model_checker.check_formula(&formula);

        match result.status {
            ModelCheckingStatus::Satisfiable => {
                VerificationResult::Verified
            },
            ModelCheckingStatus::Unsatisfiable => {
                VerificationResult::Violated {
                    counterexamples: result.counterexamples,
                }
            },
            ModelCheckingStatus::Unknown => {
                VerificationResult::Unknown
            },
        }
    }

    pub fn verify_concurrent_program(&self, program: &ConcurrentProgram) -> ConcurrentVerificationResult {
        let mut results = Vec::new();

        for property in &program.properties {
            let formula = self.program_analyzer.generate_formula(property);
            let result = self.model_checker.check_formula(&formula);

            results.push(PropertyResult {
                property: property.clone(),
                result,
            });
        }

        ConcurrentVerificationResult { results }
    }
}

pub struct Program {
    statements: Vec<Statement>,
    variables: Vec<Variable>,
}

pub struct TemporalSpecification {
    properties: Vec<TemporalProperty>,
}

pub enum TemporalProperty {
    Safety(CTLFormula),
    Liveness(CTLFormula),
    Fairness(CTLFormula),
}

pub struct ConcurrentProgram {
    processes: Vec<Process>,
    properties: Vec<TemporalProperty>,
}

pub enum VerificationResult {
    Verified,
    Violated { counterexamples: Vec<Counterexample> },
    Unknown,
}

pub struct ConcurrentVerificationResult {
    results: Vec<PropertyResult>,
}

pub struct PropertyResult {
    property: TemporalProperty,
    result: ModelCheckingResult,
}
```

### ç¡¬ä»¶éªŒè¯ / Hardware Verification

```rust
pub struct HardwareVerification {
    model_checker: ModelChecker,
    hardware_analyzer: HardwareAnalyzer,
}

impl HardwareVerification {
    pub fn verify_circuit(&self, circuit: &Circuit) -> CircuitVerificationResult {
        // ä»ç”µè·¯ç”ŸæˆçŠ¶æ€æœºæ¨¡å‹
        let state_machine = self.hardware_analyzer.generate_state_machine(circuit);

        // éªŒè¯ç”µè·¯å±æ€§
        let mut results = Vec::new();

        for property in &circuit.properties {
            let formula = self.hardware_analyzer.generate_formula(property);
            let result = self.model_checker.check_formula(&formula);

            results.push(CircuitPropertyResult {
                property: property.clone(),
                result,
            });
        }

        CircuitVerificationResult { results }
    }

    pub fn verify_protocol(&self, protocol: &Protocol) -> ProtocolVerificationResult {
        // éªŒè¯åè®®çš„æ­£ç¡®æ€§
        let protocol_model = self.hardware_analyzer.generate_protocol_model(protocol);

        let mut verification_results = Vec::new();

        for requirement in &protocol.requirements {
            let formula = self.hardware_analyzer.generate_formula(requirement);
            let result = self.model_checker.check_formula(&formula);

            verification_results.push(ProtocolRequirementResult {
                requirement: requirement.clone(),
                result,
            });
        }

        ProtocolVerificationResult { verification_results }
    }
}

pub struct Circuit {
    components: Vec<Component>,
    connections: Vec<Connection>,
    properties: Vec<CircuitProperty>,
}

pub enum CircuitProperty {
    DeadlockFree(CTLFormula),
    MutualExclusion(CTLFormula),
    Progress(CTLFormula),
}

pub struct Protocol {
    states: Vec<ProtocolState>,
    transitions: Vec<ProtocolTransition>,
    requirements: Vec<ProtocolRequirement>,
}

pub enum ProtocolRequirement {
    Safety(CTLFormula),
    Liveness(CTLFormula),
    Fairness(CTLFormula),
}

pub struct CircuitVerificationResult {
    results: Vec<CircuitPropertyResult>,
}

pub struct CircuitPropertyResult {
    property: CircuitProperty,
    result: ModelCheckingResult,
}

pub struct ProtocolVerificationResult {
    verification_results: Vec<ProtocolRequirementResult>,
}

pub struct ProtocolRequirementResult {
    requirement: ProtocolRequirement,
    result: ModelCheckingResult,
}
```

### å®æ—¶ç³»ç»ŸéªŒè¯ / Real-Time System Verification

```rust
pub struct RealTimeVerification {
    model_checker: ModelChecker,
    real_time_analyzer: RealTimeAnalyzer,
}

impl RealTimeVerification {
    pub fn verify_real_time_system(&self, system: &RealTimeSystem) -> RealTimeVerificationResult {
        // ç”Ÿæˆå®æ—¶ç³»ç»Ÿçš„æ—¶åºæ¨¡å‹
        let temporal_model = self.real_time_analyzer.generate_temporal_model(system);

        let mut results = Vec::new();

        for requirement in &system.requirements {
            let formula = self.real_time_analyzer.generate_formula(requirement);
            let result = self.model_checker.check_formula(&formula);

            results.push(RealTimeRequirementResult {
                requirement: requirement.clone(),
                result,
            });
        }

        RealTimeVerificationResult { results }
    }

    pub fn verify_schedulability(&self, system: &RealTimeSystem) -> SchedulabilityResult {
        // éªŒè¯ç³»ç»Ÿçš„å¯è°ƒåº¦æ€§
        let schedulability_formula = self.real_time_analyzer.generate_schedulability_formula(system);
        let result = self.model_checker.check_formula(&schedulability_formula);

        match result.status {
            ModelCheckingStatus::Satisfiable => {
                SchedulabilityResult::Schedulable
            },
            ModelCheckingStatus::Unsatisfiable => {
                SchedulabilityResult::NotSchedulable {
                    counterexamples: result.counterexamples,
                }
            },
            ModelCheckingStatus::Unknown => {
                SchedulabilityResult::Unknown
            },
        }
    }
}

pub struct RealTimeSystem {
    tasks: Vec<Task>,
    resources: Vec<Resource>,
    requirements: Vec<RealTimeRequirement>,
}

pub struct Task {
    id: String,
    period: Duration,
    deadline: Duration,
    worst_case_execution_time: Duration,
    priority: Priority,
}

pub enum RealTimeRequirement {
    Deadline(CTLFormula),
    ResponseTime(CTLFormula),
    Throughput(CTLFormula),
}

pub struct RealTimeVerificationResult {
    results: Vec<RealTimeRequirementResult>,
}

pub struct RealTimeRequirementResult {
    requirement: RealTimeRequirement,
    result: ModelCheckingResult,
}

pub enum SchedulabilityResult {
    Schedulable,
    NotSchedulable { counterexamples: Vec<Counterexample> },
    Unknown,
}
```

## å®ç°ç¤ºä¾‹ / Implementation Examples

### äº’æ–¥ç®—æ³•éªŒè¯ / Mutual Exclusion Algorithm Verification

```rust
pub struct MutualExclusionVerification {
    model_checker: ModelChecker,
    algorithm_analyzer: AlgorithmAnalyzer,
}

impl MutualExclusionVerification {
    pub fn verify_mutual_exclusion(&self, algorithm: &MutualExclusionAlgorithm) -> MutualExclusionResult {
        // ç”Ÿæˆç®—æ³•çš„çŠ¶æ€æ¨¡å‹
        let state_model = self.algorithm_analyzer.generate_state_model(algorithm);

        // éªŒè¯äº’æ–¥å±æ€§
        let mutual_exclusion_formula = self.generate_mutual_exclusion_formula();
        let mutual_exclusion_result = self.model_checker.check_formula(&mutual_exclusion_formula);

        // éªŒè¯æ— æ­»é”å±æ€§
        let deadlock_free_formula = self.generate_deadlock_free_formula();
        let deadlock_free_result = self.model_checker.check_formula(&deadlock_free_formula);

        // éªŒè¯è¿›å±•å±æ€§
        let progress_formula = self.generate_progress_formula();
        let progress_result = self.model_checker.check_formula(&progress_formula);

        MutualExclusionResult {
            algorithm: algorithm.clone(),
            mutual_exclusion: mutual_exclusion_result,
            deadlock_free: deadlock_free_result,
            progress: progress_result,
        }
    }

    fn generate_mutual_exclusion_formula(&self) -> CTLFormula {
        // AG Â¬(critical1 âˆ§ critical2)
        CTLFormula::AllPaths(PathFormula::Always(Box::new(
            CTLFormula::Not(Box::new(
                CTLFormula::And(
                    Box::new(CTLFormula::Atom("critical1".to_string())),
                    Box::new(CTLFormula::Atom("critical2".to_string())),
                )
            ))
        )))
    }

    fn generate_deadlock_free_formula(&self) -> CTLFormula {
        // AG EF (critical1 âˆ¨ critical2)
        CTLFormula::AllPaths(PathFormula::Always(Box::new(
            CTLFormula::ExistsPath(Box::new(
                PathFormula::Eventually(Box::new(
                    CTLFormula::Or(
                        Box::new(CTLFormula::Atom("critical1".to_string())),
                        Box::new(CTLFormula::Atom("critical2".to_string())),
                    )
                ))
            ))
        )))
    }

    fn generate_progress_formula(&self) -> CTLFormula {
        // AG (waiting1 â†’ AF critical1)
        CTLFormula::AllPaths(PathFormula::Always(Box::new(
            CTLFormula::Implies(
                Box::new(CTLFormula::Atom("waiting1".to_string())),
                Box::new(CTLFormula::AllPaths(Box::new(
                    PathFormula::Eventually(Box::new(
                        CTLFormula::Atom("critical1".to_string())
                    ))
                )))
            )
        )))
    }
}

pub struct MutualExclusionAlgorithm {
    name: String,
    processes: Vec<Process>,
    variables: Vec<Variable>,
}

pub struct MutualExclusionResult {
    algorithm: MutualExclusionAlgorithm,
    mutual_exclusion: ModelCheckingResult,
    deadlock_free: ModelCheckingResult,
    progress: ModelCheckingResult,
}
```

### ç¼“å­˜ä¸€è‡´æ€§åè®®éªŒè¯ / Cache Coherence Protocol Verification

```rust
pub struct CacheCoherenceVerification {
    model_checker: ModelChecker,
    protocol_analyzer: ProtocolAnalyzer,
}

impl CacheCoherenceVerification {
    pub fn verify_cache_coherence(&self, protocol: &CacheCoherenceProtocol) -> CacheCoherenceResult {
        // ç”Ÿæˆåè®®çš„çŠ¶æ€æ¨¡å‹
        let state_model = self.protocol_analyzer.generate_state_model(protocol);

        // éªŒè¯ä¸€è‡´æ€§å±æ€§
        let coherence_formula = self.generate_coherence_formula();
        let coherence_result = self.model_checker.check_formula(&coherence_formula);

        // éªŒè¯åºåˆ—åŒ–å±æ€§
        let serialization_formula = self.generate_serialization_formula();
        let serialization_result = self.model_checker.check_formula(&serialization_formula);

        // éªŒè¯è¿›å±•å±æ€§
        let progress_formula = self.generate_progress_formula();
        let progress_result = self.model_checker.check_formula(&progress_formula);

        CacheCoherenceResult {
            protocol: protocol.clone(),
            coherence: coherence_result,
            serialization: serialization_result,
            progress: progress_result,
        }
    }

    fn generate_coherence_formula(&self) -> CTLFormula {
        // AG (shared â†’ (exclusive1 âˆ¨ exclusive2 âˆ¨ ...))
        CTLFormula::AllPaths(PathFormula::Always(Box::new(
            CTLFormula::Implies(
                Box::new(CTLFormula::Atom("shared".to_string())),
                Box::new(CTLFormula::Or(
                    Box::new(CTLFormula::Atom("exclusive1".to_string())),
                    Box::new(CTLFormula::Atom("exclusive2".to_string())),
                ))
            )
        )))
    }

    fn generate_serialization_formula(&self) -> CTLFormula {
        // AG (write1 âˆ§ write2 â†’ (write1 U write2) âˆ¨ (write2 U write1))
        CTLFormula::AllPaths(PathFormula::Always(Box::new(
            CTLFormula::Implies(
                Box::new(CTLFormula::And(
                    Box::new(CTLFormula::Atom("write1".to_string())),
                    Box::new(CTLFormula::Atom("write2".to_string())),
                )),
                Box::new(CTLFormula::Or(
                    Box::new(CTLFormula::Until(
                        Box::new(CTLFormula::Atom("write1".to_string())),
                        Box::new(CTLFormula::Atom("write2".to_string())),
                    )),
                    Box::new(CTLFormula::Until(
                        Box::new(CTLFormula::Atom("write2".to_string())),
                        Box::new(CTLFormula::Atom("write1".to_string())),
                    )),
                ))
            )
        )))
    }
}

pub struct CacheCoherenceProtocol {
    name: String,
    caches: Vec<Cache>,
    memory: Memory,
    states: Vec<ProtocolState>,
}

pub struct CacheCoherenceResult {
    protocol: CacheCoherenceProtocol,
    coherence: ModelCheckingResult,
    serialization: ModelCheckingResult,
    progress: ModelCheckingResult,
}
```

## æœªæ¥å‘å±•æ–¹å‘ / Future Developments

### å®æ—¶æ—¶åºé€»è¾‘ / Real-Time Temporal Logic

```rust
pub struct RealTimeTemporalLogic {
    logic_system: TemporalLogicSystem,
    real_time_semantics: RealTimeSemantics,
}

impl RealTimeTemporalLogic {
    pub fn check_real_time_formula(&self, formula: &RealTimeFormula) -> RealTimeCheckingResult {
        // æ£€æŸ¥å®æ—¶æ—¶åºé€»è¾‘å…¬å¼
        let validity = self.real_time_semantics.check_validity(formula);

        if validity {
            let proof = self.real_time_semantics.generate_proof(formula);
            RealTimeCheckingResult::Valid(proof)
        } else {
            RealTimeCheckingResult::Invalid
        }
    }
}

pub enum RealTimeFormula {
    // åŸºæœ¬æ—¶åºæ“ä½œç¬¦
    Next(Box<RealTimeFormula>, Duration),
    Until(Box<RealTimeFormula>, Box<RealTimeFormula>, Duration),
    Eventually(Box<RealTimeFormula>, Duration),
    Always(Box<RealTimeFormula>, Duration),

    // å®æ—¶çº¦æŸ
    Deadline(Box<RealTimeFormula>, Duration),
    ResponseTime(Box<RealTimeFormula>, Duration),
}

pub enum RealTimeCheckingResult {
    Valid(RealTimeProof),
    Invalid,
}
```

### æ¦‚ç‡æ—¶åºé€»è¾‘ / Probabilistic Temporal Logic

```rust
pub struct ProbabilisticTemporalLogic {
    logic_system: TemporalLogicSystem,
    probabilistic_semantics: ProbabilisticSemantics,
}

impl ProbabilisticTemporalLogic {
    pub fn check_probabilistic_formula(&self, formula: &ProbabilisticFormula) -> ProbabilisticCheckingResult {
        // æ£€æŸ¥æ¦‚ç‡æ—¶åºé€»è¾‘å…¬å¼
        let probability = self.probabilistic_semantics.compute_probability(formula);

        if probability > 0.5 {
            ProbabilisticCheckingResult::Likely(probability)
        } else {
            ProbabilisticCheckingResult::Unlikely(probability)
        }
    }
}

pub enum ProbabilisticFormula {
    // æ¦‚ç‡æ“ä½œç¬¦
    ProbabilisticEventually(Box<ProbabilisticFormula>, f64),
    ProbabilisticAlways(Box<ProbabilisticFormula>, f64),
    ProbabilisticUntil(Box<ProbabilisticFormula>, Box<ProbabilisticFormula>, f64),
}

pub enum ProbabilisticCheckingResult {
    Likely(f64),
    Unlikely(f64),
}
```

---

*æ—¶åºé€»è¾‘ç†è®ºä¸ºç¨‹åºéªŒè¯ã€ç¡¬ä»¶éªŒè¯å’Œå®æ—¶ç³»ç»ŸéªŒè¯æä¾›äº†å¼ºå¤§çš„å½¢å¼åŒ–å·¥å…·ï¼Œæ˜¯ç°ä»£å½¢å¼åŒ–æ–¹æ³•çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚*

## å‚è€ƒæ–‡çŒ® / References

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Pnueli1977] Pnueli, A. (1977). "The Temporal Logic of Programs". In *18th Annual Symposium on Foundations of Computer Science (FOCS)* (pp. 46-57). IEEE.
   - **Pnueliæ—¶åºé€»è¾‘çš„å¼€åˆ›æ€§è®ºæ–‡**ï¼Œç¨‹åºéªŒè¯çš„å¥ åŸºä¹‹ä½œã€‚æœ¬æ–‡æ¡£çš„å…¨éƒ¨å†…å®¹åŸºäºæ­¤è®ºæ–‡ã€‚

2. Emerson, E. A., & Halpern, J. Y. (1986). "'Sometimes' and 'not never' revisited: On branching versus linear time temporal logic". *Journal of the ACM*, 33(1): 151-178.
   - åˆ†æ”¯æ—¶åºé€»è¾‘ä¸çº¿æ€§æ—¶åºé€»è¾‘çš„æ¯”è¾ƒç ”ç©¶ã€‚

3. Vardi, M. Y., & Wolper, P. (1986). "An automata-theoretic approach to automatic program verification". In *Logic in Computer Science (LICS)* (pp. 332-344). IEEE.
   - è‡ªåŠ¨æœºç†è®ºåœ¨ç¨‹åºéªŒè¯ä¸­çš„åº”ç”¨ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. [Clarke1999] Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). *Model Checking*. MIT Press. ISBN: 978-0262032704
   - **Clarkeæ¨¡å‹æ£€æŸ¥çš„æƒå¨æ•™æ**ï¼Œ2007å¹´å›¾çµå¥–è·å¥–å·¥ä½œã€‚

2. [BaierKatoen2008] Baier, C., & Katoen, J. P. (2008). *Principles of Model Checking*. MIT Press. ISBN: 978-0262026499
   - æ¨¡å‹æ£€æŸ¥çš„ç°ä»£æƒå¨æ•™æï¼Œæœ¬æ–‡æ¡£çš„æ¨¡å‹æ£€æŸ¥éƒ¨åˆ†å‚è€ƒæ­¤ä¹¦ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Temporal Logic**: <https://en.wikipedia.org/wiki/Temporal_logic>
   - æ—¶åºé€»è¾‘çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«çº¿æ€§æ—¶åºé€»è¾‘å’Œåˆ†æ”¯æ—¶åºé€»è¾‘ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Model Checking**: <https://en.wikipedia.org/wiki/Model_checking>
   - æ¨¡å‹æ£€æŸ¥çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»æ—¶åºé€»è¾‘åœ¨ç¨‹åºéªŒè¯ä¸­çš„åº”ç”¨ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Linear Temporal Logic**: <https://en.wikipedia.org/wiki/Linear_temporal_logic>
   - çº¿æ€§æ—¶åºé€»è¾‘çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«LTLçš„è¯­æ³•å’Œè¯­ä¹‰ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)
