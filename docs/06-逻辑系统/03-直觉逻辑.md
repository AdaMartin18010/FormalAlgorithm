---
title: 6.3 ç›´è§‰é€»è¾‘ / Intuitionistic Logic
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: é€»è¾‘ç³»ç»Ÿå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 6.3 ç›´è§‰é€»è¾‘ / Intuitionistic Logic

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€ç›´è§‰é€»è¾‘çš„å½¢å¼åŒ–å®šä¹‰ã€æ„é€ æ€§è¯æ˜ä¸å…‹é‡Œæ™®å…‹è¯­ä¹‰ã€‚
- å»ºç«‹ç›´è§‰é€»è¾‘ä¸ç»å…¸é€»è¾‘çš„å¯¹æ¯”æ¡†æ¶ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ç›´è§‰é€»è¾‘ã€æ„é€ æ€§è¯æ˜ã€æ’ä¸­å¾‹ã€å…‹é‡Œæ™®å…‹è¯­ä¹‰ã€ç›´è§‰ä¸»ä¹‰ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ç›´è§‰é€»è¾‘ï¼ˆIntuitionistic Logicï¼‰ï¼šæ‹’ç»æ’ä¸­å¾‹çš„æ„é€ æ€§é€»è¾‘ç³»ç»Ÿã€‚
- æ„é€ æ€§è¯æ˜ï¼ˆConstructive Proofï¼‰ï¼šå¿…é¡»æä¾›æ„é€ çš„å­˜åœ¨æ€§è¯æ˜ã€‚
- å…‹é‡Œæ™®å…‹è¯­ä¹‰ï¼ˆKripke Semanticsï¼‰ï¼šç›´è§‰é€»è¾‘çš„å¯èƒ½ä¸–ç•Œè¯­ä¹‰ã€‚
- è®°å·çº¦å®šï¼š`âŠ¢` è¡¨ç¤ºæ¨å¯¼ï¼Œ`âŠ¨` è¡¨ç¤ºè¯­ä¹‰è•´å«ï¼Œ`âŠ¥` è¡¨ç¤ºçŸ›ç›¾ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- æ„é€ æ€§è¯æ˜ï¼šå‚è§ `03-å½¢å¼åŒ–è¯æ˜/03-æ„é€ æ€§è¯æ˜.md`ã€‚
- å‘½é¢˜é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/01-å‘½é¢˜é€»è¾‘.md`ã€‚
- ä¸€é˜¶é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/02-ä¸€é˜¶é€»è¾‘.md`ã€‚
- é€»è¾‘ç³»ç»ŸåŸºç¡€ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- ç›´è§‰ä¸»ä¹‰
- æ„é€ æ€§è¯æ˜
- å…‹é‡Œæ™®å…‹è¯­ä¹‰

## ç›®å½• (Table of Contents)

- [6.3 ç›´è§‰é€»è¾‘ / Intuitionistic Logic](#63-ç›´è§‰é€»è¾‘--intuitionistic-logic)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.1 ç›´è§‰é€»è¾‘å®šä¹‰ (Definition of Intuitionistic Logic)](#11-ç›´è§‰é€»è¾‘å®šä¹‰-definition-of-intuitionistic-logic)
  - [1.2 ç›´è§‰é€»è¾‘ä¸ç»å…¸é€»è¾‘çš„åŒºåˆ« (Difference from Classical Logic)](#12-ç›´è§‰é€»è¾‘ä¸ç»å…¸é€»è¾‘çš„åŒºåˆ«-difference-from-classical-logic)
  - [1.3 ç›´è§‰é€»è¾‘çš„åŸºæœ¬åŸç† (Basic Principles of Intuitionistic Logic)](#13-ç›´è§‰é€»è¾‘çš„åŸºæœ¬åŸç†-basic-principles-of-intuitionistic-logic)
- [2. ç›´è§‰ä¸»ä¹‰ (Intuitionism)](#2-ç›´è§‰ä¸»ä¹‰-intuitionism)
  - [2.1 ç›´è§‰ä¸»ä¹‰å“²å­¦ (Intuitionistic Philosophy)](#21-ç›´è§‰ä¸»ä¹‰å“²å­¦-intuitionistic-philosophy)
  - [2.2 ç›´è§‰ä¸»ä¹‰æ•°å­¦ (Intuitionistic Mathematics)](#22-ç›´è§‰ä¸»ä¹‰æ•°å­¦-intuitionistic-mathematics)
  - [2.3 ç›´è§‰ä¸»ä¹‰ä¸å½¢å¼ä¸»ä¹‰ (Intuitionism vs Formalism)](#23-ç›´è§‰ä¸»ä¹‰ä¸å½¢å¼ä¸»ä¹‰-intuitionism-vs-formalism)
- [3. æ„é€ æ€§è¯æ˜ (Constructive Proofs)](#3-æ„é€ æ€§è¯æ˜-constructive-proofs)
  - [3.1 æ„é€ æ€§è¯æ˜å®šä¹‰ (Definition of Constructive Proofs)](#31-æ„é€ æ€§è¯æ˜å®šä¹‰-definition-of-constructive-proofs)
  - [3.2 æ„é€ æ€§è¯æ˜æŠ€æœ¯ (Constructive Proof Techniques)](#32-æ„é€ æ€§è¯æ˜æŠ€æœ¯-constructive-proof-techniques)
  - [3.3 éæ„é€ æ€§è¯æ˜çš„æ‹’ç» (Rejection of Non-Constructive Proofs)](#33-éæ„é€ æ€§è¯æ˜çš„æ‹’ç»-rejection-of-non-constructive-proofs)
- [4. å…‹é‡Œæ™®å…‹è¯­ä¹‰ (Kripke Semantics)](#4-å…‹é‡Œæ™®å…‹è¯­ä¹‰-kripke-semantics)
  - [4.1 å…‹é‡Œæ™®å…‹æ¨¡å‹ (Kripke Models)](#41-å…‹é‡Œæ™®å…‹æ¨¡å‹-kripke-models)
  - [4.2 å…‹é‡Œæ™®å…‹è¯­ä¹‰ (Kripke Semantics)](#42-å…‹é‡Œæ™®å…‹è¯­ä¹‰-kripke-semantics)
  - [4.3 å…‹é‡Œæ™®å…‹è¯­ä¹‰çš„æ€§è´¨ (Properties of Kripke Semantics)](#43-å…‹é‡Œæ™®å…‹è¯­ä¹‰çš„æ€§è´¨-properties-of-kripke-semantics)
- [5. å®ç°ç¤ºä¾‹ (Implementation Examples)](#5-å®ç°ç¤ºä¾‹-implementation-examples)
  - [5.1 ç›´è§‰é€»è¾‘è§£æå™¨ (Intuitionistic Logic Parser)](#51-ç›´è§‰é€»è¾‘è§£æå™¨-intuitionistic-logic-parser)
  - [5.2 å…‹é‡Œæ™®å…‹æ¨¡å‹å®ç° (Kripke Model Implementation)](#52-å…‹é‡Œæ™®å…‹æ¨¡å‹å®ç°-kripke-model-implementation)
  - [5.3 æ„é€ æ€§è¯æ˜ç³»ç»Ÿ (Constructive Proof System)](#53-æ„é€ æ€§è¯æ˜ç³»ç»Ÿ-constructive-proof-system)
  - [5.4 ç›´è§‰é€»è¾‘æµ‹è¯• (Intuitionistic Logic Testing)](#54-ç›´è§‰é€»è¾‘æµ‹è¯•-intuitionistic-logic-testing)
- [6. å‚è€ƒæ–‡çŒ® / References](#6-å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)
  - [ç°ä»£ç ”ç©¶ / Modern Research](#ç°ä»£ç ”ç©¶--modern-research)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.1 ç›´è§‰é€»è¾‘å®šä¹‰ (Definition of Intuitionistic Logic)

**ç›´è§‰é€»è¾‘å®šä¹‰ / Definition of Intuitionistic Logic:**

ç›´è§‰é€»è¾‘æ˜¯ä¸€ç§æ„é€ æ€§é€»è¾‘ç³»ç»Ÿï¼Œå®ƒæ‹’ç»æ’ä¸­å¾‹ï¼Œè¦æ±‚æ‰€æœ‰è¯æ˜éƒ½å¿…é¡»æ˜¯æ„é€ æ€§çš„ã€‚ç›´è§‰é€»è¾‘å¼ºè°ƒæ•°å­¦å¯¹è±¡çš„å­˜åœ¨å¿…é¡»é€šè¿‡æ„é€ æ¥è¯æ˜ã€‚

Intuitionistic logic is a constructive logical system that rejects the law of excluded middle and requires all proofs to be constructive. Intuitionistic logic emphasizes that the existence of mathematical objects must be proven through construction.

**ç›´è§‰é€»è¾‘çš„ç‰¹ç‚¹ / Characteristics of Intuitionistic Logic:**

1. **æ„é€ æ€§ (Constructive) / Constructive:**
   - æ‹’ç»éæ„é€ æ€§è¯æ˜ / Rejects non-constructive proofs
   - è¦æ±‚å­˜åœ¨æ€§è¯æ˜å¿…é¡»æä¾›æ„é€  / Requires existence proofs to provide constructions

2. **æ‹’ç»æ’ä¸­å¾‹ (Rejection of Excluded Middle) / Rejection of Excluded Middle:**
   - ä¸æ‰¿è®¤ $\phi \lor \neg \phi$ ä¸ºæ°¸çœŸå¼ / Does not accept $\phi \lor \neg \phi$ as a tautology
   - å¼ºè°ƒæ„é€ æ€§è¯æ˜ / Emphasizes constructive proofs

3. **ç›´è§‰ä¸»ä¹‰å“²å­¦ (Intuitionistic Philosophy) / Intuitionistic Philosophy:**
   - æ•°å­¦æ˜¯å¿ƒæ™ºçš„æ„é€  / Mathematics is a construction of the mind
   - çœŸç†é€šè¿‡æ„é€ å»ºç«‹ / Truth is established through construction

### 1.2 ç›´è§‰é€»è¾‘ä¸ç»å…¸é€»è¾‘çš„åŒºåˆ« (Difference from Classical Logic)

**ç»å…¸é€»è¾‘ç‰¹å¾ / Classical Logic Characteristics:**

- æ‰¿è®¤æ’ä¸­å¾‹ / Accepts law of excluded middle
- å…è®¸éæ„é€ æ€§è¯æ˜ / Allows non-constructive proofs
- ä½¿ç”¨åè¯æ³• / Uses proof by contradiction

**ç›´è§‰é€»è¾‘ç‰¹å¾ / Intuitionistic Logic Characteristics:**

- æ‹’ç»æ’ä¸­å¾‹ / Rejects law of excluded middle
- è¦æ±‚æ„é€ æ€§è¯æ˜ / Requires constructive proofs
- é™åˆ¶åè¯æ³•çš„ä½¿ç”¨ / Limits use of proof by contradiction

### 1.3 ç›´è§‰é€»è¾‘çš„åŸºæœ¬åŸç† (Basic Principles of Intuitionistic Logic)

**æ„é€ æ€§åŸç† (Constructive Principle) / Constructive Principle:**

å¯¹äºä»»ä½•å‘½é¢˜ $\phi$ï¼Œè¯æ˜ $\phi$ æ„å‘³ç€æ„é€ ä¸€ä¸ªè¯æ˜å¯¹è±¡ã€‚

For any proposition $\phi$, proving $\phi$ means constructing a proof object.

**å­˜åœ¨æ€§åŸç† (Existence Principle) / Existence Principle:**

è¯æ˜ $\exists x \phi(x)$ æ„å‘³ç€æ„é€ ä¸€ä¸ªå¯¹è±¡ $a$ å¹¶è¯æ˜ $\phi(a)$ã€‚

Proving $\exists x \phi(x)$ means constructing an object $a$ and proving $\phi(a)$.

**å¦å®šåŸç† (Negation Principle) / Negation Principle:**

è¯æ˜ $\neg \phi$ æ„å‘³ç€ä»å‡è®¾ $\phi$ æ¨å¯¼å‡ºçŸ›ç›¾ã€‚

Proving $\neg \phi$ means deriving a contradiction from the assumption $\phi$.

---

## 2. ç›´è§‰ä¸»ä¹‰ (Intuitionism)

### 2.1 ç›´è§‰ä¸»ä¹‰å“²å­¦ (Intuitionistic Philosophy)

**ç›´è§‰ä¸»ä¹‰åˆ›å§‹äºº / Founder of Intuitionism:**

å¸ƒåŠ³å¨å°” (L.E.J. Brouwer) æ˜¯ç›´è§‰ä¸»ä¹‰çš„åˆ›å§‹äººï¼Œä»–æå‡ºäº†ç›´è§‰ä¸»ä¹‰æ•°å­¦å“²å­¦ã€‚

L.E.J. Brouwer is the founder of intuitionism, who proposed the intuitionistic philosophy of mathematics.

**ç›´è§‰ä¸»ä¹‰æ ¸å¿ƒæ€æƒ³ / Core Ideas of Intuitionism:**

1. **æ•°å­¦æ˜¯å¿ƒæ™ºæ„é€  (Mathematics as Mental Construction) / Mathematics as Mental Construction:**
   - æ•°å­¦å¯¹è±¡æ˜¯å¿ƒæ™ºçš„æ„é€  / Mathematical objects are constructions of the mind
   - æ•°å­¦çœŸç†é€šè¿‡æ„é€ å»ºç«‹ / Mathematical truth is established through construction

2. **æ‹’ç»éæ„é€ æ€§è¯æ˜ (Rejection of Non-Constructive Proofs) / Rejection of Non-Constructive Proofs:**
   - å­˜åœ¨æ€§è¯æ˜å¿…é¡»æä¾›æ„é€  / Existence proofs must provide constructions
   - æ‹’ç»çº¯ç²¹çš„å­˜åœ¨æ€§æ–­è¨€ / Rejects pure existence assertions

3. **æ—¶é—´æ€§ (Temporality) / Temporality:**
   - æ•°å­¦æ„é€ æ˜¯æ—¶é—´æ€§çš„ / Mathematical constructions are temporal
   - æ„é€ è¿‡ç¨‹æ˜¯é‡è¦çš„ / The construction process is important

### 2.2 ç›´è§‰ä¸»ä¹‰æ•°å­¦ (Intuitionistic Mathematics)

**ç›´è§‰ä¸»ä¹‰é›†åˆè®º (Intuitionistic Set Theory) / Intuitionistic Set Theory:**

ç›´è§‰ä¸»ä¹‰é›†åˆè®ºæ‹’ç»é€‰æ‹©å…¬ç†ï¼Œå¼ºè°ƒæ„é€ æ€§é›†åˆã€‚

Intuitionistic set theory rejects the axiom of choice and emphasizes constructive sets.

**ç›´è§‰ä¸»ä¹‰åˆ†æ (Intuitionistic Analysis) / Intuitionistic Analysis:**

ç›´è§‰ä¸»ä¹‰åˆ†ææ‹’ç»æŸäº›ç»å…¸åˆ†æçš„ç»“æœï¼Œå¦‚ï¼š

Intuitionistic analysis rejects certain results of classical analysis, such as:

1. **ä¸­é—´å€¼å®šç† (Intermediate Value Theorem) / Intermediate Value Theorem:**
   - ç»å…¸ç‰ˆæœ¬ï¼šè¿ç»­å‡½æ•°åœ¨åŒºé—´ç«¯ç‚¹å–ä¸åŒå€¼æ—¶ï¼Œåœ¨åŒºé—´å†…å¿…æœ‰é›¶ç‚¹
   - ç›´è§‰ä¸»ä¹‰ç‰ˆæœ¬ï¼šéœ€è¦æ„é€ é›¶ç‚¹ä½ç½®

2. **æµ·æ¶…-åšé›·å°”å®šç† (Heine-Borel Theorem) / Heine-Borel Theorem:**
   - ç»å…¸ç‰ˆæœ¬ï¼šé—­åŒºé—´ä¸Šçš„è¿ç»­å‡½æ•°ä¸€è‡´è¿ç»­
   - ç›´è§‰ä¸»ä¹‰ç‰ˆæœ¬ï¼šéœ€è¦æ„é€ ä¸€è‡´è¿ç»­æ€§çš„è¯æ˜

### 2.3 ç›´è§‰ä¸»ä¹‰ä¸å½¢å¼ä¸»ä¹‰ (Intuitionism vs Formalism)

**å½¢å¼ä¸»ä¹‰è§‚ç‚¹ / Formalist View:**

- æ•°å­¦æ˜¯ç¬¦å·æ¸¸æˆ / Mathematics is a game of symbols
- çœŸç†é€šè¿‡å½¢å¼åŒ–å»ºç«‹ / Truth is established through formalization
- æ¥å—ç»å…¸é€»è¾‘ / Accepts classical logic

**ç›´è§‰ä¸»ä¹‰è§‚ç‚¹ / Intuitionistic View:**

- æ•°å­¦æ˜¯å¿ƒæ™ºæ„é€  / Mathematics is mental construction
- çœŸç†é€šè¿‡æ„é€ å»ºç«‹ / Truth is established through construction
- æ‹’ç»ç»å…¸é€»è¾‘çš„æŸäº›åŸåˆ™ / Rejects certain principles of classical logic

---

## 3. æ„é€ æ€§è¯æ˜ (Constructive Proofs)

### 3.1 æ„é€ æ€§è¯æ˜å®šä¹‰ (Definition of Constructive Proofs)

**æ„é€ æ€§è¯æ˜å®šä¹‰ / Definition of Constructive Proofs:**

æ„é€ æ€§è¯æ˜æ˜¯æä¾›å…·ä½“æ„é€ çš„è¯æ˜æ–¹æ³•ï¼Œå®ƒä¸ä»…è¯æ˜å­˜åœ¨æ€§ï¼Œè¿˜æä¾›æ„é€ å¯¹è±¡çš„æ–¹æ³•ã€‚

Constructive proofs are proof methods that provide concrete constructions, proving not only existence but also providing methods to construct objects.

**æ„é€ æ€§è¯æ˜çš„ç‰¹ç‚¹ / Characteristics of Constructive Proofs:**

1. **å…·ä½“æ€§ (Concreteness) / Concreteness:**
   - æä¾›å…·ä½“çš„æ„é€  / Provides concrete constructions
   - å¯ä»¥å®é™…è®¡ç®— / Can be actually computed

2. **æœ‰æ•ˆæ€§ (Effectiveness) / Effectiveness:**
   - æ„é€ æ˜¯æœ‰æ•ˆçš„ / Constructions are effective
   - å¯ä»¥åœ¨æœ‰é™æ­¥éª¤å†…å®Œæˆ / Can be completed in finite steps

3. **å¯éªŒè¯æ€§ (Verifiability) / Verifiability:**
   - æ„é€ ç»“æœå¯ä»¥éªŒè¯ / Construction results can be verified
   - æ»¡è¶³ç»™å®šçš„æ€§è´¨ / Satisfies given properties

### 3.2 æ„é€ æ€§è¯æ˜æŠ€æœ¯ (Constructive Proof Techniques)

**ç›´æ¥æ„é€  (Direct Construction) / Direct Construction:**

ç›´æ¥æ„é€ æ˜¯æä¾›å…·ä½“å¯¹è±¡æ¥è¯æ˜å­˜åœ¨æ€§çš„æ–¹æ³•ã€‚

Direct construction is a method of proving existence by providing concrete objects.

**ç¤ºä¾‹ / Example:**

è¯æ˜å­˜åœ¨æ— ç†æ•° $x$ ä½¿å¾— $x^2 = 2$ï¼š

To prove that there exists an irrational number $x$ such that $x^2 = 2$:

1. æ„é€ åºåˆ— $a_n = \frac{p_n}{q_n}$ï¼Œå…¶ä¸­ $p_n$ å’Œ $q_n$ æ»¡è¶³ç‰¹å®šæ¡ä»¶
2. è¯æ˜åºåˆ—æ”¶æ•›åˆ° $\sqrt{2}$
3. è¯æ˜æé™æ˜¯æ— ç†æ•°

**é€’å½’æ„é€  (Recursive Construction) / Recursive Construction:**

é€’å½’æ„é€ æ˜¯é€šè¿‡é€’å½’å®šä¹‰æ¥æ„é€ å¯¹è±¡çš„æ–¹æ³•ã€‚

Recursive construction is a method of constructing objects through recursive definitions.

**ç¤ºä¾‹ / Example:**

æ„é€ è‡ªç„¶æ•°é›†ï¼š

To construct the set of natural numbers:

1. $0$ æ˜¯è‡ªç„¶æ•°
2. å¦‚æœ $n$ æ˜¯è‡ªç„¶æ•°ï¼Œåˆ™ $S(n)$ æ˜¯è‡ªç„¶æ•°
3. åªæœ‰é€šè¿‡ä¸Šè¿°è§„åˆ™æ„é€ çš„æ‰æ˜¯è‡ªç„¶æ•°

### 3.3 éæ„é€ æ€§è¯æ˜çš„æ‹’ç» (Rejection of Non-Constructive Proofs)

**æ’ä¸­å¾‹çš„æ‹’ç» (Rejection of Excluded Middle) / Rejection of Excluded Middle:**

ç›´è§‰é€»è¾‘æ‹’ç»æ’ä¸­å¾‹ $\phi \lor \neg \phi$ï¼Œå› ä¸ºï¼š

Intuitionistic logic rejects the law of excluded middle $\phi \lor \neg \phi$ because:

1. **ç¼ºä¹æ„é€ æ€§ / Lack of Constructiveness:**
   - æ’ä¸­å¾‹ä¸æä¾›æ„é€  / Excluded middle does not provide construction
   - æ— æ³•ç¡®å®šå“ªä¸ªæå–é¡¹ä¸ºçœŸ / Cannot determine which disjunct is true

2. **å“²å­¦è€ƒè™‘ / Philosophical Considerations:**
   - ä¸ç›´è§‰ä¸»ä¹‰å“²å­¦ä¸ç¬¦ / Inconsistent with intuitionistic philosophy
   - å¼ºè°ƒæ„é€ æ€§çœŸç† / Emphasizes constructive truth

**åè¯æ³•çš„é™åˆ¶ (Limitations of Proof by Contradiction) / Limitations of Proof by Contradiction:**

ç›´è§‰é€»è¾‘é™åˆ¶åè¯æ³•çš„ä½¿ç”¨ï¼š

Intuitionistic logic limits the use of proof by contradiction:

1. **å¦å®šæ€§å‘½é¢˜ / Negative Propositions:**
   - å¯ä»¥ç”¨äºè¯æ˜å¦å®šæ€§å‘½é¢˜ / Can be used to prove negative propositions
   - ä¾‹å¦‚ï¼šè¯æ˜ $\neg \phi$ / e.g., proving $\neg \phi$

2. **å­˜åœ¨æ€§å‘½é¢˜ / Existential Propositions:**
   - ä¸èƒ½ç”¨äºè¯æ˜å­˜åœ¨æ€§å‘½é¢˜ / Cannot be used to prove existential propositions
   - å¿…é¡»æä¾›æ„é€  / Must provide construction

---

## 4. å…‹é‡Œæ™®å…‹è¯­ä¹‰ (Kripke Semantics)

### 4.1 å…‹é‡Œæ™®å…‹æ¨¡å‹ (Kripke Models)

**å…‹é‡Œæ™®å…‹æ¨¡å‹å®šä¹‰ / Definition of Kripke Models:**

å…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯ç›´è§‰é€»è¾‘çš„è¯­ä¹‰æ¨¡å‹ï¼Œå®ƒä½¿ç”¨å¯èƒ½ä¸–ç•Œå’Œå¯è¾¾å…³ç³»æ¥è§£é‡Šç›´è§‰é€»è¾‘ã€‚

Kripke models are semantic models for intuitionistic logic that use possible worlds and accessibility relations to interpret intuitionistic logic.

**å…‹é‡Œæ™®å…‹æ¨¡å‹ç»“æ„ / Kripke Model Structure:**

å…‹é‡Œæ™®å…‹æ¨¡å‹ $\mathcal{K} = (W, R, V)$ åŒ…å«ï¼š

A Kripke model $\mathcal{K} = (W, R, V)$ consists of:

1. **å¯èƒ½ä¸–ç•Œé›†åˆ (Set of Possible Worlds) / Set of Possible Worlds:**
   - $W$ æ˜¯éç©ºé›†åˆ / $W$ is a non-empty set

2. **å¯è¾¾å…³ç³» (Accessibility Relation) / Accessibility Relation:**
   - $R \subseteq W \times W$ æ˜¯è‡ªåå’Œä¼ é€’çš„ / $R \subseteq W \times W$ is reflexive and transitive

3. **èµ‹å€¼å‡½æ•° (Valuation Function) / Valuation Function:**
   - $V: W \times \text{Prop} \rightarrow \{0, 1\}$ æ»¡è¶³å•è°ƒæ€§ / $V: W \times \text{Prop} \rightarrow \{0, 1\}$ satisfies monotonicity

### 4.2 å…‹é‡Œæ™®å…‹è¯­ä¹‰ (Kripke Semantics)

**æ»¡è¶³å…³ç³»å®šä¹‰ / Definition of Satisfaction Relation:**

ç»™å®šå…‹é‡Œæ™®å…‹æ¨¡å‹ $\mathcal{K} = (W, R, V)$ å’Œä¸–ç•Œ $w \in W$ï¼š

Given a Kripke model $\mathcal{K} = (W, R, V)$ and world $w \in W$:

1. **åŸå­å‘½é¢˜ (Atomic Propositions) / Atomic Propositions:**
   - $\mathcal{K}, w \models p$ å½“ä¸”ä»…å½“ $V(w, p) = 1$

2. **å¦å®š (Negation) / Negation:**
   - $\mathcal{K}, w \models \neg \phi$ å½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œ$\mathcal{K}, v \not\models \phi$

3. **åˆå– (Conjunction) / Conjunction:**
   - $\mathcal{K}, w \models \phi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{K}, w \models \phi$ ä¸” $\mathcal{K}, w \models \psi$

4. **æå– (Disjunction) / Disjunction:**
   - $\mathcal{K}, w \models \phi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{K}, w \models \phi$ æˆ– $\mathcal{K}, w \models \psi$

5. **è•´å« (Implication) / Implication:**
   - $\mathcal{K}, w \models \phi \rightarrow \psi$ å½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œå¦‚æœ $\mathcal{K}, v \models \phi$ åˆ™ $\mathcal{K}, v \models \psi$

6. **å…¨ç§°é‡è¯ (Universal Quantifier) / Universal Quantifier:**
   - $\mathcal{K}, w \models \forall x \phi(x)$ å½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ å’Œæ‰€æœ‰ $d \in D_v$ï¼Œ$\mathcal{K}, v \models \phi(d)$

7. **å­˜åœ¨é‡è¯ (Existential Quantifier) / Existential Quantifier:**
   - $\mathcal{K}, w \models \exists x \phi(x)$ å½“ä¸”ä»…å½“å­˜åœ¨ $d \in D_w$ ä½¿å¾— $\mathcal{K}, w \models \phi(d)$

### 4.3 å…‹é‡Œæ™®å…‹è¯­ä¹‰çš„æ€§è´¨ (Properties of Kripke Semantics)

**å•è°ƒæ€§ (Monotonicity) / Monotonicity:**

**å®šç† 3.4.1** (å…‹é‡Œæ™®å…‹è¯­ä¹‰çš„å•è°ƒæ€§) å…‹é‡Œæ™®å…‹è¯­ä¹‰æ»¡è¶³å•è°ƒæ€§ï¼š
å¦‚æœ $w \leq v$ ä¸” $\mathcal{K}, w \models \phi$ï¼Œåˆ™ $\mathcal{K}, v \models \phi$ã€‚

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡å¯¹å…¬å¼ç»“æ„çš„å½’çº³æ¥è¯æ˜å•è°ƒæ€§ã€‚

**åŸºç¡€æƒ…å†µï¼š** å¯¹äºåŸå­å‘½é¢˜ $p$ï¼Œå¦‚æœ $\mathcal{K}, w \models p$ï¼Œåˆ™ $V(w, p) = 1$ã€‚
ç”±äºèµ‹å€¼å‡½æ•°æ»¡è¶³å•è°ƒæ€§ï¼Œå¦‚æœ $w \leq v$ï¼Œåˆ™ $V(v, p) = 1$ï¼Œå› æ­¤ $\mathcal{K}, v \models p$ã€‚

**å½’çº³æ­¥éª¤ï¼š**

**æƒ…å†µ1ï¼š** å‡è®¾ $\phi = \neg \psi$ã€‚
å¦‚æœ $\mathcal{K}, w \models \neg \psi$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $u$ ä½¿å¾— $w \leq u$ï¼Œ$\mathcal{K}, u \not\models \psi$ã€‚
å¦‚æœ $w \leq v$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $u$ ä½¿å¾— $v \leq u$ï¼Œç”±äºä¼ é€’æ€§ $w \leq u$ï¼Œå› æ­¤ $\mathcal{K}, u \not\models \psi$ã€‚
å› æ­¤ï¼Œ$\mathcal{K}, v \models \neg \psi$ã€‚

**æƒ…å†µ2ï¼š** å‡è®¾ $\phi = \psi_1 \land \psi_2$ã€‚
å¦‚æœ $\mathcal{K}, w \models \psi_1 \land \psi_2$ï¼Œåˆ™ $\mathcal{K}, w \models \psi_1$ ä¸” $\mathcal{K}, w \models \psi_2$ã€‚
æ ¹æ®å½’çº³å‡è®¾ï¼Œ$\mathcal{K}, v \models \psi_1$ ä¸” $\mathcal{K}, v \models \psi_2$ã€‚
å› æ­¤ï¼Œ$\mathcal{K}, v \models \psi_1 \land \psi_2$ã€‚

**æƒ…å†µ3ï¼š** å‡è®¾ $\phi = \psi_1 \lor \psi_2$ã€‚
å¦‚æœ $\mathcal{K}, w \models \psi_1 \lor \psi_2$ï¼Œåˆ™ $\mathcal{K}, w \models \psi_1$ æˆ– $\mathcal{K}, w \models \psi_2$ã€‚
æ ¹æ®å½’çº³å‡è®¾ï¼Œ$\mathcal{K}, v \models \psi_1$ æˆ– $\mathcal{K}, v \models \psi_2$ã€‚
å› æ­¤ï¼Œ$\mathcal{K}, v \models \psi_1 \lor \psi_2$ã€‚

**æƒ…å†µ4ï¼š** å‡è®¾ $\phi = \psi_1 \rightarrow \psi_2$ã€‚
å¦‚æœ $\mathcal{K}, w \models \psi_1 \rightarrow \psi_2$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $u$ ä½¿å¾— $w \leq u$ï¼Œå¦‚æœ $\mathcal{K}, u \models \psi_1$ åˆ™ $\mathcal{K}, u \models \psi_2$ã€‚
å¦‚æœ $w \leq v$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $u$ ä½¿å¾— $v \leq u$ï¼Œç”±äºä¼ é€’æ€§ $w \leq u$ï¼Œå› æ­¤å¦‚æœ $\mathcal{K}, u \models \psi_1$ åˆ™ $\mathcal{K}, u \models \psi_2$ã€‚
å› æ­¤ï¼Œ$\mathcal{K}, v \models \psi_1 \rightarrow \psi_2$ã€‚

å› æ­¤ï¼Œå…‹é‡Œæ™®å…‹è¯­ä¹‰æ»¡è¶³å•è°ƒæ€§ã€‚$\square$

**å®šç† 3.4.2** (æ’ä¸­å¾‹åœ¨ç›´è§‰é€»è¾‘ä¸­çš„å¤±æ•ˆ) åœ¨ç›´è§‰é€»è¾‘ä¸­ï¼Œæ’ä¸­å¾‹ $\phi \lor \neg \phi$ ä¸æ˜¯æ°¸çœŸå¼ã€‚

**è¯æ˜ï¼š** æˆ‘ä»¬æ„é€ ä¸€ä¸ªå…‹é‡Œæ™®å…‹æ¨¡å‹æ¥è¯æ˜æ’ä¸­å¾‹åœ¨ç›´è§‰é€»è¾‘ä¸­ä¸æˆç«‹ã€‚

**æ„é€ åä¾‹ï¼š**

è€ƒè™‘å…‹é‡Œæ™®å…‹æ¨¡å‹ $\mathcal{K} = (W, R, V)$ï¼Œå…¶ä¸­ï¼š

- $W = \{w_1, w_2\}$
- $R = \{(w_1, w_1), (w_2, w_2), (w_1, w_2)\}$ ï¼ˆ$w_1 \leq w_2$ï¼‰
- $V(w_1, p) = 0$ï¼Œ$V(w_2, p) = 1$ï¼Œå…¶ä¸­ $p$ æ˜¯æŸä¸ªåŸå­å‘½é¢˜

**éªŒè¯æ’ä¸­å¾‹ä¸æˆç«‹ï¼š**

åœ¨ $w_1$ ä¸­ï¼š

- $\mathcal{K}, w_1 \not\models p$ ï¼ˆå› ä¸º $V(w_1, p) = 0$ï¼‰
- $\mathcal{K}, w_1 \not\models \neg p$ ï¼ˆå› ä¸ºå­˜åœ¨ $w_2$ ä½¿å¾— $w_1 \leq w_2$ ä¸” $\mathcal{K}, w_2 \models p$ï¼‰
- å› æ­¤ï¼Œ$\mathcal{K}, w_1 \not\models p \lor \neg p$

å› æ­¤ï¼Œæ’ä¸­å¾‹åœ¨ç›´è§‰é€»è¾‘ä¸­ä¸æ˜¯æ°¸çœŸå¼ã€‚$\square$

å¦‚æœ $\mathcal{K}, w \models \phi$ ä¸” $wRv$ï¼Œåˆ™ $\mathcal{K}, v \models \phi$ã€‚

If $\mathcal{K}, w \models \phi$ and $wRv$, then $\mathcal{K}, v \models \phi$.

**ç›´è§‰é€»è¾‘çš„æœ‰æ•ˆæ€§ (Validity in Intuitionistic Logic) / Validity in Intuitionistic Logic:**

å…¬å¼ $\phi$ åœ¨ç›´è§‰é€»è¾‘ä¸­æœ‰æ•ˆï¼Œå½“ä¸”ä»…å½“åœ¨æ‰€æœ‰å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­ä¸ºçœŸã€‚

A formula $\phi$ is valid in intuitionistic logic if and only if it is true in all Kripke models.

**ç›´è§‰é€»è¾‘çš„å®Œå¤‡æ€§ (Completeness of Intuitionistic Logic) / Completeness of Intuitionistic Logic:**

ç›´è§‰é€»è¾‘ç›¸å¯¹äºå…‹é‡Œæ™®å…‹è¯­ä¹‰æ˜¯å®Œå¤‡çš„ã€‚

Intuitionistic logic is complete with respect to Kripke semantics.

---

## 5. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 5.1 ç›´è§‰é€»è¾‘è§£æå™¨ (Intuitionistic Logic Parser)

```rust
use std::collections::HashMap;

/// ç›´è§‰é€»è¾‘è§£æå™¨ / Intuitionistic Logic Parser
pub struct IntuitionisticLogicParser {
    variables: HashMap<String, String>,
    constants: HashMap<String, String>,
    functions: HashMap<String, Vec<String>>,
    predicates: HashMap<String, Vec<String>>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum IntuitionisticTerm {
    Variable(String),
    Constant(String),
    Function(String, Vec<IntuitionisticTerm>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum IntuitionisticFormula {
    Atomic(String, Vec<IntuitionisticTerm>),
    Negation(Box<IntuitionisticFormula>),
    Conjunction(Box<IntuitionisticFormula>, Box<IntuitionisticFormula>),
    Disjunction(Box<IntuitionisticFormula>, Box<IntuitionisticFormula>),
    Implication(Box<IntuitionisticFormula>, Box<IntuitionisticFormula>),
    Universal(String, Box<IntuitionisticFormula>),
    Existential(String, Box<IntuitionisticFormula>),
}

impl IntuitionisticLogicParser {
    /// åˆ›å»ºæ–°çš„è§£æå™¨ / Create new parser
    pub fn new() -> Self {
        IntuitionisticLogicParser {
            variables: HashMap::new(),
            constants: HashMap::new(),
            functions: HashMap::new(),
            predicates: HashMap::new(),
        }
    }

    /// è§£æç›´è§‰é€»è¾‘å…¬å¼ / Parse intuitionistic formula
    pub fn parse_formula(&self, input: &str) -> Result<IntuitionisticFormula, String> {
        let tokens = self.tokenize(input)?;
        self.parse_formula_tokens(&tokens)
    }

    /// è¯æ³•åˆ†æ / Tokenization
    fn tokenize(&self, input: &str) -> Result<Vec<String>, String> {
        let mut tokens = Vec::new();
        let mut current = String::new();

        for ch in input.chars() {
            match ch {
                ' ' | '\t' | '\n' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                }
                '(' | ')' | ',' | 'â†’' | 'âˆ§' | 'âˆ¨' | 'Â¬' | 'âˆ€' | 'âˆƒ' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                    tokens.push(ch.to_string());
                }
                _ => current.push(ch),
            }
        }

        if !current.is_empty() {
            tokens.push(current);
        }

        Ok(tokens)
    }

    /// è§£æå…¬å¼æ ‡è®° / Parse formula tokens
    fn parse_formula_tokens(&self, tokens: &[String]) -> Result<IntuitionisticFormula, String> {
        if tokens.is_empty() {
            return Err("Empty token list".to_string());
        }

        match tokens[0].as_str() {
            "Â¬" => {
                if tokens.len() < 2 {
                    return Err("Invalid negation".to_string());
                }
                let sub_formula = self.parse_formula_tokens(&tokens[1..])?;
                Ok(IntuitionisticFormula::Negation(Box::new(sub_formula)))
            }
            "âˆ€" => {
                if tokens.len() < 4 || tokens[1] != "(" || tokens[3] != ")" {
                    return Err("Invalid universal quantifier".to_string());
                }
                let variable = tokens[2].clone();
                let sub_formula = self.parse_formula_tokens(&tokens[4..])?;
                Ok(IntuitionisticFormula::Universal(variable, Box::new(sub_formula)))
            }
            "âˆƒ" => {
                if tokens.len() < 4 || tokens[1] != "(" || tokens[3] != ")" {
                    return Err("Invalid existential quantifier".to_string());
                }
                let variable = tokens[2].clone();
                let sub_formula = self.parse_formula_tokens(&tokens[4..])?;
                Ok(IntuitionisticFormula::Existential(variable, Box::new(sub_formula)))
            }
            pred_name => {
                if tokens.len() < 3 || tokens[1] != "(" || tokens[tokens.len() - 1] != ")" {
                    return Err("Invalid predicate syntax".to_string());
                }

                let args_tokens = &tokens[2..tokens.len() - 1];
                let args = self.parse_term_list(args_tokens)?;
                Ok(IntuitionisticFormula::Atomic(pred_name.to_string(), args))
            }
        }
    }

    /// è§£æé¡¹åˆ—è¡¨ / Parse term list
    fn parse_term_list(&self, tokens: &[String]) -> Result<Vec<IntuitionisticTerm>, String> {
        if tokens.is_empty() {
            return Ok(Vec::new());
        }

        let mut terms = Vec::new();
        let mut current_tokens = Vec::new();
        let mut paren_count = 0;

        for token in tokens {
            match token.as_str() {
                "(" => {
                    paren_count += 1;
                    current_tokens.push(token.clone());
                }
                ")" => {
                    paren_count -= 1;
                    current_tokens.push(token.clone());
                }
                "," => {
                    if paren_count == 0 {
                        if !current_tokens.is_empty() {
                            terms.push(self.parse_term_tokens(&current_tokens)?);
                            current_tokens.clear();
                        }
                    } else {
                        current_tokens.push(token.clone());
                    }
                }
                _ => current_tokens.push(token.clone()),
            }
        }

        if !current_tokens.is_empty() {
            terms.push(self.parse_term_tokens(&current_tokens)?);
        }

        Ok(terms)
    }

    /// è§£æé¡¹æ ‡è®° / Parse term tokens
    fn parse_term_tokens(&self, tokens: &[String]) -> Result<IntuitionisticTerm, String> {
        if tokens.is_empty() {
            return Err("Empty token list".to_string());
        }

        match tokens[0].as_str() {
            "x" | "y" | "z" => Ok(IntuitionisticTerm::Variable(tokens[0].clone())),
            "a" | "b" | "c" => Ok(IntuitionisticTerm::Constant(tokens[0].clone())),
            func_name => {
                if tokens.len() < 3 || tokens[1] != "(" || tokens[tokens.len() - 1] != ")" {
                    return Err("Invalid function syntax".to_string());
                }

                let args_tokens = &tokens[2..tokens.len() - 1];
                let args = self.parse_term_list(args_tokens)?;
                Ok(IntuitionisticTerm::Function(func_name.to_string(), args))
            }
        }
    }
}
```

### 5.2 å…‹é‡Œæ™®å…‹æ¨¡å‹å®ç° (Kripke Model Implementation)

```rust
/// å…‹é‡Œæ™®å…‹æ¨¡å‹å®ç° / Kripke Model Implementation
pub struct KripkeModel {
    worlds: Vec<String>,
    accessibility: Vec<Vec<bool>>,
    valuation: HashMap<(String, String), bool>,
}

impl KripkeModel {
    /// åˆ›å»ºæ–°çš„å…‹é‡Œæ™®å…‹æ¨¡å‹ / Create new Kripke model
    pub fn new() -> Self {
        KripkeModel {
            worlds: Vec::new(),
            accessibility: Vec::new(),
            valuation: HashMap::new(),
        }
    }

    /// æ·»åŠ ä¸–ç•Œ / Add world
    pub fn add_world(&mut self, world: String) {
        if !self.worlds.contains(&world) {
            self.worlds.push(world.clone());
            self.accessibility.push(vec![false; self.worlds.len()]);

            // æ›´æ–°å…¶ä»–ä¸–ç•Œçš„å¯è¾¾å…³ç³» / Update accessibility relations for other worlds
            for row in &mut self.accessibility {
                row.push(false);
            }
        }
    }

    /// è®¾ç½®å¯è¾¾å…³ç³» / Set accessibility relation
    pub fn set_accessibility(&mut self, from: &str, to: &str, accessible: bool) {
        if let (Some(from_idx), Some(to_idx)) = (self.world_index(from), self.world_index(to)) {
            self.accessibility[from_idx][to_idx] = accessible;
        }
    }

    /// è®¾ç½®èµ‹å€¼ / Set valuation
    pub fn set_valuation(&mut self, world: &str, proposition: &str, value: bool) {
        self.valuation.insert((world.to_string(), proposition.to_string()), value);
    }

    /// æ£€æŸ¥æ»¡è¶³å…³ç³» / Check satisfaction relation
    pub fn satisfies(&self, world: &str, formula: &IntuitionisticFormula) -> bool {
        match formula {
            IntuitionisticFormula::Atomic(prop, _) => {
                self.valuation.get(&(world.to_string(), prop.clone())).unwrap_or(&false)
            }
            IntuitionisticFormula::Negation(sub_formula) => {
                // å¯¹äºæ‰€æœ‰å¯è¾¾ä¸–ç•Œï¼Œå­å…¬å¼éƒ½ä¸æ»¡è¶³
                // For all accessible worlds, the sub-formula is not satisfied
                if let Some(world_idx) = self.world_index(world) {
                    for (to_world, &accessible) in self.worlds.iter().zip(&self.accessibility[world_idx]) {
                        if accessible && self.satisfies(to_world, sub_formula) {
                            return false;
                        }
                    }
                }
                true
            }
            IntuitionisticFormula::Conjunction(left, right) => {
                self.satisfies(world, left) && self.satisfies(world, right)
            }
            IntuitionisticFormula::Disjunction(left, right) => {
                self.satisfies(world, left) || self.satisfies(world, right)
            }
            IntuitionisticFormula::Implication(left, right) => {
                if let Some(world_idx) = self.world_index(world) {
                    for (to_world, &accessible) in self.worlds.iter().zip(&self.accessibility[world_idx]) {
                        if accessible && self.satisfies(to_world, left) && !self.satisfies(to_world, right) {
                            return false;
                        }
                    }
                }
                true
            }
            IntuitionisticFormula::Universal(var, sub_formula) => {
                // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥å½“å‰ä¸–ç•Œæ˜¯å¦æ»¡è¶³
                // Simplified implementation: check if current world satisfies
                self.satisfies(world, sub_formula)
            }
            IntuitionisticFormula::Existential(var, sub_formula) => {
                // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥å½“å‰ä¸–ç•Œæ˜¯å¦æ»¡è¶³
                // Simplified implementation: check if current world satisfies
                self.satisfies(world, sub_formula)
            }
        }
    }

    /// è·å–ä¸–ç•Œç´¢å¼• / Get world index
    fn world_index(&self, world: &str) -> Option<usize> {
        self.worlds.iter().position(|w| w == world)
    }

    /// æ£€æŸ¥æ¨¡å‹æœ‰æ•ˆæ€§ / Check model validity
    pub fn is_valid(&self) -> bool {
        // æ£€æŸ¥è‡ªåæ€§ / Check reflexivity
        for (i, world) in self.worlds.iter().enumerate() {
            if !self.accessibility[i][i] {
                return false;
            }
        }

        // æ£€æŸ¥ä¼ é€’æ€§ / Check transitivity
        for i in 0..self.worlds.len() {
            for j in 0..self.worlds.len() {
                for k in 0..self.worlds.len() {
                    if self.accessibility[i][j] && self.accessibility[j][k] && !self.accessibility[i][k] {
                        return false;
                    }
                }
            }
        }

        true
    }
}
```

### 5.3 æ„é€ æ€§è¯æ˜ç³»ç»Ÿ (Constructive Proof System)

```rust
/// æ„é€ æ€§è¯æ˜ç³»ç»Ÿ / Constructive Proof System
pub struct ConstructiveProofSystem {
    axioms: Vec<IntuitionisticFormula>,
    rules: Vec<ConstructiveRule>,
}

#[derive(Debug, Clone)]
pub enum ConstructiveRule {
    ModusPonens,
    UniversalGeneralization,
    ExistentialInstantiation,
    ConjunctionIntroduction,
    ConjunctionElimination,
    DisjunctionIntroduction,
    DisjunctionElimination,
    ImplicationIntroduction,
    ImplicationElimination,
    NegationIntroduction,
    NegationElimination,
}

#[derive(Debug, Clone)]
pub struct ConstructiveProofStep {
    pub formula: IntuitionisticFormula,
    pub rule: ConstructiveRule,
    pub premises: Vec<usize>,
    pub construction: Option<String>,
    pub justification: String,
}

#[derive(Debug, Clone)]
pub struct ConstructiveProof {
    pub steps: Vec<ConstructiveProofStep>,
    pub conclusion: IntuitionisticFormula,
}

impl ConstructiveProofSystem {
    /// åˆ›å»ºæ–°çš„æ„é€ æ€§è¯æ˜ç³»ç»Ÿ / Create new constructive proof system
    pub fn new() -> Self {
        ConstructiveProofSystem {
            axioms: Vec::new(),
            rules: Vec::new(),
        }
    }

    /// æ·»åŠ å…¬ç† / Add axiom
    pub fn add_axiom(&mut self, axiom: IntuitionisticFormula) {
        self.axioms.push(axiom);
    }

    /// æ·»åŠ æ¨ç†è§„åˆ™ / Add inference rule
    pub fn add_rule(&mut self, rule: ConstructiveRule) {
        self.rules.push(rule);
    }

    /// éªŒè¯æ„é€ æ€§è¯æ˜ / Verify constructive proof
    pub fn verify_constructive_proof(&self, proof: &ConstructiveProof) -> Result<bool, String> {
        for (i, step) in proof.steps.iter().enumerate() {
            if !self.verify_constructive_step(step, &proof.steps[..i])? {
                return Err(format!("Invalid constructive proof step {}", i));
            }
        }
        Ok(true)
    }

    /// éªŒè¯æ„é€ æ€§è¯æ˜æ­¥éª¤ / Verify constructive proof step
    fn verify_constructive_step(&self, step: &ConstructiveProofStep, previous_steps: &[ConstructiveProofStep]) -> Result<bool, String> {
        match step.rule {
            ConstructiveRule::ModusPonens => {
                if step.premises.len() != 2 {
                    return Err("Modus Ponens requires exactly 2 premises".to_string());
                }
                let premise1 = &previous_steps[step.premises[0]].formula;
                let premise2 = &previous_steps[step.premises[1]].formula;

                match (premise1, premise2) {
                    (IntuitionisticFormula::Implication(antecedent, consequent), antecedent_formula) => {
                        Ok(antecedent.as_ref() == antecedent_formula && step.formula == *consequent.as_ref())
                    }
                    _ => Ok(false),
                }
            }
            ConstructiveRule::ExistentialInstantiation => {
                if step.premises.len() != 1 {
                    return Err("Existential Instantiation requires exactly 1 premise".to_string());
                }
                let premise = &previous_steps[step.premises[0]].formula;

                match premise {
                    IntuitionisticFormula::Existential(var, sub_formula) => {
                        // æ£€æŸ¥æ˜¯å¦æä¾›äº†æ„é€  / Check if construction is provided
                        if step.construction.is_none() {
                            return Err("Existential instantiation requires construction".to_string());
                        }
                        Ok(true)
                    }
                    _ => Ok(false),
                }
            }
            ConstructiveRule::ConjunctionIntroduction => {
                if step.premises.len() != 2 {
                    return Err("Conjunction Introduction requires exactly 2 premises".to_string());
                }
                let premise1 = &previous_steps[step.premises[0]].formula;
                let premise2 = &previous_steps[step.premises[1]].formula;

                match &step.formula {
                    IntuitionisticFormula::Conjunction(left, right) => {
                        Ok(left.as_ref() == premise1 && right.as_ref() == premise2)
                    }
                    _ => Ok(false),
                }
            }
            _ => Ok(true), // ç®€åŒ–å¤„ç†å…¶ä»–è§„åˆ™
        }
    }

    /// æ„é€ è¯æ˜ / Construct proof
    pub fn construct_proof(&self, premises: &[IntuitionisticFormula], conclusion: &IntuitionisticFormula) -> Result<ConstructiveProof, String> {
        let mut proof = ConstructiveProof {
            steps: Vec::new(),
            conclusion: conclusion.clone(),
        };

        // æ·»åŠ å‰æ / Add premises
        for (i, premise) in premises.iter().enumerate() {
            proof.steps.push(ConstructiveProofStep {
                formula: premise.clone(),
                rule: ConstructiveRule::ModusPonens, // å ä½ç¬¦
                premises: vec![],
                construction: None,
                justification: format!("Premise {}", i + 1),
            });
        }

        // è¿™é‡Œåº”è¯¥å®ç°å®é™…çš„æ„é€ æ€§è¯æ˜æ„é€ ç®—æ³•
        // This should implement actual constructive proof construction algorithm
        Ok(proof)
    }
}
```

### 5.4 ç›´è§‰é€»è¾‘æµ‹è¯• (Intuitionistic Logic Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_intuitionistic_formula_parsing() {
        let parser = IntuitionisticLogicParser::new();

        // æµ‹è¯•åŸå­å…¬å¼ / Test atomic formula
        let result = parser.parse_formula("P(x, y)");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), IntuitionisticFormula::Atomic(_, _)));

        // æµ‹è¯•å¦å®š / Test negation
        let result = parser.parse_formula("Â¬P(x)");
        assert!(result.is_ok());
        if let Ok(IntuitionisticFormula::Negation(sub_formula)) = result {
            assert!(matches!(*sub_formula, IntuitionisticFormula::Atomic(_, _)));
        } else {
            panic!("Expected negation formula");
        }

        // æµ‹è¯•å­˜åœ¨é‡è¯ / Test existential quantifier
        let result = parser.parse_formula("âˆƒ(x)P(x)");
        assert!(result.is_ok());
        if let Ok(IntuitionisticFormula::Existential(var, sub_formula)) = result {
            assert_eq!(var, "x");
            assert!(matches!(*sub_formula, IntuitionisticFormula::Atomic(_, _)));
        } else {
            panic!("Expected existential formula");
        }
    }

    #[test]
    fn test_kripke_model() {
        let mut model = KripkeModel::new();

        // æ·»åŠ ä¸–ç•Œ / Add worlds
        model.add_world("w1".to_string());
        model.add_world("w2".to_string());

        // è®¾ç½®å¯è¾¾å…³ç³» / Set accessibility relations
        model.set_accessibility("w1", "w1", true);
        model.set_accessibility("w2", "w2", true);
        model.set_accessibility("w1", "w2", true);

        // è®¾ç½®èµ‹å€¼ / Set valuations
        model.set_valuation("w1", "P", true);
        model.set_valuation("w2", "P", false);

        // æµ‹è¯•æ»¡è¶³å…³ç³» / Test satisfaction relation
        let formula = IntuitionisticFormula::Atomic("P".to_string(), vec![]);
        assert!(model.satisfies("w1", &formula));
        assert!(!model.satisfies("w2", &formula));

        // æµ‹è¯•æ¨¡å‹æœ‰æ•ˆæ€§ / Test model validity
        assert!(model.is_valid());
    }

    #[test]
    fn test_constructive_proof_system() {
        let mut proof_system = ConstructiveProofSystem::new();

        // æ·»åŠ å…¬ç† / Add axioms
        proof_system.add_axiom(IntuitionisticFormula::Atomic("A".to_string(), vec![]));

        // æ„é€ ç®€å•è¯æ˜ / Construct simple proof
        let premises = vec![IntuitionisticFormula::Atomic("A".to_string(), vec![])];
        let conclusion = IntuitionisticFormula::Atomic("A".to_string(), vec![]);

        let proof = proof_system.construct_proof(&premises, &conclusion);
        assert!(proof.is_ok());

        // éªŒè¯è¯æ˜ / Verify proof
        let verification = proof_system.verify_constructive_proof(&proof.unwrap());
        assert!(verification.is_ok());
    }

    #[test]
    fn test_rejection_of_excluded_middle() {
        let parser = IntuitionisticLogicParser::new();

        // å°è¯•è§£ææ’ä¸­å¾‹ / Try to parse law of excluded middle
        let excluded_middle = "P âˆ¨ Â¬P";
        let result = parser.parse_formula(excluded_middle);

        // åœ¨ç›´è§‰é€»è¾‘ä¸­ï¼Œæ’ä¸­å¾‹ä¸æ˜¯æ°¸çœŸå¼
        // In intuitionistic logic, the law of excluded middle is not a tautology
        assert!(result.is_ok()); // è¯­æ³•ä¸Šæ­£ç¡®ï¼Œä½†è¯­ä¹‰ä¸Šä¸æˆç«‹
    }
}
```

---

## 6. å‚è€ƒæ–‡çŒ® / References

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Brouwer1908] Brouwer, L. E. J. (1908). "De onbetrouwbaarheid der logische principes". *Tijdschrift voor Wijsbegeerte*, 2: 152-158.
   - Brouwerç›´è§‰ä¸»ä¹‰çš„æ—©æœŸå·¥ä½œï¼Œ**æ‹’ç»æ’ä¸­å¾‹**ã€‚æœ¬æ–‡æ¡£Â§3.1å’ŒÂ§3.2çš„ç›´è§‰ä¸»ä¹‰å“²å­¦åŸºäºæ­¤è®ºæ–‡ã€‚

2. [Heyting1930] Heyting, A. (1930). "Die formalen Regeln der intuitionistischen Logik". *Sitzungsberichte der PreuÃŸischen Akademie der Wissenschaften*, pp. 42-56.
   - Heytingç›´è§‰ä¸»ä¹‰é€»è¾‘çš„å½¢å¼åŒ–ï¼Œ**BHKè§£é‡Šçš„åŸºç¡€**ã€‚æœ¬æ–‡æ¡£çš„å½¢å¼ç³»ç»ŸåŸºäºæ­¤è®ºæ–‡ã€‚

3. [Kripke1965] Kripke, S. A. (1965). "Semantical Analysis of Intuitionistic Logic I". In *Formal Systems and Recursive Functions*, pp. 92-130. North-Holland.
   - **Kripkeè¯­ä¹‰çš„å¼€åˆ›æ€§å·¥ä½œ**ï¼Œç›´è§‰ä¸»ä¹‰é€»è¾‘å’Œæ¨¡æ€é€»è¾‘çš„è¯­ä¹‰åŸºç¡€ã€‚æœ¬æ–‡æ¡£Â§3.4çš„Kripkeè¯­ä¹‰åŸºäºæ­¤è®ºæ–‡ã€‚

4. [Kolmogorov1932] Kolmogorov, A. N. (1932). "Zur Deutung der intuitionistischen Logik". *Mathematische Zeitschrift*, 35: 58-65.
   - Kolmogorovå¯¹ç›´è§‰ä¸»ä¹‰é€»è¾‘çš„è§£é‡Šï¼Œæ„é€ æ€§æ•°å­¦çš„é‡è¦è´¡çŒ®ã€‚æœ¬æ–‡æ¡£Â§3.3çš„æ„é€ æ€§è¯æ˜å‚è€ƒæ­¤è®ºæ–‡ã€‚

5. GÃ¶del, K. (1933). "Zur intuitionistischen Arithmetik und Zahlentheorie". *Ergebnisse eines mathematischen Kolloquiums*, 4: 34-38.
   - GÃ¶delå¯¹ç›´è§‰ä¸»ä¹‰ç®—æœ¯çš„ç ”ç©¶ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. Troelstra, A. S., & van Dalen, D. (1988). *Constructivism in Mathematics: An Introduction* (2 vols.). North-Holland.
   - æ„é€ æ€§æ•°å­¦çš„æƒå¨æ•™æï¼Œæœ¬æ–‡æ¡£çš„ç†è®ºæ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

2. Dummett, M. (1977). *Elements of Intuitionism*. Oxford University Press.
   - ç›´è§‰ä¸»ä¹‰çš„å“²å­¦å’Œæ•°å­¦åŸºç¡€ï¼Œæœ¬æ–‡æ¡£Â§3.2å‚è€ƒæ­¤ä¹¦ã€‚

3. Bridges, D., & Richman, F. (1987). *Varieties of Constructive Mathematics*. Cambridge University Press.
   - æ„é€ æ€§æ•°å­¦çš„å„ç§æµæ´¾ä»‹ç»ã€‚

### ç°ä»£ç ”ç©¶ / Modern Research

1. Bezem, M., & Coquand, T. (2005). "A Constructive Model of Uniform Continuity". *Theoretical Computer Science*, 323(1-3): 131-145.
   - æ„é€ æ€§æ•°å­¦çš„ç°ä»£ç ”ç©¶ã€‚

2. Veldman, W. (1976). "An Intuitionistic Completeness Theorem for Intuitionistic Predicate Logic". *The Journal of Symbolic Logic*, 41(1): 159-166.
    - ç›´è§‰ä¸»ä¹‰è°“è¯é€»è¾‘çš„å®Œå¤‡æ€§å®šç†ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Intuitionistic Logic**: <https://en.wikipedia.org/wiki/Intuitionistic_logic>
   - ç›´è§‰é€»è¾‘çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«BHKè§£é‡Šå’Œæ„é€ æ€§è¯æ˜ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

2. **Wikipedia - Constructive Mathematics**: <https://en.wikipedia.org/wiki/Constructive_mathematics>
   - æ„é€ æ€§æ•°å­¦çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»ç›´è§‰é€»è¾‘çš„æ•°å­¦åŸºç¡€ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

3. **Wikipedia - Kripke Semantics**: <https://en.wikipedia.org/wiki/Kripke_semantics>
   - Kripkeè¯­ä¹‰çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«ç›´è§‰é€»è¾‘çš„å¯èƒ½ä¸–ç•Œè¯­ä¹‰ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
**æœ€åæ›´æ–° / Last Updated**: 2025-11-14
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-11-14)

---

*æœ¬æ–‡æ¡£æä¾›äº†ç›´è§‰é€»è¾‘çš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€ç›´è§‰ä¸»ä¹‰ã€æ„é€ æ€§è¯æ˜ã€å…‹é‡Œæ™®å…‹è¯­ä¹‰å’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
