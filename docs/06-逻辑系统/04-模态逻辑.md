---
title: 6.4 æ¨¡æ€é€»è¾‘ / Modal Logic
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: é€»è¾‘ç³»ç»Ÿå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 6.4 æ¨¡æ€é€»è¾‘ / Modal Logic

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€æ¨¡æ€é€»è¾‘çš„å½¢å¼åŒ–å®šä¹‰ã€å¯èƒ½ä¸–ç•Œè¯­ä¹‰ä¸æ¨¡æ€ç³»ç»Ÿã€‚
- å»ºç«‹æ¨¡æ€é€»è¾‘çš„å…¬ç†åŒ–ä¸å®Œå¤‡æ€§ç†è®ºã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- æ¨¡æ€é€»è¾‘ã€å¿…ç„¶æ€§ã€å¯èƒ½æ€§ã€å¯èƒ½ä¸–ç•Œè¯­ä¹‰ã€å…‹é‡Œæ™®å…‹æ¨¡å‹ã€æ¨¡æ€ç³»ç»Ÿã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- æ¨¡æ€é€»è¾‘ï¼ˆModal Logicï¼‰ï¼šç ”ç©¶å¿…ç„¶æ€§å’Œå¯èƒ½æ€§çš„é€»è¾‘åˆ†æ”¯ã€‚
- å¿…ç„¶ç®—å­ï¼ˆNecessity Operatorï¼‰ï¼š`â–¡` è¡¨ç¤º"å¿…ç„¶"ã€‚
- å¯èƒ½ç®—å­ï¼ˆPossibility Operatorï¼‰ï¼š`â—‡` è¡¨ç¤º"å¯èƒ½"ã€‚
- è®°å·çº¦å®šï¼š`â–¡` è¡¨ç¤ºå¿…ç„¶ï¼Œ`â—‡` è¡¨ç¤ºå¯èƒ½ï¼Œ`âŠ¢` è¡¨ç¤ºæ¨å¯¼ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- å‘½é¢˜é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/01-å‘½é¢˜é€»è¾‘.md`ã€‚
- ä¸€é˜¶é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/02-ä¸€é˜¶é€»è¾‘.md`ã€‚
- ç›´è§‰é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/03-ç›´è§‰é€»è¾‘.md`ã€‚
- é€»è¾‘ç³»ç»ŸåŸºç¡€ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- å¯èƒ½ä¸–ç•Œè¯­ä¹‰
- æ¨¡æ€ç³»ç»Ÿ
- å…¬ç†åŒ–

## ç›®å½• (Table of Contents)

- [6.4 æ¨¡æ€é€»è¾‘ / Modal Logic](#64-æ¨¡æ€é€»è¾‘--modal-logic)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.1 æ¨¡æ€é€»è¾‘å®šä¹‰ (Definition of Modal Logic)](#11-æ¨¡æ€é€»è¾‘å®šä¹‰-definition-of-modal-logic)
  - [1.2 æ¨¡æ€ç®—å­ (Modal Operators)](#12-æ¨¡æ€ç®—å­-modal-operators)
  - [1.3 æ¨¡æ€é€»è¾‘ä¸ç»å…¸é€»è¾‘çš„å…³ç³» (Relationship with Classical Logic)](#13-æ¨¡æ€é€»è¾‘ä¸ç»å…¸é€»è¾‘çš„å…³ç³»-relationship-with-classical-logic)
- [1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation](#14-å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾--content-supplement-and-thinking-representation)
- [2. å¯èƒ½ä¸–ç•Œè¯­ä¹‰ (Possible Worlds Semantics)](#2-å¯èƒ½ä¸–ç•Œè¯­ä¹‰-possible-worlds-semantics)
  - [2.1 å…‹é‡Œæ™®å…‹æ¨¡å‹ (Kripke Models)](#21-å…‹é‡Œæ™®å…‹æ¨¡å‹-kripke-models)
  - [2.2 æ»¡è¶³å…³ç³» (Satisfaction Relation)](#22-æ»¡è¶³å…³ç³»-satisfaction-relation)
  - [2.3 æ¡†æ¶æ€§è´¨ (Frame Properties)](#23-æ¡†æ¶æ€§è´¨-frame-properties)
- [3. æ¨¡æ€ç³»ç»Ÿ (Modal Systems)](#3-æ¨¡æ€ç³»ç»Ÿ-modal-systems)
  - [3.1 åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ (Basic Modal Systems)](#31-åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ-basic-modal-systems)
  - [3.2 æ¨¡æ€ç³»ç»Ÿçš„å±‚æ¬¡ (Hierarchy of Modal Systems)](#32-æ¨¡æ€ç³»ç»Ÿçš„å±‚æ¬¡-hierarchy-of-modal-systems)
  - [3.3 ç‰¹æ®Šæ¨¡æ€ç³»ç»Ÿ (Special Modal Systems)](#33-ç‰¹æ®Šæ¨¡æ€ç³»ç»Ÿ-special-modal-systems)
- [4. å…¬ç†åŒ– (Axiomatization)](#4-å…¬ç†åŒ–-axiomatization)
  - [4.1 æ¨¡æ€é€»è¾‘å…¬ç† (Modal Logic Axioms)](#41-æ¨¡æ€é€»è¾‘å…¬ç†-modal-logic-axioms)
  - [4.2 æ¨ç†è§„åˆ™ (Inference Rules)](#42-æ¨ç†è§„åˆ™-inference-rules)
  - [4.3 å®Œå¤‡æ€§å®šç† (Completeness Theorems)](#43-å®Œå¤‡æ€§å®šç†-completeness-theorems)
- [5. å®ç°ç¤ºä¾‹ (Implementation Examples)](#5-å®ç°ç¤ºä¾‹-implementation-examples)
  - [5.1 æ¨¡æ€é€»è¾‘è§£æå™¨ (Modal Logic Parser)](#51-æ¨¡æ€é€»è¾‘è§£æå™¨-modal-logic-parser)
  - [5.2 æ¨¡æ€é€»è¾‘è§£é‡Šå™¨ (Modal Logic Interpreter)](#52-æ¨¡æ€é€»è¾‘è§£é‡Šå™¨-modal-logic-interpreter)
  - [5.3 æ¨¡æ€é€»è¾‘è¯æ˜ç³»ç»Ÿ (Modal Logic Proof System)](#53-æ¨¡æ€é€»è¾‘è¯æ˜ç³»ç»Ÿ-modal-logic-proof-system)
  - [5.4 æ¨¡æ€é€»è¾‘æµ‹è¯• (Modal Logic Testing)](#54-æ¨¡æ€é€»è¾‘æµ‹è¯•-modal-logic-testing)
- [6. å‚è€ƒæ–‡çŒ® / References](#6-å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)
  - [é«˜é˜¶æ¨¡æ€é€»è¾‘ / Higher-Order Modal Logic](#é«˜é˜¶æ¨¡æ€é€»è¾‘--higher-order-modal-logic)
  - [åº”ç”¨é¢†åŸŸ / Applications](#åº”ç”¨é¢†åŸŸ--applications)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.1 æ¨¡æ€é€»è¾‘å®šä¹‰ (Definition of Modal Logic)

**æ¨¡æ€é€»è¾‘å®šä¹‰ / Definition of Modal Logic:**

æ¨¡æ€é€»è¾‘æ˜¯ç ”ç©¶å¿…ç„¶æ€§å’Œå¯èƒ½æ€§ç­‰æ¨¡æ€æ¦‚å¿µçš„é€»è¾‘åˆ†æ”¯ã€‚å®ƒæ‰©å±•äº†ç»å…¸é€»è¾‘ï¼Œå¼•å…¥äº†æ¨¡æ€ç®—å­æ¥è¡¨è¾¾"å¿…ç„¶"å’Œ"å¯èƒ½"ç­‰æ¦‚å¿µã€‚

Modal logic is a branch of logic that studies modal concepts such as necessity and possibility. It extends classical logic by introducing modal operators to express concepts such as "necessarily" and "possibly".

**æ¨¡æ€é€»è¾‘çš„ç‰¹ç‚¹ / Characteristics of Modal Logic:**

1. **æ¨¡æ€ç®—å­ (Modal Operators) / Modal Operators:**
   - $\Box$ (å¿…ç„¶) / $\Box$ (necessity)
   - $\Diamond$ (å¯èƒ½) / $\Diamond$ (possibility)

2. **è¯­ä¹‰ä¸°å¯Œæ€§ (Semantic Richness) / Semantic Richness:**
   - å¯èƒ½ä¸–ç•Œè¯­ä¹‰ / Possible worlds semantics
   - å…³ç³»è¯­ä¹‰ / Relational semantics

3. **åº”ç”¨å¹¿æ³›æ€§ (Wide Applications) / Wide Applications:**
   - å“²å­¦é€»è¾‘ / Philosophical logic
   - è®¡ç®—æœºç§‘å­¦ / Computer science
   - äººå·¥æ™ºèƒ½ / Artificial intelligence

### 1.2 æ¨¡æ€ç®—å­ (Modal Operators)

**å¿…ç„¶ç®—å­ (Necessity Operator) / Necessity Operator:**

$\Box \phi$ è¡¨ç¤º"$\phi$ æ˜¯å¿…ç„¶çš„"ï¼Œå³ $\phi$ åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½ä¸ºçœŸã€‚

$\Box \phi$ means "$\phi$ is necessary", i.e., $\phi$ is true in all possible worlds.

**å¯èƒ½ç®—å­ (Possibility Operator) / Possibility Operator:**

$\Diamond \phi$ è¡¨ç¤º"$\phi$ æ˜¯å¯èƒ½çš„"ï¼Œå³ $\phi$ åœ¨è‡³å°‘ä¸€ä¸ªå¯èƒ½ä¸–ç•Œä¸­ä¸ºçœŸã€‚

$\Diamond \phi$ means "$\phi$ is possible", i.e., $\phi$ is true in at least one possible world.

**æ¨¡æ€ç®—å­çš„å…³ç³» (Relationship between Modal Operators) / Relationship between Modal Operators:**

$$\Diamond \phi \leftrightarrow \neg \Box \neg \phi$$

å³"$\phi$ æ˜¯å¯èƒ½çš„"ç­‰ä»·äº"$\neg \phi$ ä¸æ˜¯å¿…ç„¶çš„"ã€‚

That is, "$\phi$ is possible" is equivalent to "$\neg \phi$ is not necessary".

**å®šç† 4.1.1** (æ¨¡æ€ç®—å­çš„å¯¹å¶æ€§) å¿…ç„¶ç®—å­å’Œå¯èƒ½ç®—å­æ»¡è¶³å¯¹å¶æ€§ï¼š
$$\Diamond \phi \leftrightarrow \neg \Box \neg \phi, \quad \Box \phi \leftrightarrow \neg \Diamond \neg \phi$$

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡å¯èƒ½ä¸–ç•Œè¯­ä¹‰æ¥è¯æ˜è¿™ä¸ªå¯¹å¶æ€§ã€‚

**ç¬¬ä¸€éƒ¨åˆ†ï¼š** è¯æ˜ $\Diamond \phi \leftrightarrow \neg \Box \neg \phi$

æ ¹æ®å¯èƒ½ä¸–ç•Œè¯­ä¹‰ï¼š

- $\mathcal{M}, w \models \Diamond \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \phi$
- $\mathcal{M}, w \models \Box \neg \phi$ å½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œ$\mathcal{M}, v \models \neg \phi$
- $\mathcal{M}, w \models \neg \Box \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \Box \neg \phi$
- $\mathcal{M}, w \not\models \Box \neg \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \not\models \neg \phi$
- $\mathcal{M}, v \not\models \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, v \models \phi$

å› æ­¤ï¼Œ$\mathcal{M}, w \models \Diamond \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \neg \Box \neg \phi$ã€‚

**ç¬¬äºŒéƒ¨åˆ†ï¼š** è¯æ˜ $\Box \phi \leftrightarrow \neg \Diamond \neg \phi$

æ ¹æ®å¯èƒ½ä¸–ç•Œè¯­ä¹‰ï¼š

- $\mathcal{M}, w \models \Box \phi$ å½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œ$\mathcal{M}, v \models \phi$
- $\mathcal{M}, w \models \Diamond \neg \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \neg \phi$
- $\mathcal{M}, w \models \neg \Diamond \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \Diamond \neg \phi$
- $\mathcal{M}, w \not\models \Diamond \neg \phi$ å½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œ$\mathcal{M}, v \not\models \neg \phi$
- $\mathcal{M}, v \not\models \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, v \models \phi$

å› æ­¤ï¼Œ$\mathcal{M}, w \models \Box \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \neg \Diamond \neg \phi$ã€‚

å› æ­¤ï¼Œæ¨¡æ€ç®—å­çš„å¯¹å¶æ€§æˆç«‹ã€‚$\square$

**å®šç† 4.1.2** (æ¨¡æ€ç®—å­çš„å•è°ƒæ€§) å¿…ç„¶ç®—å­å’Œå¯èƒ½ç®—å­æ»¡è¶³å•è°ƒæ€§ï¼š
å¦‚æœ $\phi \rightarrow \psi$ æ˜¯æ°¸çœŸå¼ï¼Œåˆ™ï¼š
$$\Box \phi \rightarrow \Box \psi, \quad \Diamond \phi \rightarrow \Diamond \psi$$

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡å¯èƒ½ä¸–ç•Œè¯­ä¹‰æ¥è¯æ˜å•è°ƒæ€§ã€‚

**ç¬¬ä¸€éƒ¨åˆ†ï¼š** è¯æ˜ $\Box \phi \rightarrow \Box \psi$

å‡è®¾ $\phi \rightarrow \psi$ æ˜¯æ°¸çœŸå¼ï¼Œå³å¯¹äºæ‰€æœ‰ä¸–ç•Œ $w$ï¼Œå¦‚æœ $\mathcal{M}, w \models \phi$ åˆ™ $\mathcal{M}, w \models \psi$ã€‚

å¦‚æœ $\mathcal{M}, w \models \Box \phi$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œ$\mathcal{M}, v \models \phi$ã€‚
ç”±äº $\phi \rightarrow \psi$ æ˜¯æ°¸çœŸå¼ï¼Œå¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œ$\mathcal{M}, v \models \psi$ã€‚
å› æ­¤ï¼Œ$\mathcal{M}, w \models \Box \psi$ã€‚

**ç¬¬äºŒéƒ¨åˆ†ï¼š** è¯æ˜ $\Diamond \phi \rightarrow \Diamond \psi$

å¦‚æœ $\mathcal{M}, w \models \Diamond \phi$ï¼Œåˆ™å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \phi$ã€‚
ç”±äº $\phi \rightarrow \psi$ æ˜¯æ°¸çœŸå¼ï¼Œ$\mathcal{M}, v \models \psi$ã€‚
å› æ­¤ï¼Œ$\mathcal{M}, w \models \Diamond \psi$ã€‚

å› æ­¤ï¼Œæ¨¡æ€ç®—å­çš„å•è°ƒæ€§æˆç«‹ã€‚$\square$

### 1.3 æ¨¡æ€é€»è¾‘ä¸ç»å…¸é€»è¾‘çš„å…³ç³» (Relationship with Classical Logic)

**ç»å…¸é€»è¾‘æ‰©å±• / Classical Logic Extension:**

æ¨¡æ€é€»è¾‘æ˜¯ç»å…¸é€»è¾‘çš„æ‰©å±•ï¼Œå®ƒï¼š

Modal logic is an extension of classical logic that:

1. **ä¿ç•™ç»å…¸é€»è¾‘çš„æ‰€æœ‰å…¬ç† / Preserves all axioms of classical logic**
2. **æ·»åŠ æ¨¡æ€å…¬ç† / Adds modal axioms**
3. **æ‰©å±•è¯­ä¹‰ / Extends semantics**

**ç»å…¸é€»è¾‘åµŒå…¥ / Classical Logic Embedding:**

ç»å…¸é€»è¾‘å¯ä»¥åµŒå…¥åˆ°æ¨¡æ€é€»è¾‘ä¸­ï¼š

Classical logic can be embedded into modal logic:

- ç»å…¸å‘½é¢˜ $\phi$ å¯¹åº”æ¨¡æ€å‘½é¢˜ $\phi$
- ç»å…¸æ¨ç†è§„åˆ™åœ¨æ¨¡æ€é€»è¾‘ä¸­ä»ç„¶æœ‰æ•ˆ

---

## 1.4 å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾ / Content Supplement and Thinking Representation

> æœ¬èŠ‚æŒ‰ [å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ](../å†…å®¹è¡¥å……ä¸æ€ç»´è¡¨å¾å…¨é¢è®¡åˆ’æ–¹æ¡ˆ.md) **åªè¡¥å……ã€ä¸åˆ é™¤**ã€‚æ ‡å‡†è§ [å†…å®¹è¡¥å……æ ‡å‡†](../å†…å®¹è¡¥å……æ ‡å‡†-æ¦‚å¿µå®šä¹‰å±æ€§å…³ç³»è§£é‡Šè®ºè¯å½¢å¼è¯æ˜.md)ã€[æ€ç»´è¡¨å¾æ¨¡æ¿é›†](../æ€ç»´è¡¨å¾æ¨¡æ¿é›†.md)ã€‚

**è§£é‡Šä¸ç›´è§‚**ï¼šæ¨¡æ€é€»è¾‘ç”¨ $\Box$ï¼ˆå¿…ç„¶ï¼‰ä¸ $\Diamond$ï¼ˆå¯èƒ½ï¼‰åˆ»ç”»å‘½é¢˜çš„å¿…ç„¶æ€§ä¸å¯èƒ½æ€§ï¼›å¯èƒ½ä¸–ç•Œè¯­ä¹‰ï¼ˆKripke æ¨¡å‹ï¼‰ä¸º $\Box/\Diamond$ æä¾›è¯­ä¹‰ï¼Œç”¨äºçŸ¥è¯†ã€ä¿¡å¿µã€æ—¶åºä¸ç¨‹åºéªŒè¯ï¼ˆè§ 07-æ—¶åºé€»è¾‘ã€08-å½¢å¼åŒ–éªŒè¯ï¼‰ã€‚

**æ¦‚å¿µå±æ€§è¡¨**ï¼š$\Box \phi$ â€” å¿…ç„¶ï¼›$\Diamond \phi$ â€” å¯èƒ½ï¼ˆ$\Diamond \phi \equiv \neg \Box \neg \phi$ï¼‰ï¼›Kripke æ¨¡å‹ $\mathcal{M}=(W,R,V)$ â€” ä¸–ç•Œã€å¯è¾¾å…³ç³»ã€èµ‹å€¼ï¼›å…¬ç† Kã€Tã€4ã€5 â€” å¯¹åº”å…³ç³»æ€§è´¨ã€‚

**æ¦‚å¿µå…³ç³»**ï¼šæ¨¡æ€é€»è¾‘ â€”extendsâ€” å‘½é¢˜é€»è¾‘ï¼ˆè§ 01ï¼‰ï¼›ä¸ 07-æ—¶åºé€»è¾‘ã€09-æ—¶åºé€»è¾‘ç†è®º â€” æ—¶åºä¸ç¨‹åºé€»è¾‘ï¼›ä¸ 08-å½¢å¼åŒ–éªŒè¯ â€” è§„èŒƒä¸æ¨¡å‹æ£€æµ‹ã€‚

**æ¦‚å¿µä¾èµ–å›¾**ï¼šå‘½é¢˜é€»è¾‘ â†’ $\Box/\Diamond$ â†’ æ¨¡æ€é€»è¾‘ï¼›Kripke æ¨¡å‹ â†’ å¯èƒ½ä¸–ç•Œè¯­ä¹‰ï¼›å…¬ç† K/T/4/5 â†’ å¯¹åº”å…³ç³»è‡ªå/ä¼ é€’/æ¬§æ€§ç­‰ï¼›è§ 07ã€08ã€‚

**æ€ç»´å¯¼å›¾**ï¼šæ¨¡æ€é€»è¾‘ â†’ $\Box/\Diamond$ã€Kripke è¯­ä¹‰ã€å…¬ç†ä¸å¯¹åº”ã€å¤šæ¨¡æ€ â†’ çŸ¥è¯†é€»è¾‘ã€æ—¶åºé€»è¾‘ã€ç¨‹åºéªŒè¯ã€‚

**å¤šç»´çŸ©é˜µ**ï¼šK/T/S4/S5 â€” å…¬ç†ä¸æ¡†æ¶ï¼›å¯èƒ½ä¸–ç•Œ/é‚»åŸŸ â€” è¯­ä¹‰ï¼›çŸ¥è¯†/ä¿¡å¿µ/æ—¶åº â€” åº”ç”¨ï¼ˆè§ 07ã€08ï¼‰ã€‚

**å…¬ç†å®šç†æ¨ç†è¯æ˜å†³ç­–æ ‘**ï¼šå…¬ç† Kã€Tã€4ã€5 â†’ å¯¹åº”å…³ç³»æ€§è´¨ï¼›Kripke å®Œå¤‡æ€§ï¼›ä¸ç»å…¸åµŒå…¥ï¼›è§ Â§2â€“Â§3ã€‚

**åº”ç”¨å†³ç­–å»ºæ¨¡æ ‘**ï¼šç¨‹åº/è§„èŒƒéªŒè¯ â†’ æ—¶åºé€»è¾‘ä¸æ¨¡å‹æ£€æµ‹ï¼ˆè§ 07ã€08ï¼‰ï¼›çŸ¥è¯†ä¸ä¿¡å¿µ â†’ å¤šä¸»ä½“é€»è¾‘ï¼›å½¢å¼åŒ–éªŒè¯ â†’ è§ 08-å½¢å¼åŒ–éªŒè¯ã€10-å½¢å¼åŒ–éªŒè¯çš„é«˜çº§æŠ€æœ¯ã€‚

---

## 2. å¯èƒ½ä¸–ç•Œè¯­ä¹‰ (Possible Worlds Semantics)

### 2.1 å…‹é‡Œæ™®å…‹æ¨¡å‹ (Kripke Models)

**å…‹é‡Œæ™®å…‹æ¨¡å‹å®šä¹‰ / Definition of Kripke Models:**

æ¨¡æ€é€»è¾‘çš„å…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{M} = (W, R, V)$ï¼Œå…¶ä¸­ï¼š

A Kripke model for modal logic is a triple $\mathcal{M} = (W, R, V)$, where:

1. **$W$ æ˜¯å¯èƒ½ä¸–ç•Œé›†åˆ (Set of Possible Worlds) / Set of Possible Worlds:**
   - éç©ºé›†åˆ / Non-empty set

2. **$R$ æ˜¯å¯è¾¾å…³ç³» (Accessibility Relation) / Accessibility Relation:**
   - $R \subseteq W \times W$ / $R \subseteq W \times W$

3. **$V$ æ˜¯èµ‹å€¼å‡½æ•° (Valuation Function) / Valuation Function:**
   - $V: W \times \text{Prop} \rightarrow \{0, 1\}$ / $V: W \times \text{Prop} \rightarrow \{0, 1\}$

### 2.2 æ»¡è¶³å…³ç³» (Satisfaction Relation)

**æ»¡è¶³å…³ç³»å®šä¹‰ / Definition of Satisfaction Relation:**

ç»™å®šå…‹é‡Œæ™®å…‹æ¨¡å‹ $\mathcal{M} = (W, R, V)$ å’Œä¸–ç•Œ $w \in W$ï¼š

Given a Kripke model $\mathcal{M} = (W, R, V)$ and world $w \in W$:

1. **åŸå­å‘½é¢˜ (Atomic Propositions) / Atomic Propositions:**
   - $\mathcal{M}, w \models p$ å½“ä¸”ä»…å½“ $V(w, p) = 1$

2. **å¦å®š (Negation) / Negation:**
   - $\mathcal{M}, w \models \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \phi$

3. **åˆå– (Conjunction) / Conjunction:**
   - $\mathcal{M}, w \models \phi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \phi$ ä¸” $\mathcal{M}, w \models \psi$

4. **æå– (Disjunction) / Disjunction:**
   - $\mathcal{M}, w \models \phi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \phi$ æˆ– $\mathcal{M}, w \models \psi$

5. **è•´å« (Implication) / Implication:**
   - $\mathcal{M}, w \models \phi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \phi$ æˆ– $\mathcal{M}, w \models \psi$

6. **å¿…ç„¶ (Necessity) / Necessity:**
   - $\mathcal{M}, w \models \Box \phi$ å½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œ$\mathcal{M}, v \models \phi$

7. **å¯èƒ½ (Possibility) / Possibility:**
   - $\mathcal{M}, w \models \Diamond \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \phi$

### 2.3 æ¡†æ¶æ€§è´¨ (Frame Properties)

**æ¡†æ¶å®šä¹‰ / Definition of Frame:**

æ¡†æ¶æ˜¯äºŒå…ƒç»„ $\mathcal{F} = (W, R)$ï¼Œå…¶ä¸­ $W$ æ˜¯ä¸–ç•Œé›†åˆï¼Œ$R$ æ˜¯å¯è¾¾å…³ç³»ã€‚

A frame is a pair $\mathcal{F} = (W, R)$, where $W$ is a set of worlds and $R$ is an accessibility relation.

**å¸¸è§æ¡†æ¶æ€§è´¨ / Common Frame Properties:**

1. **è‡ªåæ€§ (Reflexivity) / Reflexivity:**
   - $\forall w \in W, wRw$
   - å¯¹åº”å…¬ç†ï¼š$\Box \phi \rightarrow \phi$ (Tå…¬ç†)

2. **å¯¹ç§°æ€§ (Symmetry) / Symmetry:**
   - $\forall w, v \in W, wRv \rightarrow vRw$
   - å¯¹åº”å…¬ç†ï¼š$\phi \rightarrow \Box \Diamond \phi$ (Bå…¬ç†)

3. **ä¼ é€’æ€§ (Transitivity) / Transitivity:**
   - $\forall w, v, u \in W, wRv \land vRu \rightarrow wRu$
   - å¯¹åº”å…¬ç†ï¼š$\Box \phi \rightarrow \Box \Box \phi$ (4å…¬ç†)

4. **æ¬§å‡ é‡Œå¾—æ€§ (Euclidean) / Euclidean:**
   - $\forall w, v, u \in W, wRv \land wRu \rightarrow vRu$
   - å¯¹åº”å…¬ç†ï¼š$\Diamond \phi \rightarrow \Box \Diamond \phi$ (5å…¬ç†)

---

## 3. æ¨¡æ€ç³»ç»Ÿ (Modal Systems)

### 3.1 åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ (Basic Modal Systems)

**Kç³»ç»Ÿ (System K) / System K:**

Kç³»ç»Ÿæ˜¯æœ€åŸºæœ¬çš„æ¨¡æ€ç³»ç»Ÿï¼ŒåŒ…å«ï¼š

System K is the most basic modal system, containing:

1. **ç»å…¸é€»è¾‘å…¬ç† / Classical Logic Axioms:**
   - æ‰€æœ‰ç»å…¸é€»è¾‘çš„å…¬ç† / All axioms of classical logic

2. **Kå…¬ç† (K Axiom) / K Axiom:**
   - $\Box(\phi \rightarrow \psi) \rightarrow (\Box \phi \rightarrow \Box \psi)$

3. **æ¨ç†è§„åˆ™ / Inference Rules:**
   - åˆ†ç¦»è§„åˆ™ (Modus Ponens) / Modus Ponens
   - å¿…ç„¶åŒ–è§„åˆ™ (Necessitation) / Necessitation: $\frac{\phi}{\Box \phi}$

**Tç³»ç»Ÿ (System T) / System T:**

Tç³»ç»Ÿåœ¨Kç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ Tå…¬ç†ï¼š

System T adds the T axiom to System K:

- **Tå…¬ç† (T Axiom) / T Axiom:** $\Box \phi \rightarrow \phi$

**S4ç³»ç»Ÿ (System S4) / System S4:**

S4ç³»ç»Ÿåœ¨Tç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ 4å…¬ç†ï¼š

System S4 adds the 4 axiom to System T:

- **4å…¬ç† (4 Axiom) / 4 Axiom:** $\Box \phi \rightarrow \Box \Box \phi$

**S5ç³»ç»Ÿ (System S5) / System S5:**

S5ç³»ç»Ÿåœ¨S4ç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ 5å…¬ç†ï¼š

System S5 adds the 5 axiom to System S4:

- **5å…¬ç† (5 Axiom) / 5 Axiom:** $\Diamond \phi \rightarrow \Box \Diamond \phi$

### 3.2 æ¨¡æ€ç³»ç»Ÿçš„å±‚æ¬¡ (Hierarchy of Modal Systems)

**æ¨¡æ€ç³»ç»Ÿå±‚æ¬¡ / Modal System Hierarchy:**

```text
K (æœ€å¼±) / K (weakest)
  â†“
T (æ·»åŠ è‡ªåæ€§) / T (adds reflexivity)
  â†“
S4 (æ·»åŠ ä¼ é€’æ€§) / S4 (adds transitivity)
  â†“
S5 (æœ€å¼º) / S5 (strongest)
```

**ç³»ç»ŸåŒ…å«å…³ç³» / System Inclusion Relations:**

- K âŠ† T âŠ† S4 âŠ† S5
- K âŠ† T âŠ† B âŠ† S5 (å…¶ä¸­Bæ˜¯Brouwerç³»ç»Ÿ)

### 3.3 ç‰¹æ®Šæ¨¡æ€ç³»ç»Ÿ (Special Modal Systems)

**Brouwerç³»ç»Ÿ (Brouwer System) / Brouwer System:**

Bç³»ç»Ÿåœ¨Tç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ Bå…¬ç†ï¼š

System B adds the B axiom to System T:

- **Bå…¬ç† (B Axiom) / B Axiom:** $\phi \rightarrow \Box \Diamond \phi$

**GLç³»ç»Ÿ (GÃ¶del-LÃ¶b System) / GÃ¶del-LÃ¶b System:**

GLç³»ç»Ÿåœ¨Kç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ GLå…¬ç†ï¼š

System GL adds the GL axiom to System K:

- **GLå…¬ç† (GL Axiom) / GL Axiom:** $\Box(\Box \phi \rightarrow \phi) \rightarrow \Box \phi$

---

## 4. å…¬ç†åŒ– (Axiomatization)

### 4.1 æ¨¡æ€é€»è¾‘å…¬ç† (Modal Logic Axioms)

**åŸºæœ¬å…¬ç† (Basic Axioms) / Basic Axioms:**

1. **ç»å…¸é€»è¾‘å…¬ç† / Classical Logic Axioms:**
   - $\phi \rightarrow (\psi \rightarrow \phi)$
   - $(\phi \rightarrow (\psi \rightarrow \chi)) \rightarrow ((\phi \rightarrow \psi) \rightarrow (\phi \rightarrow \chi))$
   - $(\neg \phi \rightarrow \neg \psi) \rightarrow (\psi \rightarrow \phi)$

2. **Kå…¬ç† (K Axiom) / K Axiom:**
   - $\Box(\phi \rightarrow \psi) \rightarrow (\Box \phi \rightarrow \Box \psi)$

3. **Tå…¬ç† (T Axiom) / T Axiom:**
   - $\Box \phi \rightarrow \phi$

4. **4å…¬ç† (4 Axiom) / 4 Axiom:**
   - $\Box \phi \rightarrow \Box \Box \phi$

5. **5å…¬ç† (5 Axiom) / 5 Axiom:**
   - $\Diamond \phi \rightarrow \Box \Diamond \phi$

6. **Bå…¬ç† (B Axiom) / B Axiom:**
   - $\phi \rightarrow \Box \Diamond \phi$

### 4.2 æ¨ç†è§„åˆ™ (Inference Rules)

**åŸºæœ¬æ¨ç†è§„åˆ™ / Basic Inference Rules:**

1. **åˆ†ç¦»è§„åˆ™ (Modus Ponens) / Modus Ponens:**
   - $\frac{\phi \rightarrow \psi \quad \phi}{\psi}$

2. **å¿…ç„¶åŒ–è§„åˆ™ (Necessitation) / Necessitation:**
   - $\frac{\phi}{\Box \phi}$

3. **å¯èƒ½åŒ–è§„åˆ™ (Possibilitation) / Possibilitation:**
   - $\frac{\phi}{\Diamond \phi}$ (åœ¨æŸäº›ç³»ç»Ÿä¸­)

### 4.3 å®Œå¤‡æ€§å®šç† (Completeness Theorems)

**Kç³»ç»Ÿå®Œå¤‡æ€§ (Completeness of System K) / Completeness of System K:**

Kç³»ç»Ÿç›¸å¯¹äºæ‰€æœ‰å…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯å®Œå¤‡çš„ã€‚

System K is complete with respect to all Kripke models.

**Tç³»ç»Ÿå®Œå¤‡æ€§ (Completeness of System T) / Completeness of System T:**

Tç³»ç»Ÿç›¸å¯¹äºè‡ªåå…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯å®Œå¤‡çš„ã€‚

System T is complete with respect to reflexive Kripke models.

**S4ç³»ç»Ÿå®Œå¤‡æ€§ (Completeness of System S4) / Completeness of System S4:**

S4ç³»ç»Ÿç›¸å¯¹äºè‡ªåä¼ é€’å…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯å®Œå¤‡çš„ã€‚

System S4 is complete with respect to reflexive and transitive Kripke models.

**S5ç³»ç»Ÿå®Œå¤‡æ€§ (Completeness of System S5) / Completeness of System S5:**

S5ç³»ç»Ÿç›¸å¯¹äºç­‰ä»·å…³ç³»å…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯å®Œå¤‡çš„ã€‚

System S5 is complete with respect to equivalence relation Kripke models.

---

## 5. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 5.1 æ¨¡æ€é€»è¾‘è§£æå™¨ (Modal Logic Parser)

```rust
use std::collections::HashMap;

/// æ¨¡æ€é€»è¾‘è§£æå™¨ / Modal Logic Parser
pub struct ModalLogicParser {
    variables: HashMap<String, String>,
    constants: HashMap<String, String>,
    functions: HashMap<String, Vec<String>>,
    predicates: HashMap<String, Vec<String>>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ModalTerm {
    Variable(String),
    Constant(String),
    Function(String, Vec<ModalTerm>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum ModalFormula {
    Atomic(String, Vec<ModalTerm>),
    Negation(Box<ModalFormula>),
    Conjunction(Box<ModalFormula>, Box<ModalFormula>),
    Disjunction(Box<ModalFormula>, Box<ModalFormula>),
    Implication(Box<ModalFormula>, Box<ModalFormula>),
    Necessity(Box<ModalFormula>),
    Possibility(Box<ModalFormula>),
}

impl ModalLogicParser {
    /// åˆ›å»ºæ–°çš„è§£æå™¨ / Create new parser
    pub fn new() -> Self {
        ModalLogicParser {
            variables: HashMap::new(),
            constants: HashMap::new(),
            functions: HashMap::new(),
            predicates: HashMap::new(),
        }
    }

    /// è§£ææ¨¡æ€é€»è¾‘å…¬å¼ / Parse modal logic formula
    pub fn parse_formula(&self, input: &str) -> Result<ModalFormula, String> {
        let tokens = self.tokenize(input)?;
        self.parse_formula_tokens(&tokens)
    }

    /// è¯æ³•åˆ†æ / Tokenization
    fn tokenize(&self, input: &str) -> Result<Vec<String>, String> {
        let mut tokens = Vec::new();
        let mut current = String::new();

        for ch in input.chars() {
            match ch {
                ' ' | '\t' | '\n' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                }
                '(' | ')' | ',' | 'â†’' | 'âˆ§' | 'âˆ¨' | 'Â¬' | 'â–¡' | 'â—‡' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                    tokens.push(ch.to_string());
                }
                _ => current.push(ch),
            }
        }

        if !current.is_empty() {
            tokens.push(current);
        }

        Ok(tokens)
    }

    /// è§£æå…¬å¼æ ‡è®° / Parse formula tokens
    fn parse_formula_tokens(&self, tokens: &[String]) -> Result<ModalFormula, String> {
        if tokens.is_empty() {
            return Err("Empty token list".to_string());
        }

        match tokens[0].as_str() {
            "Â¬" => {
                if tokens.len() < 2 {
                    return Err("Invalid negation".to_string());
                }
                let sub_formula = self.parse_formula_tokens(&tokens[1..])?;
                Ok(ModalFormula::Negation(Box::new(sub_formula)))
            }
            "â–¡" => {
                if tokens.len() < 2 {
                    return Err("Invalid necessity".to_string());
                }
                let sub_formula = self.parse_formula_tokens(&tokens[1..])?;
                Ok(ModalFormula::Necessity(Box::new(sub_formula)))
            }
            "â—‡" => {
                if tokens.len() < 2 {
                    return Err("Invalid possibility".to_string());
                }
                let sub_formula = self.parse_formula_tokens(&tokens[1..])?;
                Ok(ModalFormula::Possibility(Box::new(sub_formula)))
            }
            pred_name => {
                if tokens.len() < 3 || tokens[1] != "(" || tokens[tokens.len() - 1] != ")" {
                    return Err("Invalid predicate syntax".to_string());
                }

                let args_tokens = &tokens[2..tokens.len() - 1];
                let args = self.parse_term_list(args_tokens)?;
                Ok(ModalFormula::Atomic(pred_name.to_string(), args))
            }
        }
    }

    /// è§£æé¡¹åˆ—è¡¨ / Parse term list
    fn parse_term_list(&self, tokens: &[String]) -> Result<Vec<ModalTerm>, String> {
        if tokens.is_empty() {
            return Ok(Vec::new());
        }

        let mut terms = Vec::new();
        let mut current_tokens = Vec::new();
        let mut paren_count = 0;

        for token in tokens {
            match token.as_str() {
                "(" => {
                    paren_count += 1;
                    current_tokens.push(token.clone());
                }
                ")" => {
                    paren_count -= 1;
                    current_tokens.push(token.clone());
                }
                "," => {
                    if paren_count == 0 {
                        if !current_tokens.is_empty() {
                            terms.push(self.parse_term_tokens(&current_tokens)?);
                            current_tokens.clear();
                        }
                    } else {
                        current_tokens.push(token.clone());
                    }
                }
                _ => current_tokens.push(token.clone()),
            }
        }

        if !current_tokens.is_empty() {
            terms.push(self.parse_term_tokens(&current_tokens)?);
        }

        Ok(terms)
    }

    /// è§£æé¡¹æ ‡è®° / Parse term tokens
    fn parse_term_tokens(&self, tokens: &[String]) -> Result<ModalTerm, String> {
        if tokens.is_empty() {
            return Err("Empty token list".to_string());
        }

        match tokens[0].as_str() {
            "x" | "y" | "z" => Ok(ModalTerm::Variable(tokens[0].clone())),
            "a" | "b" | "c" => Ok(ModalTerm::Constant(tokens[0].clone())),
            func_name => {
                if tokens.len() < 3 || tokens[1] != "(" || tokens[tokens.len() - 1] != ")" {
                    return Err("Invalid function syntax".to_string());
                }

                let args_tokens = &tokens[2..tokens.len() - 1];
                let args = self.parse_term_list(args_tokens)?;
                Ok(ModalTerm::Function(func_name.to_string(), args))
            }
        }
    }
}
```

### 5.2 æ¨¡æ€é€»è¾‘è§£é‡Šå™¨ (Modal Logic Interpreter)

```rust
/// æ¨¡æ€é€»è¾‘è§£é‡Šå™¨ / Modal Logic Interpreter
pub struct ModalLogicInterpreter {
    worlds: Vec<String>,
    accessibility: Vec<Vec<bool>>,
    valuation: HashMap<(String, String), bool>,
}

impl ModalLogicInterpreter {
    /// åˆ›å»ºæ–°çš„è§£é‡Šå™¨ / Create new interpreter
    pub fn new() -> Self {
        ModalLogicInterpreter {
            worlds: Vec::new(),
            accessibility: Vec::new(),
            valuation: HashMap::new(),
        }
    }

    /// æ·»åŠ ä¸–ç•Œ / Add world
    pub fn add_world(&mut self, world: String) {
        if !self.worlds.contains(&world) {
            self.worlds.push(world.clone());
            self.accessibility.push(vec![false; self.worlds.len()]);

            // æ›´æ–°å…¶ä»–ä¸–ç•Œçš„å¯è¾¾å…³ç³» / Update accessibility relations for other worlds
            for row in &mut self.accessibility {
                row.push(false);
            }
        }
    }

    /// è®¾ç½®å¯è¾¾å…³ç³» / Set accessibility relation
    pub fn set_accessibility(&mut self, from: &str, to: &str, accessible: bool) {
        if let (Some(from_idx), Some(to_idx)) = (self.world_index(from), self.world_index(to)) {
            self.accessibility[from_idx][to_idx] = accessible;
        }
    }

    /// è®¾ç½®èµ‹å€¼ / Set valuation
    pub fn set_valuation(&mut self, world: &str, proposition: &str, value: bool) {
        self.valuation.insert((world.to_string(), proposition.to_string()), value);
    }

    /// æ£€æŸ¥æ»¡è¶³å…³ç³» / Check satisfaction relation
    pub fn satisfies(&self, world: &str, formula: &ModalFormula) -> bool {
        match formula {
            ModalFormula::Atomic(prop, _) => {
                self.valuation.get(&(world.to_string(), prop.clone())).unwrap_or(&false)
            }
            ModalFormula::Negation(sub_formula) => {
                !self.satisfies(world, sub_formula)
            }
            ModalFormula::Conjunction(left, right) => {
                self.satisfies(world, left) && self.satisfies(world, right)
            }
            ModalFormula::Disjunction(left, right) => {
                self.satisfies(world, left) || self.satisfies(world, right)
            }
            ModalFormula::Implication(left, right) => {
                !self.satisfies(world, left) || self.satisfies(world, right)
            }
            ModalFormula::Necessity(sub_formula) => {
                if let Some(world_idx) = self.world_index(world) {
                    for (to_world, &accessible) in self.worlds.iter().zip(&self.accessibility[world_idx]) {
                        if accessible && !self.satisfies(to_world, sub_formula) {
                            return false;
                        }
                    }
                }
                true
            }
            ModalFormula::Possibility(sub_formula) => {
                if let Some(world_idx) = self.world_index(world) {
                    for (to_world, &accessible) in self.worlds.iter().zip(&self.accessibility[world_idx]) {
                        if accessible && self.satisfies(to_world, sub_formula) {
                            return true;
                        }
                    }
                }
                false
            }
        }
    }

    /// è·å–ä¸–ç•Œç´¢å¼• / Get world index
    fn world_index(&self, world: &str) -> Option<usize> {
        self.worlds.iter().position(|w| w == world)
    }

    /// æ£€æŸ¥æ¡†æ¶æ€§è´¨ / Check frame properties
    pub fn check_frame_properties(&self) -> FrameProperties {
        FrameProperties {
            reflexive: self.is_reflexive(),
            symmetric: self.is_symmetric(),
            transitive: self.is_transitive(),
            euclidean: self.is_euclidean(),
        }
    }

    /// æ£€æŸ¥è‡ªåæ€§ / Check reflexivity
    fn is_reflexive(&self) -> bool {
        for (i, _) in self.worlds.iter().enumerate() {
            if !self.accessibility[i][i] {
                return false;
            }
        }
        true
    }

    /// æ£€æŸ¥å¯¹ç§°æ€§ / Check symmetry
    fn is_symmetric(&self) -> bool {
        for i in 0..self.worlds.len() {
            for j in 0..self.worlds.len() {
                if self.accessibility[i][j] != self.accessibility[j][i] {
                    return false;
                }
            }
        }
        true
    }

    /// æ£€æŸ¥ä¼ é€’æ€§ / Check transitivity
    fn is_transitive(&self) -> bool {
        for i in 0..self.worlds.len() {
            for j in 0..self.worlds.len() {
                for k in 0..self.worlds.len() {
                    if self.accessibility[i][j] && self.accessibility[j][k] && !self.accessibility[i][k] {
                        return false;
                    }
                }
            }
        }
        true
    }

    /// æ£€æŸ¥æ¬§å‡ é‡Œå¾—æ€§ / Check euclidean property
    fn is_euclidean(&self) -> bool {
        for i in 0..self.worlds.len() {
            for j in 0..self.worlds.len() {
                for k in 0..self.worlds.len() {
                    if self.accessibility[i][j] && self.accessibility[i][k] && !self.accessibility[j][k] {
                        return false;
                    }
                }
            }
        }
        true
    }
}

#[derive(Debug, Clone)]
pub struct FrameProperties {
    pub reflexive: bool,
    pub symmetric: bool,
    pub transitive: bool,
    pub euclidean: bool,
}
```

### 5.3 æ¨¡æ€é€»è¾‘è¯æ˜ç³»ç»Ÿ (Modal Logic Proof System)

```rust
/// æ¨¡æ€é€»è¾‘è¯æ˜ç³»ç»Ÿ / Modal Logic Proof System
pub struct ModalLogicProofSystem {
    axioms: Vec<ModalFormula>,
    rules: Vec<ModalRule>,
    system_type: ModalSystem,
}

#[derive(Debug, Clone)]
pub enum ModalSystem {
    K,
    T,
    S4,
    S5,
    B,
    GL,
}

#[derive(Debug, Clone)]
pub enum ModalRule {
    ModusPonens,
    Necessitation,
    Possibilitation,
    ConjunctionIntroduction,
    ConjunctionElimination,
    DisjunctionIntroduction,
    DisjunctionElimination,
    ImplicationIntroduction,
    ImplicationElimination,
    NegationIntroduction,
    NegationElimination,
}

#[derive(Debug, Clone)]
pub struct ModalProofStep {
    pub formula: ModalFormula,
    pub rule: ModalRule,
    pub premises: Vec<usize>,
    pub justification: String,
}

#[derive(Debug, Clone)]
pub struct ModalProof {
    pub steps: Vec<ModalProofStep>,
    pub conclusion: ModalFormula,
}

impl ModalLogicProofSystem {
    /// åˆ›å»ºæ–°çš„è¯æ˜ç³»ç»Ÿ / Create new proof system
    pub fn new(system_type: ModalSystem) -> Self {
        let mut system = ModalLogicProofSystem {
            axioms: Vec::new(),
            rules: Vec::new(),
            system_type,
        };

        system.add_basic_axioms();
        system.add_modal_axioms();

        system
    }

    /// æ·»åŠ åŸºæœ¬å…¬ç† / Add basic axioms
    fn add_basic_axioms(&mut self) {
        // æ·»åŠ ç»å…¸é€»è¾‘å…¬ç† / Add classical logic axioms
        // è¿™é‡Œç®€åŒ–å¤„ç† / Simplified here
    }

    /// æ·»åŠ æ¨¡æ€å…¬ç† / Add modal axioms
    fn add_modal_axioms(&mut self) {
        match self.system_type {
            ModalSystem::K => {
                // Kå…¬ç†ï¼šâ–¡(Ï†â†’Ïˆ) â†’ (â–¡Ï†â†’â–¡Ïˆ)
                // K axiom: â–¡(Ï†â†’Ïˆ) â†’ (â–¡Ï†â†’â–¡Ïˆ)
            }
            ModalSystem::T => {
                // Tå…¬ç†ï¼šâ–¡Ï† â†’ Ï†
                // T axiom: â–¡Ï† â†’ Ï†
            }
            ModalSystem::S4 => {
                // 4å…¬ç†ï¼šâ–¡Ï† â†’ â–¡â–¡Ï†
                // 4 axiom: â–¡Ï† â†’ â–¡â–¡Ï†
            }
            ModalSystem::S5 => {
                // 5å…¬ç†ï¼šâ—‡Ï† â†’ â–¡â—‡Ï†
                // 5 axiom: â—‡Ï† â†’ â–¡â—‡Ï†
            }
            ModalSystem::B => {
                // Bå…¬ç†ï¼šÏ† â†’ â–¡â—‡Ï†
                // B axiom: Ï† â†’ â–¡â—‡Ï†
            }
            ModalSystem::GL => {
                // GLå…¬ç†ï¼šâ–¡(â–¡Ï†â†’Ï†) â†’ â–¡Ï†
                // GL axiom: â–¡(â–¡Ï†â†’Ï†) â†’ â–¡Ï†
            }
        }
    }

    /// éªŒè¯æ¨¡æ€è¯æ˜ / Verify modal proof
    pub fn verify_modal_proof(&self, proof: &ModalProof) -> Result<bool, String> {
        for (i, step) in proof.steps.iter().enumerate() {
            if !self.verify_modal_step(step, &proof.steps[..i])? {
                return Err(format!("Invalid modal proof step {}", i));
            }
        }
        Ok(true)
    }

    /// éªŒè¯æ¨¡æ€è¯æ˜æ­¥éª¤ / Verify modal proof step
    fn verify_modal_step(&self, step: &ModalProofStep, previous_steps: &[ModalProofStep]) -> Result<bool, String> {
        match step.rule {
            ModalRule::ModusPonens => {
                if step.premises.len() != 2 {
                    return Err("Modus Ponens requires exactly 2 premises".to_string());
                }
                let premise1 = &previous_steps[step.premises[0]].formula;
                let premise2 = &previous_steps[step.premises[1]].formula;

                match (premise1, premise2) {
                    (ModalFormula::Implication(antecedent, consequent), antecedent_formula) => {
                        Ok(antecedent.as_ref() == antecedent_formula && step.formula == *consequent.as_ref())
                    }
                    _ => Ok(false),
                }
            }
            ModalRule::Necessitation => {
                if step.premises.len() != 1 {
                    return Err("Necessitation requires exactly 1 premise".to_string());
                }
                let premise = &previous_steps[step.premises[0]].formula;

                match &step.formula {
                    ModalFormula::Necessity(sub_formula) => {
                        Ok(premise == sub_formula.as_ref())
                    }
                    _ => Ok(false),
                }
            }
            ModalRule::ConjunctionIntroduction => {
                if step.premises.len() != 2 {
                    return Err("Conjunction Introduction requires exactly 2 premises".to_string());
                }
                let premise1 = &previous_steps[step.premises[0]].formula;
                let premise2 = &previous_steps[step.premises[1]].formula;

                match &step.formula {
                    ModalFormula::Conjunction(left, right) => {
                        Ok(left.as_ref() == premise1 && right.as_ref() == premise2)
                    }
                    _ => Ok(false),
                }
            }
            _ => Ok(true), // ç®€åŒ–å¤„ç†å…¶ä»–è§„åˆ™
        }
    }

    /// æ„é€ æ¨¡æ€è¯æ˜ / Construct modal proof
    pub fn construct_modal_proof(&self, premises: &[ModalFormula], conclusion: &ModalFormula) -> Result<ModalProof, String> {
        let mut proof = ModalProof {
            steps: Vec::new(),
            conclusion: conclusion.clone(),
        };

        // æ·»åŠ å‰æ / Add premises
        for (i, premise) in premises.iter().enumerate() {
            proof.steps.push(ModalProofStep {
                formula: premise.clone(),
                rule: ModalRule::ModusPonens, // å ä½ç¬¦
                premises: vec![],
                justification: format!("Premise {}", i + 1),
            });
        }

        // è¿™é‡Œåº”è¯¥å®ç°å®é™…çš„æ¨¡æ€è¯æ˜æ„é€ ç®—æ³•
        // This should implement actual modal proof construction algorithm
        Ok(proof)
    }
}
```

### 5.4 æ¨¡æ€é€»è¾‘æµ‹è¯• (Modal Logic Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_modal_formula_parsing() {
        let parser = ModalLogicParser::new();

        // æµ‹è¯•åŸå­å…¬å¼ / Test atomic formula
        let result = parser.parse_formula("P(x, y)");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), ModalFormula::Atomic(_, _)));

        // æµ‹è¯•å¿…ç„¶ç®—å­ / Test necessity operator
        let result = parser.parse_formula("â–¡P(x)");
        assert!(result.is_ok());
        if let Ok(ModalFormula::Necessity(sub_formula)) = result {
            assert!(matches!(*sub_formula, ModalFormula::Atomic(_, _)));
        } else {
            panic!("Expected necessity formula");
        }

        // æµ‹è¯•å¯èƒ½ç®—å­ / Test possibility operator
        let result = parser.parse_formula("â—‡P(x)");
        assert!(result.is_ok());
        if let Ok(ModalFormula::Possibility(sub_formula)) = result {
            assert!(matches!(*sub_formula, ModalFormula::Atomic(_, _)));
        } else {
            panic!("Expected possibility formula");
        }
    }

    #[test]
    fn test_modal_interpretation() {
        let mut interpreter = ModalLogicInterpreter::new();

        // æ·»åŠ ä¸–ç•Œ / Add worlds
        interpreter.add_world("w1".to_string());
        interpreter.add_world("w2".to_string());
        interpreter.add_world("w3".to_string());

        // è®¾ç½®å¯è¾¾å…³ç³» / Set accessibility relations
        interpreter.set_accessibility("w1", "w1", true);
        interpreter.set_accessibility("w2", "w2", true);
        interpreter.set_accessibility("w3", "w3", true);
        interpreter.set_accessibility("w1", "w2", true);
        interpreter.set_accessibility("w2", "w3", true);

        // è®¾ç½®èµ‹å€¼ / Set valuations
        interpreter.set_valuation("w1", "P", true);
        interpreter.set_valuation("w2", "P", true);
        interpreter.set_valuation("w3", "P", false);

        // æµ‹è¯•å¿…ç„¶ç®—å­ / Test necessity operator
        let formula = ModalFormula::Necessity(Box::new(ModalFormula::Atomic("P".to_string(), vec![])));
        assert!(interpreter.satisfies("w1", &formula)); // åœ¨æ‰€æœ‰å¯è¾¾ä¸–ç•Œä¸­Péƒ½ä¸ºçœŸ

        // æµ‹è¯•å¯èƒ½ç®—å­ / Test possibility operator
        let formula = ModalFormula::Possibility(Box::new(ModalFormula::Atomic("P".to_string(), vec![])));
        assert!(interpreter.satisfies("w1", &formula)); // åœ¨è‡³å°‘ä¸€ä¸ªå¯è¾¾ä¸–ç•Œä¸­Pä¸ºçœŸ

        // æµ‹è¯•æ¡†æ¶æ€§è´¨ / Test frame properties
        let properties = interpreter.check_frame_properties();
        assert!(properties.reflexive);
        assert!(!properties.symmetric);
        assert!(properties.transitive);
    }

    #[test]
    fn test_modal_proof_system() {
        let proof_system = ModalLogicProofSystem::new(ModalSystem::T);

        // æ„é€ ç®€å•è¯æ˜ / Construct simple proof
        let premises = vec![ModalFormula::Atomic("A".to_string(), vec![])];
        let conclusion = ModalFormula::Atomic("A".to_string(), vec![]);

        let proof = proof_system.construct_modal_proof(&premises, &conclusion);
        assert!(proof.is_ok());

        // éªŒè¯è¯æ˜ / Verify proof
        let verification = proof_system.verify_modal_proof(&proof.unwrap());
        assert!(verification.is_ok());
    }

    #[test]
    fn test_modal_systems() {
        // æµ‹è¯•ä¸åŒæ¨¡æ€ç³»ç»Ÿ / Test different modal systems
        let k_system = ModalLogicProofSystem::new(ModalSystem::K);
        let t_system = ModalLogicProofSystem::new(ModalSystem::T);
        let s4_system = ModalLogicProofSystem::new(ModalSystem::S4);
        let s5_system = ModalLogicProofSystem::new(ModalSystem::S5);

        // éªŒè¯ç³»ç»Ÿåˆ›å»ºæˆåŠŸ / Verify successful system creation
        assert!(matches!(k_system.system_type, ModalSystem::K));
        assert!(matches!(t_system.system_type, ModalSystem::T));
        assert!(matches!(s4_system.system_type, ModalSystem::S4));
        assert!(matches!(s5_system.system_type, ModalSystem::S5));
    }
}
```

---

## 6. å‚è€ƒæ–‡çŒ® / References

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**: æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ [CITATION_STANDARD.md](../CITATION_STANDARD.md)ã€[å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md](../å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)ï¼‰ã€‚æ–‡å†…é‡‡ç”¨ [Key] æ ¼å¼å¼•ç”¨ï¼Œä¸å‚è€ƒæ–‡çŒ®åˆ—è¡¨å¯¹åº”ã€‚

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Lewis1918] Lewis, C. I. (1918). *A Survey of Symbolic Logic*. University of California Press.
   - Lewiså¼€åˆ›ç°ä»£æ¨¡æ€é€»è¾‘ï¼Œæå‡ºä¸¥æ ¼è•´æ¶µã€‚æœ¬æ–‡æ¡£Â§4.3çš„æ¨¡æ€ç³»ç»ŸåŸºäºLewisçš„å·¥ä½œã€‚

2. [Kripke1963Modal] Kripke, S. A. (1963). "Semantical Analysis of Modal Logic I: Normal Modal Propositional Calculi". *Zeitschrift fÃ¼r mathematische Logik und Grundlagen der Mathematik*, 9(5-6): 67-96.
   - **Kripkeæ¨¡æ€é€»è¾‘è¯­ä¹‰çš„å¼€åˆ›æ€§è®ºæ–‡**ï¼Œå¯èƒ½ä¸–ç•Œè¯­ä¹‰çš„å¥ åŸºä¹‹ä½œã€‚æœ¬æ–‡æ¡£Â§4.2çš„å¯èƒ½ä¸–ç•Œè¯­ä¹‰åŸºäºæ­¤è®ºæ–‡ã€‚

3. GÃ¶del, K. (1933). "Eine Interpretation des intuitionistischen AussagenkalkÃ¼ls". *Ergebnisse eines mathematischen Kolloquiums*, 4: 39-40.
   - GÃ¶delå¯¹ç›´è§‰ä¸»ä¹‰é€»è¾‘çš„æ¨¡æ€è§£é‡Šã€‚

4. McKinsey, J. C. C., & Tarski, A. (1948). "Some Theorems About the Sentential Calculi of Lewis and Heyting". *The Journal of Symbolic Logic*, 13(1): 1-15.
   - McKinsey-Tarskiå…³äºLewiså’ŒHeytingé€»è¾‘çš„é‡è¦å®šç†ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. [BlackburnEtAl2001] Blackburn, P., de Rijke, M., & Venema, Y. (2001). *Modal Logic*. Cambridge University Press. ISBN: 978-0521527149.
   - æ¨¡æ€é€»è¾‘çš„æƒå¨æ•™æï¼Œæœ¬æ–‡æ¡£çš„åŸºç¡€æ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

2. Hughes, G. E., & Cresswell, M. J. (1996). *A New Introduction to Modal Logic*. Routledge.
   - æ¨¡æ€é€»è¾‘çš„ç»å…¸å…¥é—¨æ•™æã€‚

3. Chellas, B. F. (1980). *Modal Logic: An Introduction*. Cambridge University Press.
   - æ¨¡æ€é€»è¾‘çš„æ ‡å‡†æ•™æã€‚

4. Lemmon, E. J. (1977). *An Introduction to Modal Logic*. Blackwell.
   - Lemmonæ¨¡æ€é€»è¾‘å…¥é—¨æ•™æã€‚

### é«˜é˜¶æ¨¡æ€é€»è¾‘ / Higher-Order Modal Logic

1. Fitting, M., & Mendelsohn, R. L. (1998). *First-Order Modal Logic*. Kluwer Academic Publishers.
   - ä¸€é˜¶æ¨¡æ€é€»è¾‘çš„ä¸“è‘—ã€‚

### åº”ç”¨é¢†åŸŸ / Applications

1. Goldblatt, R. (1987). *Logics of Time and Computation*. CSLI Publications.
    - æ¨¡æ€é€»è¾‘åœ¨æ—¶é—´å’Œè®¡ç®—ä¸­çš„åº”ç”¨ã€‚

2. Segerberg, K. (1971). *An Essay in Classical Modal Logic*. Filosofiska Studier.
    - ç»å…¸æ¨¡æ€é€»è¾‘ç ”ç©¶ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Modal Logic**: <https://en.wikipedia.org/wiki/Modal_logic>
   - æ¨¡æ€é€»è¾‘çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«å¯èƒ½ä¸–ç•Œè¯­ä¹‰å’Œæ¨¡æ€ç³»ç»Ÿï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Kripke Semantics**: <https://en.wikipedia.org/wiki/Kripke_semantics>
   - Kripkeè¯­ä¹‰çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»æ¨¡æ€é€»è¾‘çš„å¯èƒ½ä¸–ç•Œè¯­ä¹‰ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Possible Worlds**: <https://en.wikipedia.org/wiki/Possible_world>
   - å¯èƒ½ä¸–ç•Œçš„Wikipediaæ¡ç›®ï¼Œæ¨¡æ€é€»è¾‘çš„è¯­ä¹‰åŸºç¡€ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£æä¾›äº†æ¨¡æ€é€»è¾‘çš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€å¯èƒ½ä¸–ç•Œè¯­ä¹‰ã€æ¨¡æ€ç³»ç»Ÿã€å…¬ç†åŒ–å’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
