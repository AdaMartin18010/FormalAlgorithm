---
title: 6.2 ä¸€é˜¶é€»è¾‘ / First-Order Logic
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: é€»è¾‘ç³»ç»Ÿå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 6.2 ä¸€é˜¶é€»è¾‘ / First-Order Logic

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€ä¸€é˜¶é€»è¾‘çš„å½¢å¼åŒ–å®šä¹‰ã€è¯­æ³•ã€è¯­ä¹‰ä¸è¯æ˜ç³»ç»Ÿã€‚
- å»ºç«‹ä¸€é˜¶é€»è¾‘çš„å®Œå¤‡æ€§ç†è®ºä¸æ¨¡å‹è®ºåŸºç¡€ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ä¸€é˜¶é€»è¾‘ã€é‡è¯ã€è°“è¯ã€é¡¹ã€å…¬å¼ã€ç»“æ„ã€èµ‹å€¼ã€æ»¡è¶³å…³ç³»ã€å®Œå¤‡æ€§å®šç†ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ä¸€é˜¶é€»è¾‘ï¼ˆFirst-Order Logicï¼‰ï¼šåŒ…å«é‡è¯çš„å½¢å¼é€»è¾‘ç³»ç»Ÿã€‚
- å…¨ç§°é‡è¯ï¼ˆUniversal Quantifierï¼‰ï¼š`âˆ€` è¡¨ç¤º"å¯¹æ‰€æœ‰"ã€‚
- å­˜åœ¨é‡è¯ï¼ˆExistential Quantifierï¼‰ï¼š`âˆƒ` è¡¨ç¤º"å­˜åœ¨"ã€‚
- è®°å·çº¦å®šï¼š`âŠ¢` è¡¨ç¤ºè¯­æ³•æ¨å¯¼ï¼Œ`âŠ¨` è¡¨ç¤ºè¯­ä¹‰è•´å«ï¼Œ`â‰¡` è¡¨ç¤ºé€»è¾‘ç­‰ä»·ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- å‘½é¢˜é€»è¾‘ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/01-å‘½é¢˜é€»è¾‘.md`ã€‚
- è¯æ˜ç³»ç»Ÿï¼šå‚è§ `03-å½¢å¼åŒ–è¯æ˜/01-è¯æ˜ç³»ç»Ÿ.md`ã€‚
- æ¨¡å‹è®ºï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/` ç›¸å…³æ–‡æ¡£ã€‚
- é€»è¾‘ç³»ç»ŸåŸºç¡€ï¼šå‚è§ `06-é€»è¾‘ç³»ç»Ÿ/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- è¯­æ³•
- è¯­ä¹‰
- è¯æ˜ç³»ç»Ÿ
- å®Œå¤‡æ€§

## ç›®å½• (Table of Contents)

- [6.2 ä¸€é˜¶é€»è¾‘ / First-Order Logic](#62-ä¸€é˜¶é€»è¾‘--first-order-logic)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.1 ä¸€é˜¶é€»è¾‘å®šä¹‰ (Definition of First-Order Logic)](#11-ä¸€é˜¶é€»è¾‘å®šä¹‰-definition-of-first-order-logic)
  - [1.2 ä¸€é˜¶é€»è¾‘ä¸å‘½é¢˜é€»è¾‘çš„åŒºåˆ« (Difference from Propositional Logic)](#12-ä¸€é˜¶é€»è¾‘ä¸å‘½é¢˜é€»è¾‘çš„åŒºåˆ«-difference-from-propositional-logic)
  - [1.3 ä¸€é˜¶é€»è¾‘çš„åŸºæœ¬è¦ç´  (Basic Elements of First-Order Logic)](#13-ä¸€é˜¶é€»è¾‘çš„åŸºæœ¬è¦ç´ -basic-elements-of-first-order-logic)
- [2. è¯­æ³• (Syntax)](#2-è¯­æ³•-syntax)
  - [2.1 è¯­è¨€å®šä¹‰ (Language Definition)](#21-è¯­è¨€å®šä¹‰-language-definition)
  - [2.2 é¡¹çš„å®šä¹‰ (Definition of Terms)](#22-é¡¹çš„å®šä¹‰-definition-of-terms)
  - [2.3 å…¬å¼çš„å®šä¹‰ (Definition of Formulas)](#23-å…¬å¼çš„å®šä¹‰-definition-of-formulas)
  - [2.4 è‡ªç”±å˜é‡å’Œçº¦æŸå˜é‡ (Free and Bound Variables)](#24-è‡ªç”±å˜é‡å’Œçº¦æŸå˜é‡-free-and-bound-variables)
- [3. è¯­ä¹‰ (Semantics)](#3-è¯­ä¹‰-semantics)
  - [3.1 ç»“æ„å®šä¹‰ (Definition of Structure)](#31-ç»“æ„å®šä¹‰-definition-of-structure)
  - [3.2 èµ‹å€¼ (Assignment)](#32-èµ‹å€¼-assignment)
  - [3.3 æ»¡è¶³å…³ç³» (Satisfaction Relation)](#33-æ»¡è¶³å…³ç³»-satisfaction-relation)
- [4. è¯æ˜ç³»ç»Ÿ (Proof Systems)](#4-è¯æ˜ç³»ç»Ÿ-proof-systems)
  - [4.1 è‡ªç„¶æ¼”ç»ç³»ç»Ÿ (Natural Deduction System)](#41-è‡ªç„¶æ¼”ç»ç³»ç»Ÿ-natural-deduction-system)
  - [4.2 å¸Œå°”ä¼¯ç‰¹ç³»ç»Ÿ (Hilbert System)](#42-å¸Œå°”ä¼¯ç‰¹ç³»ç»Ÿ-hilbert-system)
  - [4.3 åºåˆ—æ¼”ç®— (Sequent Calculus)](#43-åºåˆ—æ¼”ç®—-sequent-calculus)
- [5. å®Œå¤‡æ€§ (Completeness)](#5-å®Œå¤‡æ€§-completeness)
  - [5.1 å®Œå¤‡æ€§å®šç† (Completeness Theorem)](#51-å®Œå¤‡æ€§å®šç†-completeness-theorem)
  - [5.2 ç´§è‡´æ€§å®šç† (Compactness Theorem)](#52-ç´§è‡´æ€§å®šç†-compactness-theorem)
  - [5.3 å‹’æ–‡æµ·å§†-æ–¯ç§‘ä¼¦å®šç† (LÃ¶wenheim-Skolem Theorem)](#53-å‹’æ–‡æµ·å§†-æ–¯ç§‘ä¼¦å®šç†-lÃ¶wenheim-skolem-theorem)
- [6. å®ç°ç¤ºä¾‹ (Implementation Examples)](#6-å®ç°ç¤ºä¾‹-implementation-examples)
  - [6.1 ä¸€é˜¶é€»è¾‘è§£æå™¨ (First-Order Logic Parser)](#61-ä¸€é˜¶é€»è¾‘è§£æå™¨-first-order-logic-parser)
  - [6.2 ä¸€é˜¶é€»è¾‘è§£é‡Šå™¨ (First-Order Logic Interpreter)](#62-ä¸€é˜¶é€»è¾‘è§£é‡Šå™¨-first-order-logic-interpreter)
  - [6.3 ä¸€é˜¶é€»è¾‘è¯æ˜ç³»ç»Ÿ (First-Order Logic Proof System)](#63-ä¸€é˜¶é€»è¾‘è¯æ˜ç³»ç»Ÿ-first-order-logic-proof-system)
  - [6.4 ä¸€é˜¶é€»è¾‘æµ‹è¯• (First-Order Logic Testing)](#64-ä¸€é˜¶é€»è¾‘æµ‹è¯•-first-order-logic-testing)
- [7. å‚è€ƒæ–‡çŒ® / References](#7-å‚è€ƒæ–‡çŒ®--references)
  - [ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature](#ç»å…¸å¥ åŸºæ–‡çŒ®--classic-foundational-literature)
  - [æ ‡å‡†æ•™æ / Standard Textbooks](#æ ‡å‡†æ•™æ--standard-textbooks)
  - [æ¨¡å‹è®º / Model Theory](#æ¨¡å‹è®º--model-theory)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.1 ä¸€é˜¶é€»è¾‘å®šä¹‰ (Definition of First-Order Logic)

**ä¸€é˜¶é€»è¾‘å®šä¹‰ / Definition of First-Order Logic:**

ä¸€é˜¶é€»è¾‘æ˜¯å½¢å¼é€»è¾‘çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œå®ƒç ”ç©¶ä¸ªä½“ã€è°“è¯ã€é‡è¯å’Œé€»è¾‘è¿æ¥è¯ä¹‹é—´çš„å…³ç³»ã€‚å®ƒæ˜¯æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦ä¸­æœ€åŸºç¡€çš„å½¢å¼åŒ–é€»è¾‘ç³»ç»Ÿã€‚

First-order logic is a branch of formal logic that studies the relationships between individuals, predicates, quantifiers, and logical connectives. It is the most fundamental formal logical system in mathematics and computer science.

**ä¸€é˜¶é€»è¾‘çš„ç‰¹ç‚¹ / Characteristics of First-Order Logic:**

1. **è¡¨è¾¾èƒ½åŠ› / Expressiveness:**
   - å¯ä»¥è¡¨è¾¾å¤æ‚çš„æ•°å­¦å‘½é¢˜ / Can express complex mathematical propositions
   - æ”¯æŒé‡è¯å’Œè°“è¯ / Supports quantifiers and predicates

2. **å½¢å¼åŒ–ç¨‹åº¦ / Formalization:**
   - ä¸¥æ ¼çš„è¯­æ³•è§„åˆ™ / Strict syntactic rules
   - ç²¾ç¡®çš„è¯­ä¹‰å®šä¹‰ / Precise semantic definitions

3. **åº”ç”¨å¹¿æ³› / Wide Applications:**
   - æ•°å­¦åŸºç¡€ / Mathematical foundations
   - è®¡ç®—æœºç§‘å­¦ / Computer science
   - äººå·¥æ™ºèƒ½ / Artificial intelligence

### 1.2 ä¸€é˜¶é€»è¾‘ä¸å‘½é¢˜é€»è¾‘çš„åŒºåˆ« (Difference from Propositional Logic)

**å‘½é¢˜é€»è¾‘é™åˆ¶ / Propositional Logic Limitations:**

- åªèƒ½å¤„ç†ç®€å•å‘½é¢˜ / Can only handle simple propositions
- æ— æ³•è¡¨è¾¾é‡è¯ / Cannot express quantifiers
- è¡¨è¾¾èƒ½åŠ›æœ‰é™ / Limited expressiveness

**ä¸€é˜¶é€»è¾‘ä¼˜åŠ¿ / First-Order Logic Advantages:**

- å¯ä»¥å¤„ç†å¤æ‚è°“è¯ / Can handle complex predicates
- æ”¯æŒå…¨ç§°å’Œå­˜åœ¨é‡è¯ / Supports universal and existential quantifiers
- è¡¨è¾¾èƒ½åŠ›æ›´å¼º / Stronger expressiveness

### 1.3 ä¸€é˜¶é€»è¾‘çš„åŸºæœ¬è¦ç´  (Basic Elements of First-Order Logic)

**ä¸ªä½“ (Individuals) / Individuals:**

- è®ºåŸŸä¸­çš„å¯¹è±¡ / Objects in the domain
- ç”¨å°å†™å­—æ¯è¡¨ç¤º / Denoted by lowercase letters

**è°“è¯ (Predicates) / Predicates:**

- æè¿°ä¸ªä½“æ€§è´¨çš„ç¬¦å· / Symbols describing properties of individuals
- ç”¨å¤§å†™å­—æ¯è¡¨ç¤º / Denoted by uppercase letters

**å‡½æ•°ç¬¦å· (Function Symbols) / Function Symbols:**

- è¡¨ç¤ºä¸ªä½“é—´å…³ç³»çš„ç¬¦å· / Symbols representing relationships between individuals
- ç”¨å°å†™å­—æ¯è¡¨ç¤º / Denoted by lowercase letters

**é‡è¯ (Quantifiers) / Quantifiers:**

- å…¨ç§°é‡è¯ $\forall$ / Universal quantifier $\forall$
- å­˜åœ¨é‡è¯ $\exists$ / Existential quantifier $\exists$

---

## 2. è¯­æ³• (Syntax)

### 2.1 è¯­è¨€å®šä¹‰ (Language Definition)

**ä¸€é˜¶è¯­è¨€å®šä¹‰ / Definition of First-Order Language:**

ä¸€é˜¶è¯­è¨€ $\mathcal{L}$ ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

A first-order language $\mathcal{L}$ consists of:

1. **å¸¸é‡ç¬¦å· (Constant Symbols) / Constant Symbols:**
   - è¡¨ç¤ºè®ºåŸŸä¸­çš„ç‰¹å®šå¯¹è±¡ / Represent specific objects in the domain
   - ä¾‹å¦‚ï¼š$a, b, c$ / e.g., $a, b, c$

2. **å‡½æ•°ç¬¦å· (Function Symbols) / Function Symbols:**
   - è¡¨ç¤ºè®ºåŸŸä¸­çš„å‡½æ•° / Represent functions in the domain
   - ä¾‹å¦‚ï¼š$f, g, h$ / e.g., $f, g, h$

3. **è°“è¯ç¬¦å· (Predicate Symbols) / Predicate Symbols:**
   - è¡¨ç¤ºè®ºåŸŸä¸­çš„å…³ç³» / Represent relations in the domain
   - ä¾‹å¦‚ï¼š$P, Q, R$ / e.g., $P, Q, R$

4. **é€»è¾‘è¿æ¥è¯ (Logical Connectives) / Logical Connectives:**
   - $\neg$ (å¦å®š) / $\neg$ (negation)
   - $\land$ (åˆå–) / $\land$ (conjunction)
   - $\lor$ (æå–) / $\lor$ (disjunction)
   - $\rightarrow$ (è•´å«) / $\rightarrow$ (implication)
   - $\leftrightarrow$ (ç­‰ä»·) / $\leftrightarrow$ (equivalence)

5. **é‡è¯ (Quantifiers) / Quantifiers:**
   - $\forall$ (å…¨ç§°é‡è¯) / $\forall$ (universal quantifier)
   - $\exists$ (å­˜åœ¨é‡è¯) / $\exists$ (existential quantifier)

6. **å˜é‡ (Variables) / Variables:**
   - $x, y, z$ ç­‰ / $x, y, z$, etc.

### 2.2 é¡¹çš„å®šä¹‰ (Definition of Terms)

**é¡¹çš„å®šä¹‰ / Definition of Terms:**

é¡¹æ˜¯è¯­è¨€ä¸­è¡¨ç¤ºä¸ªä½“çš„è¡¨è¾¾å¼ï¼š

Terms are expressions representing individuals in the language:

1. **åŸºæœ¬é¡¹ (Basic Terms) / Basic Terms:**
   - å¸¸é‡æ˜¯é¡¹ / Constants are terms
   - å˜é‡æ˜¯é¡¹ / Variables are terms

2. **å¤åˆé¡¹ (Compound Terms) / Compound Terms:**
   - å¦‚æœ $f$ æ˜¯ $n$ å…ƒå‡½æ•°ç¬¦å·ï¼Œ$t_1, \ldots, t_n$ æ˜¯é¡¹ï¼Œåˆ™ $f(t_1, \ldots, t_n)$ æ˜¯é¡¹
   - If $f$ is an $n$-ary function symbol and $t_1, \ldots, t_n$ are terms, then $f(t_1, \ldots, t_n)$ is a term

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$\text{Terms} ::= c \mid x \mid f(t_1, \ldots, t_n)$$

å…¶ä¸­ $c$ æ˜¯å¸¸é‡ï¼Œ$x$ æ˜¯å˜é‡ï¼Œ$f$ æ˜¯å‡½æ•°ç¬¦å·ã€‚

where $c$ is a constant, $x$ is a variable, and $f$ is a function symbol.

### 2.3 å…¬å¼çš„å®šä¹‰ (Definition of Formulas)

**åŸå­å…¬å¼ (Atomic Formulas) / Atomic Formulas:**

å¦‚æœ $P$ æ˜¯ $n$ å…ƒè°“è¯ç¬¦å·ï¼Œ$t_1, \ldots, t_n$ æ˜¯é¡¹ï¼Œåˆ™ $P(t_1, \ldots, t_n)$ æ˜¯åŸå­å…¬å¼ã€‚

If $P$ is an $n$-ary predicate symbol and $t_1, \ldots, t_n$ are terms, then $P(t_1, \ldots, t_n)$ is an atomic formula.

**å¤åˆå…¬å¼ (Compound Formulas) / Compound Formulas:**

1. **å¦å®š (Negation) / Negation:**
   - å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg \phi$ æ˜¯å…¬å¼
   - If $\phi$ is a formula, then $\neg \phi$ is a formula

2. **äºŒå…ƒè¿æ¥è¯ (Binary Connectives) / Binary Connectives:**
   - å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\phi \land \psi$, $\phi \lor \psi$, $\phi \rightarrow \psi$, $\phi \leftrightarrow \psi$ æ˜¯å…¬å¼
   - If $\phi$ and $\psi$ are formulas, then $\phi \land \psi$, $\phi \lor \psi$, $\phi \rightarrow \psi$, $\phi \leftrightarrow \psi$ are formulas

3. **é‡è¯ (Quantifiers) / Quantifiers:**
   - å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œ$x$ æ˜¯å˜é‡ï¼Œåˆ™ $\forall x \phi$ å’Œ $\exists x \phi$ æ˜¯å…¬å¼
   - If $\phi$ is a formula and $x$ is a variable, then $\forall x \phi$ and $\exists x \phi$ are formulas

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$\text{Formulas} ::= P(t_1, \ldots, t_n) \mid \neg \phi \mid \phi \land \psi \mid \phi \lor \psi \mid \phi \rightarrow \psi \mid \phi \leftrightarrow \psi \mid \forall x \phi \mid \exists x \phi$$

### 2.4 è‡ªç”±å˜é‡å’Œçº¦æŸå˜é‡ (Free and Bound Variables)

**è‡ªç”±å˜é‡å®šä¹‰ / Definition of Free Variables:**

å˜é‡ $x$ åœ¨å…¬å¼ $\phi$ ä¸­æ˜¯è‡ªç”±çš„ï¼Œå¦‚æœï¼š

Variable $x$ is free in formula $\phi$ if:

1. $\phi$ æ˜¯åŸå­å…¬å¼ $P(t_1, \ldots, t_n)$ï¼Œä¸” $x$ å‡ºç°åœ¨æŸä¸ª $t_i$ ä¸­
2. $\phi$ æ˜¯ $\neg \psi$ï¼Œä¸” $x$ åœ¨ $\psi$ ä¸­æ˜¯è‡ªç”±çš„
3. $\phi$ æ˜¯ $\psi \land \chi$, $\psi \lor \chi$, $\psi \rightarrow \chi$, $\psi \leftrightarrow \chi$ï¼Œä¸” $x$ åœ¨ $\psi$ æˆ– $\chi$ ä¸­æ˜¯è‡ªç”±çš„
4. $\phi$ æ˜¯ $\forall y \psi$ æˆ– $\exists y \psi$ï¼Œä¸” $x \neq y$ ä¸” $x$ åœ¨ $\psi$ ä¸­æ˜¯è‡ªç”±çš„

**çº¦æŸå˜é‡å®šä¹‰ / Definition of Bound Variables:**

å˜é‡ $x$ åœ¨å…¬å¼ $\phi$ ä¸­æ˜¯çº¦æŸçš„ï¼Œå¦‚æœï¼š

Variable $x$ is bound in formula $\phi$ if:

1. $\phi$ æ˜¯ $\forall x \psi$ æˆ– $\exists x \psi$
2. $\phi$ æ˜¯å¤åˆå…¬å¼ï¼Œä¸” $x$ åœ¨å­å…¬å¼ä¸­æ˜¯çº¦æŸçš„

---

## 3. è¯­ä¹‰ (Semantics)

### 3.1 ç»“æ„å®šä¹‰ (Definition of Structure)

**ç»“æ„å®šä¹‰ / Definition of Structure:**

ä¸€é˜¶è¯­è¨€ $\mathcal{L}$ çš„ç»“æ„ $\mathcal{M}$ ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

A structure $\mathcal{M}$ for first-order language $\mathcal{L}$ consists of:

1. **è®ºåŸŸ (Domain) / Domain:**
   - éç©ºé›†åˆ $D$ / Non-empty set $D$

2. **è§£é‡Šå‡½æ•° (Interpretation Function) / Interpretation Function:**
   - å°†å¸¸é‡æ˜ å°„åˆ°è®ºåŸŸä¸­çš„å…ƒç´  / Maps constants to elements in the domain
   - å°†å‡½æ•°ç¬¦å·æ˜ å°„åˆ°è®ºåŸŸä¸Šçš„å‡½æ•° / Maps function symbols to functions on the domain
   - å°†è°“è¯ç¬¦å·æ˜ å°„åˆ°è®ºåŸŸä¸Šçš„å…³ç³» / Maps predicate symbols to relations on the domain

**å½¢å¼åŒ–å®šä¹‰ / Formal Definition:**

$$\mathcal{M} = (D, I)$$

å…¶ä¸­ $D$ æ˜¯è®ºåŸŸï¼Œ$I$ æ˜¯è§£é‡Šå‡½æ•°ã€‚

where $D$ is the domain and $I$ is the interpretation function.

### 3.2 èµ‹å€¼ (Assignment)

**èµ‹å€¼å®šä¹‰ / Definition of Assignment:**

èµ‹å€¼æ˜¯ä»å˜é‡åˆ°è®ºåŸŸçš„æ˜ å°„ï¼š

Assignment is a mapping from variables to the domain:

$$\sigma: \text{Variables} \rightarrow D$$

**é¡¹çš„è§£é‡Š (Interpretation of Terms) / Interpretation of Terms:**

ç»™å®šç»“æ„ $\mathcal{M}$ å’Œèµ‹å€¼ $\sigma$ï¼Œé¡¹ $t$ çš„è§£é‡Š $t^{\mathcal{M},\sigma}$ å®šä¹‰ä¸ºï¼š

Given structure $\mathcal{M}$ and assignment $\sigma$, the interpretation of term $t$, $t^{\mathcal{M},\sigma}$, is defined as:

1. **å˜é‡ (Variables) / Variables:**
   - $x^{\mathcal{M},\sigma} = \sigma(x)$

2. **å¸¸é‡ (Constants) / Constants:**
   - $c^{\mathcal{M},\sigma} = I(c)$

3. **å‡½æ•°åº”ç”¨ (Function Application) / Function Application:**
   - $f(t_1, \ldots, t_n)^{\mathcal{M},\sigma} = I(f)(t_1^{\mathcal{M},\sigma}, \ldots, t_n^{\mathcal{M},\sigma})$

### 3.3 æ»¡è¶³å…³ç³» (Satisfaction Relation)

**æ»¡è¶³å…³ç³»å®šä¹‰ / Definition of Satisfaction Relation:**

ç»™å®šç»“æ„ $\mathcal{M}$ å’Œèµ‹å€¼ $\sigma$ï¼Œå…¬å¼ $\phi$ çš„æ»¡è¶³å…³ç³» $\mathcal{M} \models_\sigma \phi$ å®šä¹‰ä¸ºï¼š

Given structure $\mathcal{M}$ and assignment $\sigma$, the satisfaction relation $\mathcal{M} \models_\sigma \phi$ is defined as:

1. **åŸå­å…¬å¼ (Atomic Formulas) / Atomic Formulas:**
   - $\mathcal{M} \models_\sigma P(t_1, \ldots, t_n)$ å½“ä¸”ä»…å½“ $(t_1^{\mathcal{M},\sigma}, \ldots, t_n^{\mathcal{M},\sigma}) \in I(P)$

2. **å¦å®š (Negation) / Negation:**
   - $\mathcal{M} \models_\sigma \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M} \not\models_\sigma \phi$

3. **åˆå– (Conjunction) / Conjunction:**
   - $\mathcal{M} \models_\sigma \phi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M} \models_\sigma \phi$ ä¸” $\mathcal{M} \models_\sigma \psi$

4. **æå– (Disjunction) / Disjunction:**
   - $\mathcal{M} \models_\sigma \phi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{M} \models_\sigma \phi$ æˆ– $\mathcal{M} \models_\sigma \psi$

5. **è•´å« (Implication) / Implication:**
   - $\mathcal{M} \models_\sigma \phi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{M} \not\models_\sigma \phi$ æˆ– $\mathcal{M} \models_\sigma \psi$

6. **å…¨ç§°é‡è¯ (Universal Quantifier) / Universal Quantifier:**
   - $\mathcal{M} \models_\sigma \forall x \phi$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $d \in D$ï¼Œ$\mathcal{M} \models_{\sigma[x \mapsto d]} \phi$

7. **å­˜åœ¨é‡è¯ (Existential Quantifier) / Existential Quantifier:**
   - $\mathcal{M} \models_\sigma \exists x \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $d \in D$ï¼Œä½¿å¾— $\mathcal{M} \models_{\sigma[x \mapsto d]} \phi$

**å®šç† 2.3.1** (é‡è¯çš„å¯¹å¶æ€§) å…¨ç§°é‡è¯å’Œå­˜åœ¨é‡è¯æ»¡è¶³å¯¹å¶æ€§ï¼š
$$\neg \forall x \phi \equiv \exists x \neg \phi, \quad \neg \exists x \phi \equiv \forall x \neg \phi$$

**è¯æ˜ï¼š** æˆ‘ä»¬é€šè¿‡æ»¡è¶³å…³ç³»çš„å®šä¹‰æ¥è¯æ˜è¿™ä¸ªå¯¹å¶æ€§ã€‚

**ç¬¬ä¸€éƒ¨åˆ†ï¼š** è¯æ˜ $\neg \forall x \phi \equiv \exists x \neg \phi$

æ ¹æ®æ»¡è¶³å…³ç³»å®šä¹‰ï¼š

- $\mathcal{M} \models_\sigma \neg \forall x \phi$ å½“ä¸”ä»…å½“ $\mathcal{M} \not\models_\sigma \forall x \phi$
- $\mathcal{M} \not\models_\sigma \forall x \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $d \in D$ï¼Œä½¿å¾— $\mathcal{M} \not\models_{\sigma[x \mapsto d]} \phi$
- $\mathcal{M} \not\models_{\sigma[x \mapsto d]} \phi$ å½“ä¸”ä»…å½“ $\mathcal{M} \models_{\sigma[x \mapsto d]} \neg \phi$
- å› æ­¤ï¼Œ$\mathcal{M} \models_\sigma \neg \forall x \phi$ å½“ä¸”ä»…å½“ $\mathcal{M} \models_\sigma \exists x \neg \phi$

**ç¬¬äºŒéƒ¨åˆ†ï¼š** è¯æ˜ $\neg \exists x \phi \equiv \forall x \neg \phi$

æ ¹æ®æ»¡è¶³å…³ç³»å®šä¹‰ï¼š

- $\mathcal{M} \models_\sigma \neg \exists x \phi$ å½“ä¸”ä»…å½“ $\mathcal{M} \not\models_\sigma \exists x \phi$
- $\mathcal{M} \not\models_\sigma \exists x \phi$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $d \in D$ï¼Œ$\mathcal{M} \not\models_{\sigma[x \mapsto d]} \phi$
- $\mathcal{M} \not\models_{\sigma[x \mapsto d]} \phi$ å½“ä¸”ä»…å½“ $\mathcal{M} \models_{\sigma[x \mapsto d]} \neg \phi$
- å› æ­¤ï¼Œ$\mathcal{M} \models_\sigma \neg \exists x \phi$ å½“ä¸”ä»…å½“ $\mathcal{M} \models_\sigma \forall x \neg \phi$

å› æ­¤ï¼Œé‡è¯çš„å¯¹å¶æ€§æˆç«‹ã€‚$\square$

**å®šç† 2.3.2** (é‡è¯çš„åˆ†é…å¾‹) é‡è¯å¯¹é€»è¾‘è¿æ¥è¯æ»¡è¶³åˆ†é…å¾‹ï¼š
$$\forall x (\phi \land \psi) \equiv \forall x \phi \land \forall x \psi$$
$$\exists x (\phi \lor \psi) \equiv \exists x \phi \lor \exists x \psi$$

**è¯æ˜ï¼š** æˆ‘ä»¬é€ä¸€è¯æ˜è¿™äº›åˆ†é…å¾‹ã€‚

**ç¬¬ä¸€éƒ¨åˆ†ï¼š** è¯æ˜ $\forall x (\phi \land \psi) \equiv \forall x \phi \land \forall x \psi$

æ ¹æ®æ»¡è¶³å…³ç³»å®šä¹‰ï¼š

- $\mathcal{M} \models_\sigma \forall x (\phi \land \psi)$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $d \in D$ï¼Œ$\mathcal{M} \models_{\sigma[x \mapsto d]} \phi \land \psi$
- $\mathcal{M} \models_{\sigma[x \mapsto d]} \phi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M} \models_{\sigma[x \mapsto d]} \phi$ ä¸” $\mathcal{M} \models_{\sigma[x \mapsto d]} \psi$
- å› æ­¤ï¼Œå¯¹æ‰€æœ‰ $d \in D$ï¼Œ$\mathcal{M} \models_{\sigma[x \mapsto d]} \phi$ ä¸”å¯¹æ‰€æœ‰ $d \in D$ï¼Œ$\mathcal{M} \models_{\sigma[x \mapsto d]} \psi$
- è¿™ç­‰ä»·äº $\mathcal{M} \models_\sigma \forall x \phi \land \forall x \psi$

**ç¬¬äºŒéƒ¨åˆ†ï¼š** è¯æ˜ $\exists x (\phi \lor \psi) \equiv \exists x \phi \lor \exists x \psi$

æ ¹æ®æ»¡è¶³å…³ç³»å®šä¹‰ï¼š

- $\mathcal{M} \models_\sigma \exists x (\phi \lor \psi)$ å½“ä¸”ä»…å½“å­˜åœ¨ $d \in D$ï¼Œä½¿å¾— $\mathcal{M} \models_{\sigma[x \mapsto d]} \phi \lor \psi$
- $\mathcal{M} \models_{\sigma[x \mapsto d]} \phi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{M} \models_{\sigma[x \mapsto d]} \phi$ æˆ– $\mathcal{M} \models_{\sigma[x \mapsto d]} \psi$
- å› æ­¤ï¼Œå­˜åœ¨ $d \in D$ï¼Œä½¿å¾— $\mathcal{M} \models_{\sigma[x \mapsto d]} \phi$ æˆ–å­˜åœ¨ $d \in D$ï¼Œä½¿å¾— $\mathcal{M} \models_{\sigma[x \mapsto d]} \psi$
- è¿™ç­‰ä»·äº $\mathcal{M} \models_\sigma \exists x \phi \lor \exists x \psi$

å› æ­¤ï¼Œé‡è¯çš„åˆ†é…å¾‹æˆç«‹ã€‚$\square$

---

## 4. è¯æ˜ç³»ç»Ÿ (Proof Systems)

### 4.1 è‡ªç„¶æ¼”ç»ç³»ç»Ÿ (Natural Deduction System)

**è‡ªç„¶æ¼”ç»è§„åˆ™ / Natural Deduction Rules:**

1. **å¼•å…¥è§„åˆ™ (Introduction Rules) / Introduction Rules:**

   **åˆå–å¼•å…¥ (Conjunction Introduction) / Conjunction Introduction:**
   $$\frac{\phi \quad \psi}{\phi \land \psi}$$

   **æå–å¼•å…¥ (Disjunction Introduction) / Disjunction Introduction:**
   $$\frac{\phi}{\phi \lor \psi} \quad \frac{\psi}{\phi \lor \psi}$$

   **è•´å«å¼•å…¥ (Implication Introduction) / Implication Introduction:**
   $$\frac{[\phi] \quad \vdots \quad \psi}{\phi \rightarrow \psi}$$

   **å…¨ç§°å¼•å…¥ (Universal Introduction) / Universal Introduction:**
   $$\frac{\phi}{\forall x \phi} \quad (x \text{ not free in assumptions})$$

   **å­˜åœ¨å¼•å…¥ (Existential Introduction) / Existential Introduction:**
   $$\frac{\phi[t/x]}{\exists x \phi}$$

2. **æ¶ˆé™¤è§„åˆ™ (Elimination Rules) / Elimination Rules:**

   **åˆå–æ¶ˆé™¤ (Conjunction Elimination) / Conjunction Elimination:**
   $$\frac{\phi \land \psi}{\phi} \quad \frac{\phi \land \psi}{\psi}$$

   **æå–æ¶ˆé™¤ (Disjunction Elimination) / Disjunction Elimination:**
   $$\frac{\phi \lor \psi \quad [\phi] \quad \vdots \quad \chi \quad [\psi] \quad \vdots \quad \chi}{\chi}$$

   **è•´å«æ¶ˆé™¤ (Implication Elimination) / Implication Elimination:**
   $$\frac{\phi \rightarrow \psi \quad \phi}{\psi}$$

   **å…¨ç§°æ¶ˆé™¤ (Universal Elimination) / Universal Elimination:**
   $$\frac{\forall x \phi}{\phi[t/x]}$$

   **å­˜åœ¨æ¶ˆé™¤ (Existential Elimination) / Existential Elimination:**
   $$\frac{\exists x \phi \quad [\phi] \quad \vdots \quad \psi}{\psi} \quad (x \text{ not free in } \psi)$$

### 4.2 å¸Œå°”ä¼¯ç‰¹ç³»ç»Ÿ (Hilbert System)

**å¸Œå°”ä¼¯ç‰¹å…¬ç† (Hilbert Axioms) / Hilbert Axioms:**

1. **å‘½é¢˜é€»è¾‘å…¬ç† (Propositional Logic Axioms) / Propositional Logic Axioms:**
   - $\phi \rightarrow (\psi \rightarrow \phi)$
   - $(\phi \rightarrow (\psi \rightarrow \chi)) \rightarrow ((\phi \rightarrow \psi) \rightarrow (\phi \rightarrow \chi))$
   - $(\neg \phi \rightarrow \neg \psi) \rightarrow (\psi \rightarrow \phi)$

2. **é‡è¯å…¬ç† (Quantifier Axioms) / Quantifier Axioms:**
   - $\forall x \phi \rightarrow \phi[t/x]$ (å…¨ç§°å®ä¾‹åŒ– / Universal instantiation)
   - $\phi[t/x] \rightarrow \exists x \phi$ (å­˜åœ¨æ¦‚æ‹¬ / Existential generalization)

3. **æ¨ç†è§„åˆ™ (Inference Rules) / Inference Rules:**
   - åˆ†ç¦»è§„åˆ™ (Modus Ponens) / Modus Ponens: $\frac{\phi \rightarrow \psi \quad \phi}{\psi}$
   - æ¦‚æ‹¬è§„åˆ™ (Generalization) / Generalization: $\frac{\phi}{\forall x \phi}$

### 4.3 åºåˆ—æ¼”ç®— (Sequent Calculus)

**åºåˆ—å®šä¹‰ / Definition of Sequent:**

åºåˆ—æ˜¯å½¢å¦‚ $\Gamma \vdash \Delta$ çš„è¡¨è¾¾å¼ï¼Œå…¶ä¸­ $\Gamma$ å’Œ $\Delta$ æ˜¯å…¬å¼é›†åˆã€‚

A sequent is an expression of the form $\Gamma \vdash \Delta$, where $\Gamma$ and $\Delta$ are sets of formulas.

**åºåˆ—æ¼”ç®—è§„åˆ™ / Sequent Calculus Rules:**

1. **ç»“æ„è§„åˆ™ (Structural Rules) / Structural Rules:**
   - å¼±åŒ– (Weakening) / Weakening: $\frac{\Gamma \vdash \Delta}{\Gamma, \phi \vdash \Delta}$
   - æ”¶ç¼© (Contraction) / Contraction: $\frac{\Gamma, \phi, \phi \vdash \Delta}{\Gamma, \phi \vdash \Delta}$

2. **é€»è¾‘è§„åˆ™ (Logical Rules) / Logical Rules:**
   - åˆå–è§„åˆ™ (Conjunction Rules) / Conjunction Rules
   - æå–è§„åˆ™ (Disjunction Rules) / Disjunction Rules
   - è•´å«è§„åˆ™ (Implication Rules) / Implication Rules
   - é‡è¯è§„åˆ™ (Quantifier Rules) / Quantifier Rules

---

## 5. å®Œå¤‡æ€§ (Completeness)

### 5.1 å®Œå¤‡æ€§å®šç† (Completeness Theorem)

**å“¥å¾·å°”å®Œå¤‡æ€§å®šç† (GÃ¶del's Completeness Theorem) / GÃ¶del's Completeness Theorem:**

å¯¹äºä¸€é˜¶é€»è¾‘ï¼Œå¦‚æœå…¬å¼ $\phi$ åœ¨æ‰€æœ‰æ¨¡å‹ä¸­éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œé‚£ä¹ˆ $\phi$ æ˜¯å¯è¯æ˜çš„ã€‚

For first-order logic, if a formula $\phi$ is valid in all models, then $\phi$ is provable.

**å½¢å¼åŒ–è¡¨è¿° / Formal Statement:**

$$\models \phi \Rightarrow \vdash \phi$$

### 5.2 ç´§è‡´æ€§å®šç† (Compactness Theorem)

**ç´§è‡´æ€§å®šç† / Compactness Theorem:**

å¦‚æœå…¬å¼é›†åˆ $\Gamma$ çš„æ¯ä¸ªæœ‰é™å­é›†éƒ½æ˜¯å¯æ»¡è¶³çš„ï¼Œé‚£ä¹ˆ $\Gamma$ æœ¬èº«æ˜¯å¯æ»¡è¶³çš„ã€‚

If every finite subset of a set of formulas $\Gamma$ is satisfiable, then $\Gamma$ itself is satisfiable.

**å½¢å¼åŒ–è¡¨è¿° / Formal Statement:**

å¦‚æœå¯¹äºæ‰€æœ‰æœ‰é™å­é›† $\Gamma' \subseteq \Gamma$ï¼Œå­˜åœ¨æ¨¡å‹ $\mathcal{M}$ ä½¿å¾— $\mathcal{M} \models \Gamma'$ï¼Œé‚£ä¹ˆå­˜åœ¨æ¨¡å‹ $\mathcal{M}$ ä½¿å¾— $\mathcal{M} \models \Gamma$ã€‚

If for every finite subset $\Gamma' \subseteq \Gamma$, there exists a model $\mathcal{M}$ such that $\mathcal{M} \models \Gamma'$, then there exists a model $\mathcal{M}$ such that $\mathcal{M} \models \Gamma$.

### 5.3 å‹’æ–‡æµ·å§†-æ–¯ç§‘ä¼¦å®šç† (LÃ¶wenheim-Skolem Theorem)

**å‘ä¸‹å‹’æ–‡æµ·å§†-æ–¯ç§‘ä¼¦å®šç† (Downward LÃ¶wenheim-Skolem Theorem) / Downward LÃ¶wenheim-Skolem Theorem:**

å¦‚æœå¯æ•°è¯­è¨€çš„ä¸€é˜¶ç†è®ºæœ‰æ— é™æ¨¡å‹ï¼Œé‚£ä¹ˆå®ƒæœ‰å¯æ•°æ¨¡å‹ã€‚

If a first-order theory in a countable language has an infinite model, then it has a countable model.

**å‘ä¸Šå‹’æ–‡æµ·å§†-æ–¯ç§‘ä¼¦å®šç† (Upward LÃ¶wenheim-Skolem Theorem) / Upward LÃ¶wenheim-Skolem Theorem:**

å¦‚æœä¸€é˜¶ç†è®ºæœ‰æ— é™æ¨¡å‹ï¼Œé‚£ä¹ˆå¯¹äºä»»ä½•åŸºæ•° $\kappa \geq |\mathcal{L}|$ï¼Œå®ƒéƒ½æœ‰åŸºæ•°ä¸º $\kappa$ çš„æ¨¡å‹ã€‚

If a first-order theory has an infinite model, then for any cardinal $\kappa \geq |\mathcal{L}|$, it has a model of cardinality $\kappa$.

---

## 6. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 6.1 ä¸€é˜¶é€»è¾‘è§£æå™¨ (First-Order Logic Parser)

```rust
use std::collections::HashMap;

/// ä¸€é˜¶é€»è¾‘è§£æå™¨ / First-Order Logic Parser
pub struct FirstOrderLogicParser {
    variables: HashMap<String, String>,
    constants: HashMap<String, String>,
    functions: HashMap<String, Vec<String>>,
    predicates: HashMap<String, Vec<String>>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Term {
    Variable(String),
    Constant(String),
    Function(String, Vec<Term>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Formula {
    Atomic(String, Vec<Term>),
    Negation(Box<Formula>),
    Conjunction(Box<Formula>, Box<Formula>),
    Disjunction(Box<Formula>, Box<Formula>),
    Implication(Box<Formula>, Box<Formula>),
    Equivalence(Box<Formula>, Box<Formula>),
    Universal(String, Box<Formula>),
    Existential(String, Box<Formula>),
}

impl FirstOrderLogicParser {
    /// åˆ›å»ºæ–°çš„è§£æå™¨ / Create new parser
    pub fn new() -> Self {
        FirstOrderLogicParser {
            variables: HashMap::new(),
            constants: HashMap::new(),
            functions: HashMap::new(),
            predicates: HashMap::new(),
        }
    }

    /// è§£æé¡¹ / Parse term
    pub fn parse_term(&self, input: &str) -> Result<Term, String> {
        let tokens = self.tokenize(input)?;
        self.parse_term_tokens(&tokens)
    }

    /// è§£æå…¬å¼ / Parse formula
    pub fn parse_formula(&self, input: &str) -> Result<Formula, String> {
        let tokens = self.tokenize(input)?;
        self.parse_formula_tokens(&tokens)
    }

    /// è¯æ³•åˆ†æ / Tokenization
    fn tokenize(&self, input: &str) -> Result<Vec<String>, String> {
        let mut tokens = Vec::new();
        let mut current = String::new();
        let mut in_quotes = false;

        for ch in input.chars() {
            match ch {
                ' ' | '\t' | '\n' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                }
                '(' | ')' | ',' => {
                    if !current.is_empty() {
                        tokens.push(current.clone());
                        current.clear();
                    }
                    tokens.push(ch.to_string());
                }
                _ => current.push(ch),
            }
        }

        if !current.is_empty() {
            tokens.push(current);
        }

        Ok(tokens)
    }

    /// è§£æé¡¹æ ‡è®° / Parse term tokens
    fn parse_term_tokens(&self, tokens: &[String]) -> Result<Term, String> {
        if tokens.is_empty() {
            return Err("Empty token list".to_string());
        }

        match tokens[0].as_str() {
            "x" | "y" | "z" => Ok(Term::Variable(tokens[0].clone())),
            "a" | "b" | "c" => Ok(Term::Constant(tokens[0].clone())),
            func_name => {
                if tokens.len() < 3 || tokens[1] != "(" || tokens[tokens.len() - 1] != ")" {
                    return Err("Invalid function syntax".to_string());
                }

                let args_tokens = &tokens[2..tokens.len() - 1];
                let args = self.parse_term_list(args_tokens)?;
                Ok(Term::Function(func_name.to_string(), args))
            }
        }
    }

    /// è§£æé¡¹åˆ—è¡¨ / Parse term list
    fn parse_term_list(&self, tokens: &[String]) -> Result<Vec<Term>, String> {
        if tokens.is_empty() {
            return Ok(Vec::new());
        }

        let mut terms = Vec::new();
        let mut current_tokens = Vec::new();
        let mut paren_count = 0;

        for token in tokens {
            match token.as_str() {
                "(" => {
                    paren_count += 1;
                    current_tokens.push(token.clone());
                }
                ")" => {
                    paren_count -= 1;
                    current_tokens.push(token.clone());
                }
                "," => {
                    if paren_count == 0 {
                        if !current_tokens.is_empty() {
                            terms.push(self.parse_term_tokens(&current_tokens)?);
                            current_tokens.clear();
                        }
                    } else {
                        current_tokens.push(token.clone());
                    }
                }
                _ => current_tokens.push(token.clone()),
            }
        }

        if !current_tokens.is_empty() {
            terms.push(self.parse_term_tokens(&current_tokens)?);
        }

        Ok(terms)
    }

    /// è§£æå…¬å¼æ ‡è®° / Parse formula tokens
    fn parse_formula_tokens(&self, tokens: &[String]) -> Result<Formula, String> {
        if tokens.is_empty() {
            return Err("Empty token list".to_string());
        }

        match tokens[0].as_str() {
            "Â¬" | "~" => {
                if tokens.len() < 2 {
                    return Err("Invalid negation".to_string());
                }
                let sub_formula = self.parse_formula_tokens(&tokens[1..])?;
                Ok(Formula::Negation(Box::new(sub_formula)))
            }
            "âˆ€" | "forall" => {
                if tokens.len() < 4 || tokens[1] != "(" || tokens[3] != ")" {
                    return Err("Invalid universal quantifier".to_string());
                }
                let variable = tokens[2].clone();
                let sub_formula = self.parse_formula_tokens(&tokens[4..])?;
                Ok(Formula::Universal(variable, Box::new(sub_formula)))
            }
            "âˆƒ" | "exists" => {
                if tokens.len() < 4 || tokens[1] != "(" || tokens[3] != ")" {
                    return Err("Invalid existential quantifier".to_string());
                }
                let variable = tokens[2].clone();
                let sub_formula = self.parse_formula_tokens(&tokens[4..])?;
                Ok(Formula::Existential(variable, Box::new(sub_formula)))
            }
            pred_name => {
                if tokens.len() < 3 || tokens[1] != "(" || tokens[tokens.len() - 1] != ")" {
                    return Err("Invalid predicate syntax".to_string());
                }

                let args_tokens = &tokens[2..tokens.len() - 1];
                let args = self.parse_term_list(args_tokens)?;
                Ok(Formula::Atomic(pred_name.to_string(), args))
            }
        }
    }
}
```

### 6.2 ä¸€é˜¶é€»è¾‘è§£é‡Šå™¨ (First-Order Logic Interpreter)

```rust
/// ä¸€é˜¶é€»è¾‘è§£é‡Šå™¨ / First-Order Logic Interpreter
pub struct FirstOrderLogicInterpreter {
    domain: Vec<String>,
    interpretations: HashMap<String, String>,
    function_interpretations: HashMap<String, Box<dyn Fn(&[String]) -> String>>,
    predicate_interpretations: HashMap<String, Box<dyn Fn(&[String]) -> bool>>,
}

impl FirstOrderLogicInterpreter {
    /// åˆ›å»ºæ–°çš„è§£é‡Šå™¨ / Create new interpreter
    pub fn new() -> Self {
        FirstOrderLogicInterpreter {
            domain: Vec::new(),
            interpretations: HashMap::new(),
            function_interpretations: HashMap::new(),
            predicate_interpretations: HashMap::new(),
        }
    }

    /// è®¾ç½®è®ºåŸŸ / Set domain
    pub fn set_domain(&mut self, domain: Vec<String>) {
        self.domain = domain;
    }

    /// æ·»åŠ å¸¸é‡è§£é‡Š / Add constant interpretation
    pub fn add_constant_interpretation(&mut self, constant: String, value: String) {
        self.interpretations.insert(constant, value);
    }

    /// æ·»åŠ å‡½æ•°è§£é‡Š / Add function interpretation
    pub fn add_function_interpretation<F>(&mut self, function: String, interpretation: F)
    where
        F: Fn(&[String]) -> String + 'static,
    {
        self.function_interpretations.insert(function, Box::new(interpretation));
    }

    /// æ·»åŠ è°“è¯è§£é‡Š / Add predicate interpretation
    pub fn add_predicate_interpretation<F>(&mut self, predicate: String, interpretation: F)
    where
        F: Fn(&[String]) -> bool + 'static,
    {
        self.predicate_interpretations.insert(predicate, Box::new(interpretation));
    }

    /// è§£é‡Šé¡¹ / Interpret term
    pub fn interpret_term(&self, term: &Term, assignment: &HashMap<String, String>) -> Result<String, String> {
        match term {
            Term::Variable(var) => {
                assignment.get(var)
                    .cloned()
                    .ok_or_else(|| format!("Variable {} not assigned", var))
            }
            Term::Constant(constant) => {
                self.interpretations.get(constant)
                    .cloned()
                    .ok_or_else(|| format!("Constant {} not interpreted", constant))
            }
            Term::Function(func_name, args) => {
                let interpreted_args: Result<Vec<String>, String> = args
                    .iter()
                    .map(|arg| self.interpret_term(arg, assignment))
                    .collect();

                let args_values = interpreted_args?;

                if let Some(interpretation) = self.function_interpretations.get(func_name) {
                    Ok(interpretation(&args_values))
                } else {
                    Err(format!("Function {} not interpreted", func_name))
                }
            }
        }
    }

    /// è§£é‡Šå…¬å¼ / Interpret formula
    pub fn interpret_formula(&self, formula: &Formula, assignment: &HashMap<String, String>) -> Result<bool, String> {
        match formula {
            Formula::Atomic(pred_name, args) => {
                let interpreted_args: Result<Vec<String>, String> = args
                    .iter()
                    .map(|arg| self.interpret_term(arg, assignment))
                    .collect();

                let args_values = interpreted_args?;

                if let Some(interpretation) = self.predicate_interpretations.get(pred_name) {
                    Ok(interpretation(&args_values))
                } else {
                    Err(format!("Predicate {} not interpreted", pred_name))
                }
            }
            Formula::Negation(sub_formula) => {
                let sub_result = self.interpret_formula(sub_formula, assignment)?;
                Ok(!sub_result)
            }
            Formula::Conjunction(left, right) => {
                let left_result = self.interpret_formula(left, assignment)?;
                let right_result = self.interpret_formula(right, assignment)?;
                Ok(left_result && right_result)
            }
            Formula::Disjunction(left, right) => {
                let left_result = self.interpret_formula(left, assignment)?;
                let right_result = self.interpret_formula(right, assignment)?;
                Ok(left_result || right_result)
            }
            Formula::Implication(left, right) => {
                let left_result = self.interpret_formula(left, assignment)?;
                let right_result = self.interpret_formula(right, assignment)?;
                Ok(!left_result || right_result)
            }
            Formula::Equivalence(left, right) => {
                let left_result = self.interpret_formula(left, assignment)?;
                let right_result = self.interpret_formula(right, assignment)?;
                Ok(left_result == right_result)
            }
            Formula::Universal(var, sub_formula) => {
                let mut all_true = true;
                for value in &self.domain {
                    let mut new_assignment = assignment.clone();
                    new_assignment.insert(var.clone(), value.clone());
                    let sub_result = self.interpret_formula(sub_formula, &new_assignment)?;
                    if !sub_result {
                        all_true = false;
                        break;
                    }
                }
                Ok(all_true)
            }
            Formula::Existential(var, sub_formula) => {
                for value in &self.domain {
                    let mut new_assignment = assignment.clone();
                    new_assignment.insert(var.clone(), value.clone());
                    let sub_result = self.interpret_formula(sub_formula, &new_assignment)?;
                    if sub_result {
                        return Ok(true);
                    }
                }
                Ok(false)
            }
        }
    }
}
```

### 6.3 ä¸€é˜¶é€»è¾‘è¯æ˜ç³»ç»Ÿ (First-Order Logic Proof System)

```rust
/// ä¸€é˜¶é€»è¾‘è¯æ˜ç³»ç»Ÿ / First-Order Logic Proof System
pub struct FirstOrderLogicProofSystem {
    axioms: Vec<Formula>,
    rules: Vec<ProofRule>,
}

#[derive(Debug, Clone)]
pub enum ProofRule {
    ModusPonens,
    UniversalGeneralization,
    ExistentialInstantiation,
    ConjunctionIntroduction,
    ConjunctionElimination,
    DisjunctionIntroduction,
    DisjunctionElimination,
    ImplicationIntroduction,
    ImplicationElimination,
    NegationIntroduction,
    NegationElimination,
}

#[derive(Debug, Clone)]
pub struct ProofStep {
    pub formula: Formula,
    pub rule: ProofRule,
    pub premises: Vec<usize>,
    pub justification: String,
}

#[derive(Debug, Clone)]
pub struct Proof {
    pub steps: Vec<ProofStep>,
    pub conclusion: Formula,
}

impl FirstOrderLogicProofSystem {
    /// åˆ›å»ºæ–°çš„è¯æ˜ç³»ç»Ÿ / Create new proof system
    pub fn new() -> Self {
        FirstOrderLogicProofSystem {
            axioms: Vec::new(),
            rules: Vec::new(),
        }
    }

    /// æ·»åŠ å…¬ç† / Add axiom
    pub fn add_axiom(&mut self, axiom: Formula) {
        self.axioms.push(axiom);
    }

    /// æ·»åŠ æ¨ç†è§„åˆ™ / Add inference rule
    pub fn add_rule(&mut self, rule: ProofRule) {
        self.rules.push(rule);
    }

    /// éªŒè¯è¯æ˜ / Verify proof
    pub fn verify_proof(&self, proof: &Proof) -> Result<bool, String> {
        for (i, step) in proof.steps.iter().enumerate() {
            if !self.verify_step(step, &proof.steps[..i])? {
                return Err(format!("Invalid proof step {}", i));
            }
        }
        Ok(true)
    }

    /// éªŒè¯è¯æ˜æ­¥éª¤ / Verify proof step
    fn verify_step(&self, step: &ProofStep, previous_steps: &[ProofStep]) -> Result<bool, String> {
        match step.rule {
            ProofRule::ModusPonens => {
                if step.premises.len() != 2 {
                    return Err("Modus Ponens requires exactly 2 premises".to_string());
                }
                let premise1 = &previous_steps[step.premises[0]].formula;
                let premise2 = &previous_steps[step.premises[1]].formula;

                match (premise1, premise2) {
                    (Formula::Implication(antecedent, consequent), antecedent_formula) => {
                        Ok(antecedent.as_ref() == antecedent_formula && step.formula == *consequent.as_ref())
                    }
                    _ => Ok(false),
                }
            }
            ProofRule::UniversalGeneralization => {
                if step.premises.len() != 1 {
                    return Err("Universal Generalization requires exactly 1 premise".to_string());
                }
                let premise = &previous_steps[step.premises[0]].formula;

                match &step.formula {
                    Formula::Universal(var, sub_formula) => {
                        Ok(premise == sub_formula.as_ref())
                    }
                    _ => Ok(false),
                }
            }
            ProofRule::ConjunctionIntroduction => {
                if step.premises.len() != 2 {
                    return Err("Conjunction Introduction requires exactly 2 premises".to_string());
                }
                let premise1 = &previous_steps[step.premises[0]].formula;
                let premise2 = &previous_steps[step.premises[1]].formula;

                match &step.formula {
                    Formula::Conjunction(left, right) => {
                        Ok(left.as_ref() == premise1 && right.as_ref() == premise2)
                    }
                    _ => Ok(false),
                }
            }
            ProofRule::ConjunctionElimination => {
                if step.premises.len() != 1 {
                    return Err("Conjunction Elimination requires exactly 1 premise".to_string());
                }
                let premise = &previous_steps[step.premises[0]].formula;

                match premise {
                    Formula::Conjunction(left, right) => {
                        Ok(step.formula == *left.as_ref() || step.formula == *right.as_ref())
                    }
                    _ => Ok(false),
                }
            }
            _ => Ok(true), // ç®€åŒ–å¤„ç†å…¶ä»–è§„åˆ™
        }
    }

    /// æ„é€ è¯æ˜ / Construct proof
    pub fn construct_proof(&self, premises: &[Formula], conclusion: &Formula) -> Result<Proof, String> {
        let mut proof = Proof {
            steps: Vec::new(),
            conclusion: conclusion.clone(),
        };

        // æ·»åŠ å‰æ / Add premises
        for (i, premise) in premises.iter().enumerate() {
            proof.steps.push(ProofStep {
                formula: premise.clone(),
                rule: ProofRule::ModusPonens, // å ä½ç¬¦
                premises: vec![],
                justification: format!("Premise {}", i + 1),
            });
        }

        // è¿™é‡Œåº”è¯¥å®ç°å®é™…çš„è¯æ˜æ„é€ ç®—æ³•
        // This should implement actual proof construction algorithm
        Ok(proof)
    }
}
```

### 6.4 ä¸€é˜¶é€»è¾‘æµ‹è¯• (First-Order Logic Testing)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_term_parsing() {
        let parser = FirstOrderLogicParser::new();

        // æµ‹è¯•å˜é‡ / Test variable
        let result = parser.parse_term("x");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), Term::Variable(_)));

        // æµ‹è¯•å¸¸é‡ / Test constant
        let result = parser.parse_term("a");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), Term::Constant(_)));

        // æµ‹è¯•å‡½æ•° / Test function
        let result = parser.parse_term("f(x, y)");
        assert!(result.is_ok());
        if let Ok(Term::Function(name, args)) = result {
            assert_eq!(name, "f");
            assert_eq!(args.len(), 2);
        } else {
            panic!("Expected function term");
        }
    }

    #[test]
    fn test_formula_parsing() {
        let parser = FirstOrderLogicParser::new();

        // æµ‹è¯•åŸå­å…¬å¼ / Test atomic formula
        let result = parser.parse_formula("P(x, y)");
        assert!(result.is_ok());
        assert!(matches!(result.unwrap(), Formula::Atomic(_, _)));

        // æµ‹è¯•å¦å®š / Test negation
        let result = parser.parse_formula("Â¬P(x)");
        assert!(result.is_ok());
        if let Ok(Formula::Negation(sub_formula)) = result {
            assert!(matches!(*sub_formula, Formula::Atomic(_, _)));
        } else {
            panic!("Expected negation formula");
        }

        // æµ‹è¯•å…¨ç§°é‡è¯ / Test universal quantifier
        let result = parser.parse_formula("âˆ€(x)P(x)");
        assert!(result.is_ok());
        if let Ok(Formula::Universal(var, sub_formula)) = result {
            assert_eq!(var, "x");
            assert!(matches!(*sub_formula, Formula::Atomic(_, _)));
        } else {
            panic!("Expected universal formula");
        }
    }

    #[test]
    fn test_interpretation() {
        let mut interpreter = FirstOrderLogicInterpreter::new();

        // è®¾ç½®è®ºåŸŸ / Set domain
        interpreter.set_domain(vec!["0".to_string(), "1".to_string(), "2".to_string()]);

        // æ·»åŠ å¸¸é‡è§£é‡Š / Add constant interpretation
        interpreter.add_constant_interpretation("a".to_string(), "0".to_string());

        // æ·»åŠ è°“è¯è§£é‡Š / Add predicate interpretation
        interpreter.add_predicate_interpretation("P".to_string(), |args| {
            args.len() == 1 && args[0] == "0"
        });

        // æµ‹è¯•è§£é‡Š / Test interpretation
        let term = Term::Constant("a".to_string());
        let assignment = HashMap::new();
        let result = interpreter.interpret_term(&term, &assignment);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "0");

        let formula = Formula::Atomic("P".to_string(), vec![Term::Constant("a".to_string())]);
        let result = interpreter.interpret_formula(&formula, &assignment);
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[test]
    fn test_proof_system() {
        let mut proof_system = FirstOrderLogicProofSystem::new();

        // æ·»åŠ å…¬ç† / Add axioms
        proof_system.add_axiom(Formula::Atomic("A".to_string(), vec![]));

        // æ„é€ ç®€å•è¯æ˜ / Construct simple proof
        let premises = vec![Formula::Atomic("A".to_string(), vec![])];
        let conclusion = Formula::Atomic("A".to_string(), vec![]);

        let proof = proof_system.construct_proof(&premises, &conclusion);
        assert!(proof.is_ok());

        // éªŒè¯è¯æ˜ / Verify proof
        let verification = proof_system.verify_proof(&proof.unwrap());
        assert!(verification.is_ok());
    }
}
```

---

## 7. å‚è€ƒæ–‡çŒ® / References

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

### ç»å…¸å¥ åŸºæ–‡çŒ® / Classic Foundational Literature

1. [Goedel1930] GÃ¶del, K. (1930). "Die VollstÃ¤ndigkeit der Axiome des logischen FunktionenkalkÃ¼ls". *Monatshefte fÃ¼r Mathematik und Physik*, 37(1): 349-360.
   - **å“¥å¾·å°”å®Œå¤‡æ€§å®šç†**ï¼Œä¸€é˜¶é€»è¾‘çš„é‡Œç¨‹ç¢‘ã€‚æœ¬æ–‡æ¡£Â§2.5çš„å®Œå¤‡æ€§ç†è®ºåŸºäºæ­¤è®ºæ–‡ã€‚

2. [Church1936Entscheidungsproblem] Church, A. (1936). "A Note on the Entscheidungsproblem". *The Journal of Symbolic Logic*, 1(1): 40-41.
   - Churchè¯æ˜ä¸€é˜¶é€»è¾‘ä¸å¯åˆ¤å®šï¼Œä¸TuringåŒæ—¶æœŸçš„é‡è¦å·¥ä½œã€‚æœ¬æ–‡æ¡£å…³äºä¸å¯åˆ¤å®šæ€§çš„è®¨è®ºåŸºäºæ­¤è®ºæ–‡ã€‚

3. [Tarski1936] Tarski, A. (1936). "Der Wahrheitsbegriff in den formalisierten Sprachen". *Studia Philosophica*, 1: 261-405.
   - **Tarskiè¯­ä¹‰å­¦çš„å¥ åŸºä¹‹ä½œ**ï¼Œæ¨¡å‹è®ºçš„åŸºç¡€ã€‚æœ¬æ–‡æ¡£Â§2.3çš„è¯­ä¹‰ç†è®ºåŸºäºæ­¤è®ºæ–‡ã€‚

### æ ‡å‡†æ•™æ / Standard Textbooks

1. Enderton, H. B. (2001). *A Mathematical Introduction to Logic*. Academic Press.
   - ä¸€é˜¶é€»è¾‘çš„ç»å…¸æ•™æï¼Œæœ¬æ–‡æ¡£çš„åŸºç¡€æ¡†æ¶å‚è€ƒæ­¤ä¹¦ã€‚

2. Mendelson, E. (2015). *Introduction to Mathematical Logic* (6th ed.). CRC Press.
   - æ•°ç†é€»è¾‘æ ‡å‡†æ•™æï¼Œæœ¬æ–‡æ¡£Â§2.2å’ŒÂ§2.4çš„å†…å®¹å‚è€ƒæ­¤ä¹¦ã€‚

3. Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). *Computability and Logic* (5th ed.). Cambridge University Press.
   - å¯è®¡ç®—æ€§ä¸é€»è¾‘çš„ç»¼åˆæ€§æ•™æã€‚

### æ¨¡å‹è®º / Model Theory

1. Robinson, A. (1963). *Introduction to Model Theory and to the Metamathematics of Algebra*. North-Holland.
   - æ¨¡å‹è®ºçš„æ—©æœŸç»å…¸æ•™æã€‚

2. Chang, C. C., & Keisler, H. J. (2012). *Model Theory* (3rd ed.). Elsevier.
   - æ¨¡å‹è®ºçš„æƒå¨æ•™æï¼Œæœ¬æ–‡æ¡£æ¨¡å‹è®ºéƒ¨åˆ†å‚è€ƒæ­¤ä¹¦ã€‚

3. Hodges, W. (1993). *Model Theory*. Cambridge University Press.
   - ç°ä»£æ¨¡å‹è®ºçš„æ ‡å‡†æ•™æã€‚

4. Marker, D. (2002). *Model Theory: An Introduction*. Springer.
    - æ¨¡å‹è®ºçš„å…¥é—¨æ•™æï¼Œæ¸…æ™°æ˜“æ‡‚ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - First-Order Logic**: <https://en.wikipedia.org/wiki/First-order_logic>
   - ä¸€é˜¶é€»è¾‘çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«è¯­æ³•ã€è¯­ä¹‰å’Œå®Œå¤‡æ€§å®šç†ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Model Theory**: <https://en.wikipedia.org/wiki/Model_theory>
   - æ¨¡å‹è®ºçš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»ä¸€é˜¶é€»è¾‘çš„è¯­ä¹‰ç†è®ºï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - GÃ¶del's Completeness Theorem**: <https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem>
   - å“¥å¾·å°”å®Œå¤‡æ€§å®šç†çš„Wikipediaæ¡ç›®ï¼Œä¸€é˜¶é€»è¾‘çš„æ ¸å¿ƒç»“æœï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
****æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£æä¾›äº†ä¸€é˜¶é€»è¾‘çš„å…¨é¢ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€è¯­æ³•ã€è¯­ä¹‰ã€è¯æ˜ç³»ç»Ÿã€å®Œå¤‡æ€§å’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„Rustä»£ç å®ç°ã€‚*
