# 01-形式化定义 / Formal Definition

> 导航：`docs/形式化算法文档改进完成报告.md` · `docs/术语与符号总表.md` · `docs/跨文档索引.md`

## 目录 / Table of Contents

- [01-形式化定义 / Formal Definition](#01-形式化定义--formal-definition)
  - [目录 / Table of Contents](#目录--table-of-contents)
  - [1. 基本概念 / Basic Concepts](#1-基本概念--basic-concepts)
    - [1.1 形式化 / Formalization](#11-形式化--formalization)
    - [1.2 算法 / Algorithm](#12-算法--algorithm)
    - [1.3 计算 / Computation](#13-计算--computation)
  - [2. 形式化语言 / Formal Language](#2-形式化语言--formal-language)
    - [2.1 字母表 / Alphabet](#21-字母表--alphabet)
    - [2.2 字符串 / String](#22-字符串--string)
    - [2.3 语言 / Language](#23-语言--language)
  - [3. 算法定义 / Algorithm Definition](#3-算法定义--algorithm-definition)
    - [3.1 图灵机模型 / Turing Machine Model](#31-图灵机模型--turing-machine-model)
    - [3.2 转移函数 / Transition Function](#32-转移函数--transition-function)
    - [3.3 计算过程 / Computation Process](#33-计算过程--computation-process)
  - [4. 计算模型 / Computation Models](#4-计算模型--computation-models)
    - [4.1 递归函数 / Recursive Functions](#41-递归函数--recursive-functions)
    - [4.2 原始递归 / Primitive Recursion](#42-原始递归--primitive-recursion)
    - [4.3 μ-递归 / μ-Recursion](#43-μ-递归--μ-recursion)
  - [5. 形式化系统 / Formal Systems](#5-形式化系统--formal-systems)
    - [5.1 公理系统 / Axiomatic System](#51-公理系统--axiomatic-system)
    - [5.2 证明 / Proof](#52-证明--proof)
    - [5.3 一致性 / Consistency](#53-一致性--consistency)
  - [6. 参考文献 / References](#6-参考文献--references)
    - [经典文献 / Classical References](#经典文献--classical-references)
    - [现代教材 / Modern Textbooks](#现代教材--modern-textbooks)
    - [形式化系统 / Formal Systems](#形式化系统--formal-systems)
    - [计算理论 / Computation Theory](#计算理论--computation-theory)
    - [类型理论 / Type Theory](#类型理论--type-theory)
    - [逻辑系统 / Logical Systems](#逻辑系统--logical-systems)
    - [在线资源 / Online Resources](#在线资源--online-resources)
    - [国际标准 / International Standards](#国际标准--international-standards)

---

## 1. 基本概念 / Basic Concepts

### 1.1 形式化 / Formalization

**定义 1.1.1** 形式化是指将非形式化的概念、推理或系统转换为严格的形式语言的过程。
**Definition 1.1.1** Formalization is the process of converting informal concepts, reasoning, or systems into strict formal language.

**数学表示 / Mathematical Representation:**
设 $C$ 为概念集合，$L$ 为形式语言，$F$ 为形式化函数，则：
Let $C$ be the concept set, $L$ be the formal language, and $F$ be the formalization function, then:
$$F: C \rightarrow L$$

**形式化系统的公理化定义 / Axiomatic Definition of Formal System:**

一个形式化系统 $\mathcal{F}$ 是一个四元组：
A formal system $\mathcal{F}$ is a 4-tuple:
$$\mathcal{F} = (\mathcal{L}, \mathcal{A}, \mathcal{R}, \mathcal{P})$$

其中 / where:

- $\mathcal{L}$：形式语言 / Formal language
- $\mathcal{A}$：公理集合 / Set of axioms  
- $\mathcal{R}$：推理规则集合 / Set of inference rules
- $\mathcal{P}$：证明系统 / Proof system

**形式语言的严格定义 / Strict Definition of Formal Language:**

形式语言 $\mathcal{L}$ 由以下部分组成：
A formal language $\mathcal{L}$ consists of:

1. **字母表 / Alphabet**: $\Sigma = \{a_1, a_2, \ldots, a_n\}$
2. **语法规则 / Syntax Rules**: $G = (V, \Sigma, P, S)$
3. **语义函数 / Semantic Function**: $\llbracket \cdot \rrbracket: \mathcal{L} \rightarrow \mathcal{D}$

其中 $G$ 是上下文无关文法，$V$ 是非终结符集合，$P$ 是产生式规则，$S$ 是起始符号。
where $G$ is a context-free grammar, $V$ is the set of non-terminals, $P$ is the set of production rules, and $S$ is the start symbol.

**性质 / Properties:**

- **精确性 / Precision**: 每个符号都有明确的语义 / Each symbol has clear semantics
- **一致性 / Consistency**: 系统内部无矛盾 / No contradictions within the system
- **完备性 / Completeness**: 所有真命题都可证明 / All true propositions can be proven
- **可判定性 / Decidability**: 存在算法判断命题真假 / There exists an algorithm to determine the truth of propositions

**形式化系统的元理论性质 / Metatheoretical Properties:**

**定理 1.1.1** (哥德尔不完备性定理) 任何包含算术的一致形式化系统都是不完备的。
**Theorem 1.1.1** (Gödel's Incompleteness Theorem) Any consistent formal system containing arithmetic is incomplete.

**证明 / Proof:**
通过构造自指语句 $G$："$G$ 不可证明"。如果 $G$ 可证明，则它为假；如果 $G$ 不可证明，则它为真。这导致矛盾。
By constructing the self-referential statement $G$: "$G$ is not provable". If $G$ is provable, then it is false; if $G$ is not provable, then it is true. This leads to a contradiction.

**定理 1.1.2** (塔斯基不可定义性定理) 在足够强的形式化系统中，真性概念不可在该系统内部定义。
**Theorem 1.1.2** (Tarski's Undefinability Theorem) In sufficiently strong formal systems, the concept of truth cannot be defined within the system itself.

### 1.2 算法 / Algorithm

**定义 1.2.1** 算法是一个有限的、明确的、可执行的指令序列，用于解决特定问题。
**Definition 1.2.1** An algorithm is a finite, definite, and executable sequence of instructions for solving a specific problem.

**算法的公理化定义 / Axiomatic Definition of Algorithm:**

算法 $A$ 是一个六元组：
Algorithm $A$ is a 6-tuple:
$$A = (Q, \Sigma, \Gamma, \delta, q_0, F)$$

其中 / where:

- $Q$：有限状态集合 / Finite set of states
- $\Sigma$：输入字母表 / Input alphabet
- $\Gamma$：工作字母表 / Working alphabet ($\Sigma \subseteq \Gamma$)
- $\delta$：转移函数 / Transition function
- $q_0 \in Q$：初始状态 / Initial state
- $F \subseteq Q$：接受状态集合 / Set of accepting states

**转移函数的严格定义 / Strict Definition of Transition Function:**

$$\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R, N\}$$

其中 $L, R, N$ 分别表示左移、右移和不动。
where $L, R, N$ represent left move, right move, and no move respectively.

**算法的计算过程 / Computation Process of Algorithm:**

**定义 1.2.2** 配置 / Configuration:
配置是一个三元组 $(q, w, u)$，其中：
A configuration is a triple $(q, w, u)$, where:

- $q \in Q$：当前状态 / Current state
- $w \in \Gamma^*$：磁带左半部分 / Left part of tape
- $u \in \Gamma^*$：磁带右半部分 / Right part of tape

**定义 1.2.3** 配置转移关系 / Configuration Transition Relation:
$$(q, w, u) \vdash_A (q', w', u')$$

当且仅当 $\delta(q, u_1) = (q', b, D)$ 且：
if and only if $\delta(q, u_1) = (q', b, D)$ and:

- 如果 $D = L$：$w' = w_{|w|-1}, u' = w_{|w|} \cdot b \cdot u_{2:}$
- 如果 $D = R$：$w' = w \cdot b, u' = u_{2:}$
- 如果 $D = N$：$w' = w, u' = b \cdot u_{2:}$

**算法的语言识别 / Language Recognition by Algorithm:**

**定义 1.2.4** 算法 $A$ 识别的语言：
The language recognized by algorithm $A$:
$$L(A) = \{x \in \Sigma^* : (q_0, \epsilon, x) \vdash_A^* (q_f, w, u) \text{ for some } q_f \in F\}$$

其中 $\vdash_A^*$ 是 $\vdash_A$ 的自反传递闭包。
where $\vdash_A^*$ is the reflexive transitive closure of $\vdash_A$.

**算法的复杂度分析 / Complexity Analysis of Algorithm:**

**定义 1.2.5** 时间复杂度函数：
Time complexity function:
$$T_A: \Sigma^* \rightarrow \mathbb{N}$$

其中 $T_A(x)$ 是算法 $A$ 在输入 $x$ 上的计算步数。
where $T_A(x)$ is the number of computation steps of algorithm $A$ on input $x$.

**定义 1.2.6** 空间复杂度函数：
Space complexity function:
$$S_A: \Sigma^* \rightarrow \mathbb{N}$$

其中 $S_A(x)$ 是算法 $A$ 在输入 $x$ 上使用的最大磁带格子数。
where $S_A(x)$ is the maximum number of tape cells used by algorithm $A$ on input $x$.

### 1.3 计算 / Computation

**定义 1.3.1** 计算是算法在给定输入上执行的过程。
**Definition 1.3.1** Computation is the process of executing an algorithm on given input.

**计算的公理化定义 / Axiomatic Definition of Computation:**

计算是一个三元组：
Computation is a triple:
$$\mathcal{C} = (I, P, O)$$

其中 / where:

- $I$：输入域 / Input domain
- $P$：计算过程 / Computation process
- $O$：输出域 / Output domain

**计算函数的严格定义 / Strict Definition of Computation Function:**

**定义 1.3.2** 部分计算函数：
Partial computation function:
$$f: \mathbb{N}^n \rightharpoonup \mathbb{N}$$

其中 $\rightharpoonup$ 表示部分函数。
where $\rightharpoonup$ denotes a partial function.

**定义 1.3.3** 全计算函数：
Total computation function:
$$f: \mathbb{N}^n \rightarrow \mathbb{N}$$

**计算的可计算性 / Computability of Functions:**

**定义 1.3.4** 函数 $f: \mathbb{N}^n \rightharpoonup \mathbb{N}$ 是可计算的，当且仅当存在图灵机 $M$ 使得：
A function $f: \mathbb{N}^n \rightharpoonup \mathbb{N}$ is computable if and only if there exists a Turing machine $M$ such that:
$$\forall \vec{x} \in \text{dom}(f): M(\vec{x}) = f(\vec{x})$$

其中 $\text{dom}(f)$ 是 $f$ 的定义域。
where $\text{dom}(f)$ is the domain of $f$.

**计算的复杂度理论 / Complexity Theory of Computation:**

**定义 1.3.5** 计算复杂度类：
Computational complexity classes:

- **P类**：多项式时间可计算函数
- **P class**: Functions computable in polynomial time
$$\text{P} = \{f : \exists \text{图灵机 } M, \exists k \in \mathbb{N}: T_M(x) = O(|x|^k)\}$$

- **NP类**：非确定性多项式时间可验证函数
- **NP class**: Functions verifiable in non-deterministic polynomial time
$$\text{NP} = \{f : \exists \text{非确定性图灵机 } M, \exists k \in \mathbb{N}: T_M(x) = O(|x|^k)\}$$

**丘奇-图灵论题 / Church-Turing Thesis:**

**论题 1.3.1** (丘奇-图灵论题) 函数是可计算的当且仅当它是图灵可计算的。
**Thesis 1.3.1** (Church-Turing Thesis) A function is computable if and only if it is Turing computable.

**形式化表述：**
$$\text{Computable}(f) \Leftrightarrow \exists \text{图灵机 } M: \forall x \in \text{dom}(f), M(x) = f(x)$$

**计算的理论模型 / Theoretical Models of Computation:**

1. **图灵机模型 / Turing Machine Model**
2. **λ演算模型 / Lambda Calculus Model**
3. **递归函数模型 / Recursive Function Model**
4. **组合子逻辑模型 / Combinatory Logic Model**
5. **量子计算模型 / Quantum Computation Model**

**定理 1.3.1** (计算模型等价性) 上述所有计算模型在可计算性方面都是等价的。
**Theorem 1.3.1** (Equivalence of Computation Models) All the above computation models are equivalent in terms of computability.

---

## 2. 形式化语言 / Formal Language

### 2.1 字母表 / Alphabet

**定义 2.1.1** 字母表是一个有限的符号集合。
**Definition 2.1.1** An alphabet is a finite set of symbols.

**公理化定义 / Axiomatic Definition:**
$$\Sigma = \{a_1, a_2, \ldots, a_n\}$$

其中 $n \in \mathbb{N}$ 且 $n > 0$。
where $n \in \mathbb{N}$ and $n > 0$.

**字母表的代数结构 / Algebraic Structure of Alphabet:**

字母表 $\Sigma$ 上的自由幺半群：
Free monoid over alphabet $\Sigma$:
$$(\Sigma^*, \cdot, \epsilon)$$

其中 $\cdot$ 是字符串连接操作，$\epsilon$ 是单位元。
where $\cdot$ is string concatenation and $\epsilon$ is the identity element.

### 2.2 字符串 / String

**定义 2.2.1** 字符串是字母表中符号的有限序列。
**Definition 2.2.1** A string is a finite sequence of symbols from an alphabet.

**形式化定义 / Formal Definition:**
$$\Sigma^* = \bigcup_{i=0}^{\infty} \Sigma^i$$

其中 $\Sigma^0 = \{\epsilon\}$，$\epsilon$ 为空字符串。
where $\Sigma^0 = \{\epsilon\}$ and $\epsilon$ is the empty string.

**字符串的代数性质 / Algebraic Properties of Strings:**

**定理 2.2.1** $(\Sigma^*, \cdot, \epsilon)$ 构成一个幺半群。
**Theorem 2.2.1** $(\Sigma^*, \cdot, \epsilon)$ forms a monoid.

**证明 / Proof:**

1. **结合律 / Associativity**: $(u \cdot v) \cdot w = u \cdot (v \cdot w)$
2. **单位元 / Identity**: $\epsilon \cdot u = u \cdot \epsilon = u$

**字符串的长度函数 / Length Function of Strings:**

**定义 2.2.2** 长度函数：
Length function:
$$|\cdot|: \Sigma^* \rightarrow \mathbb{N}$$

递归定义：
Recursively defined:

- $|\epsilon| = 0$
- $|a \cdot w| = 1 + |w|$，其中 $a \in \Sigma, w \in \Sigma^*$

### 2.3 语言 / Language

**定义 2.3.1** 语言是字符串集合的子集。
**Definition 2.3.1** A language is a subset of the string set.

**形式化表示 / Formal Representation:**
$$L \subseteq \Sigma^*$$

**语言的代数运算 / Algebraic Operations on Languages:**

**定义 2.3.2** 语言连接：
Language concatenation:
$$L_1 \cdot L_2 = \{w_1 \cdot w_2 : w_1 \in L_1, w_2 \in L_2\}$$

**定义 2.3.3** 语言幂运算：
Language power:
$$L^0 = \{\epsilon\}$$
$$L^{n+1} = L \cdot L^n$$

**定义 2.3.4** 克林闭包：
Kleene closure:
$$L^* = \bigcup_{i=0}^{\infty} L^i$$

**定义 2.3.5** 正闭包：
Positive closure:
$$L^+ = \bigcup_{i=1}^{\infty} L^i$$

**语言的布尔运算 / Boolean Operations on Languages:**

**定义 2.3.6** 语言并集：
Language union:
$$L_1 \cup L_2 = \{w : w \in L_1 \text{ or } w \in L_2\}$$

**定义 2.3.7** 语言交集：
Language intersection:
$$L_1 \cap L_2 = \{w : w \in L_1 \text{ and } w \in L_2\}$$

**定义 2.3.8** 语言补集：
Language complement:
$$\overline{L} = \Sigma^* \setminus L$$

**定理 2.3.1** 语言在布尔运算下构成布尔代数。
**Theorem 2.3.1** Languages form a Boolean algebra under Boolean operations.

**证明 / Proof:**
通过验证布尔代数的所有公理。
By verifying all axioms of Boolean algebra.

---

## 3. 算法定义 / Algorithm Definition

### 3.1 图灵机模型 / Turing Machine Model

**定义 3.1.1** 图灵机是一个七元组：
**Definition 3.1.1** A Turing machine is a 7-tuple:
$$M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$$

其中 / where:

- $Q$：有限状态集 / Finite set of states
- $\Sigma$：输入字母表 / Input alphabet
- $\Gamma$：带字母表 / Tape alphabet ($\Sigma \subseteq \Gamma$)
- $\delta$：转移函数 / Transition function
- $q_0 \in Q$：初始状态 / Initial state
- $B \in \Gamma \setminus \Sigma$：空白符号 / Blank symbol
- $F \subseteq Q$：接受状态集 / Set of accepting states

**图灵机的配置 / Configuration of Turing Machine:**

**定义 3.1.2** 瞬时描述（配置）：
Instantaneous description (configuration):
$$C = (q, w, u)$$

其中：
where:

- $q \in Q$：当前状态 / Current state
- $w \in \Gamma^*$：读写头左侧的磁带内容 / Tape content to the left of head
- $u \in \Gamma^*$：读写头位置及右侧的磁带内容 / Tape content at and to the right of head

**图灵机的初始配置 / Initial Configuration:**

**定义 3.1.3** 对于输入 $x = x_1 x_2 \ldots x_n \in \Sigma^*$，初始配置为：
For input $x = x_1 x_2 \ldots x_n \in \Sigma^*$, the initial configuration is:
$$C_0 = (q_0, \epsilon, x_1 x_2 \ldots x_n)$$

### 3.2 转移函数 / Transition Function

**定义 3.2.1** 转移函数定义了图灵机的计算规则：
**Definition 3.2.1** The transition function defines the computation rules of a Turing machine:
$$\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R, N\}$$

其中 $L$、$R$、$N$ 分别表示左移、右移和不动。
where $L$, $R$, $N$ represent left move, right move, and no move respectively.

**转移函数的语义 / Semantics of Transition Function:**

**定义 3.2.2** 配置转移关系：
Configuration transition relation:
$$(q, w, u) \vdash_M (q', w', u')$$

当且仅当 $\delta(q, u_1) = (q', b, D)$ 且：
if and only if $\delta(q, u_1) = (q', b, D)$ and:

1. **左移情况 / Left Move Case** ($D = L$):
   - $w' = w_{|w|-1}$（移除最后一个符号）
   - $u' = w_{|w|} \cdot b \cdot u_{2:}$（将最后一个符号移到读写头位置）

2. **右移情况 / Right Move Case** ($D = R$):
   - $w' = w \cdot b$（将新符号添加到左侧）
   - $u' = u_{2:}$（移除读写头位置的符号）

3. **不动情况 / No Move Case** ($D = N$):
   - $w' = w$（左侧不变）
   - $u' = b \cdot u_{2:}$（替换读写头位置的符号）

其中 $u_1$ 是 $u$ 的第一个符号，$u_{2:}$ 是 $u$ 的剩余部分。
where $u_1$ is the first symbol of $u$ and $u_{2:}$ is the remaining part of $u$.

### 3.3 计算过程 / Computation Process

**定义 3.3.1** 图灵机的计算过程是配置序列：
**Definition 3.3.1** The computation process of a Turing machine is a sequence of configurations:
$$C_0 \vdash_M C_1 \vdash_M C_2 \vdash_M \cdots \vdash_M C_n$$

其中每个配置 $C_i$ 包含当前状态、带内容和读写头位置。
where each configuration $C_i$ contains the current state, tape content, and read-write head position.

**多步转移 / Multi-step Transition:**

**定义 3.3.2** 多步转移关系：
Multi-step transition relation:
$$\vdash_M^* = \text{自反传递闭包}(\vdash_M)$$

**定义 3.3.3** 恰好 $k$ 步转移：
Exactly $k$ steps transition:
$$\vdash_M^k = \underbrace{\vdash_M \circ \vdash_M \circ \cdots \circ \vdash_M}_{k \text{ times}}$$

**图灵机的计算结果 / Computation Result of Turing Machine:**

**定义 3.3.4** 图灵机 $M$ 在输入 $x$ 上的计算：
Computation of Turing machine $M$ on input $x$:
$$
M(x) = \begin{cases}
\text{accept} & \text{if } (q_0, \epsilon, x) \vdash_M^* (q_f, w, u) \text{ for some } q_f \in F \\
\text{reject} & \text{if } (q_0, \epsilon, x) \vdash_M^* (q_f, w, u) \text{ for some } q_f \in Q \setminus F \\
\text{loop} & \text{otherwise (infinite computation)}
\end{cases}
$$

**图灵机的语言识别 / Language Recognition by Turing Machine:**

**定义 3.3.5** 图灵机 $M$ 识别的语言：
Language recognized by Turing machine $M$:
$$L(M) = \{x \in \Sigma^* : M(x) = \text{accept}\}$$

**定理 3.3.1** (图灵机的计算能力) 图灵机可以计算任何可计算函数。
**Theorem 3.3.1** (Computational Power of Turing Machine) Turing machines can compute any computable function.

**证明 / Proof:**
通过构造性证明，展示如何用图灵机模拟其他计算模型。
By constructive proof, showing how to simulate other computation models using Turing machines.

---

## 4. 计算模型 / Computation Models

### 4.1 递归函数 / Recursive Functions

**定义 4.1.1** 递归函数是通过基本函数和构造规则定义的函数类。
**Definition 4.1.1** Recursive functions are function classes defined through basic functions and construction rules.

**基本函数 / Basic Functions:**

**定义 4.1.2** 基本递归函数：
Basic recursive functions:

1. **零函数 / Zero Function**: $Z: \mathbb{N} \rightarrow \mathbb{N}$, $Z(x) = 0$
2. **后继函数 / Successor Function**: $S: \mathbb{N} \rightarrow \mathbb{N}$, $S(x) = x + 1$
3. **投影函数 / Projection Function**: $P_i^n: \mathbb{N}^n \rightarrow \mathbb{N}$, $P_i^n(x_1, \ldots, x_n) = x_i$

**函数构造规则 / Function Construction Rules:**

**定义 4.1.3** 函数复合：
Function composition:
如果 $g: \mathbb{N}^m \rightarrow \mathbb{N}$ 和 $h_1, \ldots, h_m: \mathbb{N}^n \rightarrow \mathbb{N}$，则：
If $g: \mathbb{N}^m \rightarrow \mathbb{N}$ and $h_1, \ldots, h_m: \mathbb{N}^n \rightarrow \mathbb{N}$, then:
$$f(\vec{x}) = g(h_1(\vec{x}), \ldots, h_m(\vec{x}))$$

**定义 4.1.4** 原始递归：
Primitive recursion:
如果 $g: \mathbb{N}^n \rightarrow \mathbb{N}$ 和 $h: \mathbb{N}^{n+2} \rightarrow \mathbb{N}$，则：
If $g: \mathbb{N}^n \rightarrow \mathbb{N}$ and $h: \mathbb{N}^{n+2} \rightarrow \mathbb{N}$, then:
$$f(0, \vec{x}) = g(\vec{x})$$
$$f(n+1, \vec{x}) = h(n, \vec{x}, f(n, \vec{x}))$$

### 4.2 原始递归 / Primitive Recursion

**定义 4.2.1** 原始递归是通过以下模式构造的函数：
**Definition 4.2.1** Primitive recursion constructs functions through the following pattern:
$$f(0, \vec{x}) = g(\vec{x})$$
$$f(n+1, \vec{x}) = h(n, \vec{x}, f(n, \vec{x}))$$

其中 $g$ 和 $h$ 是已知函数。
where $g$ and $h$ are known functions.

**原始递归函数的性质 / Properties of Primitive Recursive Functions:**

**定理 4.2.1** 原始递归函数是全域的（对所有输入都有定义）。
**Theorem 4.2.1** Primitive recursive functions are total (defined for all inputs).

**证明 / Proof:**
通过对递归深度进行数学归纳。
By mathematical induction on the recursion depth.

**定理 4.2.2** 原始递归函数是可计算的。
**Theorem 4.2.2** Primitive recursive functions are computable.

**证明 / Proof:**
通过构造图灵机来模拟原始递归计算。
By constructing Turing machines to simulate primitive recursive computation.

**原始递归函数的例子 / Examples of Primitive Recursive Functions:**

**例 4.2.1** 加法函数：
Addition function:
$$\text{add}(0, y) = y$$
$$\text{add}(x+1, y) = S(\text{add}(x, y))$$

**例 4.2.2** 乘法函数：
Multiplication function:
$$\text{mult}(0, y) = 0$$
$$\text{mult}(x+1, y) = \text{add}(\text{mult}(x, y), y)$$

**例 4.2.3** 指数函数：
Exponentiation function:
$$\text{exp}(0, y) = 1$$
$$\text{exp}(x+1, y) = \text{mult}(\text{exp}(x, y), y)$$

### 4.3 μ-递归 / μ-Recursion

**定义 4.3.1** μ-递归函数通过最小化算子定义：
**Definition 4.3.1** μ-recursive functions are defined through the minimization operator:
$$f(\vec{x}) = \mu y[g(\vec{x}, y) = 0]$$

表示最小的 $y$ 使得 $g(\vec{x}, y) = 0$。
represents the smallest $y$ such that $g(\vec{x}, y) = 0$.

**最小化算子的严格定义 / Strict Definition of Minimization Operator:**

**定义 4.3.2** 对于函数 $g: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$，最小化算子定义为：
For function $g: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$, the minimization operator is defined as:
$$
f(\vec{x}) = \mu y[g(\vec{x}, y) = 0] = \begin{cases}
\min\{y : g(\vec{x}, y) = 0\} & \text{if such } y \text{ exists} \\
\text{undefined} & \text{otherwise}
\end{cases}
$$

**μ-递归函数的性质 / Properties of μ-Recursive Functions:**

**定理 4.3.1** μ-递归函数可能是部分函数（不是全域的）。
**Theorem 4.3.1** μ-recursive functions may be partial (not total).

**证明 / Proof:**
通过构造例子，如阿克曼函数的逆函数。
By constructing examples, such as the inverse of the Ackermann function.

**定理 4.3.2** (克莱尼定理) 函数是递归的当且仅当它是μ-递归的。
**Theorem 4.3.2** (Kleene's Theorem) A function is recursive if and only if it is μ-recursive.

**证明 / Proof:**
通过展示μ-递归函数与图灵可计算函数的等价性。
By showing the equivalence between μ-recursive functions and Turing computable functions.

**μ-递归函数的例子 / Examples of μ-Recursive Functions:**

**例 4.3.1** 减法函数：
Subtraction function:
$$\text{sub}(x, y) = \mu z[\text{add}(y, z) = x]$$

**例 4.3.2** 整数除法：
Integer division:
$$\text{div}(x, y) = \mu z[\text{mult}(y, z) \geq x]$$

**例 4.3.3** 平方根：
Square root:
$$\text{sqrt}(x) = \mu y[\text{mult}(y, y) \geq x]$$

**递归函数的层次结构 / Hierarchy of Recursive Functions:**

**定义 4.3.3** 递归函数层次：
Recursive function hierarchy:

1. **基本函数 / Basic Functions**: $Z, S, P_i^n$
2. **原始递归函数 / Primitive Recursive Functions**: 通过复合和原始递归构造
3. **μ-递归函数 / μ-Recursive Functions**: 通过最小化算子构造
4. **一般递归函数 / General Recursive Functions**: 等价于μ-递归函数

**定理 4.3.3** (递归函数完备性) 所有可计算函数都是μ-递归的。
**Theorem 4.3.3** (Completeness of Recursive Functions) All computable functions are μ-recursive.

**证明 / Proof:**
通过丘奇-图灵论题和克莱尼定理。
By Church-Turing thesis and Kleene's theorem.

---

## 5. 形式化系统 / Formal Systems

### 5.1 公理系统 / Axiomatic System

**定义 5.1.1** 公理系统由公理集合和推理规则组成。
**Definition 5.1.1** An axiomatic system consists of a set of axioms and inference rules.

**公理系统的严格定义 / Strict Definition of Axiomatic System:**

**定义 5.1.2** 公理系统是一个三元组：
An axiomatic system is a triple:
$$\mathcal{A} = (\mathcal{L}, \mathcal{A}, \mathcal{R})$$

其中 / where:

- $\mathcal{L}$：形式语言 / Formal language
- $\mathcal{A}$：公理集合 / Set of axioms
- $\mathcal{R}$：推理规则集合 / Set of inference rules

**公理 / Axioms:**
公理是不需要证明的基本命题。
Axioms are basic propositions that do not require proof.

**公理的形式化定义 / Formal Definition of Axioms:**

**定义 5.1.3** 公理是形式语言中的合式公式，具有以下性质：
An axiom is a well-formed formula in the formal language with the following properties:

1. **自明性 / Self-evidence**: 公理在语义上是显然为真的
2. **独立性 / Independence**: 公理不能从其他公理推导出来
3. **完备性 / Completeness**: 公理集合足够推导出所有真命题

**推理规则 / Inference Rules:**
推理规则是从已知命题推导新命题的规则。
Inference rules are rules for deriving new propositions from known propositions.

**推理规则的形式化定义 / Formal Definition of Inference Rules:**

**定义 5.1.4** 推理规则是一个函数：
An inference rule is a function:
$$R: \mathcal{P}(\text{Formula}) \rightarrow \mathcal{P}(\text{Formula})$$

其中 $\text{Formula}$ 是合式公式集合。
where $\text{Formula}$ is the set of well-formed formulas.

**常见的推理规则 / Common Inference Rules:**

1. **假言推理 / Modus Ponens**:
   $$\frac{\phi \rightarrow \psi \quad \phi}{\psi}$$

2. **假言三段论 / Hypothetical Syllogism**:
   $$\frac{\phi \rightarrow \psi \quad \psi \rightarrow \chi}{\phi \rightarrow \chi}$$

3. **析取三段论 / Disjunctive Syllogism**:
   $$\frac{\phi \lor \psi \quad \neg\phi}{\psi}$$

### 5.2 证明 / Proof

**定义 5.2.1** 证明是从公理到目标命题的有限推理序列。
**Definition 5.2.1** A proof is a finite sequence of inferences from axioms to the target proposition.

**证明的严格定义 / Strict Definition of Proof:**

**定义 5.2.2** 证明是一个有限序列：
A proof is a finite sequence:
$$\pi = (\phi_1, \phi_2, \ldots, \phi_n)$$

其中每个 $\phi_i$ 要么是公理，要么是通过推理规则从前面的公式推导出来的。
where each $\phi_i$ is either an axiom or derived from previous formulas by inference rules.

**证明结构 / Proof Structure:**
$$A_1, A_2, \ldots, A_n \vdash B$$

其中 $A_i$ 是公理或已证明的命题，$B$ 是目标命题。
where $A_i$ are axioms or proven propositions, and $B$ is the target proposition.

**证明的元理论性质 / Metatheoretical Properties of Proofs:**

**定理 5.2.1** (演绎定理) 如果 $\Gamma \cup \{\phi\} \vdash \psi$，则 $\Gamma \vdash \phi \rightarrow \psi$。
**Theorem 5.2.1** (Deduction Theorem) If $\Gamma \cup \{\phi\} \vdash \psi$, then $\Gamma \vdash \phi \rightarrow \psi$.

**证明 / Proof:**
通过对证明长度的归纳。
By induction on the length of the proof.

**定理 5.2.2** (反证法) 如果 $\Gamma \cup \{\neg\phi\} \vdash \bot$，则 $\Gamma \vdash \phi$。
**Theorem 5.2.2** (Proof by Contradiction) If $\Gamma \cup \{\neg\phi\} \vdash \bot$, then $\Gamma \vdash \phi$.

**证明 / Proof:**
通过演绎定理和否定引入规则。
By deduction theorem and negation introduction rule.

### 5.3 一致性 / Consistency

**定义 5.3.1** 形式化系统是一致的，当且仅当不存在命题 $P$ 使得 $P$ 和 $\neg P$ 都可证明。
**Definition 5.3.1** A formal system is consistent if and only if there does not exist a proposition $P$ such that both $P$ and $\neg P$ can be proven.

**一致性的形式化定义 / Formal Definition of Consistency:**

**定义 5.3.2** 理论 $\Gamma$ 是一致的：
Theory $\Gamma$ is consistent:
$$\text{Consistent}(\Gamma) \Leftrightarrow \neg \exists \phi: \Gamma \vdash \phi \land \Gamma \vdash \neg\phi$$

**数学表示 / Mathematical Representation:**
$$\neg \exists P: \vdash P \land \vdash \neg P$$

**一致性的等价定义 / Equivalent Definitions of Consistency:**

**定理 5.3.1** 以下陈述等价：
**Theorem 5.3.1** The following statements are equivalent:

1. $\Gamma$ 是一致的
2. 存在公式 $\phi$ 使得 $\Gamma \not\vdash \phi$
3. 不存在公式 $\phi$ 使得 $\Gamma \vdash \phi \land \neg\phi$
4. $\Gamma \not\vdash \bot$

**证明 / Proof:**
通过逻辑等价性和爆炸原理。
By logical equivalence and explosion principle.

**一致性的保持 / Preservation of Consistency:**

**定理 5.3.2** 如果 $\Gamma$ 是一致的且 $\Gamma \not\vdash \neg\phi$，则 $\Gamma \cup \{\phi\}$ 也是一致的。
**Theorem 5.3.2** If $\Gamma$ is consistent and $\Gamma \not\vdash \neg\phi$, then $\Gamma \cup \{\phi\}$ is also consistent.

**证明 / Proof:**
通过反证法，假设 $\Gamma \cup \{\phi\}$ 不一致，则 $\Gamma \vdash \neg\phi$，矛盾。
By contradiction, assuming $\Gamma \cup \{\phi\}$ is inconsistent, then $\Gamma \vdash \neg\phi$, contradiction.

**最大一致集 / Maximal Consistent Sets:**

**定义 5.3.3** 理论 $\Gamma$ 是最大一致的，当且仅当：
Theory $\Gamma$ is maximally consistent if and only if:

1. $\Gamma$ 是一致的
2. 对于任何公式 $\phi$，要么 $\phi \in \Gamma$，要么 $\neg\phi \in \Gamma$

**定理 5.3.3** (林登鲍姆引理) 任何一致的理论都可以扩展为最大一致理论。
**Theorem 5.3.3** (Lindenbaum's Lemma) Any consistent theory can be extended to a maximally consistent theory.

**证明 / Proof:**
通过佐恩引理和递归构造。
By Zorn's lemma and recursive construction.

---

## 6. 参考文献 / References

### 经典文献 / Classical References

   1. **Turing, A.M.** (1936). "On Computable Numbers, with an Application to the Entscheidungsproblem". *Proceedings of the London Mathematical Society*, 42(2), 230-265.
   2. **Church, A.** (1936). "An Unsolvable Problem of Elementary Number Theory". *American Journal of Mathematics*, 58(2), 345-363.
   3. **Gödel, K.** (1931). "Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme I". *Monatshefte für Mathematik und Physik*, 38(1), 173-198.
   4. **Kleene, S.C.** (1952). *Introduction to Metamathematics*. North-Holland Publishing Company.
   5. **Post, E.L.** (1944). "Recursively Enumerable Sets of Positive Integers and Their Decision Problems". *Bulletin of the American Mathematical Society*, 50(5), 284-316.

### 现代教材 / Modern Textbooks

   1. **Hopcroft, J.E., Ullman, J.D.** (1979). *Introduction to Automata Theory, Languages, and Computation*. Addison-Wesley.
   2. **Sipser, M.** (2012). *Introduction to the Theory of Computation*. Cengage Learning.
   3. **Boolos, G.S., Burgess, J.P., Jeffrey, R.C.** (2007). *Computability and Logic*. Cambridge University Press.
   4. **Enderton, H.B.** (2001). *A Mathematical Introduction to Logic*. Academic Press.
   5. **Shapiro, S.** (2000). *Foundations without Foundationalism: A Case for Second-Order Logic*. Oxford University Press.

### 形式化系统 / Formal Systems

   1. **Gentzen, G.** (1935). "Untersuchungen über das logische Schließen". *Mathematische Zeitschrift*, 39(1), 176-210.
   2. **Hilbert, D., Bernays, P.** (1934). *Grundlagen der Mathematik*. Springer-Verlag.
   3. **Tarski, A.** (1936). "Der Wahrheitsbegriff in den formalisierten Sprachen". *Studia Philosophica*, 1, 261-405.
   4. **Smullyan, R.M.** (1968). *First-Order Logic*. Springer-Verlag.
   5. **Prawitz, D.** (1965). *Natural Deduction: A Proof-Theoretical Study*. Almqvist & Wiksell.

### 计算理论 / Computation Theory

   1. **Davis, M.** (1958). *Computability and Unsolvability*. McGraw-Hill.
   2. **Rogers, H.** (1967). *Theory of Recursive Functions and Effective Computability*. McGraw-Hill.
   3. **Odifreddi, P.** (1989). *Classical Recursion Theory*. North-Holland.
   4. **Soare, R.I.** (2016). *Turing Computability: Theory and Applications*. Springer.
   5. **Cooper, S.B.** (2004). *Computability Theory*. Chapman & Hall/CRC.

### 类型理论 / Type Theory

   1. **Martin-Löf, P.** (1984). *Intuitionistic Type Theory*. Bibliopolis.
   2. **Pierce, B.C.** (2002). *Types and Programming Languages*. MIT Press.
   3. **Thompson, S.** (1991). *Type Theory and Functional Programming*. Addison-Wesley.
   4. **Barendregt, H.P.** (1984). *The Lambda Calculus: Its Syntax and Semantics*. North-Holland.
   5. **Cardelli, L., Wegner, P.** (1985). "On Understanding Types, Data Abstraction, and Polymorphism". *ACM Computing Surveys*, 17(4), 471-522.

### 逻辑系统 / Logical Systems

   1. **Girard, J.Y., Lafont, Y., Taylor, P.** (1989). *Proofs and Types*. Cambridge University Press.
   2. **Troelstra, A.S., Schwichtenberg, H.** (2000). *Basic Proof Theory*. Cambridge University Press.
   3. **van Dalen, D.** (2013). *Logic and Structure*. Springer.
   4. **Hodges, W.** (1997). *A Shorter Model Theory*. Cambridge University Press.
   5. **Chang, C.C., Keisler, H.J.** (1990). *Model Theory*. North-Holland.

### 在线资源 / Online Resources

   1. **Stanford Encyclopedia of Philosophy**: [Formal Systems](https://plato.stanford.edu/entries/formal-systems/)
   2. **Wikipedia**: [Turing Machine](https://en.wikipedia.org/wiki/Turing_machine)
   3. **nLab**: [Type Theory](https://ncatlab.org/nlab/show/type+theory)
   4. **ProofWiki**: [Mathematical Proofs](https://proofwiki.org/)
   5. **Coq Documentation**: [The Coq Proof Assistant](https://coq.inria.fr/documentation)

### 国际标准 / International Standards

   1. **ISO/IEC 2382-1**: Information technology — Vocabulary — Part 1: Fundamental terms
   2. **IEEE 754**: Standard for Floating-Point Arithmetic
   3. **RFC 2119**: Key words for use in RFCs to Indicate Requirement Levels
   4. **W3C**: Web Ontology Language (OWL) Specification
   5. **OMG**: Unified Modeling Language (UML) Specification
