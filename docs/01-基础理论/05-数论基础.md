# 数论基础 / Number Theory Fundamentals

## 目录 (Table of Contents)

- [数论基础 / Number Theory Fundamentals](#数论基础--number-theory-fundamentals)
  - [目录 (Table of Contents)](#目录-table-of-contents)
  - [概述 / Overview](#概述--overview)
  - [基本概念 / Basic Concepts](#基本概念--basic-concepts)
    - [整数与整除 / Integers and Divisibility](#整数与整除--integers-and-divisibility)
    - [最大公约数与最小公倍数 / Greatest Common Divisor and Least Common Multiple](#最大公约数与最小公倍数--greatest-common-divisor-and-least-common-multiple)
  - [同余理论 / Congruence Theory](#同余理论--congruence-theory)
    - [1基本概念 / Basic Concepts](#1基本概念--basic-concepts)
    - [线性同余方程 / Linear Congruence Equations](#线性同余方程--linear-congruence-equations)
  - [素数理论 / Prime Number Theory](#素数理论--prime-number-theory)
    - [2基本概念 / Basic Concepts](#2基本概念--basic-concepts)
    - [欧拉函数 / Euler's Totient Function](#欧拉函数--eulers-totient-function)
  - [数论函数 / Number Theoretic Functions](#数论函数--number-theoretic-functions)
    - [基本数论函数 / Basic Number Theoretic Functions](#基本数论函数--basic-number-theoretic-functions)
  - [应用示例 / Applications](#应用示例--applications)
    - [密码学应用 / Cryptographic Applications](#密码学应用--cryptographic-applications)
    - [算法优化应用 / Algorithm Optimization Applications](#算法优化应用--algorithm-optimization-applications)
  - [总结 / Summary](#总结--summary)
  - [术语对照表 / Terminology Reference](#术语对照表--terminology-reference)
  - [练习与习题 / Exercises and Problems](#练习与习题--exercises-and-problems)
    - [基础练习 / Basic Exercises](#基础练习--basic-exercises)
    - [进阶练习 / Advanced Exercises](#进阶练习--advanced-exercises)
    - [编程练习 / Programming Exercises](#编程练习--programming-exercises)
    - [应用练习 / Application Exercises](#应用练习--application-exercises)
  - [参考文献 / References](#参考文献--references)

## 概述 / Overview

数论是研究整数性质的数学分支，在算法理论中具有重要地位。本文档介绍数论的基本概念、定理和算法应用。

Number theory is the branch of mathematics that studies the properties of integers, playing a crucial role in algorithm theory. This document introduces the fundamental concepts, theorems, and algorithmic applications of number theory.

## 基本概念 / Basic Concepts

### 整数与整除 / Integers and Divisibility

**定义 1.1 (整除)** / **Definition 1.1 (Divisibility)**
设 $a, b \in \mathbb{Z}$，如果存在 $q \in \mathbb{Z}$ 使得 $b = aq$，则称 $a$ 整除 $b$，记作 $a \mid b$。

Let $a, b \in \mathbb{Z}$. If there exists $q \in \mathbb{Z}$ such that $b = aq$, then we say that $a$ divides $b$, denoted by $a \mid b$.

**性质 1.1 (整除的基本性质)** / **Properties 1.1 (Basic Properties of Divisibility)**

1. 如果 $a \mid b$ 且 $b \mid c$，则 $a \mid c$ (传递性)
2. 如果 $a \mid b$ 且 $a \mid c$，则 $a \mid (bx + cy)$ 对所有 $x, y \in \mathbb{Z}$
3. 如果 $a \mid b$ 且 $b \mid a$，则 $a = \pm b$

   1. If $a \mid b$ and $b \mid c$, then $a \mid c$ (transitivity)
   2. If $a \mid b$ and $a \mid c$, then $a \mid (bx + cy)$ for all $x, y \in \mathbb{Z}$
   3. If $a \mid b$ and $b \mid a$, then $a = \pm b$

### 最大公约数与最小公倍数 / Greatest Common Divisor and Least Common Multiple

**定义 1.2 (最大公约数)** / **Definition 1.2 (Greatest Common Divisor)**
设 $a, b \in \mathbb{Z}$，不全为零。$a$ 和 $b$ 的最大公约数 $\gcd(a, b)$ 是满足以下条件的正整数 $d$：

1. $d \mid a$ 且 $d \mid b$
2. 如果 $c \mid a$ 且 $c \mid b$，则 $c \mid d$

Let $a, b \in \mathbb{Z}$, not both zero. The greatest common divisor $\gcd(a, b)$ is the positive integer $d$ satisfying:

1. $d \mid a$ and $d \mid b$
2. If $c \mid a$ and $c \mid b$, then $c \mid d$

**定理 1.1 (欧几里得算法)** / **Theorem 1.1 (Euclidean Algorithm)**
对于任意 $a, b \in \mathbb{Z}$，有 $\gcd(a, b) = \gcd(b, a \bmod b)$。

For any $a, b \in \mathbb{Z}$, we have $\gcd(a, b) = \gcd(b, a \bmod b)$.

**算法 1.1 (欧几里得算法)** / **Algorithm 1.1 (Euclidean Algorithm)**

```rust
/// 计算两个整数的最大公约数
/// Calculate the greatest common divisor of two integers
pub fn gcd(mut a: i64, mut b: i64) -> i64 {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a.abs()
}

/// 扩展欧几里得算法，计算 Bézout 系数
/// Extended Euclidean algorithm to compute Bézout coefficients
pub fn extended_gcd(a: i64, b: i64) -> (i64, i64, i64) {
    if b == 0 {
        (a, 1, 0)
    } else {
        let (gcd, x, y) = extended_gcd(b, a % b);
        (gcd, y, x - (a / b) * y)
    }
}

/// 计算最小公倍数
/// Calculate the least common multiple
pub fn lcm(a: i64, b: i64) -> i64 {
    (a * b).abs() / gcd(a, b)
}
```

## 同余理论 / Congruence Theory

### 1基本概念 / Basic Concepts

**定义 2.1 (同余)** / **Definition 2.1 (Congruence)**
设 $a, b, m \in \mathbb{Z}$，$m > 0$。如果 $m \mid (a - b)$，则称 $a$ 与 $b$ 模 $m$ 同余，记作 $a \equiv b \pmod{m}$。

Let $a, b, m \in \mathbb{Z}$, $m > 0$. If $m \mid (a - b)$, then we say that $a$ is congruent to $b$ modulo $m$, denoted by $a \equiv b \pmod{m}$.

**性质 2.1 (同余的基本性质)** / **Properties 2.1 (Basic Properties of Congruence)**

1. 自反性：$a \equiv a \pmod{m}$
2. 对称性：如果 $a \equiv b \pmod{m}$，则 $b \equiv a \pmod{m}$
3. 传递性：如果 $a \equiv b \pmod{m}$ 且 $b \equiv c \pmod{m}$，则 $a \equiv c \pmod{m}$
4. 如果 $a \equiv b \pmod{m}$ 且 $c \equiv d \pmod{m}$，则：
   - $a + c \equiv b + d \pmod{m}$
   - $a - c \equiv b - d \pmod{m}$
   - $ac \equiv bd \pmod{m}$

   1. Reflexivity: $a \equiv a \pmod{m}$
   2. Symmetry: If $a \equiv b \pmod{m}$, then $b \equiv a \pmod{m}$
   3. Transitivity: If $a \equiv b \pmod{m}$ and $b \equiv c \pmod{m}$, then $a \equiv c \pmod{m}$
   4. If $a \equiv b \pmod{m}$ and $c \equiv d \pmod{m}$, then:
      - $a + c \equiv b + d \pmod{m}$
      - $a - c \equiv b - d \pmod{m}$
      - $ac \equiv bd \pmod{m}$

### 线性同余方程 / Linear Congruence Equations

**定义 2.2 (线性同余方程)** / **Definition 2.2 (Linear Congruence Equation)**
形如 $ax \equiv b \pmod{m}$ 的方程称为线性同余方程。

An equation of the form $ax \equiv b \pmod{m}$ is called a linear congruence equation.

**定理 2.1 (线性同余方程的解)** / **Theorem 2.1 (Solution of Linear Congruence)**
线性同余方程 $ax \equiv b \pmod{m}$ 有解的充分必要条件是 $\gcd(a, m) \mid b$。

The linear congruence equation $ax \equiv b \pmod{m}$ has a solution if and only if $\gcd(a, m) \mid b$.

**算法 2.1 (求解线性同余方程)** / **Algorithm 2.1 (Solving Linear Congruence)**

```rust
/// 求解线性同余方程 ax ≡ b (mod m)
/// Solve linear congruence equation ax ≡ b (mod m)
pub fn solve_linear_congruence(a: i64, b: i64, m: i64) -> Option<Vec<i64>> {
    let (gcd, x, _) = extended_gcd(a, m);
    
    if b % gcd != 0 {
        return None; // 无解
    }
    
    let x0 = (x * (b / gcd)) % m;
    let solutions: Vec<i64> = (0..gcd)
        .map(|k| (x0 + k * (m / gcd)) % m)
        .collect();
    
    Some(solutions)
}

/// 中国剩余定理
/// Chinese Remainder Theorem
pub fn chinese_remainder_theorem(remainders: &[i64], moduli: &[i64]) -> Option<i64> {
    if remainders.len() != moduli.len() {
        return None;
    }
    
    let mut result = 0;
    let mut product = 1;
    
    // 计算所有模数的乘积
    for &m in moduli {
        product *= m;
    }
    
    for i in 0..remainders.len() {
        let pi = product / moduli[i];
        let (_, inv, _) = extended_gcd(pi, moduli[i]);
        result = (result + remainders[i] * pi * inv) % product;
    }
    
    Some((result + product) % product)
}
```

## 素数理论 / Prime Number Theory

### 2基本概念 / Basic Concepts

**定义 3.1 (素数)** / **Definition 3.1 (Prime Number)**
大于1的整数 $p$ 称为素数，如果 $p$ 的正因子只有1和 $p$ 本身。

An integer $p > 1$ is called a prime number if its only positive divisors are 1 and $p$ itself.

**定理 3.1 (算术基本定理)** / **Theorem 3.1 (Fundamental Theorem of Arithmetic)**
每个大于1的整数都可以唯一地表示为素数的乘积（不计因子的顺序）。

Every integer greater than 1 can be uniquely represented as a product of primes (up to the order of factors).

**算法 3.1 (素数判定)** / **Algorithm 3.1 (Prime Testing)**

```rust
/// 判断一个数是否为素数
/// Determine if a number is prime
pub fn is_prime(n: u64) -> bool {
    if n < 2 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    
    let sqrt_n = (n as f64).sqrt() as u64;
    for i in (3..=sqrt_n).step_by(2) {
        if n % i == 0 {
            return false;
        }
    }
    true
}

/// 埃拉托斯特尼筛法
/// Sieve of Eratosthenes
pub fn sieve_of_eratosthenes(n: usize) -> Vec<bool> {
    let mut is_prime = vec![true; n + 1];
    is_prime[0] = false;
    is_prime[1] = false;
    
    for i in 2..=((n as f64).sqrt() as usize) {
        if is_prime[i] {
            for j in (i * i..=n).step_by(i) {
                is_prime[j] = false;
            }
        }
    }
    
    is_prime
}

/// 质因数分解
/// Prime factorization
pub fn prime_factorization(mut n: u64) -> Vec<(u64, u32)> {
    let mut factors = Vec::new();
    let mut d = 2;
    
    while d * d <= n {
        let mut count = 0;
        while n % d == 0 {
            n /= d;
            count += 1;
        }
        if count > 0 {
            factors.push((d, count));
        }
        d += 1;
    }
    
    if n > 1 {
        factors.push((n, 1));
    }
    
    factors
}
```

### 欧拉函数 / Euler's Totient Function

**定义 3.2 (欧拉函数)** / **Definition 3.2 (Euler's Totient Function)**
欧拉函数 $\phi(n)$ 定义为小于 $n$ 且与 $n$ 互素的正整数的个数。

Euler's totient function $\phi(n)$ is defined as the number of positive integers less than $n$ that are coprime to $n$.

**定理 3.2 (欧拉函数的性质)** / **Theorem 3.2 (Properties of Euler's Function)**

1. 如果 $p$ 是素数，则 $\phi(p) = p - 1$
2. 如果 $p$ 是素数，$k \geq 1$，则 $\phi(p^k) = p^k - p^{k-1}$
3. 如果 $\gcd(m, n) = 1$，则 $\phi(mn) = \phi(m)\phi(n)$

   1. If $p$ is prime, then $\phi(p) = p - 1$
   2. If $p$ is prime, $k \geq 1$, then $\phi(p^k) = p^k - p^{k-1}$
   3. If $\gcd(m, n) = 1$, then $\phi(mn) = \phi(m)\phi(n)$

**算法 3.2 (计算欧拉函数)** / **Algorithm 3.2 (Computing Euler's Function)**

```rust
/// 计算欧拉函数 φ(n)
/// Compute Euler's totient function φ(n)
pub fn euler_totient(n: u64) -> u64 {
    let factors = prime_factorization(n);
    let mut result = n;
    
    for (prime, _) in factors {
        result = result / prime * (prime - 1);
    }
    
    result
}

/// 欧拉定理
/// Euler's theorem
pub fn euler_theorem(a: u64, n: u64) -> u64 {
    if gcd(a as i64, n as i64) != 1 {
        return 0; // 不适用
    }
    
    let phi_n = euler_totient(n);
    mod_pow(a, phi_n, n)
}

/// 模幂运算
/// Modular exponentiation
pub fn mod_pow(mut base: u64, mut exp: u64, modulus: u64) -> u64 {
    if modulus == 1 {
        return 0;
    }
    
    let mut result = 1;
    base %= modulus;
    
    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulus;
        }
        base = (base * base) % modulus;
        exp >>= 1;
    }
    
    result
}
```

## 数论函数 / Number Theoretic Functions

### 基本数论函数 / Basic Number Theoretic Functions

**定义 4.1 (除数函数)** / **Definition 4.1 (Divisor Function)**
$\sigma_k(n)$ 表示 $n$ 的所有正因子的 $k$ 次幂之和：
$$\sigma_k(n) = \sum_{d \mid n} d^k$$

$\sigma_k(n)$ represents the sum of the $k$-th powers of all positive divisors of $n$:
$$\sigma_k(n) = \sum_{d \mid n} d^k$$

**定义 4.2 (莫比乌斯函数)** / **Definition 4.2 (Möbius Function)**
莫比乌斯函数 $\mu(n)$ 定义为：
$$
\mu(n) = \begin{cases}
1 & \text{if } n = 1 \\
0 & \text{if } n \text{ has a squared factor} \\
(-1)^k & \text{if } n \text{ is the product of } k \text{ distinct primes}
\end{cases}
$$

The Möbius function $\mu(n)$ is defined as:
$$
\mu(n) = \begin{cases}
1 & \text{if } n = 1 \\
0 & \text{if } n \text{ has a squared factor} \\
(-1)^k & \text{if } n \text{ is the product of } k \text{ distinct primes}
\end{cases}
$$

**算法 4.1 (计算数论函数)** / **Algorithm 4.1 (Computing Number Theoretic Functions)**

```rust
/// 计算除数个数
/// Count the number of divisors
pub fn divisor_count(n: u64) -> u32 {
    let factors = prime_factorization(n);
    factors.iter().map(|(_, exp)| exp + 1).product()
}

/// 计算除数之和
/// Calculate the sum of divisors
pub fn divisor_sum(n: u64) -> u64 {
    let factors = prime_factorization(n);
    factors.iter()
        .map(|(prime, exp)| {
            let mut sum = 0;
            let mut power = 1;
            for _ in 0..=*exp {
                sum += power;
                power *= prime;
            }
            sum
        })
        .product()
}

/// 计算莫比乌斯函数
/// Compute the Möbius function
pub fn mobius_function(n: u64) -> i32 {
    if n == 1 {
        return 1;
    }

    let factors = prime_factorization(n);
    for (_, exp) in &factors {
        if *exp > 1 {
            return 0;
        }
    }

    if factors.len() % 2 == 0 {
        1
    } else {
        -1
    }
}
```

## 应用示例 / Applications

### 密码学应用 / Cryptographic Applications

**示例 1: RSA 算法** / **Example 1: RSA Algorithm**

```rust
/// RSA 密钥生成
/// RSA key generation
pub struct RSAKey {
    pub n: u64,
    pub e: u64,
    pub d: u64,
}

pub fn generate_rsa_keys(p: u64, q: u64) -> Option<RSAKey> {
    if !is_prime(p) || !is_prime(q) {
        return None;
    }

    let n = p * q;
    let phi_n = (p - 1) * (q - 1);
    let e = 65537; // 常用的公钥指数

    let (gcd, _, _) = extended_gcd(e as i64, phi_n as i64);
    if gcd != 1 {
        return None;
    }

    let d = mod_inverse(e, phi_n)?;

    Some(RSAKey { n, e, d })
}

/// 模逆元
/// Modular multiplicative inverse
pub fn mod_inverse(a: u64, m: u64) -> Option<u64> {
    let (gcd, x, _) = extended_gcd(a as i64, m as i64);
    if gcd != 1 {
        return None;
    }
    Some(((x % m as i64 + m as i64) % m as i64) as u64)
}
```

### 算法优化应用 / Algorithm Optimization Applications

**示例 2: 快速幂算法** / **Example 2: Fast Exponentiation**

```rust
/// 快速幂算法
/// Fast exponentiation algorithm
pub fn fast_pow(mut base: u64, mut exp: u64) -> u64 {
    let mut result = 1;

    while exp > 0 {
        if exp % 2 == 1 {
            result *= base;
        }
        base *= base;
        exp >>= 1;
    }

    result
}

/// 模快速幂算法
/// Modular fast exponentiation
pub fn mod_fast_pow(mut base: u64, mut exp: u64, modulus: u64) -> u64 {
    if modulus == 1 {
        return 0;
    }

    let mut result = 1;
    base %= modulus;

    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulus;
        }
        base = (base * base) % modulus;
        exp >>= 1;
    }

    result
}
```

## 总结 / Summary

数论基础为算法理论提供了重要的数学工具，包括：

1. **整除理论**：为算法分析提供基础
2. **同余理论**：在密码学和模运算中广泛应用
3. **素数理论**：为随机算法和密码学提供基础
4. **数论函数**：在算法分析和优化中发挥重要作用

Number theory fundamentals provide important mathematical tools for algorithm theory, including:

1. **Divisibility theory**: Provides foundation for algorithm analysis
2. **Congruence theory**: Widely used in cryptography and modular arithmetic
3. **Prime number theory**: Provides foundation for randomized algorithms and cryptography
4. **Number theoretic functions**: Play important roles in algorithm analysis and optimization

## 术语对照表 / Terminology Reference

| 中文术语 | English Term | 定义/说明 |
|---------|-------------|----------|
| 整除 | Divisibility | $a \mid b$ 表示 $a$ 整除 $b$ |
| 最大公约数 | Greatest Common Divisor | $\gcd(a, b)$ 表示 $a$ 和 $b$ 的最大公约数 |
| 最小公倍数 | Least Common Multiple | $\text{lcm}(a, b)$ 表示 $a$ 和 $b$ 的最小公倍数 |
| 同余 | Congruence | $a \equiv b \pmod{m}$ 表示 $a$ 与 $b$ 模 $m$ 同余 |
| 素数 | Prime Number | 大于1且只有1和自身两个正因子的整数 |
| 欧拉函数 | Euler's Totient Function | $\phi(n)$ 表示小于 $n$ 且与 $n$ 互素的正整数个数 |
| 模逆元 | Modular Multiplicative Inverse | $a^{-1} \pmod{m}$ 表示 $a$ 模 $m$ 的逆元 |
| 中国剩余定理 | Chinese Remainder Theorem | 求解同余方程组的定理 |
| 算术基本定理 | Fundamental Theorem of Arithmetic | 每个大于1的整数可唯一分解为素数乘积 |
| 莫比乌斯函数 | Möbius Function | $\mu(n)$ 数论函数，用于容斥原理 |

## 练习与习题 / Exercises and Problems

### 基础练习 / Basic Exercises

**练习 1.1** / **Exercise 1.1**
证明：如果 $a \mid b$ 且 $b \mid c$，则 $a \mid c$。

Prove: If $a \mid b$ and $b \mid c$, then $a \mid c$.

**练习 1.2** / **Exercise 1.2**
计算 $\gcd(48, 18)$ 和 $\text{lcm}(48, 18)$。

Calculate $\gcd(48, 18)$ and $\text{lcm}(48, 18)$.

**练习 1.3** / **Exercise 1.3**
求解线性同余方程 $3x \equiv 2 \pmod{7}$。

Solve the linear congruence equation $3x \equiv 2 \pmod{7}$.

### 进阶练习 / Advanced Exercises

**练习 2.1** / **Exercise 2.1**
使用中国剩余定理解同余方程组：
$$
\begin{cases}
x \equiv 2 \pmod{3} \\
x \equiv 3 \pmod{5} \\
x \equiv 2 \pmod{7}
\end{cases}
$$

Use the Chinese Remainder Theorem to solve the system of congruences:
$$
\begin{cases}
x \equiv 2 \pmod{3} \\
x \equiv 3 \pmod{5} \\
x \equiv 2 \pmod{7}
\end{cases}
$$

**练习 2.2** / **Exercise 2.2**
计算 $\phi(12)$ 和 $\phi(15)$，并验证 $\phi(12 \times 15) = \phi(12) \times \phi(15)$。

Calculate $\phi(12)$ and $\phi(15)$, and verify that $\phi(12 \times 15) = \phi(12) \times \phi(15)$.

**练习 2.3** / **Exercise 2.3**
实现一个函数，判断一个数是否为素数，并分析其时间复杂度。

Implement a function to determine if a number is prime, and analyze its time complexity.

### 编程练习 / Programming Exercises

**练习 3.1** / **Exercise 3.1**
实现扩展欧几里得算法，并用于求解模逆元。

Implement the extended Euclidean algorithm and use it to find modular multiplicative inverses.

**练习 3.2** / **Exercise 3.2**
实现埃拉托斯特尼筛法，找出小于等于 $n$ 的所有素数。

Implement the Sieve of Eratosthenes to find all prime numbers less than or equal to $n$.

**练习 3.3** / **Exercise 3.3**
实现快速幂算法，计算 $a^b \pmod{m}$。

Implement fast exponentiation to calculate $a^b \pmod{m}$.

### 应用练习 / Application Exercises

**练习 4.1** / **Exercise 4.1**
设计一个简单的RSA加密系统，包括密钥生成、加密和解密。

Design a simple RSA encryption system including key generation, encryption, and decryption.

**练习 4.2** / **Exercise 4.2**
使用数论函数分析一个算法的复杂度，例如计算 $\sum_{i=1}^n \sigma_0(i)$。

Use number theoretic functions to analyze the complexity of an algorithm, such as computing $\sum_{i=1}^n \sigma_0(i)$.

## 参考文献 / References

1. Hardy, G. H., & Wright, E. M. (2008). An Introduction to the Theory of Numbers. Oxford University Press.
2. Rosen, K. H. (2011). Elementary Number Theory and Its Applications. Pearson.
3. Niven, I., Zuckerman, H. S., & Montgomery, H. L. (1991). An Introduction to the Theory of Numbers. Wiley.
4. Apostol, T. M. (2013). Introduction to Analytic Number Theory. Springer.
5. Ireland, K., & Rosen, M. (2013). A Classical Introduction to Modern Number Theory. Springer.
