---
title: 1.5 æ•°è®ºåŸºç¡€ / Number Theory Fundamentals
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: åŸºç¡€ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 1.5 æ•°è®ºåŸºç¡€ / Number Theory Fundamentals

### æ‘˜è¦ / Executive Summary

- å»ºç«‹æ•°è®ºçš„åŸºç¡€ç†è®ºï¼Œç»Ÿä¸€æ•´æ•°ã€æ•´é™¤ã€åŒä½™ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚
- å»ºç«‹æ•°è®ºåœ¨ç®—æ³•ç†è®ºä¸­çš„åŸºç¡€åœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- æ•´æ•°ã€æ•´é™¤ã€æœ€å¤§å…¬çº¦æ•°ã€æœ€å°å…¬å€æ•°ã€åŒä½™ã€ç´ æ•°ã€æ¨¡è¿ç®—ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- æ•´æ•°ï¼ˆIntegerï¼‰ï¼šæ­£æ•´æ•°ã€è´Ÿæ•´æ•°å’Œé›¶çš„é›†åˆã€‚
- æ•´é™¤ï¼ˆDivisibilityï¼‰ï¼šä¸€ä¸ªæ•°èƒ½è¢«å¦ä¸€ä¸ªæ•°æ•´é™¤çš„å…³ç³»ã€‚
- æœ€å¤§å…¬çº¦æ•°ï¼ˆGreatest Common Divisorï¼‰ï¼šä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬å› å­ã€‚
- æœ€å°å…¬å€æ•°ï¼ˆLeast Common Multipleï¼‰ï¼šä¸¤ä¸ªæ•°çš„æœ€å°å…¬å€æ•°ã€‚
- è®°å·çº¦å®šï¼š`Z` è¡¨ç¤ºæ•´æ•°é›†ï¼Œ`gcd(a,b)` è¡¨ç¤ºæœ€å¤§å…¬çº¦æ•°ï¼Œ`lcm(a,b)` è¡¨ç¤ºæœ€å°å…¬å€æ•°ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- æ•°å­¦åŸºç¡€ï¼šå‚è§ `01-åŸºç¡€ç†è®º/02-æ•°å­¦åŸºç¡€.md`ã€‚
- ä»£æ•°ç»“æ„åŸºç¡€ï¼šå‚è§ `01-åŸºç¡€ç†è®º/06-ä»£æ•°ç»“æ„åŸºç¡€.md`ã€‚
- ç®—æ³•ç†è®ºï¼šå‚è§ `09-ç®—æ³•ç†è®º/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- æ•´é™¤ç†è®º
- åŒä½™ç†è®º

## ç›®å½• (Table of Contents)

- [1.5 æ•°è®ºåŸºç¡€ / Number Theory Fundamentals](#15-æ•°è®ºåŸºç¡€--number-theory-fundamentals)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [æ¦‚è¿° / Overview](#æ¦‚è¿°--overview)
- [åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [æ•´æ•°ä¸æ•´é™¤ / Integers and Divisibility](#æ•´æ•°ä¸æ•´é™¤--integers-and-divisibility)
  - [æœ€å¤§å…¬çº¦æ•°ä¸æœ€å°å…¬å€æ•° / Greatest Common Divisor and Least Common Multiple](#æœ€å¤§å…¬çº¦æ•°ä¸æœ€å°å…¬å€æ•°--greatest-common-divisor-and-least-common-multiple)
- [åŒä½™ç†è®º / Congruence Theory](#åŒä½™ç†è®º--congruence-theory)
  - [1åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#1åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [çº¿æ€§åŒä½™æ–¹ç¨‹ / Linear Congruence Equations](#çº¿æ€§åŒä½™æ–¹ç¨‹--linear-congruence-equations)
- [ç´ æ•°ç†è®º / Prime Number Theory](#ç´ æ•°ç†è®º--prime-number-theory)
  - [2åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#2åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [æ¬§æ‹‰å‡½æ•° / Euler's Totient Function](#æ¬§æ‹‰å‡½æ•°--eulers-totient-function)
- [æ•°è®ºå‡½æ•° / Number Theoretic Functions](#æ•°è®ºå‡½æ•°--number-theoretic-functions)
  - [åŸºæœ¬æ•°è®ºå‡½æ•° / Basic Number Theoretic Functions](#åŸºæœ¬æ•°è®ºå‡½æ•°--basic-number-theoretic-functions)
- [åº”ç”¨ç¤ºä¾‹ / Applications](#åº”ç”¨ç¤ºä¾‹--applications)
  - [å¯†ç å­¦åº”ç”¨ / Cryptographic Applications](#å¯†ç å­¦åº”ç”¨--cryptographic-applications)
  - [ç®—æ³•ä¼˜åŒ–åº”ç”¨ / Algorithm Optimization Applications](#ç®—æ³•ä¼˜åŒ–åº”ç”¨--algorithm-optimization-applications)
- [æ€»ç»“ / Summary](#æ€»ç»“--summary)
- [æœ¯è¯­å¯¹ç…§è¡¨ / Terminology Reference](#æœ¯è¯­å¯¹ç…§è¡¨--terminology-reference)
- [ç»ƒä¹ ä¸ä¹ é¢˜ / Exercises and Problems](#ç»ƒä¹ ä¸ä¹ é¢˜--exercises-and-problems)
  - [åŸºç¡€ç»ƒä¹  / Basic Exercises](#åŸºç¡€ç»ƒä¹ --basic-exercises)
  - [è¿›é˜¶ç»ƒä¹  / Advanced Exercises](#è¿›é˜¶ç»ƒä¹ --advanced-exercises)
  - [ç¼–ç¨‹ç»ƒä¹  / Programming Exercises](#ç¼–ç¨‹ç»ƒä¹ --programming-exercises)
  - [åº”ç”¨ç»ƒä¹  / Application Exercises](#åº”ç”¨ç»ƒä¹ --application-exercises)
- [å‚è€ƒæ–‡çŒ® / References](#å‚è€ƒæ–‡çŒ®--references)

## æ¦‚è¿° / Overview

æ•°è®ºæ˜¯ç ”ç©¶æ•´æ•°æ€§è´¨çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨ç®—æ³•ç†è®ºä¸­å…·æœ‰é‡è¦åœ°ä½ã€‚æœ¬æ–‡æ¡£ä»‹ç»æ•°è®ºçš„åŸºæœ¬æ¦‚å¿µã€å®šç†å’Œç®—æ³•åº”ç”¨ã€‚

Number theory is the branch of mathematics that studies the properties of integers, playing a crucial role in algorithm theory. This document introduces the fundamental concepts, theorems, and algorithmic applications of number theory.

## åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### æ•´æ•°ä¸æ•´é™¤ / Integers and Divisibility

**å®šä¹‰ 1.1 (æ•´é™¤)** / **Definition 1.1 (Divisibility)** [HardyWright2008]
è®¾ $a, b \in \mathbb{Z}$ï¼Œå¦‚æœå­˜åœ¨ $q \in \mathbb{Z}$ ä½¿å¾— $b = aq$ï¼Œåˆ™ç§° $a$ æ•´é™¤ $b$ï¼Œè®°ä½œ $a \mid b$ã€‚

Let $a, b \in \mathbb{Z}$. If there exists $q \in \mathbb{Z}$ such that $b = aq$, then we say that $a$ divides $b$, denoted by $a \mid b$ [HardyWright2008].

**æ€§è´¨ 1.1 (æ•´é™¤çš„åŸºæœ¬æ€§è´¨)** / **Properties 1.1 (Basic Properties of Divisibility)**

1. å¦‚æœ $a \mid b$ ä¸” $b \mid c$ï¼Œåˆ™ $a \mid c$ (ä¼ é€’æ€§)
2. å¦‚æœ $a \mid b$ ä¸” $a \mid c$ï¼Œåˆ™ $a \mid (bx + cy)$ å¯¹æ‰€æœ‰ $x, y \in \mathbb{Z}$
3. å¦‚æœ $a \mid b$ ä¸” $b \mid a$ï¼Œåˆ™ $a = \pm b$

   1. If $a \mid b$ and $b \mid c$, then $a \mid c$ (transitivity)
   2. If $a \mid b$ and $a \mid c$, then $a \mid (bx + cy)$ for all $x, y \in \mathbb{Z}$
   3. If $a \mid b$ and $b \mid a$, then $a = \pm b$

### æœ€å¤§å…¬çº¦æ•°ä¸æœ€å°å…¬å€æ•° / Greatest Common Divisor and Least Common Multiple

**å®šä¹‰ 1.2 (æœ€å¤§å…¬çº¦æ•°)** / **Definition 1.2 (Greatest Common Divisor)**
è®¾ $a, b \in \mathbb{Z}$ï¼Œä¸å…¨ä¸ºé›¶ã€‚$a$ å’Œ $b$ çš„æœ€å¤§å…¬çº¦æ•° $\gcd(a, b)$ æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æ­£æ•´æ•° $d$ï¼š

1. $d \mid a$ ä¸” $d \mid b$
2. å¦‚æœ $c \mid a$ ä¸” $c \mid b$ï¼Œåˆ™ $c \mid d$

Let $a, b \in \mathbb{Z}$, not both zero. The greatest common divisor $\gcd(a, b)$ is the positive integer $d$ satisfying:

1. $d \mid a$ and $d \mid b$
2. If $c \mid a$ and $c \mid b$, then $c \mid d$

**å®šç† 1.1 (æ¬§å‡ é‡Œå¾—ç®—æ³•)** / **Theorem 1.1 (Euclidean Algorithm)**
å¯¹äºä»»æ„ $a, b \in \mathbb{Z}$ï¼Œæœ‰ $\gcd(a, b) = \gcd(b, a \bmod b)$ã€‚

For any $a, b \in \mathbb{Z}$, we have $\gcd(a, b) = \gcd(b, a \bmod b)$.

**ç®—æ³• 1.1 (æ¬§å‡ é‡Œå¾—ç®—æ³•)** / **Algorithm 1.1 (Euclidean Algorithm)**

```rust
/// è®¡ç®—ä¸¤ä¸ªæ•´æ•°çš„æœ€å¤§å…¬çº¦æ•°
/// Calculate the greatest common divisor of two integers
pub fn gcd(mut a: i64, mut b: i64) -> i64 {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a.abs()
}

/// æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œè®¡ç®— BÃ©zout ç³»æ•°
/// Extended Euclidean algorithm to compute BÃ©zout coefficients
pub fn extended_gcd(a: i64, b: i64) -> (i64, i64, i64) {
    if b == 0 {
        (a, 1, 0)
    } else {
        let (gcd, x, y) = extended_gcd(b, a % b);
        (gcd, y, x - (a / b) * y)
    }
}

/// è®¡ç®—æœ€å°å…¬å€æ•°
/// Calculate the least common multiple
pub fn lcm(a: i64, b: i64) -> i64 {
    (a * b).abs() / gcd(a, b)
}
```

## åŒä½™ç†è®º / Congruence Theory

### 1åŸºæœ¬æ¦‚å¿µ / Basic Concepts

**å®šä¹‰ 2.1 (åŒä½™)** / **Definition 2.1 (Congruence)**
è®¾ $a, b, m \in \mathbb{Z}$ï¼Œ$m > 0$ã€‚å¦‚æœ $m \mid (a - b)$ï¼Œåˆ™ç§° $a$ ä¸ $b$ æ¨¡ $m$ åŒä½™ï¼Œè®°ä½œ $a \equiv b \pmod{m}$ã€‚

Let $a, b, m \in \mathbb{Z}$, $m > 0$. If $m \mid (a - b)$, then we say that $a$ is congruent to $b$ modulo $m$, denoted by $a \equiv b \pmod{m}$.

**æ€§è´¨ 2.1 (åŒä½™çš„åŸºæœ¬æ€§è´¨)** / **Properties 2.1 (Basic Properties of Congruence)**

1. è‡ªåæ€§ï¼š$a \equiv a \pmod{m}$
2. å¯¹ç§°æ€§ï¼šå¦‚æœ $a \equiv b \pmod{m}$ï¼Œåˆ™ $b \equiv a \pmod{m}$
3. ä¼ é€’æ€§ï¼šå¦‚æœ $a \equiv b \pmod{m}$ ä¸” $b \equiv c \pmod{m}$ï¼Œåˆ™ $a \equiv c \pmod{m}$
4. å¦‚æœ $a \equiv b \pmod{m}$ ä¸” $c \equiv d \pmod{m}$ï¼Œåˆ™ï¼š
   - $a + c \equiv b + d \pmod{m}$
   - $a - c \equiv b - d \pmod{m}$
   - $ac \equiv bd \pmod{m}$

   1. Reflexivity: $a \equiv a \pmod{m}$
   2. Symmetry: If $a \equiv b \pmod{m}$, then $b \equiv a \pmod{m}$
   3. Transitivity: If $a \equiv b \pmod{m}$ and $b \equiv c \pmod{m}$, then $a \equiv c \pmod{m}$
   4. If $a \equiv b \pmod{m}$ and $c \equiv d \pmod{m}$, then:
      - $a + c \equiv b + d \pmod{m}$
      - $a - c \equiv b - d \pmod{m}$
      - $ac \equiv bd \pmod{m}$

### çº¿æ€§åŒä½™æ–¹ç¨‹ / Linear Congruence Equations

**å®šä¹‰ 2.2 (çº¿æ€§åŒä½™æ–¹ç¨‹)** / **Definition 2.2 (Linear Congruence Equation)**
å½¢å¦‚ $ax \equiv b \pmod{m}$ çš„æ–¹ç¨‹ç§°ä¸ºçº¿æ€§åŒä½™æ–¹ç¨‹ã€‚

An equation of the form $ax \equiv b \pmod{m}$ is called a linear congruence equation.

**å®šç† 2.1 (çº¿æ€§åŒä½™æ–¹ç¨‹çš„è§£)** / **Theorem 2.1 (Solution of Linear Congruence)**
çº¿æ€§åŒä½™æ–¹ç¨‹ $ax \equiv b \pmod{m}$ æœ‰è§£çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ $\gcd(a, m) \mid b$ã€‚

The linear congruence equation $ax \equiv b \pmod{m}$ has a solution if and only if $\gcd(a, m) \mid b$.

**ç®—æ³• 2.1 (æ±‚è§£çº¿æ€§åŒä½™æ–¹ç¨‹)** / **Algorithm 2.1 (Solving Linear Congruence)**

```rust
/// æ±‚è§£çº¿æ€§åŒä½™æ–¹ç¨‹ ax â‰¡ b (mod m)
/// Solve linear congruence equation ax â‰¡ b (mod m)
pub fn solve_linear_congruence(a: i64, b: i64, m: i64) -> Option<Vec<i64>> {
    let (gcd, x, _) = extended_gcd(a, m);

    if b % gcd != 0 {
        return None; // æ— è§£
    }

    let x0 = (x * (b / gcd)) % m;
    let solutions: Vec<i64> = (0..gcd)
        .map(|k| (x0 + k * (m / gcd)) % m)
        .collect();

    Some(solutions)
}

/// ä¸­å›½å‰©ä½™å®šç†
/// Chinese Remainder Theorem
pub fn chinese_remainder_theorem(remainders: &[i64], moduli: &[i64]) -> Option<i64> {
    if remainders.len() != moduli.len() {
        return None;
    }

    let mut result = 0;
    let mut product = 1;

    // è®¡ç®—æ‰€æœ‰æ¨¡æ•°çš„ä¹˜ç§¯
    for &m in moduli {
        product *= m;
    }

    for i in 0..remainders.len() {
        let pi = product / moduli[i];
        let (_, inv, _) = extended_gcd(pi, moduli[i]);
        result = (result + remainders[i] * pi * inv) % product;
    }

    Some((result + product) % product)
}
```

## ç´ æ•°ç†è®º / Prime Number Theory

### 2åŸºæœ¬æ¦‚å¿µ / Basic Concepts

**å®šä¹‰ 3.1 (ç´ æ•°)** / **Definition 3.1 (Prime Number)**
å¤§äº1çš„æ•´æ•° $p$ ç§°ä¸ºç´ æ•°ï¼Œå¦‚æœ $p$ çš„æ­£å› å­åªæœ‰1å’Œ $p$ æœ¬èº«ã€‚

An integer $p > 1$ is called a prime number if its only positive divisors are 1 and $p$ itself.

**å®šç† 3.1 (ç®—æœ¯åŸºæœ¬å®šç†)** / **Theorem 3.1 (Fundamental Theorem of Arithmetic)**
æ¯ä¸ªå¤§äº1çš„æ•´æ•°éƒ½å¯ä»¥å”¯ä¸€åœ°è¡¨ç¤ºä¸ºç´ æ•°çš„ä¹˜ç§¯ï¼ˆä¸è®¡å› å­çš„é¡ºåºï¼‰ã€‚

Every integer greater than 1 can be uniquely represented as a product of primes (up to the order of factors).

**ç®—æ³• 3.1 (ç´ æ•°åˆ¤å®š)** / **Algorithm 3.1 (Prime Testing)**

```rust
/// åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºç´ æ•°
/// Determine if a number is prime
pub fn is_prime(n: u64) -> bool {
    if n < 2 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }

    let sqrt_n = (n as f64).sqrt() as u64;
    for i in (3..=sqrt_n).step_by(2) {
        if n % i == 0 {
            return false;
        }
    }
    true
}

/// åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•
/// Sieve of Eratosthenes
pub fn sieve_of_eratosthenes(n: usize) -> Vec<bool> {
    let mut is_prime = vec![true; n + 1];
    is_prime[0] = false;
    is_prime[1] = false;

    for i in 2..=((n as f64).sqrt() as usize) {
        if is_prime[i] {
            for j in (i * i..=n).step_by(i) {
                is_prime[j] = false;
            }
        }
    }

    is_prime
}

/// è´¨å› æ•°åˆ†è§£
/// Prime factorization
pub fn prime_factorization(mut n: u64) -> Vec<(u64, u32)> {
    let mut factors = Vec::new();
    let mut d = 2;

    while d * d <= n {
        let mut count = 0;
        while n % d == 0 {
            n /= d;
            count += 1;
        }
        if count > 0 {
            factors.push((d, count));
        }
        d += 1;
    }

    if n > 1 {
        factors.push((n, 1));
    }

    factors
}
```

### æ¬§æ‹‰å‡½æ•° / Euler's Totient Function

**å®šä¹‰ 3.2 (æ¬§æ‹‰å‡½æ•°)** / **Definition 3.2 (Euler's Totient Function)**
æ¬§æ‹‰å‡½æ•° $\phi(n)$ å®šä¹‰ä¸ºå°äº $n$ ä¸”ä¸ $n$ äº’ç´ çš„æ­£æ•´æ•°çš„ä¸ªæ•°ã€‚

Euler's totient function $\phi(n)$ is defined as the number of positive integers less than $n$ that are coprime to $n$.

**å®šç† 3.2 (æ¬§æ‹‰å‡½æ•°çš„æ€§è´¨)** / **Theorem 3.2 (Properties of Euler's Function)**

1. å¦‚æœ $p$ æ˜¯ç´ æ•°ï¼Œåˆ™ $\phi(p) = p - 1$
2. å¦‚æœ $p$ æ˜¯ç´ æ•°ï¼Œ$k \geq 1$ï¼Œåˆ™ $\phi(p^k) = p^k - p^{k-1}$
3. å¦‚æœ $\gcd(m, n) = 1$ï¼Œåˆ™ $\phi(mn) = \phi(m)\phi(n)$

   1. If $p$ is prime, then $\phi(p) = p - 1$
   2. If $p$ is prime, $k \geq 1$, then $\phi(p^k) = p^k - p^{k-1}$
   3. If $\gcd(m, n) = 1$, then $\phi(mn) = \phi(m)\phi(n)$

**ç®—æ³• 3.2 (è®¡ç®—æ¬§æ‹‰å‡½æ•°)** / **Algorithm 3.2 (Computing Euler's Function)**

```rust
/// è®¡ç®—æ¬§æ‹‰å‡½æ•° Ï†(n)
/// Compute Euler's totient function Ï†(n)
pub fn euler_totient(n: u64) -> u64 {
    let factors = prime_factorization(n);
    let mut result = n;

    for (prime, _) in factors {
        result = result / prime * (prime - 1);
    }

    result
}

/// æ¬§æ‹‰å®šç†
/// Euler's theorem
pub fn euler_theorem(a: u64, n: u64) -> u64 {
    if gcd(a as i64, n as i64) != 1 {
        return 0; // ä¸é€‚ç”¨
    }

    let phi_n = euler_totient(n);
    mod_pow(a, phi_n, n)
}

/// æ¨¡å¹‚è¿ç®—
/// Modular exponentiation
pub fn mod_pow(mut base: u64, mut exp: u64, modulus: u64) -> u64 {
    if modulus == 1 {
        return 0;
    }

    let mut result = 1;
    base %= modulus;

    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulus;
        }
        base = (base * base) % modulus;
        exp >>= 1;
    }

    result
}
```

## æ•°è®ºå‡½æ•° / Number Theoretic Functions

### åŸºæœ¬æ•°è®ºå‡½æ•° / Basic Number Theoretic Functions

**å®šä¹‰ 4.1 (é™¤æ•°å‡½æ•°)** / **Definition 4.1 (Divisor Function)**
$\sigma_k(n)$ è¡¨ç¤º $n$ çš„æ‰€æœ‰æ­£å› å­çš„ $k$ æ¬¡å¹‚ä¹‹å’Œï¼š
$$\sigma_k(n) = \sum_{d \mid n} d^k$$

$\sigma_k(n)$ represents the sum of the $k$-th powers of all positive divisors of $n$:
$$\sigma_k(n) = \sum_{d \mid n} d^k$$

**å®šä¹‰ 4.2 (è«æ¯”ä¹Œæ–¯å‡½æ•°)** / **Definition 4.2 (MÃ¶bius Function)**
è«æ¯”ä¹Œæ–¯å‡½æ•° $\mu(n)$ å®šä¹‰ä¸ºï¼š
$$
\mu(n) = \begin{cases}
1 & \text{if } n = 1 \\
0 & \text{if } n \text{ has a squared factor} \\
(-1)^k & \text{if } n \text{ is the product of } k \text{ distinct primes}
\end{cases}
$$

The MÃ¶bius function $\mu(n)$ is defined as:
$$
\mu(n) = \begin{cases}
1 & \text{if } n = 1 \\
0 & \text{if } n \text{ has a squared factor} \\
(-1)^k & \text{if } n \text{ is the product of } k \text{ distinct primes}
\end{cases}
$$

**ç®—æ³• 4.1 (è®¡ç®—æ•°è®ºå‡½æ•°)** / **Algorithm 4.1 (Computing Number Theoretic Functions)**

```rust
/// è®¡ç®—é™¤æ•°ä¸ªæ•°
/// Count the number of divisors
pub fn divisor_count(n: u64) -> u32 {
    let factors = prime_factorization(n);
    factors.iter().map(|(_, exp)| exp + 1).product()
}

/// è®¡ç®—é™¤æ•°ä¹‹å’Œ
/// Calculate the sum of divisors
pub fn divisor_sum(n: u64) -> u64 {
    let factors = prime_factorization(n);
    factors.iter()
        .map(|(prime, exp)| {
            let mut sum = 0;
            let mut power = 1;
            for _ in 0..=*exp {
                sum += power;
                power *= prime;
            }
            sum
        })
        .product()
}

/// è®¡ç®—è«æ¯”ä¹Œæ–¯å‡½æ•°
/// Compute the MÃ¶bius function
pub fn mobius_function(n: u64) -> i32 {
    if n == 1 {
        return 1;
    }

    let factors = prime_factorization(n);
    for (_, exp) in &factors {
        if *exp > 1 {
            return 0;
        }
    }

    if factors.len() % 2 == 0 {
        1
    } else {
        -1
    }
}
```

## åº”ç”¨ç¤ºä¾‹ / Applications

### å¯†ç å­¦åº”ç”¨ / Cryptographic Applications

**ç¤ºä¾‹ 1: RSA ç®—æ³•** / **Example 1: RSA Algorithm**

```rust
/// RSA å¯†é’¥ç”Ÿæˆ
/// RSA key generation
pub struct RSAKey {
    pub n: u64,
    pub e: u64,
    pub d: u64,
}

pub fn generate_rsa_keys(p: u64, q: u64) -> Option<RSAKey> {
    if !is_prime(p) || !is_prime(q) {
        return None;
    }

    let n = p * q;
    let phi_n = (p - 1) * (q - 1);
    let e = 65537; // å¸¸ç”¨çš„å…¬é’¥æŒ‡æ•°

    let (gcd, _, _) = extended_gcd(e as i64, phi_n as i64);
    if gcd != 1 {
        return None;
    }

    let d = mod_inverse(e, phi_n)?;

    Some(RSAKey { n, e, d })
}

/// æ¨¡é€†å…ƒ
/// Modular multiplicative inverse
pub fn mod_inverse(a: u64, m: u64) -> Option<u64> {
    let (gcd, x, _) = extended_gcd(a as i64, m as i64);
    if gcd != 1 {
        return None;
    }
    Some(((x % m as i64 + m as i64) % m as i64) as u64)
}
```

### ç®—æ³•ä¼˜åŒ–åº”ç”¨ / Algorithm Optimization Applications

**ç¤ºä¾‹ 2: å¿«é€Ÿå¹‚ç®—æ³•** / **Example 2: Fast Exponentiation**

```rust
/// å¿«é€Ÿå¹‚ç®—æ³•
/// Fast exponentiation algorithm
pub fn fast_pow(mut base: u64, mut exp: u64) -> u64 {
    let mut result = 1;

    while exp > 0 {
        if exp % 2 == 1 {
            result *= base;
        }
        base *= base;
        exp >>= 1;
    }

    result
}

/// æ¨¡å¿«é€Ÿå¹‚ç®—æ³•
/// Modular fast exponentiation
pub fn mod_fast_pow(mut base: u64, mut exp: u64, modulus: u64) -> u64 {
    if modulus == 1 {
        return 0;
    }

    let mut result = 1;
    base %= modulus;

    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulus;
        }
        base = (base * base) % modulus;
        exp >>= 1;
    }

    result
}
```

## æ€»ç»“ / Summary

æ•°è®ºåŸºç¡€ä¸ºç®—æ³•ç†è®ºæä¾›äº†é‡è¦çš„æ•°å­¦å·¥å…·ï¼ŒåŒ…æ‹¬ï¼š

1. **æ•´é™¤ç†è®º**ï¼šä¸ºç®—æ³•åˆ†ææä¾›åŸºç¡€
2. **åŒä½™ç†è®º**ï¼šåœ¨å¯†ç å­¦å’Œæ¨¡è¿ç®—ä¸­å¹¿æ³›åº”ç”¨
3. **ç´ æ•°ç†è®º**ï¼šä¸ºéšæœºç®—æ³•å’Œå¯†ç å­¦æä¾›åŸºç¡€
4. **æ•°è®ºå‡½æ•°**ï¼šåœ¨ç®—æ³•åˆ†æå’Œä¼˜åŒ–ä¸­å‘æŒ¥é‡è¦ä½œç”¨

Number theory fundamentals provide important mathematical tools for algorithm theory, including:

1. **Divisibility theory**: Provides foundation for algorithm analysis
2. **Congruence theory**: Widely used in cryptography and modular arithmetic
3. **Prime number theory**: Provides foundation for randomized algorithms and cryptography
4. **Number theoretic functions**: Play important roles in algorithm analysis and optimization

## æœ¯è¯­å¯¹ç…§è¡¨ / Terminology Reference

| ä¸­æ–‡æœ¯è¯­ | English Term | å®šä¹‰/è¯´æ˜ |
|---------|-------------|----------|
| æ•´é™¤ | Divisibility | $a \mid b$ è¡¨ç¤º $a$ æ•´é™¤ $b$ |
| æœ€å¤§å…¬çº¦æ•° | Greatest Common Divisor | $\gcd(a, b)$ è¡¨ç¤º $a$ å’Œ $b$ çš„æœ€å¤§å…¬çº¦æ•° |
| æœ€å°å…¬å€æ•° | Least Common Multiple | $\text{lcm}(a, b)$ è¡¨ç¤º $a$ å’Œ $b$ çš„æœ€å°å…¬å€æ•° |
| åŒä½™ | Congruence | $a \equiv b \pmod{m}$ è¡¨ç¤º $a$ ä¸ $b$ æ¨¡ $m$ åŒä½™ |
| ç´ æ•° | Prime Number | å¤§äº1ä¸”åªæœ‰1å’Œè‡ªèº«ä¸¤ä¸ªæ­£å› å­çš„æ•´æ•° |
| æ¬§æ‹‰å‡½æ•° | Euler's Totient Function | $\phi(n)$ è¡¨ç¤ºå°äº $n$ ä¸”ä¸ $n$ äº’ç´ çš„æ­£æ•´æ•°ä¸ªæ•° |
| æ¨¡é€†å…ƒ | Modular Multiplicative Inverse | $a^{-1} \pmod{m}$ è¡¨ç¤º $a$ æ¨¡ $m$ çš„é€†å…ƒ |
| ä¸­å›½å‰©ä½™å®šç† | Chinese Remainder Theorem | æ±‚è§£åŒä½™æ–¹ç¨‹ç»„çš„å®šç† |
| ç®—æœ¯åŸºæœ¬å®šç† | Fundamental Theorem of Arithmetic | æ¯ä¸ªå¤§äº1çš„æ•´æ•°å¯å”¯ä¸€åˆ†è§£ä¸ºç´ æ•°ä¹˜ç§¯ |
| è«æ¯”ä¹Œæ–¯å‡½æ•° | MÃ¶bius Function | $\mu(n)$ æ•°è®ºå‡½æ•°ï¼Œç”¨äºå®¹æ–¥åŸç† |

## ç»ƒä¹ ä¸ä¹ é¢˜ / Exercises and Problems

### åŸºç¡€ç»ƒä¹  / Basic Exercises

**ç»ƒä¹  1.1** / **Exercise 1.1**
è¯æ˜ï¼šå¦‚æœ $a \mid b$ ä¸” $b \mid c$ï¼Œåˆ™ $a \mid c$ã€‚

Prove: If $a \mid b$ and $b \mid c$, then $a \mid c$.

**ç»ƒä¹  1.2** / **Exercise 1.2**
è®¡ç®— $\gcd(48, 18)$ å’Œ $\text{lcm}(48, 18)$ã€‚

Calculate $\gcd(48, 18)$ and $\text{lcm}(48, 18)$.

**ç»ƒä¹  1.3** / **Exercise 1.3**
æ±‚è§£çº¿æ€§åŒä½™æ–¹ç¨‹ $3x \equiv 2 \pmod{7}$ã€‚

Solve the linear congruence equation $3x \equiv 2 \pmod{7}$.

### è¿›é˜¶ç»ƒä¹  / Advanced Exercises

**ç»ƒä¹  2.1** / **Exercise 2.1**
ä½¿ç”¨ä¸­å›½å‰©ä½™å®šç†è§£åŒä½™æ–¹ç¨‹ç»„ï¼š
$$
\begin{cases}
x \equiv 2 \pmod{3} \\
x \equiv 3 \pmod{5} \\
x \equiv 2 \pmod{7}
\end{cases}
$$

Use the Chinese Remainder Theorem to solve the system of congruences:
$$
\begin{cases}
x \equiv 2 \pmod{3} \\
x \equiv 3 \pmod{5} \\
x \equiv 2 \pmod{7}
\end{cases}
$$

**ç»ƒä¹  2.2** / **Exercise 2.2**
è®¡ç®— $\phi(12)$ å’Œ $\phi(15)$ï¼Œå¹¶éªŒè¯ $\phi(12 \times 15) = \phi(12) \times \phi(15)$ã€‚

Calculate $\phi(12)$ and $\phi(15)$, and verify that $\phi(12 \times 15) = \phi(12) \times \phi(15)$.

**ç»ƒä¹  2.3** / **Exercise 2.3**
å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºç´ æ•°ï¼Œå¹¶åˆ†æå…¶æ—¶é—´å¤æ‚åº¦ã€‚

Implement a function to determine if a number is prime, and analyze its time complexity.

### ç¼–ç¨‹ç»ƒä¹  / Programming Exercises

**ç»ƒä¹  3.1** / **Exercise 3.1**
å®ç°æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œå¹¶ç”¨äºæ±‚è§£æ¨¡é€†å…ƒã€‚

Implement the extended Euclidean algorithm and use it to find modular multiplicative inverses.

**ç»ƒä¹  3.2** / **Exercise 3.2**
å®ç°åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•ï¼Œæ‰¾å‡ºå°äºç­‰äº $n$ çš„æ‰€æœ‰ç´ æ•°ã€‚

Implement the Sieve of Eratosthenes to find all prime numbers less than or equal to $n$.

**ç»ƒä¹  3.3** / **Exercise 3.3**
å®ç°å¿«é€Ÿå¹‚ç®—æ³•ï¼Œè®¡ç®— $a^b \pmod{m}$ã€‚

Implement fast exponentiation to calculate $a^b \pmod{m}$.

### åº”ç”¨ç»ƒä¹  / Application Exercises

**ç»ƒä¹  4.1** / **Exercise 4.1**
è®¾è®¡ä¸€ä¸ªç®€å•çš„RSAåŠ å¯†ç³»ç»Ÿï¼ŒåŒ…æ‹¬å¯†é’¥ç”Ÿæˆã€åŠ å¯†å’Œè§£å¯†ã€‚

Design a simple RSA encryption system including key generation, encryption, and decryption.

**ç»ƒä¹  4.2** / **Exercise 4.2**
ä½¿ç”¨æ•°è®ºå‡½æ•°åˆ†æä¸€ä¸ªç®—æ³•çš„å¤æ‚åº¦ï¼Œä¾‹å¦‚è®¡ç®— $\sum_{i=1}^n \sigma_0(i)$ã€‚

Use number theoretic functions to analyze the complexity of an algorithm, such as computing $\sum_{i=1}^n \sigma_0(i)$.

---

## é¢å‘ AI çš„è¦ç‚¹ / Highlights for AI & ML

- **å¯†ç å­¦ä¸å®‰å…¨åè®®çš„æ•°å­¦å¼•æ“**ï¼šåŒä½™ã€æ¨¡è¿ç®—ã€ç´ æ•°åˆ†è§£ä¸ç¦»æ•£å¯¹æ•°æ„æˆç°ä»£å…¬é’¥å¯†ç ï¼ˆRSAã€Diffieâ€“Hellmanã€æ¤­åœ†æ›²çº¿å¯†ç ï¼‰çš„æ ¸å¿ƒï¼›åœ¨ `12-åº”ç”¨é¢†åŸŸ/03-ç½‘ç»œå®‰å…¨ç®—æ³•åº”ç”¨.md` ä¸­ä¼šå¤§é‡ç”¨åˆ°æœ¬èŠ‚å†…å®¹ã€‚
- **å“ˆå¸Œä¸ä¼ªéšæœºæ€§çš„ç›´è§‰åŸºç¡€**ï¼šæ•°è®ºæ„é€ çš„å“ˆå¸Œå‡½æ•°ã€ä¼ªéšæœºæ•°å‘ç”Ÿå™¨ä¾èµ–äºæ¨¡è¿ç®—ä¸æ•°è®ºå‡½æ•°çš„æ€§è´¨ï¼Œæœ‰åŠ©äºç†è§£å¸ƒéš†è¿‡æ»¤å™¨ã€éšæœºç®—æ³•ä¸­çš„â€œå‡åŒ€æ€§å‡è®¾â€ã€‚
- **åŒä½™ç±»ä¸ embedding**ï¼šå¾ˆå¤š embedding/é‡åŒ–æ–¹æ³•å¯ä»¥ä»â€œæ¨¡ç±»åˆ†è§£â€çš„è§’åº¦ç†è§£ï¼Œä¾‹å¦‚å¾ªç¯ç»“æ„ã€å‘¨æœŸæ€§ç‰¹å¾ï¼Œå¯æ˜ å°„åˆ°æ•°è®ºä¸­çš„å‰©ä½™ç±»ã€‚
- **ç®—æ³•å¤æ‚åº¦ä¸‹ç•Œä¸æ„é€ **ï¼šç­›æ³•ã€å¿«é€Ÿå¹‚ã€æ‰©å±•æ¬§å‡ é‡Œå¾—ç­‰æ•°è®ºç®—æ³•æ˜¯ç®—æ³•è®¾è®¡ä¸­â€œç»“æ„åŒ–æ„é€ â€çš„å…¸å‹æ¡ˆä¾‹ï¼Œé€‚åˆä½œä¸º `09-ç®—æ³•ç†è®º` ä¸­æ—¶é—´å¤æ‚åº¦ä¸ç®—æ³•è®¾è®¡èŒƒå¼çš„ç»ƒä¹ è½½ä½“ã€‚

### å¤–éƒ¨è¯¾ç¨‹å¯¹æ ‡ / External Course Alignment

- **MIT 6.042J / 6.046**ï¼šæ•´é™¤ã€åŒä½™ä¸æ•°è®ºåœ¨ç»„åˆè®¡æ•°ã€å“ˆå¸Œå’Œç®—æ³•ä¸‹ç•Œä¸­çš„åº”ç”¨ï¼Œå¯ä»¥ä½œä¸ºæœ¬èŠ‚åº”ç”¨éƒ¨åˆ†çš„è¡¥å……é˜…è¯»ã€‚
- **CMU 15â€‘251 / 15â€‘451**ï¼šåœ¨â€œå›¾è®ºä¸æ•°è®ºâ€ç« èŠ‚ä¸­ï¼Œæ•°è®ºè¢«ç”¨æ¥æ„é€ ä¼ªéšæœºå›¾ã€å“ˆå¸Œå‡½æ•°å’Œä¸‹ç•Œè¯æ˜ï¼Œä¸æœ¬èŠ‚â€œç®—æ³•ä¼˜åŒ–åº”ç”¨â€å¯äº’ç›¸å‚ç…§ã€‚
- **CS2023**ï¼šå°†æœ¬èŠ‚ä½œä¸ºâ€œç¦»æ•£ç»“æ„ / æ•°è®ºä¸æ¨¡ç®—æœ¯â€çŸ¥è¯†å•å…ƒçš„æ ¸å¿ƒå†…å®¹ï¼Œæ”¯æ’‘å¯†ç å­¦ã€å®‰å…¨å’Œç®—æ³•è¯¾ç¨‹ã€‚

## å‚è€ƒæ–‡çŒ® / References

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**: æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ [CITATION_STANDARD.md](../CITATION_STANDARD.md)ã€[å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md](../å­¦æœ¯å¼•ç”¨è§„èŒƒ-ACMå¯¹é½ç‰ˆ.md)ï¼‰ã€‚æ–‡å†…é‡‡ç”¨ [Key] æ ¼å¼å¼•ç”¨ï¼Œä¸å‚è€ƒæ–‡çŒ®åˆ—è¡¨å¯¹åº”ã€‚

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**ç»å…¸æ•™æ / Classic Textbooks**:

1. [HardyWright2008] Hardy, G. H., & Wright, E. M. (2008). *An Introduction to the Theory of Numbers* (6th Edition). Oxford University Press. ISBN: 978-0199219858.
   - æ•°è®ºçš„ç»å…¸æ•™æï¼Œç®€ç§°"Hardy & Wright"ï¼Œå†…å®¹è¯¦å°½å…¨é¢ï¼Œæ¶µç›–åˆç­‰æ•°è®ºåˆ°è§£ææ•°è®ºçš„å„ä¸ªæ–¹é¢ã€‚è‡ª1938å¹´é¦–ç‰ˆä»¥æ¥ä¸€ç›´æ˜¯æ•°è®ºé¢†åŸŸçš„æƒå¨å‚è€ƒã€‚

2. [Rosen2011] Rosen, K. H. (2011). *Elementary Number Theory and Its Applications* (6th Edition). Pearson. ISBN: 978-0321500311.
   - åº”ç”¨å¯¼å‘çš„æ•°è®ºæ•™æï¼Œç‰¹åˆ«å¼ºè°ƒå¯†ç å­¦åº”ç”¨ã€‚åŒ…å«å¤§é‡ç®—æ³•å®ç°å’Œåº”ç”¨å®ä¾‹ï¼Œé€‚åˆè®¡ç®—æœºç§‘å­¦èƒŒæ™¯çš„å­¦ä¹ è€…ã€‚

3. [Ireland1990] Ireland, K., & Rosen, M. (1990). *A Classical Introduction to Modern Number Theory* (2nd Edition). Springer. ISBN: 978-0387973296.
   - ç°ä»£æ•°è®ºçš„ç»å…¸å¯¼å¼•ï¼Œæ¶µç›–ä»£æ•°æ•°è®ºå’Œè§£ææ•°è®ºã€‚æä¾›äº†ä»å¤å…¸ç»“æœåˆ°ç°ä»£ç†è®ºçš„ç³»ç»Ÿæ€§æ¡¥æ¢ã€‚

**å¯è®¡ç®—æ€§ä¸ç®—æ³• / Computability and Algorithms**:

1. [Rogers1987] Rogers, H., Jr. (1987). *Theory of Recursive Functions and Effective Computability*. MIT Press. ISBN: 978-0262680523.
   - é€’å½’å‡½æ•°è®ºçš„æƒå¨æ•™æï¼Œä¸ºæ•°è®ºä¸­çš„å¯åˆ¤å®šæ€§å’Œå¯è®¡ç®—æ€§é—®é¢˜æä¾›ç†è®ºåŸºç¡€ã€‚

2. [CLRS2009] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd Edition). MIT Press. ISBN: 978-0262033848.
   - ç®—æ³•å¯¼è®ºï¼ŒåŒ…å«æ•°è®ºç®—æ³•ï¼ˆGCDã€æ¨¡è¿ç®—ã€ç´ æ•°åˆ¤å®šç­‰ï¼‰çš„è¯¦ç»†åˆ†æå’Œå®ç°ã€‚

**å»¶ä¼¸é˜…è¯» / Further Reading**:

1. Niven, I., Zuckerman, H. S., & Montgomery, H. L. (1991). *An Introduction to the Theory of Numbers* (5th Edition). Wiley.
   - ç»å…¸çš„æ•°è®ºå…¥é—¨æ•™æï¼Œæ¸…æ™°æ˜“æ‡‚ï¼Œé€‚åˆåˆå­¦è€…ã€‚

2. Apostol, T. M. (1976). *Introduction to Analytic Number Theory*. Springer.
   - è§£ææ•°è®ºçš„æ ‡å‡†æ•™æï¼Œè¯¦ç»†ä»‹ç»ç´ æ•°åˆ†å¸ƒå’Œæ•°è®ºå‡½æ•°ã€‚

3. Burton, D. M. (2010). *Elementary Number Theory* (7th Edition). McGraw-Hill.
   - åˆç­‰æ•°è®ºçš„ç»¼åˆæ€§æ•™æï¼ŒåŒ…å«ä¸°å¯Œçš„ä¹ é¢˜å’Œå†å²æ³¨è®°ã€‚

**åœ¨çº¿èµ„æºä¸è¯¾ç¨‹ / Online Resources and Courses**:

1. **Wikipedia - Number Theory**: <https://en.wikipedia.org/wiki/Number_theory>
   - æ•°è®ºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«åˆç­‰æ•°è®ºã€è§£ææ•°è®ºç­‰æ ¸å¿ƒåˆ†æ”¯ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Prime Number**: <https://en.wikipedia.org/wiki/Prime_number>
   - ç´ æ•°çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»ç´ æ•°çš„æ€§è´¨å’Œåˆ†å¸ƒï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Euclidean Algorithm**: <https://en.wikipedia.org/wiki/Euclidean_algorithm>
   - æ¬§å‡ é‡Œå¾—ç®—æ³•çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«æœ€å¤§å…¬çº¦æ•°çš„è®¡ç®—æ–¹æ³•ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

4. **Wikipedia - Fundamental Theorem of Arithmetic**: <https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic>
   - ç®—æœ¯åŸºæœ¬å®šç†çš„Wikipediaæ¡ç›®ï¼Œè¯´æ˜å”¯ä¸€åˆ†è§£å®šç†ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.2
**æœ€åæ›´æ–° / Last Updated**: 2025-02-02
**çŠ¶æ€ / Status**: å·²è¡¥å……å­¦æœ¯å¼•ç”¨ä¸æ–‡å†…å¼•ç”¨ (P1)
