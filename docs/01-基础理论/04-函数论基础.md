---
title: 1.4 函数论基础 / Function Theory Foundation
version: 1.1
status: maintained
last_updated: 2025-11-14
owner: 基础理论工作组
---

## 1.4 函数论基础 / Function Theory Foundation

### 摘要 / Executive Summary

- 建立函数论的基础理论，统一函数、映射、复合等核心概念。
- 建立函数论在算法理论中的基础地位。

### 关键术语与符号 / Glossary

- 函数、映射、复合、反函数、单射、满射、双射。
- 术语对齐与引用规范：`docs/术语与符号总表.md`，`01-基础理论/00-撰写规范与引用指南.md`

### 术语与符号规范 / Terminology & Notation

- 函数（Function）：从定义域到值域的映射。
- 映射（Mapping）：函数的同义词。
- 复合（Composition）：函数的复合运算。
- 反函数（Inverse Function）：函数的逆映射。
- 记号约定：`f` 表示函数，`f: A → B` 表示从A到B的函数，`f∘g` 表示复合。

### 交叉引用导航 / Cross-References

- 集合论基础：参见 `01-基础理论/03-集合论基础.md`。
- 数学基础：参见 `01-基础理论/02-数学基础.md`。
- 形式化定义：参见 `01-基础理论/01-形式化定义.md`。

### 快速导航 / Quick Links

- 基本概念
- 函数性质
- 函数运算

## 目录 (Table of Contents)

- [1.4 函数论基础 / Function Theory Foundation](#14-函数论基础--function-theory-foundation)
  - [摘要 / Executive Summary](#摘要--executive-summary)
  - [关键术语与符号 / Glossary](#关键术语与符号--glossary)
  - [术语与符号规范 / Terminology \& Notation](#术语与符号规范--terminology--notation)
  - [交叉引用导航 / Cross-References](#交叉引用导航--cross-references)
  - [快速导航 / Quick Links](#快速导航--quick-links)
- [目录 (Table of Contents)](#目录-table-of-contents)
- [1. 基本概念 (Basic Concepts)](#1-基本概念-basic-concepts)
  - [1.0 构造性函数论基础 / Constructive Function Theory Foundation](#10-构造性函数论基础--constructive-function-theory-foundation)
    - [1.0.1 构造性函数定义 / Constructive Function Definition](#101-构造性函数定义--constructive-function-definition)
    - [1.0.2 构造性函数的基本性质 / Basic Properties of Constructive Functions](#102-构造性函数的基本性质--basic-properties-of-constructive-functions)
    - [1.0.3 构造性函数与经典函数的比较 / Comparison between Constructive and Classical Functions](#103-构造性函数与经典函数的比较--comparison-between-constructive-and-classical-functions)
  - [1.1 函数定义 (Function Definition)](#11-函数定义-function-definition)
  - [1.2 函数图像 (Function Graph)](#12-函数图像-function-graph)
- [2. 函数类型 (Function Types)](#2-函数类型-function-types)
  - [2.1 单射函数 (Injective Functions)](#21-单射函数-injective-functions)
  - [2.2 满射函数 (Surjective Functions)](#22-满射函数-surjective-functions)
  - [2.3 双射函数 (Bijective Functions)](#23-双射函数-bijective-functions)
  - [2.4 常数函数 (Constant Functions)](#24-常数函数-constant-functions)
  - [2.5 恒等函数 (Identity Functions)](#25-恒等函数-identity-functions)
- [3. 函数运算 (Function Operations)](#3-函数运算-function-operations)
  - [3.1 函数复合 (Function Composition)](#31-函数复合-function-composition)
  - [3.2 逆函数 (Inverse Functions)](#32-逆函数-inverse-functions)
  - [3.3 函数限制 (Function Restriction)](#33-函数限制-function-restriction)
  - [3.4 函数延拓 (Function Extension)](#34-函数延拓-function-extension)
- [4. 函数空间 (Function Spaces)](#4-函数空间-function-spaces)
  - [4.1 函数集合 (Function Sets)](#41-函数集合-function-sets)
  - [4.2 连续函数空间 (Continuous Function Spaces)](#42-连续函数空间-continuous-function-spaces)
  - [4.3 可测函数空间 (Measurable Function Spaces)](#43-可测函数空间-measurable-function-spaces)
- [5. 函数极限 (Function Limits)](#5-函数极限-function-limits)
  - [5.1 序列极限 (Sequence Limits)](#51-序列极限-sequence-limits)
  - [5.2 函数极限 (Function Limits)](#52-函数极限-function-limits)
  - [5.3 单侧极限 (One-Sided Limits)](#53-单侧极限-one-sided-limits)
- [6. 函数连续性 (Function Continuity)](#6-函数连续性-function-continuity)
  - [6.1 连续性定义 (Continuity Definition)](#61-连续性定义-continuity-definition)
  - [6.2 一致连续性 (Uniform Continuity)](#62-一致连续性-uniform-continuity)
  - [6.3 连续函数性质 (Continuous Function Properties)](#63-连续函数性质-continuous-function-properties)
- [7. 实现示例 (Implementation Examples)](#7-实现示例-implementation-examples)
  - [7.1 基本函数实现 (Basic Function Implementation)](#71-基本函数实现-basic-function-implementation)
  - [7.2 函数类型检查 (Function Type Checking)](#72-函数类型检查-function-type-checking)
  - [7.3 函数复合实现 (Function Composition Implementation)](#73-函数复合实现-function-composition-implementation)
  - [7.4 函数限制和延拓 (Function Restriction and Extension)](#74-函数限制和延拓-function-restriction-and-extension)
  - [7.5 函数空间实现 (Function Space Implementation)](#75-函数空间实现-function-space-implementation)
  - [7.6 函数极限计算 (Function Limit Calculation)](#76-函数极限计算-function-limit-calculation)
- [8. 参考文献 (References)](#8-参考文献-references)

---

## 1. 基本概念 (Basic Concepts)

### 1.0 构造性函数论基础 / Constructive Function Theory Foundation

#### 1.0.1 构造性函数定义 / Constructive Function Definition

**构造性函数论哲学 / Philosophy of Constructive Function Theory:**

构造性函数论强调函数的构造性本质，认为函数不仅是抽象的数学对象，更是可以通过具体算法构造的实体。
Constructive function theory emphasizes the constructive nature of functions, viewing functions not only as abstract mathematical objects but also as entities that can be constructed through specific algorithms.

**构造性函数的基本思想 / Basic Ideas of Constructive Functions:**

1. **构造性存在 / Constructive Existence:**
   - 函数的存在必须通过构造来证明
   - 不能仅通过非构造性方法证明存在
   - Function existence must be proven through construction
   - Cannot be proven to exist through non-constructive methods alone

2. **算法实现 / Algorithmic Implementation:**
   - 每个函数都必须有具体的算法实现
   - 函数与算法在本质上是等价的
   - Each function must have a concrete algorithmic implementation
   - Functions and algorithms are essentially equivalent

3. **可计算性 / Computability:**
   - 所有构造性函数都必须是可计算的
   - 强调函数的实际可执行性
   - All constructive functions must be computable
   - Emphasizes the actual executability of functions

**构造性函数的严格定义 / Strict Definition of Constructive Functions:**

**定义 1.0.1** (构造性函数 / Constructive Function)
构造性函数是从集合 $A$ 到集合 $B$ 的映射，存在算法 $\mathcal{A}$ 使得对于任意 $a \in A$，$\mathcal{A}(a) = f(a)$。
**Definition 1.0.1** (Constructive Function)
A constructive function is a mapping from set $A$ to set $B$ such that there exists an algorithm $\mathcal{A}$ where for any $a \in A$, $\mathcal{A}(a) = f(a)$.

**形式化表示 / Formal Representation:**
$$f: A \rightarrow B \text{ is constructive} \iff \exists \mathcal{A}: \forall a \in A, \mathcal{A}(a) = f(a)$$

**构造性函数的等价定义 / Equivalent Definitions of Constructive Functions:**

**定理 1.0.1** (构造性函数等价性) 以下定义等价：
**Theorem 1.0.1** (Constructive Function Equivalence) The following definitions are equivalent:

1. **算法定义 / Algorithmic Definition:**
   $f$ 是构造性函数当且仅当存在算法 $\mathcal{A}$ 计算 $f$
   $f$ is a constructive function if and only if there exists an algorithm $\mathcal{A}$ that computes $f$

2. **图灵机定义 / Turing Machine Definition:**
   $f$ 是构造性函数当且仅当存在图灵机 $M$ 计算 $f$
   $f$ is a constructive function if and only if there exists a Turing machine $M$ that computes $f$

3. **递归函数定义 / Recursive Function Definition:**
   $f$ 是构造性函数当且仅当 $f$ 是递归函数
   $f$ is a constructive function if and only if $f$ is a recursive function

**证明 / Proof:**

**步骤1：算法定义蕴含图灵机定义 / Step 1: Algorithmic Definition Implies Turing Machine Definition**
任何算法都可以由图灵机模拟，因此算法定义蕴含图灵机定义。
Any algorithm can be simulated by a Turing machine, so the algorithmic definition implies the Turing machine definition.

**步骤2：图灵机定义蕴含递归函数定义 / Step 2: Turing Machine Definition Implies Recursive Function Definition**
图灵可计算函数等价于递归函数，因此图灵机定义蕴含递归函数定义。
Turing computable functions are equivalent to recursive functions, so the Turing machine definition implies the recursive function definition.

**步骤3：递归函数定义蕴含算法定义 / Step 3: Recursive Function Definition Implies Algorithmic Definition**
递归函数可以通过算法实现，因此递归函数定义蕴含算法定义。
Recursive functions can be implemented by algorithms, so the recursive function definition implies the algorithmic definition.

#### 1.0.2 构造性函数的基本性质 / Basic Properties of Constructive Functions

**构造性函数的代数结构 / Algebraic Structure of Constructive Functions:**

**定理 1.0.2** (构造性函数代数) 构造性函数在复合运算下构成一个幺半群。
**Theorem 1.0.2** (Constructive Function Algebra) Constructive functions form a monoid under composition.

**证明 / Proof:**

1. **封闭性 / Closure:**
   如果 $f: A \rightarrow B$ 和 $g: B \rightarrow C$ 都是构造性的，那么 $g \circ f: A \rightarrow C$ 也是构造性的。
   If $f: A \rightarrow B$ and $g: B \rightarrow C$ are both constructive, then $g \circ f: A \rightarrow C$ is also constructive.

2. **结合律 / Associativity:**
   $(h \circ g) \circ f = h \circ (g \circ f)$ 对所有构造性函数 $f, g, h$ 成立。
   $(h \circ g) \circ f = h \circ (g \circ f)$ holds for all constructive functions $f, g, h$.

3. **单位元 / Identity:**
   恒等函数 $id_A: A \rightarrow A$ 是构造性的，且对所有构造性函数 $f: A \rightarrow B$，$f \circ id_A = id_B \circ f = f$。
   The identity function $id_A: A \rightarrow A$ is constructive, and for all constructive functions $f: A \rightarrow B$, $f \circ id_A = id_B \circ f = f$.

**构造性函数的可计算性 / Computability of Constructive Functions:**

**定理 1.0.3** (构造性函数可计算性) 所有构造性函数都是可计算的。
**Theorem 1.0.3** (Computability of Constructive Functions) All constructive functions are computable.

**证明 / Proof:**
由构造性函数的定义，每个构造性函数都有对应的算法实现，因此是可计算的。
By the definition of constructive functions, each constructive function has a corresponding algorithmic implementation, so it is computable.

**构造性函数的复杂度 / Complexity of Constructive Functions:**

**定义 1.0.2** (构造性函数复杂度) 构造性函数 $f$ 的复杂度是计算 $f$ 所需的最少计算步骤数。
**Definition 1.0.2** (Complexity of Constructive Functions) The complexity of a constructive function $f$ is the minimum number of computational steps required to compute $f$.

**形式化表示 / Formal Representation:**
$$\text{Complexity}(f) = \min_{\mathcal{A}} \{\text{Steps}(\mathcal{A}, x) \mid \mathcal{A} \text{ computes } f, x \in \text{dom}(f)\}$$

#### 1.0.3 构造性函数与经典函数的比较 / Comparison between Constructive and Classical Functions

**经典函数论观点 / Classical Function Theory View:**

- 函数是抽象的数学对象
- 不要求具体的算法实现
- 允许非构造性的存在性证明
- Functions are abstract mathematical objects
- Do not require concrete algorithmic implementation
- Allow non-constructive existence proofs

**构造性函数论观点 / Constructive Function Theory View:**

- 函数必须通过算法构造
- 强调实际的可计算性
- 只允许构造性的存在性证明
- Functions must be constructed through algorithms
- Emphasize actual computability
- Only allow constructive existence proofs

**构造性函数论的优势 / Advantages of Constructive Function Theory:**

1. **实际可操作性 / Practical Operability:**
   - 所有函数都可以实际计算
   - 避免了纯理论的存在性
   - All functions can be actually computed
   - Avoids purely theoretical existence

2. **算法指导性 / Algorithmic Guidance:**
   - 为算法设计提供理论基础
   - 强调构造性思维
   - Provide theoretical foundation for algorithm design
   - Emphasize constructive thinking

3. **计算复杂性 / Computational Complexity:**
   - 自然引入复杂度分析
   - 关注实际计算效率
   - Naturally introduce complexity analysis
   - Focus on actual computational efficiency

### 1.1 函数定义 (Function Definition)

**定义 1.1.1** (函数 / Function)
函数是从集合 $A$ 到集合 $B$ 的映射，记作 $f: A \rightarrow B$。

**Definition 1.1.1** (Function)
A function is a mapping from set $A$ to set $B$, denoted by $f: A \rightarrow B$.

**形式化表示 (Formal Representation):**
$$f: A \rightarrow B \iff \forall a \in A, \exists! b \in B, f(a) = b$$

其中 $\exists!$ 表示存在唯一的。

where $\exists!$ means "there exists a unique".

**定义 1.1.2** (定义域 / Domain)
函数 $f: A \rightarrow B$ 的定义域是集合 $A$，记作 $\text{dom}(f) = A$。

**Definition 1.1.2** (Domain)
The domain of function $f: A \rightarrow B$ is set $A$, denoted by $\text{dom}(f) = A$.

**定义 1.1.3** (陪域 / Codomain)
函数 $f: A \rightarrow B$ 的陪域是集合 $B$，记作 $\text{codom}(f) = B$。

**Definition 1.1.3** (Codomain)
The codomain of function $f: A \rightarrow B$ is set $B$, denoted by $\text{codom}(f) = B$.

**定义 1.1.4** (值域 / Range)
函数 $f: A \rightarrow B$ 的值域是 $B$ 中所有被映射到的元素的集合。

**Definition 1.1.4** (Range)
The range of function $f: A \rightarrow B$ is the set of all elements in $B$ that are mapped to.

**形式化表示 (Formal Representation):**
$$\text{range}(f) = \{f(a) \mid a \in A\}$$

### 1.2 函数图像 (Function Graph)

**定义 1.2.1** (函数图像 / Function Graph)
函数 $f: A \rightarrow B$ 的图像是笛卡尔积 $A \times B$ 的子集。

**Definition 1.2.1** (Function Graph)
The graph of function $f: A \rightarrow B$ is a subset of the Cartesian product $A \times B$.

**形式化表示 (Formal Representation):**
$$\text{graph}(f) = \{(a, f(a)) \mid a \in A\}$$

**定理 1.2.1** (函数图像性质 / Function Graph Properties)
函数图像满足垂直直线测试：任何垂直线最多与图像相交一次。

**Theorem 1.2.1** (Function Graph Properties)
The function graph satisfies the vertical line test: any vertical line intersects the graph at most once.

---

## 2. 函数类型 (Function Types)

### 2.1 单射函数 (Injective Functions)

**定义 2.1.1** (单射函数 / Injective Function)
函数 $f: A \rightarrow B$ 是单射的，当且仅当不同的输入对应不同的输出。

**Definition 2.1.1** (Injective Function)
Function $f: A \rightarrow B$ is injective if and only if different inputs correspond to different outputs.

**形式化表示 (Formal Representation):**
$$\forall x_1, x_2 \in A, f(x_1) = f(x_2) \rightarrow x_1 = x_2$$

**等价定义 (Equivalent Definition):**
$$\forall x_1, x_2 \in A, x_1 \neq x_2 \rightarrow f(x_1) \neq f(x_2)$$

### 2.2 满射函数 (Surjective Functions)

**定义 2.2.1** (满射函数 / Surjective Function)
函数 $f: A \rightarrow B$ 是满射的，当且仅当 $B$ 的每个元素都是某个 $A$ 中元素的像。

**Definition 2.2.1** (Surjective Function)
Function $f: A \rightarrow B$ is surjective if and only if every element of $B$ is the image of some element of $A$.

**形式化表示 (Formal Representation):**
$$\forall y \in B, \exists x \in A, f(x) = y$$

**等价定义 (Equivalent Definition):**
$$\text{range}(f) = B$$

### 2.3 双射函数 (Bijective Functions)

**定义 2.3.1** (双射函数 / Bijective Function)
函数 $f: A \rightarrow B$ 是双射的，当且仅当它既是单射又是满射。

**Definition 2.3.1** (Bijective Function)
Function $f: A \rightarrow B$ is bijective if and only if it is both injective and surjective.

**定理 2.3.1** (双射函数性质 / Bijective Function Properties)
双射函数存在唯一的逆函数。

**Theorem 2.3.1** (Bijective Function Properties)
A bijective function has a unique inverse function.

### 2.4 常数函数 (Constant Functions)

**定义 2.4.1** (常数函数 / Constant Function)
函数 $f: A \rightarrow B$ 是常数函数，当且仅当存在 $c \in B$ 使得 $\forall x \in A, f(x) = c$。

**Definition 2.4.1** (Constant Function)
Function $f: A \rightarrow B$ is a constant function if and only if there exists $c \in B$ such that $\forall x \in A, f(x) = c$.

**形式化表示 (Formal Representation):**
$$\exists c \in B, \forall x \in A, f(x) = c$$

### 2.5 恒等函数 (Identity Functions)

**定义 2.5.1** (恒等函数 / Identity Function)
集合 $A$ 上的恒等函数是 $I_A: A \rightarrow A$，定义为 $\forall x \in A, I_A(x) = x$。

**Definition 2.5.1** (Identity Function)
The identity function on set $A$ is $I_A: A \rightarrow A$ defined by $\forall x \in A, I_A(x) = x$.

---

## 3. 函数运算 (Function Operations)

### 3.1 函数复合 (Function Composition)

**定义 3.1.1** (函数复合 / Function Composition)
函数 $f: A \rightarrow B$ 和 $g: B \rightarrow C$ 的复合是函数 $g \circ f: A \rightarrow C$。

**Definition 3.1.1** (Function Composition)
The composition of functions $f: A \rightarrow B$ and $g: B \rightarrow C$ is the function $g \circ f: A \rightarrow C$.

**形式化表示 (Formal Representation):**
$$\forall x \in A, (g \circ f)(x) = g(f(x))$$

**定理 3.1.1** (复合函数性质 / Composition Properties)

1. **结合律 (Associativity)**: $(h \circ g) \circ f = h \circ (g \circ f)$
2. **单位元 (Identity)**: $f \circ I_A = f = I_B \circ f$

**Theorem 3.1.1** (Composition Properties)

1. **Associativity**: $(h \circ g) \circ f = h \circ (g \circ f)$
2. **Identity**: $f \circ I_A = f = I_B \circ f$

### 3.2 逆函数 (Inverse Functions)

**定义 3.2.1** (逆函数 / Inverse Function)
函数 $f: A \rightarrow B$ 的逆函数是函数 $f^{-1}: B \rightarrow A$，满足：
$$f^{-1} \circ f = I_A \text{ and } f \circ f^{-1} = I_B$$

**Definition 3.2.1** (Inverse Function)
The inverse function of $f: A \rightarrow B$ is the function $f^{-1}: B \rightarrow A$ such that:
$$f^{-1} \circ f = I_A \text{ and } f \circ f^{-1} = I_B$$

**定理 3.2.1** (逆函数存在性 / Inverse Function Existence)
函数存在逆函数当且仅当它是双射的。

**Theorem 3.2.1** (Inverse Function Existence)
A function has an inverse if and only if it is bijective.

### 3.3 函数限制 (Function Restriction)

**定义 3.3.1** (函数限制 / Function Restriction)
函数 $f: A \rightarrow B$ 在子集 $S \subseteq A$ 上的限制是函数 $f|_S: S \rightarrow B$。

**Definition 3.3.1** (Function Restriction)
The restriction of function $f: A \rightarrow B$ to subset $S \subseteq A$ is the function $f|_S: S \rightarrow B$.

**形式化表示 (Formal Representation):**
$$\forall x \in S, f|_S(x) = f(x)$$

### 3.4 函数延拓 (Function Extension)

**定义 3.3.2** (函数延拓 / Function Extension)
函数 $g: A \rightarrow B$ 是函数 $f: S \rightarrow B$ 的延拓，当且仅当 $S \subseteq A$ 且 $g|_S = f$。

**Definition 3.3.2** (Function Extension)
Function $g: A \rightarrow B$ is an extension of function $f: S \rightarrow B$ if and only if $S \subseteq A$ and $g|_S = f$.

---

## 4. 函数空间 (Function Spaces)

### 4.1 函数集合 (Function Sets)

**定义 4.1.1** (函数空间 / Function Space)
从集合 $A$ 到集合 $B$ 的所有函数的集合记作 $B^A$。

**Definition 4.1.1** (Function Space)
The set of all functions from set $A$ to set $B$ is denoted by $B^A$.

**形式化表示 (Formal Representation):**
$$B^A = \{f \mid f: A \rightarrow B\}$$

**定理 4.1.1** (函数空间基数 / Function Space Cardinality)
如果 $|A| = m$ 且 $|B| = n$，则 $|B^A| = n^m$。

**Theorem 4.1.1** (Function Space Cardinality)
If $|A| = m$ and $|B| = n$, then $|B^A| = n^m$.

### 4.2 连续函数空间 (Continuous Function Spaces)

**定义 4.2.1** (连续函数空间 / Continuous Function Space)
从拓扑空间 $X$ 到拓扑空间 $Y$ 的所有连续函数的集合记作 $C(X, Y)$。

**Definition 4.2.1** (Continuous Function Space)
The set of all continuous functions from topological space $X$ to topological space $Y$ is denoted by $C(X, Y)$.

**形式化表示 (Formal Representation):**
$$C(X, Y) = \{f: X \rightarrow Y \mid f \text{ is continuous}\}$$

### 4.3 可测函数空间 (Measurable Function Spaces)

**定义 4.3.1** (可测函数空间 / Measurable Function Space)
从可测空间 $(X, \mathcal{A})$ 到可测空间 $(Y, \mathcal{B})$ 的所有可测函数的集合。

**Definition 4.3.1** (Measurable Function Space)
The set of all measurable functions from measurable space $(X, \mathcal{A})$ to measurable space $(Y, \mathcal{B})$.

**形式化表示 (Formal Representation):**
$$\mathcal{M}(X, Y) = \{f: X \rightarrow Y \mid f \text{ is measurable}\}$$

---

## 5. 函数极限 (Function Limits)

### 5.1 序列极限 (Sequence Limits)

**定义 5.1.1** (序列极限 / Sequence Limit)
序列 $\{a_n\}$ 收敛到 $L$，记作 $\lim_{n \to \infty} a_n = L$，当且仅当：
$$\forall \epsilon > 0, \exists N \in \mathbb{N}, \forall n \geq N, |a_n - L| < \epsilon$$

**Definition 5.1.1** (Sequence Limit)
Sequence $\{a_n\}$ converges to $L$, written $\lim_{n \to \infty} a_n = L$, if and only if:
$$\forall \epsilon > 0, \exists N \in \mathbb{N}, \forall n \geq N, |a_n - L| < \epsilon$$

### 5.2 函数极限 (Function Limits)

**定义 5.2.1** (函数极限 / Function Limit)
函数 $f$ 在点 $a$ 的极限是 $L$，记作 $\lim_{x \to a} f(x) = L$，当且仅当：
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, 0 < |x - a| < \delta \rightarrow |f(x) - L| < \epsilon$$

**Definition 5.2.1** (Function Limit)
The limit of function $f$ at point $a$ is $L$, written $\lim_{x \to a} f(x) = L$, if and only if:
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, 0 < |x - a| < \delta \rightarrow |f(x) - L| < \epsilon$$

**定理 5.2.1** (极限唯一性 / Limit Uniqueness)
如果函数在一点存在极限，则极限是唯一的。

**Theorem 5.2.1** (Limit Uniqueness)
If a function has a limit at a point, then the limit is unique.

### 5.3 单侧极限 (One-Sided Limits)

**定义 5.3.1** (右极限 / Right Limit)
函数 $f$ 在点 $a$ 的右极限是 $L$，记作 $\lim_{x \to a^+} f(x) = L$，当且仅当：
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, a < x < a + \delta \rightarrow |f(x) - L| < \epsilon$$

**Definition 5.3.1** (Right Limit)
The right limit of function $f$ at point $a$ is $L$, written $\lim_{x \to a^+} f(x) = L$, if and only if:
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, a < x < a + \delta \rightarrow |f(x) - L| < \epsilon$$

**定义 5.3.2** (左极限 / Left Limit)
函数 $f$ 在点 $a$ 的左极限是 $L$，记作 $\lim_{x \to a^-} f(x) = L$，当且仅当：
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, a - \delta < x < a \rightarrow |f(x) - L| < \epsilon$$

**Definition 5.3.2** (Left Limit)
The left limit of function $f$ at point $a$ is $L$, written $\lim_{x \to a^-} f(x) = L$, if and only if:
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, a - \delta < x < a \rightarrow |f(x) - L| < \epsilon$$

---

## 6. 函数连续性 (Function Continuity)

### 6.1 连续性定义 (Continuity Definition)

**定义 6.1.1** (函数连续性 / Function Continuity)
函数 $f$ 在点 $a$ 连续，当且仅当：
$$\lim_{x \to a} f(x) = f(a)$$

**Definition 6.1.1** (Function Continuity)
Function $f$ is continuous at point $a$ if and only if:
$$\lim_{x \to a} f(x) = f(a)$$

**等价定义 (Equivalent Definition):**
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, |x - a| < \delta \rightarrow |f(x) - f(a)| < \epsilon$$

### 6.2 一致连续性 (Uniform Continuity)

**定义 6.2.1** (一致连续性 / Uniform Continuity)
函数 $f$ 在集合 $A$ 上一致连续，当且仅当：
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, y \in A, |x - y| < \delta \rightarrow |f(x) - f(y)| < \epsilon$$

**Definition 6.2.1** (Uniform Continuity)
Function $f$ is uniformly continuous on set $A$ if and only if:
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, y \in A, |x - y| < \delta \rightarrow |f(x) - f(y)| < \epsilon$$

**定理 6.2.1** (一致连续性定理 / Uniform Continuity Theorem)
在紧集上的连续函数是一致连续的。

**Theorem 6.2.1** (Uniform Continuity Theorem)
A continuous function on a compact set is uniformly continuous.

### 6.3 连续函数性质 (Continuous Function Properties)

**定理 6.3.1** (连续函数运算 / Continuous Function Operations)
如果 $f$ 和 $g$ 在点 $a$ 连续，则：

1. $f + g$ 在点 $a$ 连续
2. $f \cdot g$ 在点 $a$ 连续
3. $f/g$ 在点 $a$ 连续（如果 $g(a) \neq 0$）

**Theorem 6.3.1** (Continuous Function Operations)
If $f$ and $g$ are continuous at point $a$, then:

1. $f + g$ is continuous at point $a$
2. $f \cdot g$ is continuous at point $a$
3. $f/g$ is continuous at point $a$ (if $g(a) \neq 0$)

**定理 6.3.2** (复合函数连续性 / Composition Continuity)
如果 $f$ 在点 $a$ 连续，$g$ 在点 $f(a)$ 连续，则 $g \circ f$ 在点 $a$ 连续。

**Theorem 6.3.2** (Composition Continuity)
If $f$ is continuous at point $a$ and $g$ is continuous at point $f(a)$, then $g \circ f$ is continuous at point $a$.

---

## 7. 实现示例 (Implementation Examples)

### 7.1 基本函数实现 (Basic Function Implementation)

```rust
use std::collections::HashMap;

pub struct Function<D, R> {
    mapping: HashMap<D, R>,
    domain: Vec<D>,
    codomain: Vec<R>,
}

impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash> Function<D, R> {
    pub fn new(domain: Vec<D>, codomain: Vec<R>) -> Self {
        Function {
            mapping: HashMap::new(),
            domain,
            codomain,
        }
    }
    
    pub fn add_mapping(&mut self, input: D, output: R) -> Result<(), String> {
        if !self.domain.contains(&input) {
            return Err("Input not in domain".to_string());
        }
        if !self.codomain.contains(&output) {
            return Err("Output not in codomain".to_string());
        }
        self.mapping.insert(input, output);
        Ok(())
    }
    
    pub fn apply(&self, input: &D) -> Option<&R> {
        self.mapping.get(input)
    }
    
    pub fn get_domain(&self) -> &Vec<D> {
        &self.domain
    }
    
    pub fn get_codomain(&self) -> &Vec<R> {
        &self.codomain
    }
    
    pub fn get_range(&self) -> Vec<&R> {
        self.mapping.values().collect()
    }
}
```

### 7.2 函数类型检查 (Function Type Checking)

```rust
impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash> Function<D, R> {
    // 单射检查
    pub fn is_injective(&self) -> bool {
        let mut seen_outputs = std::collections::HashSet::new();
        for output in self.mapping.values() {
            if seen_outputs.contains(output) {
                return false;
            }
            seen_outputs.insert(output);
        }
        true
    }
    
    // 满射检查
    pub fn is_surjective(&self) -> bool {
        let outputs: std::collections::HashSet<&R> = self.mapping.values().collect();
        outputs.len() == self.codomain.len()
    }
    
    // 双射检查
    pub fn is_bijective(&self) -> bool {
        self.is_injective() && self.is_surjective()
    }
    
    // 常数函数检查
    pub fn is_constant(&self) -> bool {
        if self.mapping.is_empty() {
            return true;
        }
        let first_output = self.mapping.values().next().unwrap();
        self.mapping.values().all(|output| output == first_output)
    }
}
```

### 7.3 函数复合实现 (Function Composition Implementation)

```rust
impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash, S: Clone + Eq + std::hash::Hash> Function<D, R> {
    // 函数复合
    pub fn compose<S>(&self, other: &Function<R, S>) -> Function<D, S> {
        let mut composition = Function::new(
            self.domain.clone(),
            other.codomain.clone(),
        );
        
        for (input, output) in &self.mapping {
            if let Some(final_output) = other.apply(output) {
                composition.add_mapping(input.clone(), final_output.clone()).unwrap();
            }
        }
        
        composition
    }
    
    // 逆函数（仅对双射函数）
    pub fn inverse(&self) -> Result<Function<R, D>, String> {
        if !self.is_bijective() {
            return Err("Function is not bijective".to_string());
        }
        
        let mut inverse = Function::new(
            self.codomain.clone(),
            self.domain.clone(),
        );
        
        for (input, output) in &self.mapping {
            inverse.add_mapping(output.clone(), input.clone()).unwrap();
        }
        
        Ok(inverse)
    }
}
```

### 7.4 函数限制和延拓 (Function Restriction and Extension)

```rust
impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash> Function<D, R> {
    // 函数限制
    pub fn restrict(&self, subset: &[D]) -> Function<D, R> {
        let mut restriction = Function::new(
            subset.to_vec(),
            self.codomain.clone(),
        );
        
        for input in subset {
            if let Some(output) = self.apply(input) {
                restriction.add_mapping(input.clone(), output.clone()).unwrap();
            }
        }
        
        restriction
    }
    
    // 函数延拓
    pub fn extend(&self, extended_domain: Vec<D>, extended_codomain: Vec<R>) -> Function<D, R> {
        let mut extension = Function::new(extended_domain, extended_codomain);
        
        for (input, output) in &self.mapping {
            extension.add_mapping(input.clone(), output.clone()).unwrap();
        }
        
        extension
    }
}
```

### 7.5 函数空间实现 (Function Space Implementation)

```rust
pub struct FunctionSpace<D, R> {
    functions: Vec<Function<D, R>>,
}

impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash> FunctionSpace<D, R> {
    pub fn new() -> Self {
        FunctionSpace {
            functions: Vec::new(),
        }
    }
    
    pub fn add_function(&mut self, function: Function<D, R>) {
        self.functions.push(function);
    }
    
    pub fn get_functions(&self) -> &Vec<Function<D, R>> {
        &self.functions
    }
    
    // 计算函数空间基数
    pub fn cardinality(&self) -> usize {
        if self.functions.is_empty() {
            return 0;
        }
        
        let domain_size = self.functions[0].get_domain().len();
        let codomain_size = self.functions[0].get_codomain().len();
        codomain_size.pow(domain_size as u32)
    }
    
    // 查找特定类型的函数
    pub fn find_injective_functions(&self) -> Vec<&Function<D, R>> {
        self.functions.iter().filter(|f| f.is_injective()).collect()
    }
    
    pub fn find_surjective_functions(&self) -> Vec<&Function<D, R>> {
        self.functions.iter().filter(|f| f.is_surjective()).collect()
    }
    
    pub fn find_bijective_functions(&self) -> Vec<&Function<D, R>> {
        self.functions.iter().filter(|f| f.is_bijective()).collect()
    }
}
```

### 7.6 函数极限计算 (Function Limit Calculation)

```rust
pub struct LimitCalculator;

impl LimitCalculator {
    // 序列极限
    pub fn sequence_limit(sequence: &[f64], target: f64, epsilon: f64) -> bool {
        let mut n = 0;
        while n < sequence.len() {
            if (sequence[n] - target).abs() < epsilon {
                return true;
            }
            n += 1;
        }
        false
    }
    
    // 函数极限（数值逼近）
    pub fn function_limit<F>(f: F, point: f64, target: f64, epsilon: f64) -> bool
    where
        F: Fn(f64) -> f64,
    {
        let delta = epsilon / 100.0; // 简化的delta选择
        let x1 = point - delta;
        let x2 = point + delta;
        
        (f(x1) - target).abs() < epsilon && (f(x2) - target).abs() < epsilon
    }
    
    // 连续性检查
    pub fn is_continuous<F>(f: F, point: f64, epsilon: f64) -> bool
    where
        F: Fn(f64) -> f64,
    {
        let limit = f(point);
        Self::function_limit(&f, point, limit, epsilon)
    }
}
```

---

## 8. 参考文献 (References)

本文档基于已发表的学术文献和公开资料编写。以下是主要参考文献：

**经典教材 / Classic Textbooks**:

1. [Rudin1976] Rudin, W. (1976). *Principles of Mathematical Analysis* (3rd Edition). McGraw-Hill. ISBN: 978-0070542358.
   - 实分析的经典教材，简称"Baby Rudin"，提供了严格的函数论基础，包括连续性、极限、一致收敛等核心概念。

2. [Apostol1974] Apostol, T. M. (1974). *Mathematical Analysis* (2nd Edition). Addison-Wesley. ISBN: 978-0201002881.
   - 经典的数学分析教材，详细介绍了函数的各种性质和运算，特别是连续函数和可测函数。

3. [Munkres2000] Munkres, J. R. (2000). *Topology* (2nd Edition). Prentice Hall. ISBN: 978-0131816299.
   - 拓扑学的标准教材，详细讨论了连续函数、函数空间和拓扑性质。

**可计算性理论 / Computability Theory**:

1. [Kleene1952] Kleene, S. C. (1952). *Introduction to Metamathematics*. North-Holland.
   - 递归函数论的奠基性著作，定义了可计算函数和递归函数，为构造性函数论提供了基础。

2. [Rogers1987] Rogers, H., Jr. (1987). *Theory of Recursive Functions and Effective Computability*. MIT Press. ISBN: 978-0262680523.
   - 递归函数论的权威教材，详细论述了可计算函数、递归函数和有效可计算性。

**计算模型 / Computation Models**:

1. [Turing1936] Turing, A. M. (1936). "On Computable Numbers, with an Application to the Entscheidungsproblem". *Proceedings of the London Mathematical Society*, s2-42(1), 230-265. DOI: 10.1112/plms/s2-42.1.230.
   - 计算理论的奠基性论文，首次定义了图灵机模型，为构造性函数提供了算法基础。

2. [Church1936] Church, A. (1936). "An Unsolvable Problem of Elementary Number Theory". *American Journal of Mathematics*, 58(2), 345-363. DOI: 10.2307/2371045.
   - 提出了Church论题和λ演算，为函数的算法定义提供了另一种形式化框架。

**延伸阅读 / Further Reading**:

1. Royden, H. L., & Fitzpatrick, P. M. (2010). *Real Analysis* (4th Edition). Prentice Hall.
   - 实分析的现代教材，包含测度论和可测函数空间的深入讨论。

2. Folland, G. B. (1999). *Real Analysis: Modern Techniques and Their Applications* (2nd Edition). Wiley.
   - 高级实分析教材，介绍现代分析技术及其应用。

3. Lang, S. (1993). *Real and Functional Analysis* (3rd Edition). Springer.
    - 实分析与泛函分析的综合教材，详细介绍函数空间理论。

**在线资源 / Online Resources**:

1. **Wikipedia - Function (Mathematics)**: <https://en.wikipedia.org/wiki/Function_(mathematics)>
   - 函数的Wikipedia条目，包含函数定义、定义域、值域等核心概念（截至2025年11月14日）。

2. **Wikipedia - Continuous Function**: <https://en.wikipedia.org/wiki/Continuous_function>
   - 连续函数的Wikipedia条目，详细介绍连续性的定义和性质（截至2025年11月14日）。

3. **Wikipedia - Bijection**: <https://en.wikipedia.org/wiki/Bijection>
   - 双射的Wikipedia条目，包含单射、满射和双射的关系（截至2025年11月14日）。

**引用规范说明 / Citation Guidelines**:

本文档遵循项目引用规范（见 `docs/引用规范与数据库.md`）。所有引用条目在 `docs/references_database.yaml` 中有完整记录。

本文档内容已对照Wikipedia相关条目（截至2025年11月14日）进行验证，确保术语定义和理论框架与当前学术标准一致。

---

**文档版本 / Document Version**: 1.1  
**最后更新 / Last Updated**: 2025-11-14  
**状态 / Status**: 已对照Wikipedia更新 / Updated with Wikipedia references (as of 2025-11-14)

---

*本文档严格遵循数学形式化规范，所有定义和定理均采用标准数学符号表示。*
*This document strictly follows mathematical formalization standards, with all definitions and theorems using standard mathematical notation.*
