---
title: 1.4 å‡½æ•°è®ºåŸºç¡€ / Function Theory Foundation
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: åŸºç¡€ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 1.4 å‡½æ•°è®ºåŸºç¡€ / Function Theory Foundation

### æ‘˜è¦ / Executive Summary

- å»ºç«‹å‡½æ•°è®ºçš„åŸºç¡€ç†è®ºï¼Œç»Ÿä¸€å‡½æ•°ã€æ˜ å°„ã€å¤åˆç­‰æ ¸å¿ƒæ¦‚å¿µã€‚
- å»ºç«‹å‡½æ•°è®ºåœ¨ç®—æ³•ç†è®ºä¸­çš„åŸºç¡€åœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- å‡½æ•°ã€æ˜ å°„ã€å¤åˆã€åå‡½æ•°ã€å•å°„ã€æ»¡å°„ã€åŒå°„ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- å‡½æ•°ï¼ˆFunctionï¼‰ï¼šä»å®šä¹‰åŸŸåˆ°å€¼åŸŸçš„æ˜ å°„ã€‚
- æ˜ å°„ï¼ˆMappingï¼‰ï¼šå‡½æ•°çš„åŒä¹‰è¯ã€‚
- å¤åˆï¼ˆCompositionï¼‰ï¼šå‡½æ•°çš„å¤åˆè¿ç®—ã€‚
- åå‡½æ•°ï¼ˆInverse Functionï¼‰ï¼šå‡½æ•°çš„é€†æ˜ å°„ã€‚
- è®°å·çº¦å®šï¼š`f` è¡¨ç¤ºå‡½æ•°ï¼Œ`f: A â†’ B` è¡¨ç¤ºä»Aåˆ°Bçš„å‡½æ•°ï¼Œ`fâˆ˜g` è¡¨ç¤ºå¤åˆã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- é›†åˆè®ºåŸºç¡€ï¼šå‚è§ `01-åŸºç¡€ç†è®º/03-é›†åˆè®ºåŸºç¡€.md`ã€‚
- æ•°å­¦åŸºç¡€ï¼šå‚è§ `01-åŸºç¡€ç†è®º/02-æ•°å­¦åŸºç¡€.md`ã€‚
- å½¢å¼åŒ–å®šä¹‰ï¼šå‚è§ `01-åŸºç¡€ç†è®º/01-å½¢å¼åŒ–å®šä¹‰.md`ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- å‡½æ•°æ€§è´¨
- å‡½æ•°è¿ç®—

## ç›®å½• (Table of Contents)

- [1.4 å‡½æ•°è®ºåŸºç¡€ / Function Theory Foundation](#14-å‡½æ•°è®ºåŸºç¡€--function-theory-foundation)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.0 æ„é€ æ€§å‡½æ•°è®ºåŸºç¡€ / Constructive Function Theory Foundation](#10-æ„é€ æ€§å‡½æ•°è®ºåŸºç¡€--constructive-function-theory-foundation)
    - [1.0.1 æ„é€ æ€§å‡½æ•°å®šä¹‰ / Constructive Function Definition](#101-æ„é€ æ€§å‡½æ•°å®šä¹‰--constructive-function-definition)
    - [1.0.2 æ„é€ æ€§å‡½æ•°çš„åŸºæœ¬æ€§è´¨ / Basic Properties of Constructive Functions](#102-æ„é€ æ€§å‡½æ•°çš„åŸºæœ¬æ€§è´¨--basic-properties-of-constructive-functions)
    - [1.0.3 æ„é€ æ€§å‡½æ•°ä¸ç»å…¸å‡½æ•°çš„æ¯”è¾ƒ / Comparison between Constructive and Classical Functions](#103-æ„é€ æ€§å‡½æ•°ä¸ç»å…¸å‡½æ•°çš„æ¯”è¾ƒ--comparison-between-constructive-and-classical-functions)
  - [1.1 å‡½æ•°å®šä¹‰ (Function Definition)](#11-å‡½æ•°å®šä¹‰-function-definition)
  - [1.2 å‡½æ•°å›¾åƒ (Function Graph)](#12-å‡½æ•°å›¾åƒ-function-graph)
- [2. å‡½æ•°ç±»å‹ (Function Types)](#2-å‡½æ•°ç±»å‹-function-types)
  - [2.1 å•å°„å‡½æ•° (Injective Functions)](#21-å•å°„å‡½æ•°-injective-functions)
  - [2.2 æ»¡å°„å‡½æ•° (Surjective Functions)](#22-æ»¡å°„å‡½æ•°-surjective-functions)
  - [2.3 åŒå°„å‡½æ•° (Bijective Functions)](#23-åŒå°„å‡½æ•°-bijective-functions)
  - [2.4 å¸¸æ•°å‡½æ•° (Constant Functions)](#24-å¸¸æ•°å‡½æ•°-constant-functions)
  - [2.5 æ’ç­‰å‡½æ•° (Identity Functions)](#25-æ’ç­‰å‡½æ•°-identity-functions)
- [3. å‡½æ•°è¿ç®— (Function Operations)](#3-å‡½æ•°è¿ç®—-function-operations)
  - [3.1 å‡½æ•°å¤åˆ (Function Composition)](#31-å‡½æ•°å¤åˆ-function-composition)
  - [3.2 é€†å‡½æ•° (Inverse Functions)](#32-é€†å‡½æ•°-inverse-functions)
  - [3.3 å‡½æ•°é™åˆ¶ (Function Restriction)](#33-å‡½æ•°é™åˆ¶-function-restriction)
  - [3.4 å‡½æ•°å»¶æ‹“ (Function Extension)](#34-å‡½æ•°å»¶æ‹“-function-extension)
- [4. å‡½æ•°ç©ºé—´ (Function Spaces)](#4-å‡½æ•°ç©ºé—´-function-spaces)
  - [4.1 å‡½æ•°é›†åˆ (Function Sets)](#41-å‡½æ•°é›†åˆ-function-sets)
  - [4.2 è¿ç»­å‡½æ•°ç©ºé—´ (Continuous Function Spaces)](#42-è¿ç»­å‡½æ•°ç©ºé—´-continuous-function-spaces)
  - [4.3 å¯æµ‹å‡½æ•°ç©ºé—´ (Measurable Function Spaces)](#43-å¯æµ‹å‡½æ•°ç©ºé—´-measurable-function-spaces)
- [5. å‡½æ•°æé™ (Function Limits)](#5-å‡½æ•°æé™-function-limits)
  - [5.1 åºåˆ—æé™ (Sequence Limits)](#51-åºåˆ—æé™-sequence-limits)
  - [5.2 å‡½æ•°æé™ (Function Limits)](#52-å‡½æ•°æé™-function-limits)
  - [5.3 å•ä¾§æé™ (One-Sided Limits)](#53-å•ä¾§æé™-one-sided-limits)
- [6. å‡½æ•°è¿ç»­æ€§ (Function Continuity)](#6-å‡½æ•°è¿ç»­æ€§-function-continuity)
  - [6.1 è¿ç»­æ€§å®šä¹‰ (Continuity Definition)](#61-è¿ç»­æ€§å®šä¹‰-continuity-definition)
  - [6.2 ä¸€è‡´è¿ç»­æ€§ (Uniform Continuity)](#62-ä¸€è‡´è¿ç»­æ€§-uniform-continuity)
  - [6.3 è¿ç»­å‡½æ•°æ€§è´¨ (Continuous Function Properties)](#63-è¿ç»­å‡½æ•°æ€§è´¨-continuous-function-properties)
- [7. å®ç°ç¤ºä¾‹ (Implementation Examples)](#7-å®ç°ç¤ºä¾‹-implementation-examples)
  - [7.1 åŸºæœ¬å‡½æ•°å®ç° (Basic Function Implementation)](#71-åŸºæœ¬å‡½æ•°å®ç°-basic-function-implementation)
  - [7.2 å‡½æ•°ç±»å‹æ£€æŸ¥ (Function Type Checking)](#72-å‡½æ•°ç±»å‹æ£€æŸ¥-function-type-checking)
  - [7.3 å‡½æ•°å¤åˆå®ç° (Function Composition Implementation)](#73-å‡½æ•°å¤åˆå®ç°-function-composition-implementation)
  - [7.4 å‡½æ•°é™åˆ¶å’Œå»¶æ‹“ (Function Restriction and Extension)](#74-å‡½æ•°é™åˆ¶å’Œå»¶æ‹“-function-restriction-and-extension)
  - [7.5 å‡½æ•°ç©ºé—´å®ç° (Function Space Implementation)](#75-å‡½æ•°ç©ºé—´å®ç°-function-space-implementation)
  - [7.6 å‡½æ•°æé™è®¡ç®— (Function Limit Calculation)](#76-å‡½æ•°æé™è®¡ç®—-function-limit-calculation)
- [8. å‚è€ƒæ–‡çŒ® (References)](#8-å‚è€ƒæ–‡çŒ®-references)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.0 æ„é€ æ€§å‡½æ•°è®ºåŸºç¡€ / Constructive Function Theory Foundation

#### 1.0.1 æ„é€ æ€§å‡½æ•°å®šä¹‰ / Constructive Function Definition

**æ„é€ æ€§å‡½æ•°è®ºå“²å­¦ / Philosophy of Constructive Function Theory:**

æ„é€ æ€§å‡½æ•°è®ºå¼ºè°ƒå‡½æ•°çš„æ„é€ æ€§æœ¬è´¨ï¼Œè®¤ä¸ºå‡½æ•°ä¸ä»…æ˜¯æŠ½è±¡çš„æ•°å­¦å¯¹è±¡ï¼Œæ›´æ˜¯å¯ä»¥é€šè¿‡å…·ä½“ç®—æ³•æ„é€ çš„å®ä½“ã€‚
Constructive function theory emphasizes the constructive nature of functions, viewing functions not only as abstract mathematical objects but also as entities that can be constructed through specific algorithms.

**æ„é€ æ€§å‡½æ•°çš„åŸºæœ¬æ€æƒ³ / Basic Ideas of Constructive Functions:**

1. **æ„é€ æ€§å­˜åœ¨ / Constructive Existence:**
   - å‡½æ•°çš„å­˜åœ¨å¿…é¡»é€šè¿‡æ„é€ æ¥è¯æ˜
   - ä¸èƒ½ä»…é€šè¿‡éæ„é€ æ€§æ–¹æ³•è¯æ˜å­˜åœ¨
   - Function existence must be proven through construction
   - Cannot be proven to exist through non-constructive methods alone

2. **ç®—æ³•å®ç° / Algorithmic Implementation:**
   - æ¯ä¸ªå‡½æ•°éƒ½å¿…é¡»æœ‰å…·ä½“çš„ç®—æ³•å®ç°
   - å‡½æ•°ä¸ç®—æ³•åœ¨æœ¬è´¨ä¸Šæ˜¯ç­‰ä»·çš„
   - Each function must have a concrete algorithmic implementation
   - Functions and algorithms are essentially equivalent

3. **å¯è®¡ç®—æ€§ / Computability:**
   - æ‰€æœ‰æ„é€ æ€§å‡½æ•°éƒ½å¿…é¡»æ˜¯å¯è®¡ç®—çš„
   - å¼ºè°ƒå‡½æ•°çš„å®é™…å¯æ‰§è¡Œæ€§
   - All constructive functions must be computable
   - Emphasizes the actual executability of functions

**æ„é€ æ€§å‡½æ•°çš„ä¸¥æ ¼å®šä¹‰ / Strict Definition of Constructive Functions:**

**å®šä¹‰ 1.0.1** (æ„é€ æ€§å‡½æ•° / Constructive Function)
æ„é€ æ€§å‡½æ•°æ˜¯ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„æ˜ å°„ï¼Œå­˜åœ¨ç®—æ³• $\mathcal{A}$ ä½¿å¾—å¯¹äºä»»æ„ $a \in A$ï¼Œ$\mathcal{A}(a) = f(a)$ã€‚
**Definition 1.0.1** (Constructive Function)
A constructive function is a mapping from set $A$ to set $B$ such that there exists an algorithm $\mathcal{A}$ where for any $a \in A$, $\mathcal{A}(a) = f(a)$.

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**
$$f: A \rightarrow B \text{ is constructive} \iff \exists \mathcal{A}: \forall a \in A, \mathcal{A}(a) = f(a)$$

**æ„é€ æ€§å‡½æ•°çš„ç­‰ä»·å®šä¹‰ / Equivalent Definitions of Constructive Functions:**

**å®šç† 1.0.1** (æ„é€ æ€§å‡½æ•°ç­‰ä»·æ€§) ä»¥ä¸‹å®šä¹‰ç­‰ä»·ï¼š
**Theorem 1.0.1** (Constructive Function Equivalence) The following definitions are equivalent:

1. **ç®—æ³•å®šä¹‰ / Algorithmic Definition:**
   $f$ æ˜¯æ„é€ æ€§å‡½æ•°å½“ä¸”ä»…å½“å­˜åœ¨ç®—æ³• $\mathcal{A}$ è®¡ç®— $f$
   $f$ is a constructive function if and only if there exists an algorithm $\mathcal{A}$ that computes $f$

2. **å›¾çµæœºå®šä¹‰ / Turing Machine Definition:**
   $f$ æ˜¯æ„é€ æ€§å‡½æ•°å½“ä¸”ä»…å½“å­˜åœ¨å›¾çµæœº $M$ è®¡ç®— $f$
   $f$ is a constructive function if and only if there exists a Turing machine $M$ that computes $f$

3. **é€’å½’å‡½æ•°å®šä¹‰ / Recursive Function Definition:**
   $f$ æ˜¯æ„é€ æ€§å‡½æ•°å½“ä¸”ä»…å½“ $f$ æ˜¯é€’å½’å‡½æ•°
   $f$ is a constructive function if and only if $f$ is a recursive function

**è¯æ˜ / Proof:**

**æ­¥éª¤1ï¼šç®—æ³•å®šä¹‰è•´å«å›¾çµæœºå®šä¹‰ / Step 1: Algorithmic Definition Implies Turing Machine Definition**
ä»»ä½•ç®—æ³•éƒ½å¯ä»¥ç”±å›¾çµæœºæ¨¡æ‹Ÿï¼Œå› æ­¤ç®—æ³•å®šä¹‰è•´å«å›¾çµæœºå®šä¹‰ã€‚
Any algorithm can be simulated by a Turing machine, so the algorithmic definition implies the Turing machine definition.

**æ­¥éª¤2ï¼šå›¾çµæœºå®šä¹‰è•´å«é€’å½’å‡½æ•°å®šä¹‰ / Step 2: Turing Machine Definition Implies Recursive Function Definition**
å›¾çµå¯è®¡ç®—å‡½æ•°ç­‰ä»·äºé€’å½’å‡½æ•°ï¼Œå› æ­¤å›¾çµæœºå®šä¹‰è•´å«é€’å½’å‡½æ•°å®šä¹‰ã€‚
Turing computable functions are equivalent to recursive functions, so the Turing machine definition implies the recursive function definition.

**æ­¥éª¤3ï¼šé€’å½’å‡½æ•°å®šä¹‰è•´å«ç®—æ³•å®šä¹‰ / Step 3: Recursive Function Definition Implies Algorithmic Definition**
é€’å½’å‡½æ•°å¯ä»¥é€šè¿‡ç®—æ³•å®ç°ï¼Œå› æ­¤é€’å½’å‡½æ•°å®šä¹‰è•´å«ç®—æ³•å®šä¹‰ã€‚
Recursive functions can be implemented by algorithms, so the recursive function definition implies the algorithmic definition.

#### 1.0.2 æ„é€ æ€§å‡½æ•°çš„åŸºæœ¬æ€§è´¨ / Basic Properties of Constructive Functions

**æ„é€ æ€§å‡½æ•°çš„ä»£æ•°ç»“æ„ / Algebraic Structure of Constructive Functions:**

**å®šç† 1.0.2** (æ„é€ æ€§å‡½æ•°ä»£æ•°) æ„é€ æ€§å‡½æ•°åœ¨å¤åˆè¿ç®—ä¸‹æ„æˆä¸€ä¸ªå¹ºåŠç¾¤ã€‚
**Theorem 1.0.2** (Constructive Function Algebra) Constructive functions form a monoid under composition.

**è¯æ˜ / Proof:**

1. **å°é—­æ€§ / Closure:**
   å¦‚æœ $f: A \rightarrow B$ å’Œ $g: B \rightarrow C$ éƒ½æ˜¯æ„é€ æ€§çš„ï¼Œé‚£ä¹ˆ $g \circ f: A \rightarrow C$ ä¹Ÿæ˜¯æ„é€ æ€§çš„ã€‚
   If $f: A \rightarrow B$ and $g: B \rightarrow C$ are both constructive, then $g \circ f: A \rightarrow C$ is also constructive.

2. **ç»“åˆå¾‹ / Associativity:**
   $(h \circ g) \circ f = h \circ (g \circ f)$ å¯¹æ‰€æœ‰æ„é€ æ€§å‡½æ•° $f, g, h$ æˆç«‹ã€‚
   $(h \circ g) \circ f = h \circ (g \circ f)$ holds for all constructive functions $f, g, h$.

3. **å•ä½å…ƒ / Identity:**
   æ’ç­‰å‡½æ•° $id_A: A \rightarrow A$ æ˜¯æ„é€ æ€§çš„ï¼Œä¸”å¯¹æ‰€æœ‰æ„é€ æ€§å‡½æ•° $f: A \rightarrow B$ï¼Œ$f \circ id_A = id_B \circ f = f$ã€‚
   The identity function $id_A: A \rightarrow A$ is constructive, and for all constructive functions $f: A \rightarrow B$, $f \circ id_A = id_B \circ f = f$.

**æ„é€ æ€§å‡½æ•°çš„å¯è®¡ç®—æ€§ / Computability of Constructive Functions:**

**å®šç† 1.0.3** (æ„é€ æ€§å‡½æ•°å¯è®¡ç®—æ€§) æ‰€æœ‰æ„é€ æ€§å‡½æ•°éƒ½æ˜¯å¯è®¡ç®—çš„ã€‚
**Theorem 1.0.3** (Computability of Constructive Functions) All constructive functions are computable.

**è¯æ˜ / Proof:**
ç”±æ„é€ æ€§å‡½æ•°çš„å®šä¹‰ï¼Œæ¯ä¸ªæ„é€ æ€§å‡½æ•°éƒ½æœ‰å¯¹åº”çš„ç®—æ³•å®ç°ï¼Œå› æ­¤æ˜¯å¯è®¡ç®—çš„ã€‚
By the definition of constructive functions, each constructive function has a corresponding algorithmic implementation, so it is computable.

**æ„é€ æ€§å‡½æ•°çš„å¤æ‚åº¦ / Complexity of Constructive Functions:**

**å®šä¹‰ 1.0.2** (æ„é€ æ€§å‡½æ•°å¤æ‚åº¦) æ„é€ æ€§å‡½æ•° $f$ çš„å¤æ‚åº¦æ˜¯è®¡ç®— $f$ æ‰€éœ€çš„æœ€å°‘è®¡ç®—æ­¥éª¤æ•°ã€‚
**Definition 1.0.2** (Complexity of Constructive Functions) The complexity of a constructive function $f$ is the minimum number of computational steps required to compute $f$.

**å½¢å¼åŒ–è¡¨ç¤º / Formal Representation:**
$$\text{Complexity}(f) = \min_{\mathcal{A}} \{\text{Steps}(\mathcal{A}, x) \mid \mathcal{A} \text{ computes } f, x \in \text{dom}(f)\}$$

#### 1.0.3 æ„é€ æ€§å‡½æ•°ä¸ç»å…¸å‡½æ•°çš„æ¯”è¾ƒ / Comparison between Constructive and Classical Functions

**ç»å…¸å‡½æ•°è®ºè§‚ç‚¹ / Classical Function Theory View:**

- å‡½æ•°æ˜¯æŠ½è±¡çš„æ•°å­¦å¯¹è±¡
- ä¸è¦æ±‚å…·ä½“çš„ç®—æ³•å®ç°
- å…è®¸éæ„é€ æ€§çš„å­˜åœ¨æ€§è¯æ˜
- Functions are abstract mathematical objects
- Do not require concrete algorithmic implementation
- Allow non-constructive existence proofs

**æ„é€ æ€§å‡½æ•°è®ºè§‚ç‚¹ / Constructive Function Theory View:**

- å‡½æ•°å¿…é¡»é€šè¿‡ç®—æ³•æ„é€ 
- å¼ºè°ƒå®é™…çš„å¯è®¡ç®—æ€§
- åªå…è®¸æ„é€ æ€§çš„å­˜åœ¨æ€§è¯æ˜
- Functions must be constructed through algorithms
- Emphasize actual computability
- Only allow constructive existence proofs

**æ„é€ æ€§å‡½æ•°è®ºçš„ä¼˜åŠ¿ / Advantages of Constructive Function Theory:**

1. **å®é™…å¯æ“ä½œæ€§ / Practical Operability:**
   - æ‰€æœ‰å‡½æ•°éƒ½å¯ä»¥å®é™…è®¡ç®—
   - é¿å…äº†çº¯ç†è®ºçš„å­˜åœ¨æ€§
   - All functions can be actually computed
   - Avoids purely theoretical existence

2. **ç®—æ³•æŒ‡å¯¼æ€§ / Algorithmic Guidance:**
   - ä¸ºç®—æ³•è®¾è®¡æä¾›ç†è®ºåŸºç¡€
   - å¼ºè°ƒæ„é€ æ€§æ€ç»´
   - Provide theoretical foundation for algorithm design
   - Emphasize constructive thinking

3. **è®¡ç®—å¤æ‚æ€§ / Computational Complexity:**
   - è‡ªç„¶å¼•å…¥å¤æ‚åº¦åˆ†æ
   - å…³æ³¨å®é™…è®¡ç®—æ•ˆç‡
   - Naturally introduce complexity analysis
   - Focus on actual computational efficiency

### 1.1 å‡½æ•°å®šä¹‰ (Function Definition)

**å®šä¹‰ 1.1.1** (å‡½æ•° / Function)
å‡½æ•°æ˜¯ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„æ˜ å°„ï¼Œè®°ä½œ $f: A \rightarrow B$ã€‚

**Definition 1.1.1** (Function)
A function is a mapping from set $A$ to set $B$, denoted by $f: A \rightarrow B$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$f: A \rightarrow B \iff \forall a \in A, \exists! b \in B, f(a) = b$$

å…¶ä¸­ $\exists!$ è¡¨ç¤ºå­˜åœ¨å”¯ä¸€çš„ã€‚

where $\exists!$ means "there exists a unique".

**å®šä¹‰ 1.1.2** (å®šä¹‰åŸŸ / Domain)
å‡½æ•° $f: A \rightarrow B$ çš„å®šä¹‰åŸŸæ˜¯é›†åˆ $A$ï¼Œè®°ä½œ $\text{dom}(f) = A$ã€‚

**Definition 1.1.2** (Domain)
The domain of function $f: A \rightarrow B$ is set $A$, denoted by $\text{dom}(f) = A$.

**å®šä¹‰ 1.1.3** (é™ªåŸŸ / Codomain)
å‡½æ•° $f: A \rightarrow B$ çš„é™ªåŸŸæ˜¯é›†åˆ $B$ï¼Œè®°ä½œ $\text{codom}(f) = B$ã€‚

**Definition 1.1.3** (Codomain)
The codomain of function $f: A \rightarrow B$ is set $B$, denoted by $\text{codom}(f) = B$.

**å®šä¹‰ 1.1.4** (å€¼åŸŸ / Range)
å‡½æ•° $f: A \rightarrow B$ çš„å€¼åŸŸæ˜¯ $B$ ä¸­æ‰€æœ‰è¢«æ˜ å°„åˆ°çš„å…ƒç´ çš„é›†åˆã€‚

**Definition 1.1.4** (Range)
The range of function $f: A \rightarrow B$ is the set of all elements in $B$ that are mapped to.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\text{range}(f) = \{f(a) \mid a \in A\}$$

### 1.2 å‡½æ•°å›¾åƒ (Function Graph)

**å®šä¹‰ 1.2.1** (å‡½æ•°å›¾åƒ / Function Graph)
å‡½æ•° $f: A \rightarrow B$ çš„å›¾åƒæ˜¯ç¬›å¡å°”ç§¯ $A \times B$ çš„å­é›†ã€‚

**Definition 1.2.1** (Function Graph)
The graph of function $f: A \rightarrow B$ is a subset of the Cartesian product $A \times B$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\text{graph}(f) = \{(a, f(a)) \mid a \in A\}$$

**å®šç† 1.2.1** (å‡½æ•°å›¾åƒæ€§è´¨ / Function Graph Properties)
å‡½æ•°å›¾åƒæ»¡è¶³å‚ç›´ç›´çº¿æµ‹è¯•ï¼šä»»ä½•å‚ç›´çº¿æœ€å¤šä¸å›¾åƒç›¸äº¤ä¸€æ¬¡ã€‚

**Theorem 1.2.1** (Function Graph Properties)
The function graph satisfies the vertical line test: any vertical line intersects the graph at most once.

---

## 2. å‡½æ•°ç±»å‹ (Function Types)

### 2.1 å•å°„å‡½æ•° (Injective Functions)

**å®šä¹‰ 2.1.1** (å•å°„å‡½æ•° / Injective Function)
å‡½æ•° $f: A \rightarrow B$ æ˜¯å•å°„çš„ï¼Œå½“ä¸”ä»…å½“ä¸åŒçš„è¾“å…¥å¯¹åº”ä¸åŒçš„è¾“å‡ºã€‚

**Definition 2.1.1** (Injective Function)
Function $f: A \rightarrow B$ is injective if and only if different inputs correspond to different outputs.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\forall x_1, x_2 \in A, f(x_1) = f(x_2) \rightarrow x_1 = x_2$$

**ç­‰ä»·å®šä¹‰ (Equivalent Definition):**
$$\forall x_1, x_2 \in A, x_1 \neq x_2 \rightarrow f(x_1) \neq f(x_2)$$

### 2.2 æ»¡å°„å‡½æ•° (Surjective Functions)

**å®šä¹‰ 2.2.1** (æ»¡å°„å‡½æ•° / Surjective Function)
å‡½æ•° $f: A \rightarrow B$ æ˜¯æ»¡å°„çš„ï¼Œå½“ä¸”ä»…å½“ $B$ çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯æŸä¸ª $A$ ä¸­å…ƒç´ çš„åƒã€‚

**Definition 2.2.1** (Surjective Function)
Function $f: A \rightarrow B$ is surjective if and only if every element of $B$ is the image of some element of $A$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\forall y \in B, \exists x \in A, f(x) = y$$

**ç­‰ä»·å®šä¹‰ (Equivalent Definition):**
$$\text{range}(f) = B$$

### 2.3 åŒå°„å‡½æ•° (Bijective Functions)

**å®šä¹‰ 2.3.1** (åŒå°„å‡½æ•° / Bijective Function)
å‡½æ•° $f: A \rightarrow B$ æ˜¯åŒå°„çš„ï¼Œå½“ä¸”ä»…å½“å®ƒæ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„ã€‚

**Definition 2.3.1** (Bijective Function)
Function $f: A \rightarrow B$ is bijective if and only if it is both injective and surjective.

**å®šç† 2.3.1** (åŒå°„å‡½æ•°æ€§è´¨ / Bijective Function Properties)
åŒå°„å‡½æ•°å­˜åœ¨å”¯ä¸€çš„é€†å‡½æ•°ã€‚

**Theorem 2.3.1** (Bijective Function Properties)
A bijective function has a unique inverse function.

### 2.4 å¸¸æ•°å‡½æ•° (Constant Functions)

**å®šä¹‰ 2.4.1** (å¸¸æ•°å‡½æ•° / Constant Function)
å‡½æ•° $f: A \rightarrow B$ æ˜¯å¸¸æ•°å‡½æ•°ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ $c \in B$ ä½¿å¾— $\forall x \in A, f(x) = c$ã€‚

**Definition 2.4.1** (Constant Function)
Function $f: A \rightarrow B$ is a constant function if and only if there exists $c \in B$ such that $\forall x \in A, f(x) = c$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\exists c \in B, \forall x \in A, f(x) = c$$

### 2.5 æ’ç­‰å‡½æ•° (Identity Functions)

**å®šä¹‰ 2.5.1** (æ’ç­‰å‡½æ•° / Identity Function)
é›†åˆ $A$ ä¸Šçš„æ’ç­‰å‡½æ•°æ˜¯ $I_A: A \rightarrow A$ï¼Œå®šä¹‰ä¸º $\forall x \in A, I_A(x) = x$ã€‚

**Definition 2.5.1** (Identity Function)
The identity function on set $A$ is $I_A: A \rightarrow A$ defined by $\forall x \in A, I_A(x) = x$.

---

## 3. å‡½æ•°è¿ç®— (Function Operations)

### 3.1 å‡½æ•°å¤åˆ (Function Composition)

**å®šä¹‰ 3.1.1** (å‡½æ•°å¤åˆ / Function Composition)
å‡½æ•° $f: A \rightarrow B$ å’Œ $g: B \rightarrow C$ çš„å¤åˆæ˜¯å‡½æ•° $g \circ f: A \rightarrow C$ã€‚

**Definition 3.1.1** (Function Composition)
The composition of functions $f: A \rightarrow B$ and $g: B \rightarrow C$ is the function $g \circ f: A \rightarrow C$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\forall x \in A, (g \circ f)(x) = g(f(x))$$

**å®šç† 3.1.1** (å¤åˆå‡½æ•°æ€§è´¨ / Composition Properties)

1. **ç»“åˆå¾‹ (Associativity)**: $(h \circ g) \circ f = h \circ (g \circ f)$
2. **å•ä½å…ƒ (Identity)**: $f \circ I_A = f = I_B \circ f$

**Theorem 3.1.1** (Composition Properties)

1. **Associativity**: $(h \circ g) \circ f = h \circ (g \circ f)$
2. **Identity**: $f \circ I_A = f = I_B \circ f$

### 3.2 é€†å‡½æ•° (Inverse Functions)

**å®šä¹‰ 3.2.1** (é€†å‡½æ•° / Inverse Function)
å‡½æ•° $f: A \rightarrow B$ çš„é€†å‡½æ•°æ˜¯å‡½æ•° $f^{-1}: B \rightarrow A$ï¼Œæ»¡è¶³ï¼š
$$f^{-1} \circ f = I_A \text{ and } f \circ f^{-1} = I_B$$

**Definition 3.2.1** (Inverse Function)
The inverse function of $f: A \rightarrow B$ is the function $f^{-1}: B \rightarrow A$ such that:
$$f^{-1} \circ f = I_A \text{ and } f \circ f^{-1} = I_B$$

**å®šç† 3.2.1** (é€†å‡½æ•°å­˜åœ¨æ€§ / Inverse Function Existence)
å‡½æ•°å­˜åœ¨é€†å‡½æ•°å½“ä¸”ä»…å½“å®ƒæ˜¯åŒå°„çš„ã€‚

**Theorem 3.2.1** (Inverse Function Existence)
A function has an inverse if and only if it is bijective.

### 3.3 å‡½æ•°é™åˆ¶ (Function Restriction)

**å®šä¹‰ 3.3.1** (å‡½æ•°é™åˆ¶ / Function Restriction)
å‡½æ•° $f: A \rightarrow B$ åœ¨å­é›† $S \subseteq A$ ä¸Šçš„é™åˆ¶æ˜¯å‡½æ•° $f|_S: S \rightarrow B$ã€‚

**Definition 3.3.1** (Function Restriction)
The restriction of function $f: A \rightarrow B$ to subset $S \subseteq A$ is the function $f|_S: S \rightarrow B$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\forall x \in S, f|_S(x) = f(x)$$

### 3.4 å‡½æ•°å»¶æ‹“ (Function Extension)

**å®šä¹‰ 3.3.2** (å‡½æ•°å»¶æ‹“ / Function Extension)
å‡½æ•° $g: A \rightarrow B$ æ˜¯å‡½æ•° $f: S \rightarrow B$ çš„å»¶æ‹“ï¼Œå½“ä¸”ä»…å½“ $S \subseteq A$ ä¸” $g|_S = f$ã€‚

**Definition 3.3.2** (Function Extension)
Function $g: A \rightarrow B$ is an extension of function $f: S \rightarrow B$ if and only if $S \subseteq A$ and $g|_S = f$.

---

## 4. å‡½æ•°ç©ºé—´ (Function Spaces)

### 4.1 å‡½æ•°é›†åˆ (Function Sets)

**å®šä¹‰ 4.1.1** (å‡½æ•°ç©ºé—´ / Function Space)
ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„æ‰€æœ‰å‡½æ•°çš„é›†åˆè®°ä½œ $B^A$ã€‚

**Definition 4.1.1** (Function Space)
The set of all functions from set $A$ to set $B$ is denoted by $B^A$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$B^A = \{f \mid f: A \rightarrow B\}$$

**å®šç† 4.1.1** (å‡½æ•°ç©ºé—´åŸºæ•° / Function Space Cardinality)
å¦‚æœ $|A| = m$ ä¸” $|B| = n$ï¼Œåˆ™ $|B^A| = n^m$ã€‚

**Theorem 4.1.1** (Function Space Cardinality)
If $|A| = m$ and $|B| = n$, then $|B^A| = n^m$.

### 4.2 è¿ç»­å‡½æ•°ç©ºé—´ (Continuous Function Spaces)

**å®šä¹‰ 4.2.1** (è¿ç»­å‡½æ•°ç©ºé—´ / Continuous Function Space)
ä»æ‹“æ‰‘ç©ºé—´ $X$ åˆ°æ‹“æ‰‘ç©ºé—´ $Y$ çš„æ‰€æœ‰è¿ç»­å‡½æ•°çš„é›†åˆè®°ä½œ $C(X, Y)$ã€‚

**Definition 4.2.1** (Continuous Function Space)
The set of all continuous functions from topological space $X$ to topological space $Y$ is denoted by $C(X, Y)$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$C(X, Y) = \{f: X \rightarrow Y \mid f \text{ is continuous}\}$$

### 4.3 å¯æµ‹å‡½æ•°ç©ºé—´ (Measurable Function Spaces)

**å®šä¹‰ 4.3.1** (å¯æµ‹å‡½æ•°ç©ºé—´ / Measurable Function Space)
ä»å¯æµ‹ç©ºé—´ $(X, \mathcal{A})$ åˆ°å¯æµ‹ç©ºé—´ $(Y, \mathcal{B})$ çš„æ‰€æœ‰å¯æµ‹å‡½æ•°çš„é›†åˆã€‚

**Definition 4.3.1** (Measurable Function Space)
The set of all measurable functions from measurable space $(X, \mathcal{A})$ to measurable space $(Y, \mathcal{B})$.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\mathcal{M}(X, Y) = \{f: X \rightarrow Y \mid f \text{ is measurable}\}$$

---

## 5. å‡½æ•°æé™ (Function Limits)

### 5.1 åºåˆ—æé™ (Sequence Limits)

**å®šä¹‰ 5.1.1** (åºåˆ—æé™ / Sequence Limit)
åºåˆ— $\{a_n\}$ æ”¶æ•›åˆ° $L$ï¼Œè®°ä½œ $\lim_{n \to \infty} a_n = L$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall \epsilon > 0, \exists N \in \mathbb{N}, \forall n \geq N, |a_n - L| < \epsilon$$

**Definition 5.1.1** (Sequence Limit)
Sequence $\{a_n\}$ converges to $L$, written $\lim_{n \to \infty} a_n = L$, if and only if:
$$\forall \epsilon > 0, \exists N \in \mathbb{N}, \forall n \geq N, |a_n - L| < \epsilon$$

### 5.2 å‡½æ•°æé™ (Function Limits)

**å®šä¹‰ 5.2.1** (å‡½æ•°æé™ / Function Limit)
å‡½æ•° $f$ åœ¨ç‚¹ $a$ çš„æé™æ˜¯ $L$ï¼Œè®°ä½œ $\lim_{x \to a} f(x) = L$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, 0 < |x - a| < \delta \rightarrow |f(x) - L| < \epsilon$$

**Definition 5.2.1** (Function Limit)
The limit of function $f$ at point $a$ is $L$, written $\lim_{x \to a} f(x) = L$, if and only if:
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, 0 < |x - a| < \delta \rightarrow |f(x) - L| < \epsilon$$

**å®šç† 5.2.1** (æé™å”¯ä¸€æ€§ / Limit Uniqueness)
å¦‚æœå‡½æ•°åœ¨ä¸€ç‚¹å­˜åœ¨æé™ï¼Œåˆ™æé™æ˜¯å”¯ä¸€çš„ã€‚

**Theorem 5.2.1** (Limit Uniqueness)
If a function has a limit at a point, then the limit is unique.

### 5.3 å•ä¾§æé™ (One-Sided Limits)

**å®šä¹‰ 5.3.1** (å³æé™ / Right Limit)
å‡½æ•° $f$ åœ¨ç‚¹ $a$ çš„å³æé™æ˜¯ $L$ï¼Œè®°ä½œ $\lim_{x \to a^+} f(x) = L$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, a < x < a + \delta \rightarrow |f(x) - L| < \epsilon$$

**Definition 5.3.1** (Right Limit)
The right limit of function $f$ at point $a$ is $L$, written $\lim_{x \to a^+} f(x) = L$, if and only if:
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, a < x < a + \delta \rightarrow |f(x) - L| < \epsilon$$

**å®šä¹‰ 5.3.2** (å·¦æé™ / Left Limit)
å‡½æ•° $f$ åœ¨ç‚¹ $a$ çš„å·¦æé™æ˜¯ $L$ï¼Œè®°ä½œ $\lim_{x \to a^-} f(x) = L$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, a - \delta < x < a \rightarrow |f(x) - L| < \epsilon$$

**Definition 5.3.2** (Left Limit)
The left limit of function $f$ at point $a$ is $L$, written $\lim_{x \to a^-} f(x) = L$, if and only if:
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, a - \delta < x < a \rightarrow |f(x) - L| < \epsilon$$

---

## 6. å‡½æ•°è¿ç»­æ€§ (Function Continuity)

### 6.1 è¿ç»­æ€§å®šä¹‰ (Continuity Definition)

**å®šä¹‰ 6.1.1** (å‡½æ•°è¿ç»­æ€§ / Function Continuity)
å‡½æ•° $f$ åœ¨ç‚¹ $a$ è¿ç»­ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\lim_{x \to a} f(x) = f(a)$$

**Definition 6.1.1** (Function Continuity)
Function $f$ is continuous at point $a$ if and only if:
$$\lim_{x \to a} f(x) = f(a)$$

**ç­‰ä»·å®šä¹‰ (Equivalent Definition):**
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, |x - a| < \delta \rightarrow |f(x) - f(a)| < \epsilon$$

### 6.2 ä¸€è‡´è¿ç»­æ€§ (Uniform Continuity)

**å®šä¹‰ 6.2.1** (ä¸€è‡´è¿ç»­æ€§ / Uniform Continuity)
å‡½æ•° $f$ åœ¨é›†åˆ $A$ ä¸Šä¸€è‡´è¿ç»­ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, y \in A, |x - y| < \delta \rightarrow |f(x) - f(y)| < \epsilon$$

**Definition 6.2.1** (Uniform Continuity)
Function $f$ is uniformly continuous on set $A$ if and only if:
$$\forall \epsilon > 0, \exists \delta > 0, \forall x, y \in A, |x - y| < \delta \rightarrow |f(x) - f(y)| < \epsilon$$

**å®šç† 6.2.1** (ä¸€è‡´è¿ç»­æ€§å®šç† / Uniform Continuity Theorem)
åœ¨ç´§é›†ä¸Šçš„è¿ç»­å‡½æ•°æ˜¯ä¸€è‡´è¿ç»­çš„ã€‚

**Theorem 6.2.1** (Uniform Continuity Theorem)
A continuous function on a compact set is uniformly continuous.

### 6.3 è¿ç»­å‡½æ•°æ€§è´¨ (Continuous Function Properties)

**å®šç† 6.3.1** (è¿ç»­å‡½æ•°è¿ç®— / Continuous Function Operations)
å¦‚æœ $f$ å’Œ $g$ åœ¨ç‚¹ $a$ è¿ç»­ï¼Œåˆ™ï¼š

1. $f + g$ åœ¨ç‚¹ $a$ è¿ç»­
2. $f \cdot g$ åœ¨ç‚¹ $a$ è¿ç»­
3. $f/g$ åœ¨ç‚¹ $a$ è¿ç»­ï¼ˆå¦‚æœ $g(a) \neq 0$ï¼‰

**Theorem 6.3.1** (Continuous Function Operations)
If $f$ and $g$ are continuous at point $a$, then:

1. $f + g$ is continuous at point $a$
2. $f \cdot g$ is continuous at point $a$
3. $f/g$ is continuous at point $a$ (if $g(a) \neq 0$)

**å®šç† 6.3.2** (å¤åˆå‡½æ•°è¿ç»­æ€§ / Composition Continuity)
å¦‚æœ $f$ åœ¨ç‚¹ $a$ è¿ç»­ï¼Œ$g$ åœ¨ç‚¹ $f(a)$ è¿ç»­ï¼Œåˆ™ $g \circ f$ åœ¨ç‚¹ $a$ è¿ç»­ã€‚

**Theorem 6.3.2** (Composition Continuity)
If $f$ is continuous at point $a$ and $g$ is continuous at point $f(a)$, then $g \circ f$ is continuous at point $a$.

---

## 7. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 7.1 åŸºæœ¬å‡½æ•°å®ç° (Basic Function Implementation)

```rust
use std::collections::HashMap;

pub struct Function<D, R> {
    mapping: HashMap<D, R>,
    domain: Vec<D>,
    codomain: Vec<R>,
}

impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash> Function<D, R> {
    pub fn new(domain: Vec<D>, codomain: Vec<R>) -> Self {
        Function {
            mapping: HashMap::new(),
            domain,
            codomain,
        }
    }

    pub fn add_mapping(&mut self, input: D, output: R) -> Result<(), String> {
        if !self.domain.contains(&input) {
            return Err("Input not in domain".to_string());
        }
        if !self.codomain.contains(&output) {
            return Err("Output not in codomain".to_string());
        }
        self.mapping.insert(input, output);
        Ok(())
    }

    pub fn apply(&self, input: &D) -> Option<&R> {
        self.mapping.get(input)
    }

    pub fn get_domain(&self) -> &Vec<D> {
        &self.domain
    }

    pub fn get_codomain(&self) -> &Vec<R> {
        &self.codomain
    }

    pub fn get_range(&self) -> Vec<&R> {
        self.mapping.values().collect()
    }
}
```

### 7.2 å‡½æ•°ç±»å‹æ£€æŸ¥ (Function Type Checking)

```rust
impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash> Function<D, R> {
    // å•å°„æ£€æŸ¥
    pub fn is_injective(&self) -> bool {
        let mut seen_outputs = std::collections::HashSet::new();
        for output in self.mapping.values() {
            if seen_outputs.contains(output) {
                return false;
            }
            seen_outputs.insert(output);
        }
        true
    }

    // æ»¡å°„æ£€æŸ¥
    pub fn is_surjective(&self) -> bool {
        let outputs: std::collections::HashSet<&R> = self.mapping.values().collect();
        outputs.len() == self.codomain.len()
    }

    // åŒå°„æ£€æŸ¥
    pub fn is_bijective(&self) -> bool {
        self.is_injective() && self.is_surjective()
    }

    // å¸¸æ•°å‡½æ•°æ£€æŸ¥
    pub fn is_constant(&self) -> bool {
        if self.mapping.is_empty() {
            return true;
        }
        let first_output = self.mapping.values().next().unwrap();
        self.mapping.values().all(|output| output == first_output)
    }
}
```

### 7.3 å‡½æ•°å¤åˆå®ç° (Function Composition Implementation)

```rust
impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash, S: Clone + Eq + std::hash::Hash> Function<D, R> {
    // å‡½æ•°å¤åˆ
    pub fn compose<S>(&self, other: &Function<R, S>) -> Function<D, S> {
        let mut composition = Function::new(
            self.domain.clone(),
            other.codomain.clone(),
        );

        for (input, output) in &self.mapping {
            if let Some(final_output) = other.apply(output) {
                composition.add_mapping(input.clone(), final_output.clone()).unwrap();
            }
        }

        composition
    }

    // é€†å‡½æ•°ï¼ˆä»…å¯¹åŒå°„å‡½æ•°ï¼‰
    pub fn inverse(&self) -> Result<Function<R, D>, String> {
        if !self.is_bijective() {
            return Err("Function is not bijective".to_string());
        }

        let mut inverse = Function::new(
            self.codomain.clone(),
            self.domain.clone(),
        );

        for (input, output) in &self.mapping {
            inverse.add_mapping(output.clone(), input.clone()).unwrap();
        }

        Ok(inverse)
    }
}
```

### 7.4 å‡½æ•°é™åˆ¶å’Œå»¶æ‹“ (Function Restriction and Extension)

```rust
impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash> Function<D, R> {
    // å‡½æ•°é™åˆ¶
    pub fn restrict(&self, subset: &[D]) -> Function<D, R> {
        let mut restriction = Function::new(
            subset.to_vec(),
            self.codomain.clone(),
        );

        for input in subset {
            if let Some(output) = self.apply(input) {
                restriction.add_mapping(input.clone(), output.clone()).unwrap();
            }
        }

        restriction
    }

    // å‡½æ•°å»¶æ‹“
    pub fn extend(&self, extended_domain: Vec<D>, extended_codomain: Vec<R>) -> Function<D, R> {
        let mut extension = Function::new(extended_domain, extended_codomain);

        for (input, output) in &self.mapping {
            extension.add_mapping(input.clone(), output.clone()).unwrap();
        }

        extension
    }
}
```

### 7.5 å‡½æ•°ç©ºé—´å®ç° (Function Space Implementation)

```rust
pub struct FunctionSpace<D, R> {
    functions: Vec<Function<D, R>>,
}

impl<D: Clone + Eq + std::hash::Hash, R: Clone + Eq + std::hash::Hash> FunctionSpace<D, R> {
    pub fn new() -> Self {
        FunctionSpace {
            functions: Vec::new(),
        }
    }

    pub fn add_function(&mut self, function: Function<D, R>) {
        self.functions.push(function);
    }

    pub fn get_functions(&self) -> &Vec<Function<D, R>> {
        &self.functions
    }

    // è®¡ç®—å‡½æ•°ç©ºé—´åŸºæ•°
    pub fn cardinality(&self) -> usize {
        if self.functions.is_empty() {
            return 0;
        }

        let domain_size = self.functions[0].get_domain().len();
        let codomain_size = self.functions[0].get_codomain().len();
        codomain_size.pow(domain_size as u32)
    }

    // æŸ¥æ‰¾ç‰¹å®šç±»å‹çš„å‡½æ•°
    pub fn find_injective_functions(&self) -> Vec<&Function<D, R>> {
        self.functions.iter().filter(|f| f.is_injective()).collect()
    }

    pub fn find_surjective_functions(&self) -> Vec<&Function<D, R>> {
        self.functions.iter().filter(|f| f.is_surjective()).collect()
    }

    pub fn find_bijective_functions(&self) -> Vec<&Function<D, R>> {
        self.functions.iter().filter(|f| f.is_bijective()).collect()
    }
}
```

### 7.6 å‡½æ•°æé™è®¡ç®— (Function Limit Calculation)

```rust
pub struct LimitCalculator;

impl LimitCalculator {
    // åºåˆ—æé™
    pub fn sequence_limit(sequence: &[f64], target: f64, epsilon: f64) -> bool {
        let mut n = 0;
        while n < sequence.len() {
            if (sequence[n] - target).abs() < epsilon {
                return true;
            }
            n += 1;
        }
        false
    }

    // å‡½æ•°æé™ï¼ˆæ•°å€¼é€¼è¿‘ï¼‰
    pub fn function_limit<F>(f: F, point: f64, target: f64, epsilon: f64) -> bool
    where
        F: Fn(f64) -> f64,
    {
        let delta = epsilon / 100.0; // ç®€åŒ–çš„deltaé€‰æ‹©
        let x1 = point - delta;
        let x2 = point + delta;

        (f(x1) - target).abs() < epsilon && (f(x2) - target).abs() < epsilon
    }

    // è¿ç»­æ€§æ£€æŸ¥
    pub fn is_continuous<F>(f: F, point: f64, epsilon: f64) -> bool
    where
        F: Fn(f64) -> f64,
    {
        let limit = f(point);
        Self::function_limit(&f, point, limit, epsilon)
    }
}
```

---

## 8. å‚è€ƒæ–‡çŒ® (References)

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**ç»å…¸æ•™æ / Classic Textbooks**:

1. [Rudin1976] Rudin, W. (1976). *Principles of Mathematical Analysis* (3rd Edition). McGraw-Hill. ISBN: 978-0070542358.
   - å®åˆ†æçš„ç»å…¸æ•™æï¼Œç®€ç§°"Baby Rudin"ï¼Œæä¾›äº†ä¸¥æ ¼çš„å‡½æ•°è®ºåŸºç¡€ï¼ŒåŒ…æ‹¬è¿ç»­æ€§ã€æé™ã€ä¸€è‡´æ”¶æ•›ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚

2. [Apostol1974] Apostol, T. M. (1974). *Mathematical Analysis* (2nd Edition). Addison-Wesley. ISBN: 978-0201002881.
   - ç»å…¸çš„æ•°å­¦åˆ†ææ•™æï¼Œè¯¦ç»†ä»‹ç»äº†å‡½æ•°çš„å„ç§æ€§è´¨å’Œè¿ç®—ï¼Œç‰¹åˆ«æ˜¯è¿ç»­å‡½æ•°å’Œå¯æµ‹å‡½æ•°ã€‚

3. [Munkres2000] Munkres, J. R. (2000). *Topology* (2nd Edition). Prentice Hall. ISBN: 978-0131816299.
   - æ‹“æ‰‘å­¦çš„æ ‡å‡†æ•™æï¼Œè¯¦ç»†è®¨è®ºäº†è¿ç»­å‡½æ•°ã€å‡½æ•°ç©ºé—´å’Œæ‹“æ‰‘æ€§è´¨ã€‚

**å¯è®¡ç®—æ€§ç†è®º / Computability Theory**:

1. [Kleene1952] Kleene, S. C. (1952). *Introduction to Metamathematics*. North-Holland.
   - é€’å½’å‡½æ•°è®ºçš„å¥ åŸºæ€§è‘—ä½œï¼Œå®šä¹‰äº†å¯è®¡ç®—å‡½æ•°å’Œé€’å½’å‡½æ•°ï¼Œä¸ºæ„é€ æ€§å‡½æ•°è®ºæä¾›äº†åŸºç¡€ã€‚

2. [Rogers1987] Rogers, H., Jr. (1987). *Theory of Recursive Functions and Effective Computability*. MIT Press. ISBN: 978-0262680523.
   - é€’å½’å‡½æ•°è®ºçš„æƒå¨æ•™æï¼Œè¯¦ç»†è®ºè¿°äº†å¯è®¡ç®—å‡½æ•°ã€é€’å½’å‡½æ•°å’Œæœ‰æ•ˆå¯è®¡ç®—æ€§ã€‚

**è®¡ç®—æ¨¡å‹ / Computation Models**:

1. [Turing1936] Turing, A. M. (1936). "On Computable Numbers, with an Application to the Entscheidungsproblem". *Proceedings of the London Mathematical Society*, s2-42(1), 230-265. DOI: 10.1112/plms/s2-42.1.230.
   - è®¡ç®—ç†è®ºçš„å¥ åŸºæ€§è®ºæ–‡ï¼Œé¦–æ¬¡å®šä¹‰äº†å›¾çµæœºæ¨¡å‹ï¼Œä¸ºæ„é€ æ€§å‡½æ•°æä¾›äº†ç®—æ³•åŸºç¡€ã€‚

2. [Church1936] Church, A. (1936). "An Unsolvable Problem of Elementary Number Theory". *American Journal of Mathematics*, 58(2), 345-363. DOI: 10.2307/2371045.
   - æå‡ºäº†Churchè®ºé¢˜å’ŒÎ»æ¼”ç®—ï¼Œä¸ºå‡½æ•°çš„ç®—æ³•å®šä¹‰æä¾›äº†å¦ä¸€ç§å½¢å¼åŒ–æ¡†æ¶ã€‚

**å»¶ä¼¸é˜…è¯» / Further Reading**:

1. Royden, H. L., & Fitzpatrick, P. M. (2010). *Real Analysis* (4th Edition). Prentice Hall.
   - å®åˆ†æçš„ç°ä»£æ•™æï¼ŒåŒ…å«æµ‹åº¦è®ºå’Œå¯æµ‹å‡½æ•°ç©ºé—´çš„æ·±å…¥è®¨è®ºã€‚

2. Folland, G. B. (1999). *Real Analysis: Modern Techniques and Their Applications* (2nd Edition). Wiley.
   - é«˜çº§å®åˆ†ææ•™æï¼Œä»‹ç»ç°ä»£åˆ†ææŠ€æœ¯åŠå…¶åº”ç”¨ã€‚

3. Lang, S. (1993). *Real and Functional Analysis* (3rd Edition). Springer.
    - å®åˆ†æä¸æ³›å‡½åˆ†æçš„ç»¼åˆæ•™æï¼Œè¯¦ç»†ä»‹ç»å‡½æ•°ç©ºé—´ç†è®ºã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Function (Mathematics)**: <https://en.wikipedia.org/wiki/Function_(mathematics)>
   - å‡½æ•°çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«å‡½æ•°å®šä¹‰ã€å®šä¹‰åŸŸã€å€¼åŸŸç­‰æ ¸å¿ƒæ¦‚å¿µï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

2. **Wikipedia - Continuous Function**: <https://en.wikipedia.org/wiki/Continuous_function>
   - è¿ç»­å‡½æ•°çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»è¿ç»­æ€§çš„å®šä¹‰å’Œæ€§è´¨ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

3. **Wikipedia - Bijection**: <https://en.wikipedia.org/wiki/Bijection>
   - åŒå°„çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«å•å°„ã€æ»¡å°„å’ŒåŒå°„çš„å…³ç³»ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
**æœ€åæ›´æ–° / Last Updated**: 2025-11-14
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-11-14)

---

*æœ¬æ–‡æ¡£ä¸¥æ ¼éµå¾ªæ•°å­¦å½¢å¼åŒ–è§„èŒƒï¼Œæ‰€æœ‰å®šä¹‰å’Œå®šç†å‡é‡‡ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·è¡¨ç¤ºã€‚*
*This document strictly follows mathematical formalization standards, with all definitions and theorems using standard mathematical notation.*
