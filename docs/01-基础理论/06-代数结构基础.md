# 代数结构基础 / Algebraic Structure Fundamentals

## 目录 (Table of Contents)

- [代数结构基础 / Algebraic Structure Fundamentals](#代数结构基础--algebraic-structure-fundamentals)
  - [目录 (Table of Contents)](#目录-table-of-contents)
  - [概述 / Overview](#概述--overview)
  - [群论基础 / Group Theory Fundamentals](#群论基础--group-theory-fundamentals)
    - [基本概念 / Basic Concepts](#基本概念--basic-concepts)
    - [子群与陪集 / Subgroups and Cosets](#子群与陪集--subgroups-and-cosets)
  - [环论基础 / Ring Theory Fundamentals](#环论基础--ring-theory-fundamentals)
    - [1基本概念 / Basic Concepts](#1基本概念--basic-concepts)
    - [理想与商环 / Ideals and Quotient Rings](#理想与商环--ideals-and-quotient-rings)
  - [域论基础 / Field Theory Fundamentals](#域论基础--field-theory-fundamentals)
    - [2基本概念 / Basic Concepts](#2基本概念--basic-concepts)
  - [线性代数基础 / Linear Algebra Fundamentals](#线性代数基础--linear-algebra-fundamentals)
    - [向量空间 / Vector Spaces](#向量空间--vector-spaces)
  - [应用示例 / Applications](#应用示例--applications)
    - [密码学应用 / Cryptographic Applications](#密码学应用--cryptographic-applications)
    - [算法优化应用 / Algorithm Optimization Applications](#算法优化应用--algorithm-optimization-applications)
  - [总结 / Summary](#总结--summary)
  - [术语对照表 / Terminology Reference](#术语对照表--terminology-reference)
  - [练习与习题 / Exercises and Problems](#练习与习题--exercises-and-problems)
    - [基础练习 / Basic Exercises](#基础练习--basic-exercises)
    - [进阶练习 / Advanced Exercises](#进阶练习--advanced-exercises)
    - [编程练习 / Programming Exercises](#编程练习--programming-exercises)
    - [应用练习 / Application Exercises](#应用练习--application-exercises)
  - [参考文献 / References](#参考文献--references)

## 概述 / Overview

代数结构是研究集合上运算性质的数学分支，为算法理论提供了重要的抽象工具。本文档介绍群、环、域等基本代数结构及其在算法中的应用。

Algebraic structures study the properties of operations on sets, providing important abstract tools for algorithm theory. This document introduces basic algebraic structures such as groups, rings, and fields, and their applications in algorithms.

## 群论基础 / Group Theory Fundamentals

### 基本概念 / Basic Concepts

**定义 1.1 (群)** / **Definition 1.1 (Group)**
群是一个二元组 $(G, \cdot)$，其中 $G$ 是一个非空集合，$\cdot$ 是 $G$ 上的二元运算，满足以下公理：

1. **封闭性**：对于任意 $a, b \in G$，有 $a \cdot b \in G$
2. **结合律**：对于任意 $a, b, c \in G$，有 $(a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. **单位元**：存在 $e \in G$，使得对于任意 $a \in G$，有 $e \cdot a = a \cdot e = a$
4. **逆元**：对于任意 $a \in G$，存在 $a^{-1} \in G$，使得 $a \cdot a^{-1} = a^{-1} \cdot a = e$

A group is a pair $(G, \cdot)$ where $G$ is a non-empty set and $\cdot$ is a binary operation on $G$ satisfying the following axioms:

1. **Closure**: For any $a, b \in G$, we have $a \cdot b \in G$
2. **Associativity**: For any $a, b, c \in G$, we have $(a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. **Identity**: There exists $e \in G$ such that for any $a \in G$, we have $e \cdot a = a \cdot e = a$
4. **Inverse**: For any $a \in G$, there exists $a^{-1} \in G$ such that $a \cdot a^{-1} = a^{-1} \cdot a = e$

**定义 1.2 (阿贝尔群)** / **Definition 1.2 (Abelian Group)**
如果群 $(G, \cdot)$ 还满足交换律：对于任意 $a, b \in G$，有 $a \cdot b = b \cdot a$，则称 $G$ 为阿贝尔群。

If a group $(G, \cdot)$ also satisfies commutativity: for any $a, b \in G$, we have $a \cdot b = b \cdot a$, then $G$ is called an Abelian group.

**算法 1.1 (群运算)** / **Algorithm 1.1 (Group Operations)**

```rust
/// 群的基本结构
/// Basic group structure
pub trait Group {
    type Element;
    
    /// 群运算
    /// Group operation
    fn operation(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
    
    /// 单位元
    /// Identity element
    fn identity(&self) -> Self::Element;
    
    /// 逆元
    /// Inverse element
    fn inverse(&self, a: &Self::Element) -> Self::Element;
    
    /// 幂运算
    /// Power operation
    fn power(&self, a: &Self::Element, n: i64) -> Self::Element {
        if n == 0 {
            return self.identity();
        }
        
        let mut result = if n > 0 { a.clone() } else { self.inverse(a) };
        let abs_n = n.abs();
        
        for _ in 1..abs_n {
            result = self.operation(&result, if n > 0 { a } else { &self.inverse(a) });
        }
        
        result
    }
}

/// 整数加法群
/// Integer addition group
pub struct IntegerAdditiveGroup;

impl Group for IntegerAdditiveGroup {
    type Element = i64;
    
    fn operation(&self, a: &i64, b: &i64) -> i64 {
        a + b
    }
    
    fn identity(&self) -> i64 {
        0
    }
    
    fn inverse(&self, a: &i64) -> i64 {
        -a
    }
}

/// 模n乘法群
/// Multiplicative group modulo n
pub struct MultiplicativeGroupModN {
    n: u64,
}

impl MultiplicativeGroupModN {
    pub fn new(n: u64) -> Self {
        Self { n }
    }
    
    /// 检查元素是否在群中
    /// Check if element is in the group
    pub fn is_in_group(&self, a: &u64) -> bool {
        gcd(*a as i64, self.n as i64) == 1
    }
}

impl Group for MultiplicativeGroupModN {
    type Element = u64;
    
    fn operation(&self, a: &u64, b: &u64) -> u64 {
        (a * b) % self.n
    }
    
    fn identity(&self) -> u64 {
        1
    }
    
    fn inverse(&self, a: &u64) -> u64 {
        if let Some(inv) = mod_inverse(*a, self.n) {
            inv
        } else {
            panic!("Element has no inverse");
        }
    }
}
```

### 子群与陪集 / Subgroups and Cosets

**定义 1.3 (子群)** / **Definition 1.3 (Subgroup)**
设 $(G, \cdot)$ 是一个群，$H$ 是 $G$ 的非空子集。如果 $(H, \cdot)$ 也是一个群，则称 $H$ 是 $G$ 的子群。

Let $(G, \cdot)$ be a group and $H$ be a non-empty subset of $G$. If $(H, \cdot)$ is also a group, then $H$ is called a subgroup of $G$.

**定理 1.1 (子群判定定理)** / **Theorem 1.1 (Subgroup Test)**
设 $(G, \cdot)$ 是一个群，$H$ 是 $G$ 的非空子集。$H$ 是 $G$ 的子群当且仅当：

1. 对于任意 $a, b \in H$，有 $a \cdot b \in H$
2. 对于任意 $a \in H$，有 $a^{-1} \in H$

Let $(G, \cdot)$ be a group and $H$ be a non-empty subset of $G$. $H$ is a subgroup of $G$ if and only if:

1. For any $a, b \in H$, we have $a \cdot b \in H$
2. For any $a \in H$, we have $a^{-1} \in H$

**算法 1.2 (子群判定)** / **Algorithm 1.2 (Subgroup Testing)**

```rust
/// 子群判定
/// Subgroup testing
pub fn is_subgroup<G: Group>(group: &G, subset: &[G::Element]) -> bool 
where G::Element: Clone + PartialEq {
    if subset.is_empty() {
        return false;
    }
    
    // 检查封闭性
    for a in subset {
        for b in subset {
            let result = group.operation(a, b);
            if !subset.contains(&result) {
                return false;
            }
        }
    }
    
    // 检查逆元
    for a in subset {
        let inverse = group.inverse(a);
        if !subset.contains(&inverse) {
            return false;
        }
    }
    
    true
}

/// 生成子群
/// Generate subgroup
pub fn generate_subgroup<G: Group>(group: &G, generators: &[G::Element]) -> Vec<G::Element>
where G::Element: Clone + PartialEq + Eq + std::hash::Hash {
    use std::collections::HashSet;
    
    let mut subgroup = HashSet::new();
    let mut queue = Vec::new();
    
    // 添加单位元
    subgroup.insert(group.identity());
    queue.push(group.identity());
    
    while let Some(current) = queue.pop() {
        for generator in generators {
            let new_element = group.operation(&current, generator);
            if subgroup.insert(new_element.clone()) {
                queue.push(new_element);
            }
        }
    }
    
    subgroup.into_iter().collect()
}
```

## 环论基础 / Ring Theory Fundamentals

### 1基本概念 / Basic Concepts

**定义 2.1 (环)** / **Definition 2.1 (Ring)**
环是一个三元组 $(R, +, \cdot)$，其中 $R$ 是一个非空集合，$+$ 和 $\cdot$ 是 $R$ 上的二元运算，满足以下公理：

1. $(R, +)$ 是一个阿贝尔群
2. $(R, \cdot)$ 满足结合律
3. 分配律：对于任意 $a, b, c \in R$，有 $a \cdot (b + c) = a \cdot b + a \cdot c$ 和 $(a + b) \cdot c = a \cdot c + b \cdot c$

A ring is a triple $(R, +, \cdot)$ where $R$ is a non-empty set and $+$ and $\cdot$ are binary operations on $R$ satisfying the following axioms:

1. $(R, +)$ is an Abelian group
2. $(R, \cdot)$ satisfies associativity
3. Distributivity: For any $a, b, c \in R$, we have $a \cdot (b + c) = a \cdot b + a \cdot c$ and $(a + b) \cdot c = a \cdot c + b \cdot c$

**定义 2.2 (交换环)** / **Definition 2.2 (Commutative Ring)**
如果环 $(R, +, \cdot)$ 的乘法运算满足交换律，则称 $R$ 为交换环。

If the multiplication operation of a ring $(R, +, \cdot)$ satisfies commutativity, then $R$ is called a commutative ring.

**算法 2.1 (环运算)** / **Algorithm 2.1 (Ring Operations)**

```rust
/// 环的基本结构
/// Basic ring structure
pub trait Ring {
    type Element;
    
    /// 加法运算
    /// Addition operation
    fn add(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
    
    /// 乘法运算
    /// Multiplication operation
    fn multiply(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
    
    /// 加法单位元
    /// Additive identity
    fn additive_identity(&self) -> Self::Element;
    
    /// 加法逆元
    /// Additive inverse
    fn additive_inverse(&self, a: &Self::Element) -> Self::Element;
    
    /// 减法运算
    /// Subtraction operation
    fn subtract(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
        self.add(a, &self.additive_inverse(b))
    }
}

/// 整数环
/// Integer ring
pub struct IntegerRing;

impl Ring for IntegerRing {
    type Element = i64;
    
    fn add(&self, a: &i64, b: &i64) -> i64 {
        a + b
    }
    
    fn multiply(&self, a: &i64, b: &i64) -> i64 {
        a * b
    }
    
    fn additive_identity(&self) -> i64 {
        0
    }
    
    fn additive_inverse(&self, a: &i64) -> i64 {
        -a
    }
}

/// 模n环
/// Ring modulo n
pub struct RingModN {
    n: u64,
}

impl RingModN {
    pub fn new(n: u64) -> Self {
        Self { n }
    }
}

impl Ring for RingModN {
    type Element = u64;
    
    fn add(&self, a: &u64, b: &u64) -> u64 {
        (a + b) % self.n
    }
    
    fn multiply(&self, a: &u64, b: &u64) -> u64 {
        (a * b) % self.n
    }
    
    fn additive_identity(&self) -> u64 {
        0
    }
    
    fn additive_inverse(&self, a: &u64) -> u64 {
        if *a == 0 {
            0
        } else {
            self.n - a
        }
    }
}
```

### 理想与商环 / Ideals and Quotient Rings

**定义 2.3 (理想)** / **Definition 2.3 (Ideal)**
设 $(R, +, \cdot)$ 是一个环，$I$ 是 $R$ 的子集。如果 $I$ 满足：

1. $(I, +)$ 是 $(R, +)$ 的子群
2. 对于任意 $r \in R$ 和 $i \in I$，有 $r \cdot i \in I$ 和 $i \cdot r \in I$

则称 $I$ 是 $R$ 的理想。

Let $(R, +, \cdot)$ be a ring and $I$ be a subset of $R$. If $I$ satisfies:

1. $(I, +)$ is a subgroup of $(R, +)$
2. For any $r \in R$ and $i \in I$, we have $r \cdot i \in I$ and $i \cdot r \in I$

Then $I$ is called an ideal of $R$.

**算法 2.2 (理想判定)** / **Algorithm 2.2 (Ideal Testing)**

```rust
/// 理想判定
/// Ideal testing
pub fn is_ideal<R: Ring>(ring: &R, subset: &[R::Element]) -> bool 
where R::Element: Clone + PartialEq {
    if subset.is_empty() {
        return false;
    }
    
    // 检查加法子群性质
    for a in subset {
        for b in subset {
            let sum = ring.add(a, b);
            if !subset.contains(&sum) {
                return false;
            }
        }
    }
    
    for a in subset {
        let inverse = ring.additive_inverse(a);
        if !subset.contains(&inverse) {
            return false;
        }
    }
    
    // 检查理想性质（需要环的所有元素）
    // 这里简化处理，实际应用中需要更完整的实现
    true
}
```

## 域论基础 / Field Theory Fundamentals

### 2基本概念 / Basic Concepts

**定义 3.1 (域)** / **Definition 3.1 (Field)**
域是一个三元组 $(F, +, \cdot)$，其中 $F$ 是一个非空集合，$+$ 和 $\cdot$ 是 $F$ 上的二元运算，满足以下公理：

1. $(F, +)$ 是一个阿贝尔群
2. $(F \setminus \{0\}, \cdot)$ 是一个阿贝尔群
3. 分配律：对于任意 $a, b, c \in F$，有 $a \cdot (b + c) = a \cdot b + a \cdot c$

A field is a triple $(F, +, \cdot)$ where $F$ is a non-empty set and $+$ and $\cdot$ are binary operations on $F$ satisfying the following axioms:

1. $(F, +)$ is an Abelian group
2. $(F \setminus \{0\}, \cdot)$ is an Abelian group
3. Distributivity: For any $a, b, c \in F$, we have $a \cdot (b + c) = a \cdot b + a \cdot c$

**定义 3.2 (有限域)** / **Definition 3.2 (Finite Field)**
如果域 $F$ 的元素个数有限，则称 $F$ 为有限域。

If a field $F$ has finitely many elements, then $F$ is called a finite field.

**算法 3.1 (域运算)** / **Algorithm 3.1 (Field Operations)**

```rust
/// 域的基本结构
/// Basic field structure
pub trait Field {
    type Element;
    
    /// 加法运算
    /// Addition operation
    fn add(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
    
    /// 乘法运算
    /// Multiplication operation
    fn multiply(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
    
    /// 加法单位元
    /// Additive identity
    fn additive_identity(&self) -> Self::Element;
    
    /// 乘法单位元
    /// Multiplicative identity
    fn multiplicative_identity(&self) -> Self::Element;
    
    /// 加法逆元
    /// Additive inverse
    fn additive_inverse(&self, a: &Self::Element) -> Self::Element;
    
    /// 乘法逆元
    /// Multiplicative inverse
    fn multiplicative_inverse(&self, a: &Self::Element) -> Option<Self::Element>;
    
    /// 除法运算
    /// Division operation
    fn divide(&self, a: &Self::Element, b: &Self::Element) -> Option<Self::Element> {
        if let Some(b_inv) = self.multiplicative_inverse(b) {
            Some(self.multiply(a, &b_inv))
        } else {
            None
        }
    }
}

/// 有理数域
/// Rational number field
pub struct RationalField;

impl Field for RationalField {
    type Element = (i64, i64); // (numerator, denominator)
    
    fn add(&self, a: &(i64, i64), b: &(i64, i64)) -> (i64, i64) {
        let (num_a, den_a) = a;
        let (num_b, den_b) = b;
        let lcm_den = lcm(*den_a, *den_b);
        let new_num = num_a * (lcm_den / den_a) + num_b * (lcm_den / den_b);
        let gcd_val = gcd(new_num, lcm_den);
        (new_num / gcd_val, lcm_den / gcd_val)
    }
    
    fn multiply(&self, a: &(i64, i64), b: &(i64, i64)) -> (i64, i64) {
        let (num_a, den_a) = a;
        let (num_b, den_b) = b;
        let new_num = num_a * num_b;
        let new_den = den_a * den_b;
        let gcd_val = gcd(new_num, new_den);
        (new_num / gcd_val, new_den / gcd_val)
    }
    
    fn additive_identity(&self) -> (i64, i64) {
        (0, 1)
    }
    
    fn multiplicative_identity(&self) -> (i64, i64) {
        (1, 1)
    }
    
    fn additive_inverse(&self, a: &(i64, i64)) -> (i64, i64) {
        let (num, den) = a;
        (-num, *den)
    }
    
    fn multiplicative_inverse(&self, a: &(i64, i64)) -> Option<(i64, i64)> {
        let (num, den) = a;
        if *num == 0 {
            None
        } else {
            Some((*den, *num))
        }
    }
}

/// 有限域 GF(p)
/// Finite field GF(p)
pub struct FiniteFieldGFp {
    p: u64,
}

impl FiniteFieldGFp {
    pub fn new(p: u64) -> Self {
        Self { p }
    }
}

impl Field for FiniteFieldGFp {
    type Element = u64;
    
    fn add(&self, a: &u64, b: &u64) -> u64 {
        (a + b) % self.p
    }
    
    fn multiply(&self, a: &u64, b: &u64) -> u64 {
        (a * b) % self.p
    }
    
    fn additive_identity(&self) -> u64 {
        0
    }
    
    fn multiplicative_identity(&self) -> u64 {
        1
    }
    
    fn additive_inverse(&self, a: &u64) -> u64 {
        if *a == 0 {
            0
        } else {
            self.p - a
        }
    }
    
    fn multiplicative_inverse(&self, a: &u64) -> Option<u64> {
        if *a == 0 {
            None
        } else {
            mod_inverse(*a, self.p)
        }
    }
}
```

## 线性代数基础 / Linear Algebra Fundamentals

### 向量空间 / Vector Spaces

**定义 4.1 (向量空间)** / **Definition 4.1 (Vector Space)**
设 $F$ 是一个域，$V$ 是一个非空集合。如果 $V$ 上定义了加法和标量乘法运算，满足向量空间的公理，则称 $V$ 是 $F$ 上的向量空间。

Let $F$ be a field and $V$ be a non-empty set. If addition and scalar multiplication operations are defined on $V$ satisfying the vector space axioms, then $V$ is called a vector space over $F$.

**算法 4.1 (向量运算)** / **Algorithm 4.1 (Vector Operations)**

```rust
/// 向量空间的基本结构
/// Basic vector space structure
pub trait VectorSpace<F: Field> {
    type Vector;
    
    /// 向量加法
    /// Vector addition
    fn add(&self, a: &Self::Vector, b: &Self::Vector) -> Self::Vector;
    
    /// 标量乘法
    /// Scalar multiplication
    fn scalar_multiply(&self, scalar: &F::Element, vector: &Self::Vector) -> Self::Vector;
    
    /// 零向量
    /// Zero vector
    fn zero_vector(&self) -> Self::Vector;
    
    /// 向量加法逆元
    /// Vector additive inverse
    fn vector_additive_inverse(&self, vector: &Self::Vector) -> Self::Vector;
}

/// 有限维向量空间
/// Finite dimensional vector space
pub struct FiniteDimensionalVectorSpace<F: Field> {
    field: F,
    dimension: usize,
}

impl<F: Field> FiniteDimensionalVectorSpace<F> {
    pub fn new(field: F, dimension: usize) -> Self {
        Self { field, dimension }
    }
}

impl<F: Field> VectorSpace<F> for FiniteDimensionalVectorSpace<F> {
    type Vector = Vec<F::Element>;
    
    fn add(&self, a: &Vec<F::Element>, b: &Vec<F::Element>) -> Vec<F::Element> {
        a.iter().zip(b.iter())
            .map(|(x, y)| self.field.add(x, y))
            .collect()
    }
    
    fn scalar_multiply(&self, scalar: &F::Element, vector: &Vec<F::Element>) -> Vec<F::Element> {
        vector.iter()
            .map(|x| self.field.multiply(scalar, x))
            .collect()
    }
    
    fn zero_vector(&self) -> Vec<F::Element> {
        vec![self.field.additive_identity(); self.dimension]
    }
    
    fn vector_additive_inverse(&self, vector: &Vec<F::Element>) -> Vec<F::Element> {
        vector.iter()
            .map(|x| self.field.additive_inverse(x))
            .collect()
    }
}
```

## 应用示例 / Applications

### 密码学应用 / Cryptographic Applications

**示例 1: 椭圆曲线密码学** / **Example 1: Elliptic Curve Cryptography**

```rust
/// 椭圆曲线点
/// Elliptic curve point
#[derive(Clone, PartialEq)]
pub struct EllipticCurvePoint {
    pub x: Option<u64>,
    pub y: Option<u64>,
}

impl EllipticCurvePoint {
    pub fn infinity() -> Self {
        Self { x: None, y: None }
    }
    
    pub fn new(x: u64, y: u64) -> Self {
        Self { x: Some(x), y: Some(y) }
    }
}

/// 椭圆曲线群
/// Elliptic curve group
pub struct EllipticCurveGroup {
    pub a: u64,
    pub b: u64,
    pub p: u64,
}

impl EllipticCurveGroup {
    pub fn new(a: u64, b: u64, p: u64) -> Self {
        Self { a, b, p }
    }
    
    /// 点加法
    /// Point addition
    pub fn add_points(&self, p1: &EllipticCurvePoint, p2: &EllipticCurvePoint) -> EllipticCurvePoint {
        if p1.x.is_none() {
            return p2.clone();
        }
        if p2.x.is_none() {
            return p1.clone();
        }
        
        let (x1, y1) = (p1.x.unwrap(), p1.y.unwrap());
        let (x2, y2) = (p2.x.unwrap(), p2.y.unwrap());
        
        if x1 == x2 && y1 != y2 {
            return EllipticCurvePoint::infinity();
        }
        
        let lambda = if x1 == x2 {
            // 切线斜率
            let numerator = (3 * x1 * x1 + self.a) % self.p;
            let denominator = (2 * y1) % self.p;
            (numerator * mod_inverse(denominator, self.p).unwrap()) % self.p
        } else {
            // 割线斜率
            let numerator = (y2 + self.p - y1) % self.p;
            let denominator = (x2 + self.p - x1) % self.p;
            (numerator * mod_inverse(denominator, self.p).unwrap()) % self.p
        };
        
        let x3 = (lambda * lambda + self.p - x1 + self.p - x2) % self.p;
        let y3 = (lambda * (x1 + self.p - x3) + self.p - y1) % self.p;
        
        EllipticCurvePoint::new(x3, y3)
    }
}
```

### 算法优化应用 / Algorithm Optimization Applications

**示例 2: 快速傅里叶变换** / **Example 2: Fast Fourier Transform**

```rust
/// 复数结构
/// Complex number structure
#[derive(Clone)]
pub struct Complex {
    pub real: f64,
    pub imag: f64,
}

impl Complex {
    pub fn new(real: f64, imag: f64) -> Self {
        Self { real, imag }
    }
    
    pub fn add(&self, other: &Complex) -> Complex {
        Complex::new(self.real + other.real, self.imag + other.imag)
    }
    
    pub fn multiply(&self, other: &Complex) -> Complex {
        Complex::new(
            self.real * other.real - self.imag * other.imag,
            self.real * other.imag + self.imag * other.real
        )
    }
    
    pub fn conjugate(&self) -> Complex {
        Complex::new(self.real, -self.imag)
    }
}

/// 快速傅里叶变换
/// Fast Fourier Transform
pub fn fft(polynomial: &[Complex], inverse: bool) -> Vec<Complex> {
    let n = polynomial.len();
    if n == 1 {
        return polynomial.to_vec();
    }
    
    if n & (n - 1) != 0 {
        panic!("Polynomial length must be a power of 2");
    }
    
    let mut even = Vec::new();
    let mut odd = Vec::new();
    
    for (i, &coeff) in polynomial.iter().enumerate() {
        if i % 2 == 0 {
            even.push(coeff);
        } else {
            odd.push(coeff);
        }
    }
    
    let even_fft = fft(&even, inverse);
    let odd_fft = fft(&odd, inverse);
    
    let mut result = vec![Complex::new(0.0, 0.0); n];
    let sign = if inverse { 1.0 } else { -1.0 };
    
    for k in 0..n/2 {
        let angle = sign * 2.0 * std::f64::consts::PI * k as f64 / n as f64;
        let w = Complex::new(angle.cos(), angle.sin());
        let temp = w.multiply(&odd_fft[k]);
        
        result[k] = even_fft[k].add(&temp);
        result[k + n/2] = even_fft[k].add(&temp.conjugate().multiply(&Complex::new(-1.0, 0.0)));
    }
    
    if inverse {
        for coeff in &mut result {
            coeff.real /= n as f64;
            coeff.imag /= n as f64;
        }
    }
    
    result
}
```

## 总结 / Summary

代数结构基础为算法理论提供了重要的抽象工具，包括：

1. **群论**：为对称性算法和密码学提供基础
2. **环论**：在多项式算法和编码理论中广泛应用
3. **域论**：为线性代数和有限域算法提供基础
4. **线性代数**：在机器学习、信号处理等领域发挥重要作用

Algebraic structure fundamentals provide important abstract tools for algorithm theory, including:

1. **Group theory**: Provides foundation for symmetric algorithms and cryptography
2. **Ring theory**: Widely used in polynomial algorithms and coding theory
3. **Field theory**: Provides foundation for linear algebra and finite field algorithms
4. **Linear algebra**: Plays important roles in machine learning, signal processing, and other fields

## 术语对照表 / Terminology Reference

| 中文术语 | English Term | 定义/说明 |
|---------|-------------|----------|
| 群 | Group | 满足封闭性、结合律、单位元、逆元的代数结构 |
| 阿贝尔群 | Abelian Group | 满足交换律的群 |
| 子群 | Subgroup | 群的子集，本身也构成群 |
| 陪集 | Coset | 群中元素的等价类 |
| 环 | Ring | 满足加法群、乘法结合律、分配律的代数结构 |
| 交换环 | Commutative Ring | 乘法满足交换律的环 |
| 域 | Field | 非零元素构成乘法群的环 |
| 有限域 | Finite Field | 元素个数有限的域 |
| 向量空间 | Vector Space | 域上的线性代数结构 |
| 线性变换 | Linear Transformation | 保持向量加法和标量乘法的映射 |
| 特征值 | Eigenvalue | 线性变换的不变子空间对应的标量 |
| 特征向量 | Eigenvector | 特征值对应的非零向量 |

## 练习与习题 / Exercises and Problems

### 基础练习 / Basic Exercises

**练习 1.1** / **Exercise 1.1**
证明：群中的单位元是唯一的。

Prove: The identity element in a group is unique.

**练习 1.2** / **Exercise 1.2**
证明：群中每个元素的逆元是唯一的。

Prove: The inverse of each element in a group is unique.

**练习 1.3** / **Exercise 1.3**
验证：整数加法群 $(\mathbb{Z}, +)$ 是阿贝尔群。

Verify: The integer addition group $(\mathbb{Z}, +)$ is an Abelian group.

### 进阶练习 / Advanced Exercises

**练习 2.1** / **Exercise 2.1**
证明：如果 $H$ 是群 $G$ 的子群，则 $|H|$ 整除 $|G|$（拉格朗日定理）。

Prove: If $H$ is a subgroup of group $G$, then $|H|$ divides $|G|$ (Lagrange's theorem).

**练习 2.2** / **Exercise 2.2**
证明：有限域的元素个数必须是素数的幂。

Prove: The number of elements in a finite field must be a power of a prime.

**练习 2.3** / **Exercise 2.3**
证明：环中的零元素乘以任何元素都等于零。

Prove: The zero element in a ring multiplied by any element equals zero.

### 编程练习 / Programming Exercises

**练习 3.1** / **Exercise 3.1**
实现一个通用的群结构，支持群运算、单位元和逆元计算。

Implement a generic group structure supporting group operations, identity element, and inverse element computation.

**练习 3.2** / **Exercise 3.2**
实现有限域上的基本运算，包括加法、乘法、除法和幂运算。

Implement basic operations on finite fields, including addition, multiplication, division, and exponentiation.

**练习 3.3** / **Exercise 3.3**
实现复数类，支持复数的基本运算和快速傅里叶变换。

Implement a complex number class supporting basic complex operations and fast Fourier transform.

### 应用练习 / Application Exercises

**练习 4.1** / **Exercise 4.1**
使用椭圆曲线群实现简单的数字签名算法。

Use elliptic curve groups to implement a simple digital signature algorithm.

**练习 4.2** / **Exercise 4.2**
实现有限域上的多项式运算，包括加法、乘法和除法。

Implement polynomial operations on finite fields, including addition, multiplication, and division.

**练习 4.3** / **Exercise 4.3**
使用线性代数方法求解线性方程组，并分析其复杂度。

Use linear algebra methods to solve systems of linear equations and analyze their complexity.

## 参考文献 / References

1. Dummit, D. S., & Foote, R. M. (2004). Abstract Algebra. Wiley.
2. Hungerford, T. W. (2012). Algebra. Springer.
3. Lang, S. (2002). Algebra. Springer.
4. Artin, M. (2011). Algebra. Pearson.
5. Herstein, I. N. (1996). Abstract Algebra. Macmillan.
