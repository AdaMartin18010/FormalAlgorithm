# 测度论基础 / Measure Theory Foundation

## 目录 (Table of Contents)

- [测度论基础 / Measure Theory Foundation](#测度论基础--measure-theory-foundation)
  - [目录 (Table of Contents)](#目录-table-of-contents)
  - [基本概念 / Basic Concepts](#基本概念--basic-concepts)
    - [σ-代数 / σ-Algebra](#σ-代数--σ-algebra)
    - [测度 / Measure](#测度--measure)
    - [可测函数 / Measurable Functions](#可测函数--measurable-functions)
  - [测度论在算法中的应用 / Applications of Measure Theory in Algorithms](#测度论在算法中的应用--applications-of-measure-theory-in-algorithms)
    - [概率算法 / Probabilistic Algorithms](#概率算法--probabilistic-algorithms)
    - [积分理论 / Integration Theory](#积分理论--integration-theory)
  - [测度论的高级主题 / Advanced Topics in Measure Theory](#测度论的高级主题--advanced-topics-in-measure-theory)
    - [绝对连续性和奇异测度 / Absolute Continuity and Singular Measures](#绝对连续性和奇异测度--absolute-continuity-and-singular-measures)
    - [收敛定理 / Convergence Theorems](#收敛定理--convergence-theorems)
  - [实现示例 / Implementation Examples](#实现示例--implementation-examples)
    - [概率分布 / Probability Distributions](#概率分布--probability-distributions)
  - [参考文献 / References](#参考文献--references)

## 基本概念 / Basic Concepts

### σ-代数 / σ-Algebra

**定义 1.1** (σ-代数) / **Definition 1.1** (σ-Algebra)
设 $X$ 为集合，$\mathcal{F}$ 为 $X$ 的子集族，如果 $\mathcal{F}$ 满足以下条件：
Let $X$ be a set and $\mathcal{F}$ be a family of subsets of $X$. $\mathcal{F}$ is a **σ-algebra** if it satisfies:

1. **包含全集** / **Contains Universe**: $X \in \mathcal{F}$
2. **补集封闭** / **Closed under Complements**: 若 $A \in \mathcal{F}$，则 $A^c \in \mathcal{F}$
3. **可数并封闭** / **Closed under Countable Unions**: 若 $\{A_n\}_{n=1}^{\infty} \subseteq \mathcal{F}$，则 $\bigcup_{n=1}^{\infty} A_n \in \mathcal{F}$

则称 $\mathcal{F}$ 为 $X$ 上的**σ-代数**。
Then $\mathcal{F}$ is called a **σ-algebra** on $X$.

**定理 1.1** (σ-代数的基本性质) / **Theorem 1.1** (Basic Properties of σ-Algebras)
设 $\mathcal{F}$ 为 $X$ 上的σ-代数，则：
Let $\mathcal{F}$ be a σ-algebra on $X$, then:

1. $\emptyset \in \mathcal{F}$
2. 若 $A, B \in \mathcal{F}$，则 $A \cap B \in \mathcal{F}$
3. 若 $\{A_n\}_{n=1}^{\infty} \subseteq \mathcal{F}$，则 $\bigcap_{n=1}^{\infty} A_n \in \mathcal{F}$

### 测度 / Measure

**定义 1.2** (测度) / **Definition 1.2** (Measure)
设 $(X, \mathcal{F})$ 为可测空间，函数 $\mu: \mathcal{F} \to [0, \infty]$ 称为**测度**，如果：
Let $(X, \mathcal{F})$ be a measurable space. A function $\mu: \mathcal{F} \to [0, \infty]$ is called a **measure** if:

1. **非负性** / **Non-negativity**: $\mu(A) \geq 0$ 对所有 $A \in \mathcal{F}$
2. **空集为零** / **Empty Set**: $\mu(\emptyset) = 0$
3. **可数可加性** / **Countable Additivity**: 若 $\{A_n\}_{n=1}^{\infty} \subseteq \mathcal{F}$ 为互不相交的集合族，则：
   $$\mu\left(\bigcup_{n=1}^{\infty} A_n\right) = \sum_{n=1}^{\infty} \mu(A_n)$$

**定理 1.2** (测度的基本性质) / **Theorem 1.2** (Basic Properties of Measures)
设 $\mu$ 为测度，则：
Let $\mu$ be a measure, then:

1. **单调性** / **Monotonicity**: 若 $A \subseteq B$，则 $\mu(A) \leq \mu(B)$
2. **次可加性** / **Subadditivity**: $\mu\left(\bigcup_{n=1}^{\infty} A_n\right) \leq \sum_{n=1}^{\infty} \mu(A_n)$
3. **连续性** / **Continuity**: 若 $A_n \uparrow A$，则 $\mu(A_n) \uparrow \mu(A)$

### 可测函数 / Measurable Functions

**定义 1.3** (可测函数) / **Definition 1.3** (Measurable Function)
设 $(X, \mathcal{F})$ 和 $(Y, \mathcal{G})$ 为可测空间，函数 $f: X \to Y$ 称为**可测函数**，如果：
Let $(X, \mathcal{F})$ and $(Y, \mathcal{G})$ be measurable spaces. A function $f: X \to Y$ is called **measurable** if:

$$f^{-1}(G) \in \mathcal{F} \text{ for all } G \in \mathcal{G}$$

**定理 1.3** (可测函数的性质) / **Theorem 1.3** (Properties of Measurable Functions)
设 $f, g: X \to \mathbb{R}$ 为可测函数，则：
Let $f, g: X \to \mathbb{R}$ be measurable functions, then:

1. $f + g$ 可测 / $f + g$ is measurable
2. $f \cdot g$ 可测 / $f \cdot g$ is measurable
3. $\max(f, g)$ 和 $\min(f, g)$ 可测 / $\max(f, g)$ and $\min(f, g)$ are measurable

## 测度论在算法中的应用 / Applications of Measure Theory in Algorithms

### 概率算法 / Probabilistic Algorithms

**定义 2.1** (概率空间) / **Definition 2.1** (Probability Space)
一个**概率空间**是一个三元组 $(\Omega, \mathcal{F}, P)$，其中：
A **probability space** is a triple $(\Omega, \mathcal{F}, P)$ where:

1. $\Omega$ 为样本空间 / $\Omega$ is the sample space
2. $\mathcal{F}$ 为事件σ-代数 / $\mathcal{F}$ is the event σ-algebra
3. $P$ 为概率测度，满足 $P(\Omega) = 1$ / $P$ is the probability measure with $P(\Omega) = 1$

**实现示例** / **Implementation Example**

```rust
use std::collections::HashMap;
use rand::Rng;

// 概率空间 / Probability Space
struct ProbabilitySpace {
    events: HashMap<String, f64>,
}

impl ProbabilitySpace {
    fn new() -> Self {
        ProbabilitySpace {
            events: HashMap::new(),
        }
    }
    
    fn add_event(&mut self, event: String, probability: f64) {
        self.events.insert(event, probability);
    }
    
    fn get_probability(&self, event: &str) -> f64 {
        *self.events.get(event).unwrap_or(&0.0)
    }
    
    fn total_probability(&self) -> f64 {
        self.events.values().sum()
    }
}

// 随机变量 / Random Variable
struct RandomVariable {
    values: Vec<f64>,
    probabilities: Vec<f64>,
}

impl RandomVariable {
    fn new(values: Vec<f64>, probabilities: Vec<f64>) -> Self {
        assert_eq!(values.len(), probabilities.len());
        RandomVariable { values, probabilities }
    }
    
    fn expectation(&self) -> f64 {
        self.values.iter()
            .zip(self.probabilities.iter())
            .map(|(x, p)| x * p)
            .sum()
    }
    
    fn variance(&self) -> f64 {
        let mean = self.expectation();
        self.values.iter()
            .zip(self.probabilities.iter())
            .map(|(x, p)| (x - mean).powi(2) * p)
            .sum()
    }
    
    fn sample(&self) -> f64 {
        let mut rng = rand::thread_rng();
        let u: f64 = rng.gen();
        let mut cumulative = 0.0;
        
        for (value, prob) in self.values.iter().zip(self.probabilities.iter()) {
            cumulative += prob;
            if u <= cumulative {
                return *value;
            }
        }
        
        self.values.last().unwrap_or(&0.0)
    }
}

// 蒙特卡洛算法 / Monte Carlo Algorithm
struct MonteCarlo {
    iterations: usize,
}

impl MonteCarlo {
    fn new(iterations: usize) -> Self {
        MonteCarlo { iterations }
    }
    
    fn estimate_pi(&self) -> f64 {
        let mut rng = rand::thread_rng();
        let mut inside_circle = 0;
        
        for _ in 0..self.iterations {
            let x: f64 = rng.gen_range(-1.0..1.0);
            let y: f64 = rng.gen_range(-1.0..1.0);
            
            if x * x + y * y <= 1.0 {
                inside_circle += 1;
            }
        }
        
        4.0 * inside_circle as f64 / self.iterations as f64
    }
    
    fn estimate_integral<F>(&self, f: F, a: f64, b: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let mut rng = rand::thread_rng();
        let mut sum = 0.0;
        
        for _ in 0..self.iterations {
            let x: f64 = rng.gen_range(a..b);
            sum += f(x);
        }
        
        (b - a) * sum / self.iterations as f64
    }
}

fn main() {
    // 概率空间使用示例 / Probability space usage example
    let mut ps = ProbabilitySpace::new();
    ps.add_event("heads".to_string(), 0.5);
    ps.add_event("tails".to_string(), 0.5);
    
    println!("Probability of heads: {}", ps.get_probability("heads"));
    println!("Total probability: {}", ps.total_probability());
    
    // 随机变量使用示例 / Random variable usage example
    let rv = RandomVariable::new(
        vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0],
        vec![1.0/6.0; 6],
    );
    
    println!("Expectation: {}", rv.expectation());
    println!("Variance: {}", rv.variance());
    println!("Sample: {}", rv.sample());
    
    // 蒙特卡洛算法使用示例 / Monte Carlo algorithm usage example
    let mc = MonteCarlo::new(1000000);
    println!("Estimated π: {}", mc.estimate_pi());
    
    let integral = mc.estimate_integral(|x| x * x, 0.0, 1.0);
    println!("Estimated integral of x² from 0 to 1: {}", integral);
}
```

### 积分理论 / Integration Theory

**定义 2.2** (勒贝格积分) / **Definition 2.2** (Lebesgue Integral)
设 $(X, \mathcal{F}, \mu)$ 为测度空间，$f: X \to [0, \infty]$ 为非负可测函数，则**勒贝格积分**定义为：
Let $(X, \mathcal{F}, \mu)$ be a measure space and $f: X \to [0, \infty]$ be a non-negative measurable function. The **Lebesgue integral** is defined as:

$$\int_X f \, d\mu = \sup \left\{ \sum_{i=1}^{n} a_i \mu(A_i) \mid 0 \leq \sum_{i=1}^{n} a_i \chi_{A_i} \leq f \right\}$$

**定理 2.1** (单调收敛定理) / **Theorem 2.1** (Monotone Convergence Theorem)
设 $\{f_n\}$ 为非负可测函数的递增序列，$f = \lim_{n \to \infty} f_n$，则：
Let $\{f_n\}$ be an increasing sequence of non-negative measurable functions and $f = \lim_{n \to \infty} f_n$, then:

$$\int_X f \, d\mu = \lim_{n \to \infty} \int_X f_n \, d\mu$$

**实现示例** / **Implementation Example**

```rust
// 数值积分 / Numerical Integration
trait Integrable {
    fn evaluate(&self, x: f64) -> f64;
}

struct Function<F> {
    f: F,
}

impl<F> Function<F>
where
    F: Fn(f64) -> f64,
{
    fn new(f: F) -> Self {
        Function { f }
    }
}

impl<F> Integrable for Function<F>
where
    F: Fn(f64) -> f64,
{
    fn evaluate(&self, x: f64) -> f64 {
        (self.f)(x)
    }
}

// 梯形法则 / Trapezoidal Rule
struct TrapezoidalRule {
    n: usize,
}

impl TrapezoidalRule {
    fn new(n: usize) -> Self {
        TrapezoidalRule { n }
    }
    
    fn integrate<I: Integrable>(&self, f: &I, a: f64, b: f64) -> f64 {
        let h = (b - a) / self.n as f64;
        let mut sum = 0.5 * (f.evaluate(a) + f.evaluate(b));
        
        for i in 1..self.n {
            let x = a + i as f64 * h;
            sum += f.evaluate(x);
        }
        
        h * sum
    }
}

// 辛普森法则 / Simpson's Rule
struct SimpsonsRule {
    n: usize,
}

impl SimpsonsRule {
    fn new(n: usize) -> Self {
        SimpsonsRule { n }
    }
    
    fn integrate<I: Integrable>(&self, f: &I, a: f64, b: f64) -> f64 {
        let h = (b - a) / self.n as f64;
        let mut sum = f.evaluate(a) + f.evaluate(b);
        
        for i in 1..self.n {
            let x = a + i as f64 * h;
            if i % 2 == 0 {
                sum += 2.0 * f.evaluate(x);
            } else {
                sum += 4.0 * f.evaluate(x);
            }
        }
        
        h * sum / 3.0
    }
}

// 自适应积分 / Adaptive Integration
struct AdaptiveIntegrator {
    tolerance: f64,
    max_iterations: usize,
}

impl AdaptiveIntegrator {
    fn new(tolerance: f64, max_iterations: usize) -> Self {
        AdaptiveIntegrator {
            tolerance,
            max_iterations,
        }
    }
    
    fn integrate<I: Integrable>(&self, f: &I, a: f64, b: f64) -> f64 {
        self.adaptive_step(f, a, b, 0)
    }
    
    fn adaptive_step<I: Integrable>(&self, f: &I, a: f64, b: f64, depth: usize) -> f64 {
        if depth >= self.max_iterations {
            return self.simple_integrate(f, a, b);
        }
        
        let mid = (a + b) / 2.0;
        let left = self.simple_integrate(f, a, mid);
        let right = self.simple_integrate(f, mid, b);
        let total = self.simple_integrate(f, a, b);
        
        if (left + right - total).abs() < self.tolerance {
            left + right
        } else {
            self.adaptive_step(f, a, mid, depth + 1) + 
            self.adaptive_step(f, mid, b, depth + 1)
        }
    }
    
    fn simple_integrate<I: Integrable>(&self, f: &I, a: f64, b: f64) -> f64 {
        let h = b - a;
        let fa = f.evaluate(a);
        let fb = f.evaluate(b);
        h * (fa + fb) / 2.0
    }
}

fn main() {
    // 函数积分示例 / Function integration example
    let f = Function::new(|x| x * x);
    
    // 梯形法则 / Trapezoidal rule
    let trapezoidal = TrapezoidalRule::new(1000);
    let result1 = trapezoidal.integrate(&f, 0.0, 1.0);
    println!("Trapezoidal rule: {}", result1);
    
    // 辛普森法则 / Simpson's rule
    let simpson = SimpsonsRule::new(1000);
    let result2 = simpson.integrate(&f, 0.0, 1.0);
    println!("Simpson's rule: {}", result2);
    
    // 自适应积分 / Adaptive integration
    let adaptive = AdaptiveIntegrator::new(1e-6, 10);
    let result3 = adaptive.integrate(&f, 0.0, 1.0);
    println!("Adaptive integration: {}", result3);
    
    // 理论值 / Theoretical value
    println!("Theoretical value: {}", 1.0 / 3.0);
}
```

## 测度论的高级主题 / Advanced Topics in Measure Theory

### 绝对连续性和奇异测度 / Absolute Continuity and Singular Measures

**定义 3.1** (绝对连续) / **Definition 3.1** (Absolute Continuity)
设 $\mu$ 和 $\nu$ 为测度空间 $(X, \mathcal{F})$ 上的测度，如果对任意 $A \in \mathcal{F}$，$\mu(A) = 0$ 蕴含 $\nu(A) = 0$，则称 $\nu$ 关于 $\mu$ **绝对连续**，记作 $\nu \ll \mu$。
Let $\mu$ and $\nu$ be measures on $(X, \mathcal{F})$. If for any $A \in \mathcal{F}$, $\mu(A) = 0$ implies $\nu(A) = 0$, then $\nu$ is **absolutely continuous** with respect to $\mu$, denoted by $\nu \ll \mu$.

**定理 3.1** (拉东-尼科迪姆定理) / **Theorem 3.1** (Radon-Nikodym Theorem)
设 $\mu$ 为σ-有限测度，$\nu$ 关于 $\mu$ 绝对连续，则存在非负可测函数 $f$ 使得：
Let $\mu$ be σ-finite and $\nu \ll \mu$. Then there exists a non-negative measurable function $f$ such that:

$$\nu(A) = \int_A f \, d\mu \text{ for all } A \in \mathcal{F}$$

### 收敛定理 / Convergence Theorems

**定理 3.2** (控制收敛定理) / **Theorem 3.2** (Dominated Convergence Theorem)
设 $\{f_n\}$ 为可测函数序列，$f_n \to f$ 几乎处处，且存在可积函数 $g$ 使得 $|f_n| \leq g$ 几乎处处，则：
Let $\{f_n\}$ be a sequence of measurable functions with $f_n \to f$ almost everywhere, and there exists an integrable function $g$ such that $|f_n| \leq g$ almost everywhere, then:

$$\lim_{n \to \infty} \int_X f_n \, d\mu = \int_X f \, d\mu$$

**实现示例** / **Implementation Example**

```rust
// 测度收敛 / Measure Convergence
struct MeasureConvergence {
    tolerance: f64,
}

impl MeasureConvergence {
    fn new(tolerance: f64) -> Self {
        MeasureConvergence { tolerance }
    }
    
    fn check_convergence(&self, sequence: &[f64]) -> bool {
        if sequence.len() < 2 {
            return true;
        }
        
        for i in 1..sequence.len() {
            if (sequence[i] - sequence[i-1]).abs() > self.tolerance {
                return false;
            }
        }
        true
    }
    
    fn limit(&self, sequence: &[f64]) -> Option<f64> {
        if self.check_convergence(sequence) {
            sequence.last().copied()
        } else {
            None
        }
    }
}

// 函数序列 / Function Sequence
struct FunctionSequence<F> {
    functions: Vec<F>,
}

impl<F> FunctionSequence<F>
where
    F: Fn(f64) -> f64,
{
    fn new() -> Self {
        FunctionSequence {
            functions: Vec::new(),
        }
    }
    
    fn add_function(&mut self, f: F) {
        self.functions.push(f);
    }
    
    fn evaluate_at(&self, x: f64) -> Vec<f64> {
        self.functions.iter().map(|f| f(x)).collect()
    }
    
    fn check_pointwise_convergence(&self, x: f64, limit: f64, tolerance: f64) -> bool {
        let values = self.evaluate_at(x);
        values.iter().all(|&v| (v - limit).abs() < tolerance)
    }
}

fn main() {
    // 测度收敛示例 / Measure convergence example
    let convergence = MeasureConvergence::new(1e-6);
    let sequence = vec![1.0, 1.1, 1.11, 1.111, 1.1111];
    
    println!("Sequence converges: {}", convergence.check_convergence(&sequence));
    if let Some(limit) = convergence.limit(&sequence) {
        println!("Limit: {}", limit);
    }
    
    // 函数序列示例 / Function sequence example
    let mut fs = FunctionSequence::new();
    fs.add_function(|x| x);
    fs.add_function(|x| x + 0.1);
    fs.add_function(|x| x + 0.11);
    fs.add_function(|x| x + 0.111);
    
    let x = 1.0;
    let values = fs.evaluate_at(x);
    println!("Function values at x={}: {:?}", x, values);
    
    let converges = fs.check_pointwise_convergence(x, 1.111, 1e-3);
    println!("Pointwise convergence at x={}: {}", x, converges);
}
```

## 实现示例 / Implementation Examples

### 概率分布 / Probability Distributions

```rust
// 概率分布特质 / Probability Distribution Trait
trait ProbabilityDistribution {
    fn pdf(&self, x: f64) -> f64;
    fn cdf(&self, x: f64) -> f64;
    fn mean(&self) -> f64;
    fn variance(&self) -> f64;
    fn sample(&self) -> f64;
}

// 正态分布 / Normal Distribution
struct NormalDistribution {
    mean: f64,
    std_dev: f64,
}

impl NormalDistribution {
    fn new(mean: f64, std_dev: f64) -> Self {
        NormalDistribution { mean, std_dev }
    }
    
    fn standard_normal() -> Self {
        NormalDistribution::new(0.0, 1.0)
    }
}

impl ProbabilityDistribution for NormalDistribution {
    fn pdf(&self, x: f64) -> f64 {
        let z = (x - self.mean) / self.std_dev;
        (1.0 / (self.std_dev * (2.0 * std::f64::consts::PI).sqrt())) * 
        (-0.5 * z * z).exp()
    }
    
    fn cdf(&self, x: f64) -> f64 {
        let z = (x - self.mean) / self.std_dev;
        0.5 * (1.0 + erf(z / 2.0_f64.sqrt()))
    }
    
    fn mean(&self) -> f64 {
        self.mean
    }
    
    fn variance(&self) -> f64 {
        self.std_dev * self.std_dev
    }
    
    fn sample(&self) -> f64 {
        let mut rng = rand::thread_rng();
        let u1: f64 = rng.gen();
        let u2: f64 = rng.gen();
        
        // Box-Muller变换 / Box-Muller transform
        let z0 = (-2.0 * u1.ln()).sqrt() * (2.0 * std::f64::consts::PI * u2).cos();
        self.mean + self.std_dev * z0
    }
}

// 误差函数 / Error Function
fn erf(x: f64) -> f64 {
    let a1 =  0.254829592;
    let a2 = -0.284496736;
    let a3 =  1.421413741;
    let a4 = -1.453152027;
    let a5 =  1.061405429;
    let p  =  0.3275911;
    
    let sign = if x < 0.0 { -1.0 } else { 1.0 };
    let x = x.abs();
    
    let t = 1.0 / (1.0 + p * x);
    let y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * (-x * x).exp();
    
    sign * y
}

// 指数分布 / Exponential Distribution
struct ExponentialDistribution {
    lambda: f64,
}

impl ExponentialDistribution {
    fn new(lambda: f64) -> Self {
        ExponentialDistribution { lambda }
    }
}

impl ProbabilityDistribution for ExponentialDistribution {
    fn pdf(&self, x: f64) -> f64 {
        if x >= 0.0 {
            self.lambda * (-self.lambda * x).exp()
        } else {
            0.0
        }
    }
    
    fn cdf(&self, x: f64) -> f64 {
        if x >= 0.0 {
            1.0 - (-self.lambda * x).exp()
        } else {
            0.0
        }
    }
    
    fn mean(&self) -> f64 {
        1.0 / self.lambda
    }
    
    fn variance(&self) -> f64 {
        1.0 / (self.lambda * self.lambda)
    }
    
    fn sample(&self) -> f64 {
        let mut rng = rand::thread_rng();
        let u: f64 = rng.gen();
        -u.ln() / self.lambda
    }
}

fn main() {
    // 正态分布示例 / Normal distribution example
    let normal = NormalDistribution::new(0.0, 1.0);
    println!("Normal PDF at 0: {}", normal.pdf(0.0));
    println!("Normal CDF at 0: {}", normal.cdf(0.0));
    println!("Normal mean: {}", normal.mean());
    println!("Normal variance: {}", normal.variance());
    println!("Normal sample: {}", normal.sample());
    
    // 指数分布示例 / Exponential distribution example
    let exponential = ExponentialDistribution::new(1.0);
    println!("Exponential PDF at 1: {}", exponential.pdf(1.0));
    println!("Exponential CDF at 1: {}", exponential.cdf(1.0));
    println!("Exponential mean: {}", exponential.mean());
    println!("Exponential variance: {}", exponential.variance());
    println!("Exponential sample: {}", exponential.sample());
}
```

## 参考文献 / References

1. Rudin, W. (1987). Real and complex analysis. McGraw-Hill.
2. Folland, G. B. (1999). Real analysis: modern techniques and their applications. John Wiley & Sons.
3. Royden, H. L., & Fitzpatrick, P. (2010). Real analysis. Pearson.
4. Billingsley, P. (2012). Probability and measure. John Wiley & Sons.

---

*本文档提供了测度论的基础理论及其在算法中的应用，包括σ-代数、测度、可测函数、积分等核心概念，以及它们在概率算法、数值积分、概率分布等算法中的具体应用。*
