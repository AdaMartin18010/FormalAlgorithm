---
title: 1.10 èŒƒç•´è®ºåŸºç¡€ / Category Theory Foundation
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: åŸºç¡€ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 1.10 èŒƒç•´è®ºåŸºç¡€ / Category Theory Foundation

### æ‘˜è¦ / Executive Summary

- å»ºç«‹èŒƒç•´è®ºçš„åŸºç¡€ç†è®ºï¼Œç»Ÿä¸€èŒƒç•´ã€å‡½å­ã€è‡ªç„¶å˜æ¢ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚
- å»ºç«‹èŒƒç•´è®ºåœ¨ç±»å‹ç†è®ºå’Œè®¡ç®—ç†è®ºä¸­çš„åŸºç¡€åœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- èŒƒç•´ã€å‡½å­ã€è‡ªç„¶å˜æ¢ã€æé™ã€ä½™æé™ã€ä¼´éšå‡½å­ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- èŒƒç•´ï¼ˆCategoryï¼‰ï¼šç”±å¯¹è±¡å’Œæ€å°„ç»„æˆçš„æ•°å­¦ç»“æ„ã€‚
- å‡½å­ï¼ˆFunctorï¼‰ï¼šèŒƒç•´ä¹‹é—´çš„æ˜ å°„ã€‚
- è‡ªç„¶å˜æ¢ï¼ˆNatural Transformationï¼‰ï¼šå‡½å­ä¹‹é—´çš„æ˜ å°„ã€‚
- æé™ï¼ˆLimitï¼‰ï¼šèŒƒç•´ä¸­çš„æé™æ„é€ ã€‚
- è®°å·çº¦å®šï¼š`C` è¡¨ç¤ºèŒƒç•´ï¼Œ`F` è¡¨ç¤ºå‡½å­ï¼Œ`Î·` è¡¨ç¤ºè‡ªç„¶å˜æ¢ï¼Œ`Hom` è¡¨ç¤ºæ€å°„é›†åˆã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- ç±»å‹ç†è®ºï¼šå‚è§ `05-ç±»å‹ç†è®º/` ç›¸å…³æ–‡æ¡£ã€‚
- ä»£æ•°ç»“æ„åŸºç¡€ï¼šå‚è§ `01-åŸºç¡€ç†è®º/06-ä»£æ•°ç»“æ„åŸºç¡€.md`ã€‚
- è®¡ç®—æ¨¡å‹ï¼šå‚è§ `07-è®¡ç®—æ¨¡å‹/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- èŒƒç•´ä¸å‡½å­
- è‡ªç„¶å˜æ¢

## ç›®å½• (Table of Contents)

- [1.10 èŒƒç•´è®ºåŸºç¡€ / Category Theory Foundation](#110-èŒƒç•´è®ºåŸºç¡€--category-theory-foundation)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [èŒƒç•´ / Category](#èŒƒç•´--category)
  - [å‡½å­ / Functor](#å‡½å­--functor)
  - [è‡ªç„¶å˜æ¢ / Natural Transformation](#è‡ªç„¶å˜æ¢--natural-transformation)
- [èŒƒç•´è®ºåœ¨è®¡ç®—ä¸­çš„åº”ç”¨ / Applications of Category Theory in Computing](#èŒƒç•´è®ºåœ¨è®¡ç®—ä¸­çš„åº”ç”¨--applications-of-category-theory-in-computing)
  - [å‡½æ•°å¼ç¼–ç¨‹ / Functional Programming](#å‡½æ•°å¼ç¼–ç¨‹--functional-programming)
  - [å•å­ / Monads](#å•å­--monads)
  - [ä»£æ•°æ•°æ®ç±»å‹ / Algebraic Data Types](#ä»£æ•°æ•°æ®ç±»å‹--algebraic-data-types)
- [èŒƒç•´è®ºçš„é«˜çº§ä¸»é¢˜ / Advanced Topics in Category Theory](#èŒƒç•´è®ºçš„é«˜çº§ä¸»é¢˜--advanced-topics-in-category-theory)
  - [ä¼´éšå‡½å­ / Adjunctions](#ä¼´éšå‡½å­--adjunctions)
  - [æé™å’Œä½™æé™ / Limits and Colimits](#æé™å’Œä½™æé™--limits-and-colimits)
  - [é«˜é˜¶èŒƒç•´ / Higher-Order Categories](#é«˜é˜¶èŒƒç•´--higher-order-categories)
  - [å¯ŒèŒƒç•´ / Enriched Categories](#å¯ŒèŒƒç•´--enriched-categories)
  - [2-èŒƒç•´ / 2-Categories](#2-èŒƒç•´--2-categories)
- [å½¢å¼åŒ–è¯æ˜ç³»ç»Ÿ / Formal Proof Systems](#å½¢å¼åŒ–è¯æ˜ç³»ç»Ÿ--formal-proof-systems)
  - [Coqè¯æ˜ / Coq Proofs](#coqè¯æ˜--coq-proofs)
  - [Leanè¯æ˜ / Lean Proofs](#leanè¯æ˜--lean-proofs)
  - [Agdaè¯æ˜ / Agda Proofs](#agdaè¯æ˜--agda-proofs)
- [å¤šè¡¨å¾è¡¨è¾¾ / Multi-Representation Expression](#å¤šè¡¨å¾è¡¨è¾¾--multi-representation-expression)
  - [æ•°å­¦è¡¨å¾ / Mathematical Representation](#æ•°å­¦è¡¨å¾--mathematical-representation)
  - [å›¾å½¢è¡¨å¾ / Graphical Representation](#å›¾å½¢è¡¨å¾--graphical-representation)
  - [ä»£ç è¡¨å¾ / Code Representation](#ä»£ç è¡¨å¾--code-representation)
- [å±‚æ¬¡ç»“æ„æ¨¡å‹å…³è” / Hierarchical Structure Model Association](#å±‚æ¬¡ç»“æ„æ¨¡å‹å…³è”--hierarchical-structure-model-association)
  - [çŸ¥è¯†å±‚æ¬¡ç»“æ„ / Knowledge Hierarchy](#çŸ¥è¯†å±‚æ¬¡ç»“æ„--knowledge-hierarchy)
  - [æ¨¡å‹å…³è”å…³ç³» / Model Association Relationships](#æ¨¡å‹å…³è”å…³ç³»--model-association-relationships)
- [å®ç°ç¤ºä¾‹ / Implementation Examples](#å®ç°ç¤ºä¾‹--implementation-examples)
  - [è‡ªç”±å•å­ / Free Monad](#è‡ªç”±å•å­--free-monad)
- [å‚è€ƒæ–‡çŒ® / References](#å‚è€ƒæ–‡çŒ®--references)

## åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### èŒƒç•´ / Category

**å®šä¹‰ 1.1** (èŒƒç•´) / **Definition 1.1** (Category)
ä¸€ä¸ª**èŒƒç•´** $\mathcal{C}$ ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š
A **category** $\mathcal{C}$ consists of the following data:

1. **å¯¹è±¡ç±»** / **Class of Objects**: $\text{Ob}(\mathcal{C})$ - èŒƒç•´ä¸­çš„å¯¹è±¡é›†åˆ
2. **æ€å°„é›†** / **Set of Morphisms**: å¯¹ä»»æ„å¯¹è±¡ $A, B \in \text{Ob}(\mathcal{C})$ï¼Œå­˜åœ¨æ€å°„é›† $\text{Hom}_{\mathcal{C}}(A, B)$
3. **å¤åˆè¿ç®—** / **Composition**: å¯¹ä»»æ„å¯¹è±¡ $A, B, C$ï¼Œå­˜åœ¨å¤åˆå‡½æ•°ï¼š
   $$\circ: \text{Hom}_{\mathcal{C}}(B, C) \times \text{Hom}_{\mathcal{C}}(A, B) \to \text{Hom}_{\mathcal{C}}(A, C)$$
4. **å•ä½å…ƒ** / **Identity**: å¯¹ä»»æ„å¯¹è±¡ $A$ï¼Œå­˜åœ¨å•ä½æ€å°„ $1_A \in \text{Hom}_{\mathcal{C}}(A, A)$

æ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š
Satisfying the following axioms:

1. **ç»“åˆå¾‹** / **Associativity**: $(f \circ g) \circ h = f \circ (g \circ h)$
2. **å•ä½å¾‹** / **Identity**: $f \circ 1_A = f = 1_B \circ f$

**å®šç† 1.1** (å•ä½å…ƒçš„å”¯ä¸€æ€§) / **Theorem 1.1** (Uniqueness of Identity)
è®¾ $\mathcal{C}$ ä¸ºèŒƒç•´ï¼Œ$A \in \text{Ob}(\mathcal{C})$ï¼Œåˆ™å•ä½æ€å°„ $1_A$ æ˜¯å”¯ä¸€çš„ã€‚
Let $\mathcal{C}$ be a category and $A \in \text{Ob}(\mathcal{C})$. Then the identity morphism $1_A$ is unique.

### å‡½å­ / Functor

**å®šä¹‰ 1.2** (å‡½å­) / **Definition 1.2** (Functor)
è®¾ $\mathcal{C}$ å’Œ $\mathcal{D}$ ä¸ºèŒƒç•´ï¼Œä¸€ä¸ª**å‡½å­** $F: \mathcal{C} \to \mathcal{D}$ ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š
Let $\mathcal{C}$ and $\mathcal{D}$ be categories. A **functor** $F: \mathcal{C} \to \mathcal{D}$ consists of:

1. **å¯¹è±¡æ˜ å°„** / **Object Mapping**: $F: \text{Ob}(\mathcal{C}) \to \text{Ob}(\mathcal{D})$
2. **æ€å°„æ˜ å°„** / **Morphism Mapping**: å¯¹ä»»æ„ $A, B \in \text{Ob}(\mathcal{C})$ï¼Œ
   $$F: \text{Hom}_{\mathcal{C}}(A, B) \to \text{Hom}_{\mathcal{D}}(F(A), F(B))$$

æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
Satisfying the following conditions:

1. **ä¿æŒå¤åˆ** / **Preserves Composition**: $F(f \circ g) = F(f) \circ F(g)$
2. **ä¿æŒå•ä½å…ƒ** / **Preserves Identity**: $F(1_A) = 1_{F(A)}$

**å®šç† 1.2** (å‡½å­çš„åŸºæœ¬æ€§è´¨) / **Theorem 1.2** (Basic Properties of Functors)
è®¾ $F: \mathcal{C} \to \mathcal{D}$ ä¸ºå‡½å­ï¼Œåˆ™ï¼š
Let $F: \mathcal{C} \to \mathcal{D}$ be a functor, then:

1. $F$ ä¿æŒåŒæ„ / $F$ preserves isomorphisms
2. $F$ ä¿æŒå•å°„ / $F$ preserves monomorphisms
3. $F$ ä¿æŒæ»¡å°„ / $F$ preserves epimorphisms

### è‡ªç„¶å˜æ¢ / Natural Transformation

**å®šä¹‰ 1.3** (è‡ªç„¶å˜æ¢) / **Definition 1.3** (Natural Transformation)
è®¾ $F, G: \mathcal{C} \to \mathcal{D}$ ä¸ºå‡½å­ï¼Œä¸€ä¸ª**è‡ªç„¶å˜æ¢** $\alpha: F \Rightarrow G$ æ˜¯ä¸€æ—æ€å°„ï¼š
Let $F, G: \mathcal{C} \to \mathcal{D}$ be functors. A **natural transformation** $\alpha: F \Rightarrow G$ is a family of morphisms:

$$\{\alpha_A: F(A) \to G(A) \mid A \in \text{Ob}(\mathcal{C})\}$$

ä½¿å¾—å¯¹ä»»æ„æ€å°„ $f: A \to B$ï¼Œä»¥ä¸‹å›¾è¡¨äº¤æ¢ï¼š
Such that for any morphism $f: A \to B$, the following diagram commutes:

```text
F(A) --Î±_A--> G(A)
 |              |
 |F(f)          |G(f)
 v              v
F(B) --Î±_B--> G(B)
```

**å®šç† 1.3** (è‡ªç„¶å˜æ¢çš„å¤åˆ) / **Theorem 1.3** (Composition of Natural Transformations)
è®¾ $\alpha: F \Rightarrow G$ å’Œ $\beta: G \Rightarrow H$ ä¸ºè‡ªç„¶å˜æ¢ï¼Œåˆ™å­˜åœ¨è‡ªç„¶å˜æ¢ $\beta \circ \alpha: F \Rightarrow H$ã€‚
Let $\alpha: F \Rightarrow G$ and $\beta: G \Rightarrow H$ be natural transformations. Then there exists a natural transformation $\beta \circ \alpha: F \Rightarrow H$.

## èŒƒç•´è®ºåœ¨è®¡ç®—ä¸­çš„åº”ç”¨ / Applications of Category Theory in Computing

### å‡½æ•°å¼ç¼–ç¨‹ / Functional Programming

**å®šä¹‰ 2.1** (å‡½æ•°èŒƒç•´) / **Definition 2.1** (Category of Functions)
è®¾ $\text{Set}$ ä¸ºé›†åˆèŒƒç•´ï¼Œå¯¹è±¡ä¸ºé›†åˆï¼Œæ€å°„ä¸ºå‡½æ•°ã€‚
Let $\text{Set}$ be the category of sets, with objects as sets and morphisms as functions.

**å®ç°ç¤ºä¾‹** / **Implementation Example**

```rust
// å‡½å­çš„å®ç° / Functor Implementation
trait Functor<A, B> {
    type Target<U>;
    fn map<F>(self, f: F) -> Self::Target<B>
    where
        F: Fn(A) -> B;
}

// Option å‡½å­ / Option Functor
impl<A, B> Functor<A, B> for Option<A> {
    type Target<U> = Option<U>;

    fn map<F>(self, f: F) -> Self::Target<B>
    where
        F: Fn(A) -> B,
    {
        match self {
            Some(a) => Some(f(a)),
            None => None,
        }
    }
}

// Result å‡½å­ / Result Functor
impl<A, B, E> Functor<A, B> for Result<A, E> {
    type Target<U> = Result<U, E>;

    fn map<F>(self, f: F) -> Self::Target<B>
    where
        F: Fn(A) -> B,
    {
        match self {
            Ok(a) => Ok(f(a)),
            Err(e) => Err(e),
        }
    }
}

// è‡ªç„¶å˜æ¢çš„å®ç° / Natural Transformation Implementation
trait NaturalTransformation<F, G, A, B>
where
    F: Functor<A, B>,
    G: Functor<A, B>,
{
    fn transform(self) -> G::Target<B>;
}

// Option åˆ° Result çš„è‡ªç„¶å˜æ¢ / Natural transformation from Option to Result
impl<A, B> NaturalTransformation<Option<A>, Result<A, String>, A, B> for Option<A> {
    fn transform(self) -> Result<A, String> {
        match self {
            Some(a) => Ok(a),
            None => Err("No value".to_string()),
        }
    }
}

fn main() {
    // å‡½å­ä½¿ç”¨ç¤ºä¾‹ / Functor usage example
    let opt: Option<i32> = Some(5);
    let mapped = opt.map(|x| x * 2);
    println!("Mapped Option: {:?}", mapped);

    let result: Result<i32, String> = Ok(10);
    let mapped_result = result.map(|x| x + 5);
    println!("Mapped Result: {:?}", mapped_result);

    // è‡ªç„¶å˜æ¢ä½¿ç”¨ç¤ºä¾‹ / Natural transformation usage example
    let opt_value: Option<i32> = Some(42);
    let result_value = opt_value.transform();
    println!("Transformed to Result: {:?}", result_value);
}
```

### å•å­ / Monads

**å®šä¹‰ 2.2** (å•å­) / **Definition 2.2** (Monad)
ä¸€ä¸ª**å•å­**æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(T, \eta, \mu)$ï¼Œå…¶ä¸­ï¼š
A **monad** is a triple $(T, \eta, \mu)$ where:

1. $T: \mathcal{C} \to \mathcal{C}$ æ˜¯å‡½å­
2. $\eta: 1_{\mathcal{C}} \Rightarrow T$ æ˜¯å•ä½è‡ªç„¶å˜æ¢
3. $\mu: T^2 \Rightarrow T$ æ˜¯ä¹˜æ³•è‡ªç„¶å˜æ¢

æ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š
Satisfying the following axioms:

1. **å·¦å•ä½å¾‹** / **Left Unit**: $\mu \circ T\eta = 1_T$
2. **å³å•ä½å¾‹** / **Right Unit**: $\mu \circ \eta_T = 1_T$
3. **ç»“åˆå¾‹** / **Associativity**: $\mu \circ T\mu = \mu \circ \mu_T$

**å®ç°ç¤ºä¾‹** / **Implementation Example**

```rust
// å•å­ç‰¹è´¨ / Monad Trait
trait Monad<A, B>: Functor<A, B> {
    fn unit(a: A) -> Self::Target<A>;
    fn bind<F>(self, f: F) -> Self::Target<B>
    where
        F: Fn(A) -> Self::Target<B>;
}

// Option å•å­ / Option Monad
impl<A, B> Monad<A, B> for Option<A> {
    fn unit(a: A) -> Self::Target<A> {
        Some(a)
    }

    fn bind<F>(self, f: F) -> Self::Target<B>
    where
        F: Fn(A) -> Self::Target<B>,
    {
        match self {
            Some(a) => f(a),
            None => None,
        }
    }
}

// Result å•å­ / Result Monad
impl<A, B, E> Monad<A, B> for Result<A, E>
where
    E: Clone,
{
    fn unit(a: A) -> Self::Target<A> {
        Ok(a)
    }

    fn bind<F>(self, f: F) -> Self::Target<B>
    where
        F: Fn(A) -> Self::Target<B>,
    {
        match self {
            Ok(a) => f(a),
            Err(e) => Err(e),
        }
    }
}

// å•å­è®¡ç®—ç¤ºä¾‹ / Monadic computation example
fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

fn sqrt(x: i32) -> Option<f64> {
    if x < 0 {
        None
    } else {
        Some((x as f64).sqrt())
    }
}

fn main() {
    // ä½¿ç”¨å•å­è¿›è¡Œé“¾å¼è®¡ç®— / Using monads for chained computation
    let result = Option::unit(16)
        .bind(|x| divide(x, 2))
        .bind(|x| sqrt(x));

    println!("Monadic computation result: {:?}", result);

    // é”™è¯¯å¤„ç†ç¤ºä¾‹ / Error handling example
    let result_with_error = Result::<i32, String>::unit(10)
        .bind(|x| {
            if x > 5 {
                Ok(x * 2)
            } else {
                Err("Value too small".to_string())
            }
        })
        .bind(|x| Ok(x + 5));

    println!("Result with error handling: {:?}", result_with_error);
}
```

### ä»£æ•°æ•°æ®ç±»å‹ / Algebraic Data Types

**å®šä¹‰ 2.3** (ç§¯å’Œä½™ç§¯) / **Definition 2.3** (Product and Coproduct)
åœ¨èŒƒç•´ $\mathcal{C}$ ä¸­ï¼š
In category $\mathcal{C}$:

1. **ç§¯** / **Product**: å¯¹è±¡ $A \times B$ å’ŒæŠ•å½± $\pi_1: A \times B \to A$, $\pi_2: A \times B \to B$
2. **ä½™ç§¯** / **Coproduct**: å¯¹è±¡ $A + B$ å’Œæ³¨å…¥ $\iota_1: A \to A + B$, $\iota_2: B \to A + B$

**å®ç°ç¤ºä¾‹** / **Implementation Example**

```rust
// ç§¯ç±»å‹ / Product Type
#[derive(Debug, Clone)]
struct Product<A, B> {
    first: A,
    second: B,
}

impl<A, B> Product<A, B> {
    fn new(first: A, second: B) -> Self {
        Product { first, second }
    }

    fn fst(&self) -> &A {
        &self.first
    }

    fn snd(&self) -> &B {
        &self.second
    }
}

// ä½™ç§¯ç±»å‹ / Coproduct Type
#[derive(Debug)]
enum Coproduct<A, B> {
    Left(A),
    Right(B),
}

impl<A, B> Coproduct<A, B> {
    fn left(a: A) -> Self {
        Coproduct::Left(a)
    }

    fn right(b: B) -> Self {
        Coproduct::Right(b)
    }

    fn match_with<C, F, G>(self, f: F, g: G) -> C
    where
        F: Fn(A) -> C,
        G: Fn(B) -> C,
    {
        match self {
            Coproduct::Left(a) => f(a),
            Coproduct::Right(b) => g(b),
        }
    }
}

// ä»£æ•°æ•°æ®ç±»å‹çš„åº”ç”¨ / Application of Algebraic Data Types
#[derive(Debug)]
enum Expression {
    Number(i32),
    Add(Box<Expression>, Box<Expression>),
    Multiply(Box<Expression>, Box<Expression>),
}

impl Expression {
    fn eval(&self) -> i32 {
        match self {
            Expression::Number(n) => *n,
            Expression::Add(a, b) => a.eval() + b.eval(),
            Expression::Multiply(a, b) => a.eval() * b.eval(),
        }
    }
}

fn main() {
    // ç§¯ç±»å‹ä½¿ç”¨ / Product type usage
    let product = Product::new(42, "hello");
    println!("Product: ({}, {})", product.fst(), product.snd());

    // ä½™ç§¯ç±»å‹ä½¿ç”¨ / Coproduct type usage
    let coproduct = Coproduct::left(42);
    let result = coproduct.match_with(
        |n| format!("Number: {}", n),
        |s| format!("String: {}", s),
    );
    println!("Coproduct result: {}", result);

    // ä»£æ•°æ•°æ®ç±»å‹ä½¿ç”¨ / Algebraic data type usage
    let expr = Expression::Add(
        Box::new(Expression::Number(5)),
        Box::new(Expression::Multiply(
            Box::new(Expression::Number(3)),
            Box::new(Expression::Number(4)),
        )),
    );

    println!("Expression: {:?}", expr);
    println!("Result: {}", expr.eval());
}
```

## èŒƒç•´è®ºçš„é«˜çº§ä¸»é¢˜ / Advanced Topics in Category Theory

### ä¼´éšå‡½å­ / Adjunctions

**å®šä¹‰ 3.1** (ä¼´éšå‡½å­) / **Definition 3.1** (Adjunction)
è®¾ $F: \mathcal{C} \to \mathcal{D}$ å’Œ $G: \mathcal{D} \to \mathcal{C}$ ä¸ºå‡½å­ï¼Œ$F$ å·¦ä¼´éšäº $G$ï¼ˆè®°ä½œ $F \dashv G$ï¼‰å½“ä¸”ä»…å½“å­˜åœ¨è‡ªç„¶åŒæ„ï¼š
Let $F: \mathcal{C} \to \mathcal{D}$ and $G: \mathcal{D} \to \mathcal{C}$ be functors. $F$ is left adjoint to $G$ (denoted $F \dashv G$) if and only if there exists a natural isomorphism:

$$\text{Hom}_{\mathcal{D}}(F(-), -) \cong \text{Hom}_{\mathcal{C}}(-, G(-))$$

**å®šç† 3.1** (ä¼´éšå‡½å­çš„åŸºæœ¬æ€§è´¨) / **Theorem 3.1** (Basic Properties of Adjunctions)
è®¾ $F \dashv G$ï¼Œåˆ™ï¼š
Let $F \dashv G$, then:

1. $F$ ä¿æŒä½™æé™ / $F$ preserves colimits
2. $G$ ä¿æŒæé™ / $G$ preserves limits
3. å­˜åœ¨å•ä½ $\eta: 1_{\mathcal{C}} \Rightarrow GF$ å’Œä½™å•ä½ $\varepsilon: FG \Rightarrow 1_{\mathcal{D}}$
4. æ»¡è¶³ä¸‰è§’æ’ç­‰å¼ / Satisfy triangle identities

### æé™å’Œä½™æé™ / Limits and Colimits

**å®šä¹‰ 3.2** (æé™) / **Definition 3.2** (Limit)
è®¾ $F: \mathcal{J} \to \mathcal{C}$ ä¸ºå‡½å­ï¼Œ$F$ çš„**æé™**æ˜¯ä¸€ä¸ªå¯¹è±¡ $\lim F$ å’Œä¸€æ—æ€å°„ $\pi_i: \lim F \to F(i)$ï¼Œä½¿å¾—ï¼š
Let $F: \mathcal{J} \to \mathcal{C}$ be a functor. A **limit** of $F$ is an object $\lim F$ and a family of morphisms $\pi_i: \lim F \to F(i)$ such that:

1. å¯¹ä»»æ„æ€å°„ $f: i \to j$ï¼Œ$\pi_j = F(f) \circ \pi_i$
2. å¯¹ä»»æ„å¯¹è±¡ $X$ å’Œæ€å°„æ— $\alpha_i: X \to F(i)$ï¼Œå­˜åœ¨å”¯ä¸€æ€å°„ $u: X \to \lim F$ ä½¿å¾— $\alpha_i = \pi_i \circ u$

**å®šç† 3.2** (æé™çš„å­˜åœ¨æ€§) / **Theorem 3.2** (Existence of Limits)
è®¾ $\mathcal{C}$ ä¸ºå®Œå¤‡èŒƒç•´ï¼Œåˆ™ä»»æ„å°å‡½å­ $F: \mathcal{J} \to \mathcal{C}$ éƒ½æœ‰æé™ã€‚
Let $\mathcal{C}$ be a complete category. Then any small functor $F: \mathcal{J} \to \mathcal{C}$ has a limit.

### é«˜é˜¶èŒƒç•´ / Higher-Order Categories

**å®šä¹‰ 3.3** (n-èŒƒç•´) / **Definition 3.3** (n-Category)
ä¸€ä¸ª**n-èŒƒç•´**æ˜¯ä¸€ä¸ªå…·æœ‰ä»¥ä¸‹ç»“æ„çš„æ•°å­¦å¯¹è±¡ï¼š
An **n-category** is a mathematical object with the following structure:

1. **0-å¯¹è±¡**ï¼šåŸºæœ¬å¯¹è±¡ / **0-objects**: basic objects
2. **1-æ€å°„**ï¼šå¯¹è±¡é—´çš„æ€å°„ / **1-morphisms**: morphisms between objects
3. **2-æ€å°„**ï¼šæ€å°„é—´çš„æ€å°„ / **2-morphisms**: morphisms between morphisms
4. **...**
5. **n-æ€å°„**ï¼šn-1-æ€å°„é—´çš„æ€å°„ / **n-morphisms**: morphisms between (n-1)-morphisms

**å®šç† 3.3** (é«˜é˜¶èŒƒç•´çš„å¼±åŒ–) / **Theorem 3.3** (Weakening of Higher Categories)
åœ¨å¼±n-èŒƒç•´ä¸­ï¼Œç»“åˆå¾‹å’Œå•ä½å¾‹ä»…åœ¨åŒæ„æ„ä¹‰ä¸‹æˆç«‹ã€‚
In weak n-categories, associativity and identity laws hold only up to isomorphism.

### å¯ŒèŒƒç•´ / Enriched Categories

**å®šä¹‰ 3.4** (å¯ŒèŒƒç•´) / **Definition 3.4** (Enriched Category)
è®¾ $\mathcal{V}$ ä¸ºå¹ºåŠèŒƒç•´ï¼Œä¸€ä¸ª**$\mathcal{V}$-å¯ŒèŒƒç•´** $\mathcal{C}$ ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š
Let $\mathcal{V}$ be a monoidal category. A **$\mathcal{V}$-enriched category** $\mathcal{C}$ consists of:

1. **å¯¹è±¡ç±»**ï¼š$\text{Ob}(\mathcal{C})$ / **Class of objects**: $\text{Ob}(\mathcal{C})$
2. **åŒæ€å¯¹è±¡**ï¼šå¯¹ä»»æ„ $A, B \in \text{Ob}(\mathcal{C})$ï¼Œå­˜åœ¨ $\mathcal{V}$-å¯¹è±¡ $\mathcal{C}(A, B)$
3. **å¤åˆæ€å°„**ï¼š$\circ: \mathcal{C}(B, C) \otimes \mathcal{C}(A, B) \to \mathcal{C}(A, C)$
4. **å•ä½æ€å°„**ï¼š$I \to \mathcal{C}(A, A)$

**å®šç† 3.4** (å¯ŒèŒƒç•´çš„åŸºæœ¬æ€§è´¨) / **Theorem 3.4** (Basic Properties of Enriched Categories)
è®¾ $\mathcal{C}$ ä¸º $\mathcal{V}$-å¯ŒèŒƒç•´ï¼Œåˆ™ï¼š
Let $\mathcal{C}$ be a $\mathcal{V}$-enriched category, then:

1. å¤åˆæ»¡è¶³ç»“åˆå¾‹ / Composition satisfies associativity
2. å•ä½æ€å°„æ»¡è¶³å•ä½å¾‹ / Identity morphisms satisfy identity law
3. å¯¹ä»»æ„å¯¹è±¡ $A$ï¼Œ$\mathcal{C}(A, A)$ æ˜¯ $\mathcal{V}$ ä¸­çš„å¹ºåŠå¯¹è±¡

### 2-èŒƒç•´ / 2-Categories

**å®šä¹‰ 3.5** (2-èŒƒç•´) / **Definition 3.5** (2-Category)
ä¸€ä¸ª**2-èŒƒç•´** $\mathcal{C}$ ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š
A **2-category** $\mathcal{C}$ consists of:

1. **å¯¹è±¡**ï¼š$\text{Ob}(\mathcal{C})$ / **Objects**: $\text{Ob}(\mathcal{C})$
2. **1-æ€å°„**ï¼š$\text{Hom}_{\mathcal{C}}(A, B)$ / **1-morphisms**: $\text{Hom}_{\mathcal{C}}(A, B)$
3. **2-æ€å°„**ï¼š$\text{Hom}_{\text{Hom}_{\mathcal{C}}(A, B)}(f, g)$ / **2-morphisms**: $\text{Hom}_{\text{Hom}_{\mathcal{C}}(A, B)}(f, g)$

æ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š
Satisfying the following axioms:

1. **æ°´å¹³å¤åˆ**ï¼š1-æ€å°„çš„å¤åˆ / **Horizontal composition**: composition of 1-morphisms
2. **å‚ç›´å¤åˆ**ï¼š2-æ€å°„çš„å¤åˆ / **Vertical composition**: composition of 2-morphisms
3. **äº¤æ¢å¾‹**ï¼šæ°´å¹³å¤åˆä¸å‚ç›´å¤åˆçš„äº¤æ¢å¾‹ / **Interchange law**: interchange between horizontal and vertical composition

## å½¢å¼åŒ–è¯æ˜ç³»ç»Ÿ / Formal Proof Systems

### Coqè¯æ˜ / Coq Proofs

**èŒƒç•´å®šä¹‰çš„å½¢å¼åŒ–**ï¼š

```coq
(* èŒƒç•´å®šä¹‰ *)
Record Category := {
  Ob : Type;
  Hom : Ob -> Ob -> Type;
  compose : forall {A B C : Ob}, Hom B C -> Hom A B -> Hom A C;
  identity : forall A : Ob, Hom A A;

  (* å…¬ç† *)
  associativity : forall {A B C D : Ob} (f : Hom C D) (g : Hom B C) (h : Hom A B),
    compose f (compose g h) = compose (compose f g) h;
  left_identity : forall {A B : Ob} (f : Hom A B),
    compose (identity B) f = f;
  right_identity : forall {A B : Ob} (f : Hom A B),
    compose f (identity A) = f
}.

(* å‡½å­å®šä¹‰ *)
Record Functor (C D : Category) := {
  F_Ob : Ob C -> Ob D;
  F_Hom : forall {A B : Ob C}, Hom C A B -> Hom D (F_Ob A) (F_Ob B);

  (* å‡½å­å…¬ç† *)
  F_compose : forall {A B C : Ob C} (f : Hom C B C) (g : Hom C A B),
    F_Hom (compose C f g) = compose D (F_Hom f) (F_Hom g);
  F_identity : forall A : Ob C,
    F_Hom (identity C A) = identity D (F_Ob A)
}.

(* è‡ªç„¶å˜æ¢å®šä¹‰ *)
Record NaturalTransformation {C D : Category} (F G : Functor C D) := {
  component : forall A : Ob C, Hom D (F_Ob F A) (F_Ob G A);

  (* è‡ªç„¶æ€§ *)
  naturality : forall {A B : Ob C} (f : Hom C A B),
    compose D (F_Hom G f) (component A) = compose D (component B) (F_Hom F f)
}.

(* ä¼´éšå‡½å­å®šä¹‰ *)
Record Adjunction {C D : Category} (F : Functor C D) (G : Functor D C) := {
  unit : NaturalTransformation (IdentityFunctor C) (ComposeFunctor G F);
  counit : NaturalTransformation (ComposeFunctor F G) (IdentityFunctor D);

  (* ä¸‰è§’æ’ç­‰å¼ *)
  triangle_1 : forall A : Ob C,
    compose C (counit_component (F_Ob F A)) (F_Hom G (unit_component A)) = identity C A;
  triangle_2 : forall B : Ob D,
    compose D (F_Hom F (counit_component B)) (unit_component (G_Ob G B)) = identity D B
}.
```

### Leanè¯æ˜ / Lean Proofs

**æé™å’Œä½™æé™çš„å½¢å¼åŒ–**ï¼š

```lean
-- æé™å®šä¹‰
structure limit {J C : Type} [category J] [category C] (F : J â¥¤ C) :=
(obj : C)
(Ï€ : Î  (j : J), obj âŸ¶ F.obj j)
(commute : Î  {j j' : J} (f : j âŸ¶ j'), Ï€ j â‰« F.map f = Ï€ j')
(universal : Î  {X : C} (Î± : Î  (j : J), X âŸ¶ F.obj j)
  (h : Î  {j j' : J} (f : j âŸ¶ j'), Î± j â‰« F.map f = Î± j'),
  {u : X âŸ¶ obj // Î  (j : J), u â‰« Ï€ j = Î± j âˆ§
   Î  (u' : X âŸ¶ obj), (Î  (j : J), u' â‰« Ï€ j = Î± j) â†’ u' = u})

-- ä½™æé™å®šä¹‰
structure colimit {J C : Type} [category J] [category C] (F : J â¥¤ C) :=
(obj : C)
(Î¹ : Î  (j : J), F.obj j âŸ¶ obj)
(commute : Î  {j j' : J} (f : j âŸ¶ j'), F.map f â‰« Î¹ j' = Î¹ j)
(universal : Î  {X : C} (Î± : Î  (j : J), F.obj j âŸ¶ X)
  (h : Î  {j j' : J} (f : j âŸ¶ j'), F.map f â‰« Î± j' = Î± j),
  {u : obj âŸ¶ X // Î  (j : J), Î¹ j â‰« u = Î± j âˆ§
   Î  (u' : obj âŸ¶ X), (Î  (j : J), Î¹ j â‰« u' = Î± j) â†’ u' = u})

-- å®Œå¤‡èŒƒç•´
class complete_category (C : Type) [category C] :=
(has_limits : Î  {J : Type} [category J] (F : J â¥¤ C), nonempty (limit F))

-- ä½™å®Œå¤‡èŒƒç•´
class cocomplete_category (C : Type) [category C] :=
(has_colimits : Î  {J : Type} [category J] (F : J â¥¤ C), nonempty (colimit F))

-- ä¼´éšå‡½å­å®šç†
theorem adjoint_functor_theorem {C D : Type} [category C] [category D]
  (G : D â¥¤ C) [complete_category C] [cocomplete_category D] :
  (Î  (c : C), has_colimit (comma_category G c)) â†’
  (Î  (c : C), has_colimit (comma_category G c)) â†’
  âˆƒ (F : C â¥¤ D), F âŠ£ G :=
begin
  -- æ„é€ å·¦ä¼´éš
  let F : C â¥¤ D := {
    obj := Î» c, colimit.obj (comma_category G c),
    map := Î» c c' f, colimit.desc (comma_category G c')
      (Î» j, colimit.Î¹ (comma_category G c) j â‰« f)
  },
  -- è¯æ˜ä¼´éšå…³ç³»
  constructor,
  exact F,
  -- æ„é€ å•ä½å’Œä½™å•ä½
  let Î· : ğŸ­ C âŸ¶ G â‹™ F := {
    app := Î» c, colimit.Î¹ (comma_category G c) (comma_category.base c),
    naturality' := sorry
  },
  let Îµ : F â‹™ G âŸ¶ ğŸ­ D := {
    app := Î» d, colimit.desc (comma_category G (G.obj d))
      (Î» j, j.hom),
    naturality' := sorry
  },
  -- éªŒè¯ä¸‰è§’æ’ç­‰å¼
  constructor,
  exact Î·,
  exact Îµ,
  -- è¯æ˜ä¸‰è§’æ’ç­‰å¼
  sorry,
  sorry
end
```

### Agdaè¯æ˜ / Agda Proofs

**é«˜é˜¶èŒƒç•´çš„å½¢å¼åŒ–**ï¼š

```agda
-- n-èŒƒç•´å®šä¹‰
data n-Category : â„• â†’ Set where
  -- 0-èŒƒç•´ï¼šé›†åˆ
  Setâ‚€ : Set â†’ n-Category 0

  -- n+1-èŒƒç•´ï¼šå…·æœ‰n-æ€å°„çš„èŒƒç•´
  Categoryâ‚™ : {n : â„•} â†’
    (Obj : Set) â†’
    (Hom : Obj â†’ Obj â†’ n-Category n) â†’
    (comp : {A B C : Obj} â†’ Hom B C â†’ Hom A B â†’ Hom A C) â†’
    (id : {A : Obj} â†’ Hom A A) â†’
    n-Category (suc n)

-- 2-èŒƒç•´å®šä¹‰
record 2-Category : Setâ‚ where
  field
    Obj : Set
    Hom : Obj â†’ Obj â†’ Category
    compâ‚ : {A B C : Obj} â†’ Functor (Hom B C Ã—C Hom A B) (Hom A C)
    idâ‚ : {A : Obj} â†’ Functor Unit (Hom A A)
    compâ‚‚ : {A B : Obj} {f g h : Hom A B .Obj} â†’
            Hom A B .Hom (Hom A B .comp h g) f â†’
            Hom A B .Hom h (Hom A B .comp g f)
    idâ‚‚ : {A B : Obj} {f : Hom A B .Obj} â†’
          Hom A B .Hom (Hom A B .id) f â†’ Hom A B .Hom f (Hom A B .id)

    -- äº¤æ¢å¾‹
    interchange : {A B C : Obj} {fâ‚ fâ‚‚ : Hom B C .Obj} {gâ‚ gâ‚‚ : Hom A B .Obj}
                  {Î± : Hom B C .Hom fâ‚ fâ‚‚} {Î² : Hom A B .Hom gâ‚ gâ‚‚} â†’
                  compâ‚‚ (Î± âˆ˜â‚ Î²) â‰¡ (compâ‚‚ Î±) âˆ˜â‚‚ (compâ‚‚ Î²)

-- å¯ŒèŒƒç•´å®šä¹‰
record EnrichedCategory (V : MonoidalCategory) : Setâ‚ where
  field
    Obj : Set
    Hom : Obj â†’ Obj â†’ V.Obj
    comp : {A B C : Obj} â†’ V.Hom (V.âŠ— (Hom B C) (Hom A B)) (Hom A C)
    id : {A : Obj} â†’ V.Hom V.I (Hom A A)

    -- ç»“åˆå¾‹
    associativity : {A B C D : Obj} â†’
      comp âˆ˜ (V.âŠ— comp V.id) â‰¡
      comp âˆ˜ (V.âŠ— V.id comp) âˆ˜ V.associator

    -- å•ä½å¾‹
    left-identity : {A B : Obj} â†’
      comp âˆ˜ (V.âŠ— V.id id) âˆ˜ V.left-unitor â‰¡ V.id
    right-identity : {A B : Obj} â†’
      comp âˆ˜ (V.âŠ— id V.id) âˆ˜ V.right-unitor â‰¡ V.id

-- ä¼´éšå‡½å­çš„Yonedaå¼•ç†
yoneda-lemma : {C : Category} {A : C.Obj} {F : Functor C Set} â†’
  Nat (Hom C A) F â‰… F.obj A
yoneda-lemma = record
  { to = Î» Î± â†’ Î±.app A C.id
  ; from = Î» x â†’ record
    { app = Î» B f â†’ F.map f x
    ; naturality = Î» f g â†’ cong (F.map f) (sym (F.identity))
    }
  ; left-inverse = Î» Î± â†’ extensionality Î» B â†’ extensionality Î» f â†’
      cong (Î±.app B) (C.left-identity)
  ; right-inverse = Î» x â†’ refl
  }
```

## å¤šè¡¨å¾è¡¨è¾¾ / Multi-Representation Expression

### æ•°å­¦è¡¨å¾ / Mathematical Representation

**èŒƒç•´çš„æ•°å­¦å®šä¹‰**ï¼š

```latex
% èŒƒç•´å®šä¹‰
\begin{definition}[èŒƒç•´]
ä¸€ä¸ªèŒƒç•´ $\mathcal{C}$ ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š
\begin{enumerate}
\item å¯¹è±¡ç±» $\text{Ob}(\mathcal{C})$
\item æ€å°„é›† $\text{Hom}_{\mathcal{C}}(A, B)$ å¯¹ä»»æ„ $A, B \in \text{Ob}(\mathcal{C})$
\item å¤åˆè¿ç®— $\circ: \text{Hom}_{\mathcal{C}}(B, C) \times \text{Hom}_{\mathcal{C}}(A, B) \to \text{Hom}_{\mathcal{C}}(A, C)$
\item å•ä½å…ƒ $1_A \in \text{Hom}_{\mathcal{C}}(A, A)$
\end{enumerate}
æ»¡è¶³ç»“åˆå¾‹å’Œå•ä½å¾‹ã€‚
\end{definition}

% ä¼´éšå‡½å­å®šä¹‰
\begin{definition}[ä¼´éšå‡½å­]
è®¾ $F: \mathcal{C} \to \mathcal{D}$ å’Œ $G: \mathcal{D} \to \mathcal{C}$ ä¸ºå‡½å­ï¼Œ
$F$ å·¦ä¼´éšäº $G$ï¼ˆè®°ä½œ $F \dashv G$ï¼‰å½“ä¸”ä»…å½“å­˜åœ¨è‡ªç„¶åŒæ„ï¼š
$$\text{Hom}_{\mathcal{D}}(F(-), -) \cong \text{Hom}_{\mathcal{C}}(-, G(-))$$
\end{definition}

% æé™å®šä¹‰
\begin{definition}[æé™]
è®¾ $F: \mathcal{J} \to \mathcal{C}$ ä¸ºå‡½å­ï¼Œ$F$ çš„æé™æ˜¯ä¸€ä¸ªå¯¹è±¡ $\lim F$ å’Œä¸€æ—æ€å°„ $\pi_i: \lim F \to F(i)$ï¼Œ
ä½¿å¾—å¯¹ä»»æ„æ€å°„ $f: i \to j$ï¼Œ$\pi_j = F(f) \circ \pi_i$ï¼Œå¹¶ä¸”æ»¡è¶³æ³›æ€§è´¨ã€‚
\end{definition}
```

### å›¾å½¢è¡¨å¾ / Graphical Representation

**èŒƒç•´ç»“æ„å›¾**ï¼š

```mermaid
graph TD
    A[å¯¹è±¡A] -->|æ€å°„f| B[å¯¹è±¡B]
    B -->|æ€å°„g| C[å¯¹è±¡C]
    A -->|æ€å°„gâˆ˜f| C
    A -->|å•ä½æ€å°„1_A| A
    B -->|å•ä½æ€å°„1_B| B
    C -->|å•ä½æ€å°„1_C| C

    subgraph "ç»“åˆå¾‹"
        D[æ€å°„h] --> E[æ€å°„g]
        E --> F[æ€å°„f]
        D --> G[æ€å°„gâˆ˜f]
        G --> H[æ€å°„hâˆ˜(gâˆ˜f)]
        D --> I[æ€å°„hâˆ˜g]
        I --> J[æ€å°„(hâˆ˜g)âˆ˜f]
        H -.->|ç›¸ç­‰| J
    end
```

**ä¼´éšå‡½å­å›¾**ï¼š

```mermaid
graph LR
    subgraph "èŒƒç•´C"
        A1[å¯¹è±¡A]
        B1[å¯¹è±¡B]
    end

    subgraph "èŒƒç•´D"
        A2[å¯¹è±¡F(A)]
        B2[å¯¹è±¡F(B)]
    end

    A1 -->|å‡½å­F| A2
    B1 -->|å‡½å­F| B2
    A2 -->|å‡½å­G| A1
    B2 -->|å‡½å­G| B1

    A1 -.->|è‡ªç„¶å˜æ¢Î·| A1
    B1 -.->|è‡ªç„¶å˜æ¢Î·| B1
    A2 -.->|è‡ªç„¶å˜æ¢Îµ| A2
    B2 -.->|è‡ªç„¶å˜æ¢Îµ| B2

    subgraph "ä¼´éšå…³ç³»"
        K[è‡ªç„¶åŒæ„]
        K --> L["Hom_D(F(A), B) â‰… Hom_C(A, G(B))"]
    end
```

**æé™å’Œä½™æé™å›¾**ï¼š

```mermaid
graph TD
    subgraph "æé™"
        A[æé™å¯¹è±¡lim F]
        B[F(i)]
        C[F(j)]
        D[F(k)]

        A -->|Ï€_i| B
        A -->|Ï€_j| C
        A -->|Ï€_k| D

        B -->|F(f)| C
        C -->|F(g)| D
        B -->|F(gâˆ˜f)| D
    end

    subgraph "ä½™æé™"
        E[F(i)]
        F[F(j)]
        G[F(k)]
        H[ä½™æé™å¯¹è±¡colim F]

        E -->|Î¹_i| H
        F -->|Î¹_j| H
        G -->|Î¹_k| H

        E -->|F(f)| F
        F -->|F(g)| G
        E -->|F(gâˆ˜f)| G
    end
```

### ä»£ç è¡¨å¾ / Code Representation

**Pythonå®ç°**ï¼š

```python
from typing import TypeVar, Generic, Callable, Dict, List
from abc import ABC, abstractmethod
import numpy as np

# ç±»å‹å˜é‡
A = TypeVar('A')
B = TypeVar('B')
C = TypeVar('C')

class Category(ABC):
    """èŒƒç•´æŠ½è±¡åŸºç±»"""

    @abstractmethod
    def objects(self) -> List:
        """è¿”å›å¯¹è±¡åˆ—è¡¨"""
        pass

    @abstractmethod
    def morphisms(self, obj1, obj2) -> List:
        """è¿”å›ä¸¤ä¸ªå¯¹è±¡é—´çš„æ€å°„"""
        pass

    @abstractmethod
    def compose(self, f, g):
        """æ€å°„å¤åˆ"""
        pass

    @abstractmethod
    def identity(self, obj):
        """å•ä½æ€å°„"""
        pass

class Functor(Generic[A, B]):
    """å‡½å­ç±»"""

    def __init__(self, f_obj: Callable[[A], B], f_mor: Callable):
        self.f_obj = f_obj
        self.f_mor = f_mor

    def __call__(self, x):
        return self.f_obj(x)

    def map_morphism(self, f):
        return self.f_mor(f)

class NaturalTransformation(Generic[A, B]):
    """è‡ªç„¶å˜æ¢ç±»"""

    def __init__(self, components: Dict[A, B]):
        self.components = components

    def component_at(self, obj: A) -> B:
        return self.components[obj]

    def naturality(self, f):
        """è‡ªç„¶æ€§æ¡ä»¶"""
        # å®ç°è‡ªç„¶æ€§æ£€æŸ¥
        pass

class Adjunction(Generic[A, B]):
    """ä¼´éšå‡½å­ç±»"""

    def __init__(self, left_adjoint: Functor, right_adjoint: Functor,
                 unit: NaturalTransformation, counit: NaturalTransformation):
        self.left_adjoint = left_adjoint
        self.right_adjoint = right_adjoint
        self.unit = unit
        self.counit = counit

    def triangle_identities(self):
        """éªŒè¯ä¸‰è§’æ’ç­‰å¼"""
        # å®ç°ä¸‰è§’æ’ç­‰å¼éªŒè¯
        pass

class Limit:
    """æé™ç±»"""

    def __init__(self, diagram, cone):
        self.diagram = diagram
        self.cone = cone

    def universal_property(self, other_cone):
        """æ³›æ€§è´¨"""
        # å®ç°æ³›æ€§è´¨
        pass

class Colimit:
    """ä½™æé™ç±»"""

    def __init__(self, diagram, cocone):
        self.diagram = diagram
        self.cocone = cocone

    def universal_property(self, other_cocone):
        """æ³›æ€§è´¨"""
        # å®ç°æ³›æ€§è´¨
        pass

class HigherCategory:
    """é«˜é˜¶èŒƒç•´ç±»"""

    def __init__(self, n: int):
        self.dimension = n
        self.objects = []
        self.morphisms = [[] for _ in range(n)]

    def add_object(self, obj):
        self.objects.append(obj)

    def add_morphism(self, level: int, morphism):
        if level < self.dimension:
            self.morphisms[level].append(morphism)

    def composition(self, level: int, f, g):
        """n-æ€å°„å¤åˆ"""
        if level < self.dimension:
            # å®ç°n-æ€å°„å¤åˆ
            pass

class EnrichedCategory:
    """å¯ŒèŒƒç•´ç±»"""

    def __init__(self, base_category):
        self.base_category = base_category
        self.objects = []
        self.hom_objects = {}

    def add_object(self, obj):
        self.objects.append(obj)

    def set_hom_object(self, obj1, obj2, hom_obj):
        self.hom_objects[(obj1, obj2)] = hom_obj

    def composition_morphism(self, obj1, obj2, obj3):
        """å¤åˆæ€å°„"""
        # å®ç°å¤åˆæ€å°„
        pass

# ä½¿ç”¨ç¤ºä¾‹
def example_usage():
    """ä½¿ç”¨ç¤ºä¾‹"""

    # åˆ›å»ºèŒƒç•´
    class SetCategory(Category):
        def objects(self):
            return [set(), {1}, {1, 2}, {1, 2, 3}]

        def morphisms(self, obj1, obj2):
            # è¿”å›é›†åˆé—´çš„å‡½æ•°
            return [lambda x: x for _ in range(3)]

        def compose(self, f, g):
            return lambda x: f(g(x))

        def identity(self, obj):
            return lambda x: x

    # åˆ›å»ºå‡½å­
    power_set_functor = Functor(
        f_obj=lambda s: set(frozenset(subset) for subset in powerset(s)),
        f_mor=lambda f: lambda s: set(frozenset(f(x) for x in subset) for subset in s)
    )

    # åˆ›å»ºè‡ªç„¶å˜æ¢
    singleton_nat_trans = NaturalTransformation({
        s: lambda x: {frozenset({x})} for s in SetCategory().objects()
    })

    print("èŒƒç•´è®ºé«˜çº§æ¦‚å¿µå®ç°å®Œæˆ")

def powerset(s):
    """è®¡ç®—å¹‚é›†"""
    from itertools import combinations
    return [set(combo) for r in range(len(s) + 1) for combo in combinations(s, r)]

if __name__ == "__main__":
    example_usage()
```

**Haskellå®ç°**ï¼š

```haskell
{-# LANGUAGE TypeFamilies, GADTs, DataKinds, PolyKinds #-}

-- èŒƒç•´ç±»å‹ç±»
class Category (k :: * -> * -> *) where
  id :: k a a
  (.) :: k b c -> k a b -> k a c

-- å‡½å­ç±»å‹ç±»
class (Category c, Category d) => Functor (f :: * -> *) c d where
  fmap :: c a b -> d (f a) (f b)

-- è‡ªç„¶å˜æ¢
newtype Nat c d f g = Nat { runNat :: forall a. c (f a) (g a) }

-- ä¼´éšå‡½å­
class (Functor f c d, Functor g d c) => Adjunction f g c d where
  unit :: c a (g (f a))
  counit :: d (f (g b)) b

-- æé™
data Limit f = Limit {
  limitObj :: Obj f,
  limitProj :: forall j. Proj f j
}

-- ä½™æé™
data Colimit f = Colimit {
  colimitObj :: Obj f,
  colimitInj :: forall j. Inj f j
}

-- é«˜é˜¶èŒƒç•´
data n :: Nat where
  Zero :: n 0
  Succ :: n m -> n (m + 1)

data NCat (n :: Nat) where
  NCat0 :: Set -> NCat Zero
  NCatS :: (Obj -> Obj -> NCat n) -> NCat (Succ n)

-- å¯ŒèŒƒç•´
class MonoidalCategory v => EnrichedCategory v c where
  type Obj c :: *
  type Hom c a b :: v
  comp :: v (Hom c b c âŠ— Hom c a b) (Hom c a c)
  ident :: v I (Hom c a a)

-- 2-èŒƒç•´
class (Category c, Category (Hom c)) => Category2 c where
  comp2 :: Hom c (comp1 h g) f -> Hom c h (comp1 g f)
  id2 :: Hom c id1 f -> Hom c f id1

-- ä¼´éšå‡½å­å®šç†
adjointFunctorTheorem ::
  (CompleteCategory c, CocompleteCategory d) =>
  (forall a. HasColimits (CommaCategory g a)) ->
  (forall a. HasLimits (CommaCategory g a)) ->
  Exists (Adjunction f g c d)
adjointFunctorTheorem hasColimits hasLimits =
  -- æ„é€ å·¦ä¼´éš
  let f = constructLeftAdjoint hasColimits
      unit = constructUnit f g
      counit = constructCounit f g
  in Exists (Adjunction f g unit counit)

-- ä½¿ç”¨ç¤ºä¾‹
example :: IO ()
example = do
  putStrLn "èŒƒç•´è®ºé«˜çº§æ¦‚å¿µHaskellå®ç°"

  -- é›†åˆèŒƒç•´
  let setCategory = undefined :: Category (->)

  -- å¹‚é›†å‡½å­
  let powerSetFunctor = undefined :: Functor [] (->) (->)

  -- å•å­è‡ªç„¶å˜æ¢
  let singletonNatTrans = undefined :: Nat (->) (->) Id []

  putStrLn "å®ç°å®Œæˆ"

-- è¾…åŠ©ç±»å‹
data Exists f where
  Exists :: f a -> Exists f

type Id a = a
type CommaCategory g a = undefined
type CompleteCategory c = undefined
type CocompleteCategory c = undefined
type HasColimits f = undefined
type HasLimits f = undefined

constructLeftAdjoint :: a -> b
constructLeftAdjoint = undefined

constructUnit :: a -> b -> c
constructUnit = undefined

constructCounit :: a -> b -> c
constructCounit = undefined
```

## å±‚æ¬¡ç»“æ„æ¨¡å‹å…³è” / Hierarchical Structure Model Association

### çŸ¥è¯†å±‚æ¬¡ç»“æ„ / Knowledge Hierarchy

**åŸºç¡€å±‚æ¬¡**ï¼š

```text
æ•°å­¦åŸºç¡€
â”œâ”€â”€ é›†åˆè®º (Set Theory)
â”‚   â”œâ”€â”€ é›†åˆè¿ç®— (Set Operations)
â”‚   â”œâ”€â”€ å…³ç³» (Relations)
â”‚   â””â”€â”€ å‡½æ•° (Functions)
â”œâ”€â”€ ä»£æ•°ç»“æ„ (Algebraic Structures)
â”‚   â”œâ”€â”€ ç¾¤è®º (Group Theory)
â”‚   â”œâ”€â”€ ç¯è®º (Ring Theory)
â”‚   â””â”€â”€ åŸŸè®º (Field Theory)
â””â”€â”€ æ‹“æ‰‘å­¦ (Topology)
    â”œâ”€â”€ ç‚¹é›†æ‹“æ‰‘ (Point-Set Topology)
    â”œâ”€â”€ ä»£æ•°æ‹“æ‰‘ (Algebraic Topology)
    â””â”€â”€ åŒä¼¦è®º (Homotopy Theory)
```

**æ ¸å¿ƒå±‚æ¬¡**ï¼š

```text
èŒƒç•´è®ºæ ¸å¿ƒ
â”œâ”€â”€ åŸºæœ¬æ¦‚å¿µ (Basic Concepts)
â”‚   â”œâ”€â”€ èŒƒç•´ (Categories)
â”‚   â”œâ”€â”€ å‡½å­ (Functors)
â”‚   â””â”€â”€ è‡ªç„¶å˜æ¢ (Natural Transformations)
â”œâ”€â”€ æé™ç†è®º (Limit Theory)
â”‚   â”œâ”€â”€ æé™ (Limits)
â”‚   â”œâ”€â”€ ä½™æé™ (Colimits)
â”‚   â””â”€â”€ å®Œå¤‡æ€§ (Completeness)
â””â”€â”€ ä¼´éšç†è®º (Adjunction Theory)
    â”œâ”€â”€ ä¼´éšå‡½å­ (Adjunctions)
    â”œâ”€â”€ å•ä½ä¸ä½™å•ä½ (Units and Counits)
    â””â”€â”€ ä¸‰è§’æ’ç­‰å¼ (Triangle Identities)
```

**é«˜çº§å±‚æ¬¡**ï¼š

```text
é«˜çº§èŒƒç•´è®º
â”œâ”€â”€ é«˜é˜¶èŒƒç•´ (Higher Categories)
â”‚   â”œâ”€â”€ 2-èŒƒç•´ (2-Categories)
â”‚   â”œâ”€â”€ n-èŒƒç•´ (n-Categories)
â”‚   â””â”€â”€ âˆ-èŒƒç•´ (âˆ-Categories)
â”œâ”€â”€ å¯ŒèŒƒç•´ (Enriched Categories)
â”‚   â”œâ”€â”€ V-å¯ŒèŒƒç•´ (V-Enriched Categories)
â”‚   â”œâ”€â”€ å¹ºåŠå¯ŒèŒƒç•´ (Monoidal Enriched Categories)
â”‚   â””â”€â”€ é—­å¯ŒèŒƒç•´ (Closed Enriched Categories)
â””â”€â”€ ç‰¹æ®ŠèŒƒç•´ (Special Categories)
    â”œâ”€â”€ æ‹“æ‰‘æ–¯ (Topoi)
    â”œâ”€â”€ æ¨¡å‹èŒƒç•´ (Model Categories)
    â””â”€â”€ å¯¼å‡ºèŒƒç•´ (Derived Categories)
```

### æ¨¡å‹å…³è”å…³ç³» / Model Association Relationships

**æ°´å¹³å…³è”**ï¼š

```mermaid
graph LR
    A[åŸºæœ¬èŒƒç•´] --> B[å‡½å­]
    B --> C[è‡ªç„¶å˜æ¢]
    C --> D[ä¼´éšå‡½å­]
    D --> E[æé™ç†è®º]
    E --> F[é«˜é˜¶èŒƒç•´]

    G[é›†åˆè®º] --> A
    H[ä»£æ•°ç»“æ„] --> A
    I[æ‹“æ‰‘å­¦] --> A

    J[è®¡ç®—ç†è®º] --> F
    K[é‡å­è®¡ç®—] --> F
    L[æœºå™¨å­¦ä¹ ] --> F
```

**å‚ç›´å…³è”**ï¼š

```mermaid
graph TD
    A[æ•°å­¦åŸºç¡€] --> B[èŒƒç•´è®ºåŸºç¡€]
    B --> C[é«˜çº§èŒƒç•´è®º]
    C --> D[åº”ç”¨é¢†åŸŸ]

    A1[é›†åˆè®º] --> A
    A2[ä»£æ•°ç»“æ„] --> A
    A3[æ‹“æ‰‘å­¦] --> A

    B1[èŒƒç•´å®šä¹‰] --> B
    B2[å‡½å­ç†è®º] --> B
    B3[è‡ªç„¶å˜æ¢] --> B

    C1[é«˜é˜¶èŒƒç•´] --> C
    C2[å¯ŒèŒƒç•´] --> C
    C3[ç‰¹æ®ŠèŒƒç•´] --> C

    D1[è®¡ç®—åº”ç”¨] --> D
    D2[ç‰©ç†åº”ç”¨] --> D
    D3[ç”Ÿç‰©åº”ç”¨] --> D
```

**ä¾èµ–å…³ç³»åˆ†æ**ï¼š

```python
class DependencyAnalyzer:
    """ä¾èµ–å…³ç³»åˆ†æå™¨"""

    def __init__(self):
        self.dependencies = {
            'Category': ['Set Theory', 'Algebraic Structures'],
            'Functor': ['Category'],
            'NaturalTransformation': ['Functor'],
            'Adjunction': ['NaturalTransformation', 'Limit Theory'],
            'HigherCategory': ['Category', 'Topology'],
            'EnrichedCategory': ['Category', 'Monoidal Category'],
            '2-Category': ['Category', 'HigherCategory']
        }

    def analyze_dependencies(self, concept):
        """åˆ†ææ¦‚å¿µä¾èµ–å…³ç³»"""
        if concept in self.dependencies:
            return self.dependencies[concept]
        return []

    def get_dependency_tree(self, concept):
        """è·å–ä¾èµ–æ ‘"""
        tree = {concept: []}
        deps = self.analyze_dependencies(concept)
        for dep in deps:
            tree[concept].append(self.get_dependency_tree(dep))
        return tree

class RelationshipStrength:
    """å…³ç³»å¼ºåº¦è¯„ä¼°"""

    def __init__(self):
        self.strength_levels = {
            'strong': 0.9,
            'medium': 0.6,
            'weak': 0.3
        }

    def evaluate_relationship(self, concept1, concept2):
        """è¯„ä¼°æ¦‚å¿µé—´å…³ç³»å¼ºåº¦"""
        # å®ç°å…³ç³»å¼ºåº¦è¯„ä¼°ç®—æ³•
        pass

    def get_relationship_matrix(self, concepts):
        """è·å–å…³ç³»å¼ºåº¦çŸ©é˜µ"""
        matrix = {}
        for c1 in concepts:
            matrix[c1] = {}
            for c2 in concepts:
                matrix[c1][c2] = self.evaluate_relationship(c1, c2)
        return matrix
```

## å®ç°ç¤ºä¾‹ / Implementation Examples

### è‡ªç”±å•å­ / Free Monad

```rust
// è‡ªç”±å•å­ / Free Monad
#[derive(Debug)]
enum Free<F, A> {
    Pure(A),
    Free(F::Target<Free<F, A>>),
}

impl<F, A, B> Functor<A, B> for Free<F, A>
where
    F: Functor<Free<F, A>, Free<F, B>>,
{
    type Target<U> = Free<F, U>;

    fn map<Func>(self, f: Func) -> Self::Target<B>
    where
        Func: Fn(A) -> B,
    {
        match self {
            Free::Pure(a) => Free::Pure(f(a)),
            Free::Free(fa) => Free::Free(fa.map(|x| x.map(f))),
        }
    }
}

impl<F, A, B> Monad<A, B> for Free<F, A>
where
    F: Functor<Free<F, A>, Free<F, B>>,
{
    fn unit(a: A) -> Self::Target<A> {
        Free::Pure(a)
    }

    fn bind<Func>(self, f: Func) -> Self::Target<B>
    where
        Func: Fn(A) -> Self::Target<B>,
    {
        match self {
            Free::Pure(a) => f(a),
            Free::Free(fa) => Free::Free(fa.map(|x| x.bind(f))),
        }
    }
}

// çŠ¶æ€å•å­ / State Monad
#[derive(Debug)]
struct State<S, A> {
    run_state: Box<dyn Fn(S) -> (A, S)>,
}

impl<S, A> State<S, A> {
    fn new<F>(f: F) -> Self
    where
        F: Fn(S) -> (A, S) + 'static,
    {
        State {
            run_state: Box::new(f),
        }
    }

    fn run(self, s: S) -> (A, S) {
        (self.run_state)(s)
    }
}

impl<S, A, B> Functor<A, B> for State<S, A> {
    type Target<U> = State<S, U>;

    fn map<F>(self, f: F) -> Self::Target<B>
    where
        F: Fn(A) -> B,
    {
        State::new(move |s| {
            let (a, s2) = self.run(s);
            (f(a), s2)
        })
    }
}

impl<S, A, B> Monad<A, B> for State<S, A> {
    fn unit(a: A) -> Self::Target<A> {
        State::new(move |s| (a, s))
    }

    fn bind<F>(self, f: F) -> Self::Target<B>
    where
        F: Fn(A) -> Self::Target<B>,
    {
        State::new(move |s| {
            let (a, s2) = self.run(s);
            f(a).run(s2)
        })
    }
}

fn main() {
    // è‡ªç”±å•å­ä½¿ç”¨ç¤ºä¾‹ / Free monad usage example
    let free = Free::<fn(i32) -> i32, i32>::Pure(42);
    let mapped = free.map(|x| x * 2);
    println!("Free monad: {:?}", mapped);

    // çŠ¶æ€å•å­ä½¿ç”¨ç¤ºä¾‹ / State monad usage example
    let state = State::new(|s: i32| (s + 1, s * 2));
    let (result, new_state) = state.run(5);
    println!("State monad: result = {}, new_state = {}", result, new_state);
}
```

## å‚è€ƒæ–‡çŒ® / References

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**ç»å…¸æ•™æ / Classic Textbooks**:

1. [MacLane1998] Mac Lane, S. (1998). *Categories for the Working Mathematician* (2nd Edition). Springer. ISBN: 978-0387984032.
   - èŒƒç•´è®ºçš„ç»å…¸æ•™æï¼Œç®€ç§°"Mac Lane"ï¼Œé¢å‘æ•°å­¦å·¥ä½œè€…ï¼Œè¯¦ç»†ä»‹ç»èŒƒç•´ã€å‡½å­ã€è‡ªç„¶å˜æ¢ã€ä¼´éšå‡½å­ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚

**ç°ä»£æ•™æ / Modern Textbooks**:

1. [Awodey2010] Awodey, S. (2010). *Category Theory* (2nd Edition). Oxford University Press. ISBN: 978-0199587360.
   - ç°ä»£èŒƒç•´è®ºæ•™æï¼Œæ¸…æ™°æ˜“æ‡‚ï¼Œé€‚åˆå…¥é—¨ï¼Œå¼ºè°ƒèŒƒç•´è®ºçš„åŸºç¡€æ€§å’Œæ™®é€‚æ€§ã€‚

2. [PierceCategory1991] Pierce, B. C. (1991). *Basic Category Theory for Computer Scientists*. MIT Press. ISBN: 978-0262660716.
   - é¢å‘è®¡ç®—æœºç§‘å­¦å®¶çš„èŒƒç•´è®ºå…¥é—¨ï¼Œç®€æ˜å®ç”¨ï¼Œä¸“æ³¨äºè®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨ã€‚

**è®¡ç®—æœºç§‘å­¦åº”ç”¨ / Computer Science Applications**:

1. Barr, M., & Wells, C. (1990). *Category Theory for Computing Science*. Prentice Hall.
   - èŒƒç•´è®ºåœ¨è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨ï¼Œè¯¦ç»†ä»‹ç»ç¨‹åºè¯­ä¹‰å’Œç±»å‹ç†è®ºã€‚

2. [Pierce2002] Pierce, B. C. (2002). *Types and Programming Languages*. MIT Press. ISBN: 978-0262162098.
   - ç±»å‹ç†è®ºä¸ç¼–ç¨‹è¯­è¨€ï¼ŒåŒ…å«èŒƒç•´è®ºåœ¨ç±»å‹ç³»ç»Ÿä¸­çš„åº”ç”¨ã€‚

**é«˜é˜¶ä¸»é¢˜ / Advanced Topics**:

1. [HoTTBook] The Univalent Foundations Program (2013). *Homotopy Type Theory: Univalent Foundations of Mathematics*. Institute for Advanced Study. URL: <https://homotopytypetheory.org/book/>
   - åŒä¼¦ç±»å‹è®ºï¼ŒèŒƒç•´è®ºçš„ç°ä»£å‘å±•ï¼Œå¼€æ”¾è·å–ã€‚

2. Riehl, E. (2016). *Category Theory in Context*. Dover Publications.
   - èŒƒç•´è®ºçš„ç°ä»£å¯¼å¼•ï¼Œå¼ºè°ƒä¸Šä¸‹æ–‡å’Œåº”ç”¨ã€‚

**å»¶ä¼¸é˜…è¯» / Further Reading**:

1. Leinster, T. (2014). *Basic Category Theory*. Cambridge University Press.
   - åŸºç¡€èŒƒç•´è®ºçš„ç®€æ˜æ•™æã€‚

2. Simmons, H. (2011). *An Introduction to Category Theory*. Cambridge University Press.
   - èŒƒç•´è®ºå¯¼å¼•ï¼Œé€‚åˆè‡ªå­¦ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Category Theory**: <https://en.wikipedia.org/wiki/Category_theory>
   - èŒƒç•´è®ºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«èŒƒç•´ã€å‡½å­ã€è‡ªç„¶å˜æ¢ç­‰æ ¸å¿ƒæ¦‚å¿µï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

2. **Wikipedia - Functor**: <https://en.wikipedia.org/wiki/Functor>
   - å‡½å­çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»å‡½å­çš„å®šä¹‰å’Œæ€§è´¨ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

3. **Wikipedia - Natural Transformation**: <https://en.wikipedia.org/wiki/Natural_transformation>
   - è‡ªç„¶å˜æ¢çš„Wikipediaæ¡ç›®ï¼Œä»‹ç»è‡ªç„¶å˜æ¢çš„å®šä¹‰å’Œåº”ç”¨ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´11æœˆ14æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
**æœ€åæ›´æ–° / Last Updated**: 2025-11-14
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-11-14)

---

*æœ¬æ–‡æ¡£æä¾›äº†èŒƒç•´è®ºçš„åŸºç¡€ç†è®ºåŠå…¶åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„åº”ç”¨ï¼ŒåŒ…æ‹¬èŒƒç•´ã€å‡½å­ã€è‡ªç„¶å˜æ¢ã€å•å­ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä»¥åŠå®ƒä»¬åœ¨ä»£æ•°æ•°æ®ç±»å‹ã€è‡ªç”±å•å­ã€çŠ¶æ€å•å­ç­‰ç¼–ç¨‹æ¨¡å¼ä¸­çš„å…·ä½“åº”ç”¨ã€‚*
