---
title: 1.9 åºè®ºåŸºç¡€ / Order Theory Foundation
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: åŸºç¡€ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)
> **é¡¹ç›®å¯¼èˆªä¸å¯¹æ ‡**ï¼š[é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’](../é¡¹ç›®æ‰©å±•ä¸æŒç»­æ¨è¿›ä»»åŠ¡ç¼–æ’.md)ã€[å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨](../å›½é™…è¯¾ç¨‹å¯¹æ ‡è¡¨.md)

## 1.9 åºè®ºåŸºç¡€ / Order Theory Foundation

### æ‘˜è¦ / Executive Summary

- å»ºç«‹åºè®ºçš„åŸºç¡€ç†è®ºï¼Œç»Ÿä¸€ååºã€å…¨åºã€è‰¯åºç­‰æ ¸å¿ƒæ¦‚å¿µã€‚
- å»ºç«‹åºè®ºåœ¨ç®—æ³•ç†è®ºä¸­çš„åŸºç¡€åœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ååºã€å…¨åºã€è‰¯åºã€ä¸Šç•Œã€ä¸‹ç•Œã€æœ€å¤§å…ƒã€æœ€å°å…ƒã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ååºï¼ˆPartial Orderï¼‰ï¼šæ»¡è¶³è‡ªåæ€§ã€åå¯¹ç§°æ€§å’Œä¼ é€’æ€§çš„å…³ç³»ã€‚
- å…¨åºï¼ˆTotal Orderï¼‰ï¼šä»»æ„ä¸¤ä¸ªå…ƒç´ éƒ½å¯æ¯”è¾ƒçš„ååºã€‚
- è‰¯åºï¼ˆWell-Orderingï¼‰ï¼šæ¯ä¸ªéç©ºå­é›†éƒ½æœ‰æœ€å°å…ƒçš„å…¨åºã€‚
- ä¸Šç•Œï¼ˆUpper Boundï¼‰ï¼šé›†åˆä¸­æ‰€æœ‰å…ƒç´ çš„ä¸Šç•Œã€‚
- è®°å·çº¦å®šï¼š`â‰¤` è¡¨ç¤ºååºå…³ç³»ï¼Œ`<` è¡¨ç¤ºä¸¥æ ¼ååºï¼Œ`S` è¡¨ç¤ºé›†åˆã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- é›†åˆè®ºåŸºç¡€ï¼šå‚è§ `01-åŸºç¡€ç†è®º/03-é›†åˆè®ºåŸºç¡€.md`ã€‚
- æ•°å­¦åŸºç¡€ï¼šå‚è§ `01-åŸºç¡€ç†è®º/02-æ•°å­¦åŸºç¡€.md`ã€‚
- ç®—æ³•ç†è®ºï¼šå‚è§ `09-ç®—æ³•ç†è®º/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- ååºå…³ç³»
- è‰¯åºå…³ç³»

## ç›®å½• (Table of Contents)

- [1.9 åºè®ºåŸºç¡€ / Order Theory Foundation](#19-åºè®ºåŸºç¡€--order-theory-foundation)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#åŸºæœ¬æ¦‚å¿µ--basic-concepts)
  - [ååºå…³ç³» / Partial Order Relation](#ååºå…³ç³»--partial-order-relation)
  - [å…¨åºå…³ç³» / Total Order Relation](#å…¨åºå…³ç³»--total-order-relation)
  - [è‰¯åºå…³ç³» / Well-Ordering Relation](#è‰¯åºå…³ç³»--well-ordering-relation)
- [åºè®ºåœ¨ç®—æ³•ä¸­çš„åº”ç”¨ / Applications of Order Theory in Algorithms](#åºè®ºåœ¨ç®—æ³•ä¸­çš„åº”ç”¨--applications-of-order-theory-in-algorithms)
  - [æ’åºç®—æ³• / Sorting Algorithms](#æ’åºç®—æ³•--sorting-algorithms)
  - [ä¼˜å…ˆé˜Ÿåˆ— / Priority Queues](#ä¼˜å…ˆé˜Ÿåˆ—--priority-queues)
  - [æ‹“æ‰‘æ’åº / Topological Sorting](#æ‹“æ‰‘æ’åº--topological-sorting)
- [åºè®ºçš„é«˜çº§ä¸»é¢˜ / Advanced Topics in Order Theory](#åºè®ºçš„é«˜çº§ä¸»é¢˜--advanced-topics-in-order-theory)
  - [æ ¼è®º / Lattice Theory](#æ ¼è®º--lattice-theory)
  - [å®Œå…¨æ ¼ / Complete Lattices](#å®Œå…¨æ ¼--complete-lattices)
- [å®ç°ç¤ºä¾‹ / Implementation Examples](#å®ç°ç¤ºä¾‹--implementation-examples)
  - [åŒºé—´æ ‘ / Interval Tree](#åŒºé—´æ ‘--interval-tree)
- [å‚è€ƒæ–‡çŒ® / References](#å‚è€ƒæ–‡çŒ®--references)

## åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### ååºå…³ç³» / Partial Order Relation

**å®šä¹‰ 1.1** (ååºå…³ç³») / **Definition 1.1** (Partial Order Relation)
è®¾ $R$ æ˜¯é›†åˆ $A$ ä¸Šçš„äºŒå…ƒå…³ç³»ï¼Œå¦‚æœ $R$ æ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªæ€§è´¨ï¼š
Let $R$ be a binary relation on set $A$. $R$ is a partial order if it satisfies the following three properties:

1. **è‡ªåæ€§** / **Reflexivity**: $\forall a \in A, aRa$
2. **åå¯¹ç§°æ€§** / **Antisymmetry**: $\forall a,b \in A, (aRb \land bRa) \Rightarrow a = b$
3. **ä¼ é€’æ€§** / **Transitivity**: $\forall a,b,c \in A, (aRb \land bRc) \Rightarrow aRc$

åˆ™ç§° $R$ ä¸º $A$ ä¸Šçš„**ååºå…³ç³»**ï¼Œè®°ä½œ $\leq$ã€‚
Then $R$ is called a **partial order relation** on $A$, denoted by $\leq$.

**å®šç† 1.1** (ååºçš„åŸºæœ¬æ€§è´¨) / **Theorem 1.1** (Basic Properties of Partial Orders)
è®¾ $(A, \leq)$ ä¸ºååºé›†ï¼Œåˆ™ï¼š
Let $(A, \leq)$ be a partially ordered set, then:

1. æœ€å¤§å…ƒå”¯ä¸€æ€§ / Uniqueness of maximum element
2. æœ€å°å…ƒå”¯ä¸€æ€§ / Uniqueness of minimum element
3. ä¸Šç¡®ç•Œå”¯ä¸€æ€§ / Uniqueness of supremum
4. ä¸‹ç¡®ç•Œå”¯ä¸€æ€§ / Uniqueness of infimum

### å…¨åºå…³ç³» / Total Order Relation

**å®šä¹‰ 1.2** (å…¨åºå…³ç³») / **Definition 1.2** (Total Order Relation)
è®¾ $(A, \leq)$ ä¸ºååºé›†ï¼Œå¦‚æœå¯¹ä»»æ„ $a,b \in A$ï¼Œéƒ½æœ‰ $a \leq b$ æˆ– $b \leq a$ï¼Œåˆ™ç§° $\leq$ ä¸º $A$ ä¸Šçš„**å…¨åºå…³ç³»**ã€‚
Let $(A, \leq)$ be a partially ordered set. If for any $a,b \in A$, either $a \leq b$ or $b \leq a$, then $\leq$ is called a **total order relation** on $A$.

**å®šç† 1.2** (å…¨åºçš„æ€§è´¨) / **Theorem 1.2** (Properties of Total Orders)
è®¾ $(A, \leq)$ ä¸ºå…¨åºé›†ï¼Œåˆ™ï¼š
Let $(A, \leq)$ be a totally ordered set, then:

1. ä»»æ„éç©ºæœ‰é™å­é›†éƒ½æœ‰æœ€å¤§å…ƒå’Œæœ€å°å…ƒ
   Any non-empty finite subset has maximum and minimum elements
2. ä»»æ„æœ‰ä¸Šç•Œçš„å­é›†éƒ½æœ‰ä¸Šç¡®ç•Œ
   Any bounded above subset has a supremum
3. ä»»æ„æœ‰ä¸‹ç•Œçš„å­é›†éƒ½æœ‰ä¸‹ç¡®ç•Œ
   Any bounded below subset has an infimum

### è‰¯åºå…³ç³» / Well-Ordering Relation

**å®šä¹‰ 1.3** (è‰¯åºå…³ç³») / **Definition 1.3** (Well-Ordering Relation)
è®¾ $(A, \leq)$ ä¸ºå…¨åºé›†ï¼Œå¦‚æœ $A$ çš„ä»»æ„éç©ºå­é›†éƒ½æœ‰æœ€å°å…ƒï¼Œåˆ™ç§° $\leq$ ä¸º $A$ ä¸Šçš„**è‰¯åºå…³ç³»**ã€‚
Let $(A, \leq)$ be a totally ordered set. If every non-empty subset of $A$ has a least element, then $\leq$ is called a **well-ordering relation** on $A$.

**å®šç† 1.3** (è‰¯åºçš„åŸºæœ¬æ€§è´¨) / **Theorem 1.3** (Basic Properties of Well-Orderings)
è®¾ $(A, \leq)$ ä¸ºè‰¯åºé›†ï¼Œåˆ™ï¼š
Let $(A, \leq)$ be a well-ordered set, then:

1. è‰¯åºé›†æ˜¯å…¨åºé›† / Well-ordered sets are totally ordered
2. è‰¯åºé›†çš„ä»»æ„å­é›†éƒ½æ˜¯è‰¯åºé›† / Any subset of a well-ordered set is well-ordered
3. è‰¯åºé›†ä¸è‡ªç„¶æ•°é›†åŒæ„ / Well-ordered sets are isomorphic to natural numbers

## åºè®ºåœ¨ç®—æ³•ä¸­çš„åº”ç”¨ / Applications of Order Theory in Algorithms

### æ’åºç®—æ³• / Sorting Algorithms

**å®šä¹‰ 2.1** (æ’åºé—®é¢˜) / **Definition 2.1** (Sorting Problem)
ç»™å®šä¸€ä¸ªåºåˆ— $S = (a_1, a_2, \ldots, a_n)$ å’Œå…¨åºå…³ç³» $\leq$ï¼Œæ’åºé—®é¢˜æ˜¯æ‰¾åˆ°ä¸€ä¸ªæ’åˆ— $\pi$ ä½¿å¾—ï¼š
Given a sequence $S = (a_1, a_2, \ldots, a_n)$ and a total order relation $\leq$, the sorting problem is to find a permutation $\pi$ such that:

$$a_{\pi(1)} \leq a_{\pi(2)} \leq \cdots \leq a_{\pi(n)}$$

**å®šç† 2.1** (æ¯”è¾ƒæ’åºçš„ä¸‹ç•Œ) / **Theorem 2.1** (Lower Bound for Comparison Sorting)
ä»»ä½•åŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹éœ€è¦ $\Omega(n \log n)$ æ¬¡æ¯”è¾ƒã€‚
Any comparison-based sorting algorithm requires $\Omega(n \log n)$ comparisons in the worst case.

### ä¼˜å…ˆé˜Ÿåˆ— / Priority Queues

**å®šä¹‰ 2.2** (ä¼˜å…ˆé˜Ÿåˆ—) / **Definition 2.2** (Priority Queue)
ä¼˜å…ˆé˜Ÿåˆ—æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼š
A priority queue is a data structure that supports the following operations:

1. **æ’å…¥** / **Insert**: å‘é˜Ÿåˆ—ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ 
2. **åˆ é™¤æœ€å¤§/æœ€å°** / **Delete Max/Min**: åˆ é™¤å¹¶è¿”å›æœ€å¤§æˆ–æœ€å°å…ƒç´ 
3. **æŸ¥æ‰¾æœ€å¤§/æœ€å°** / **Find Max/Min**: è¿”å›æœ€å¤§æˆ–æœ€å°å…ƒç´ 

**å®ç°ç¤ºä¾‹** / **Implementation Example**

```rust
use std::collections::BinaryHeap;
use std::cmp::Ordering;

#[derive(Debug, PartialEq, Eq)]
struct PriorityItem<T> {
    priority: i32,
    data: T,
}

impl<T> PartialOrd for PriorityItem<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl<T> Ord for PriorityItem<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.priority.cmp(&other.priority).reverse()
    }
}

struct PriorityQueue<T> {
    heap: BinaryHeap<PriorityItem<T>>,
}

impl<T> PriorityQueue<T> {
    fn new() -> Self {
        PriorityQueue {
            heap: BinaryHeap::new(),
        }
    }

    fn push(&mut self, priority: i32, data: T) {
        self.heap.push(PriorityItem { priority, data });
    }

    fn pop(&mut self) -> Option<T> {
        self.heap.pop().map(|item| item.data)
    }

    fn peek(&self) -> Option<&T> {
        self.heap.peek().map(|item| &item.data)
    }

    fn is_empty(&self) -> bool {
        self.heap.is_empty()
    }

    fn len(&self) -> usize {
        self.heap.len()
    }
}

// ä½¿ç”¨ç¤ºä¾‹ / Usage Example
fn main() {
    let mut pq = PriorityQueue::new();

    pq.push(3, "task3");
    pq.push(1, "task1");
    pq.push(2, "task2");

    while !pq.is_empty() {
        if let Some(task) = pq.pop() {
            println!("Processing: {}", task);
        }
    }
}
```

### æ‹“æ‰‘æ’åº / Topological Sorting

**å®šä¹‰ 2.3** (æ‹“æ‰‘æ’åº) / **Definition 2.3** (Topological Sorting)
ç»™å®šæœ‰å‘æ— ç¯å›¾ $G = (V, E)$ï¼Œæ‹“æ‰‘æ’åºæ˜¯é¡¶ç‚¹çš„ä¸€ä¸ªçº¿æ€§æ’åºï¼Œä½¿å¾—å¯¹äºæ¯æ¡è¾¹ $(u, v) \in E$ï¼Œéƒ½æœ‰ $u$ åœ¨ $v$ ä¹‹å‰ã€‚
Given a directed acyclic graph $G = (V, E)$, a topological sorting is a linear ordering of vertices such that for every edge $(u, v) \in E$, $u$ comes before $v$.

**ç®—æ³•å®ç°** / **Algorithm Implementation**

```rust
use std::collections::{HashMap, HashSet, VecDeque};

struct Graph {
    adj: HashMap<usize, Vec<usize>>,
    in_degree: HashMap<usize, usize>,
}

impl Graph {
    fn new() -> Self {
        Graph {
            adj: HashMap::new(),
            in_degree: HashMap::new(),
        }
    }

    fn add_edge(&mut self, from: usize, to: usize) {
        self.adj.entry(from).or_insert_with(Vec::new).push(to);
        *self.in_degree.entry(to).or_insert(0) += 1;
    }

    fn topological_sort(&self) -> Option<Vec<usize>> {
        let mut in_degree = self.in_degree.clone();
        let mut queue = VecDeque::new();
        let mut result = Vec::new();

        // æ‰¾åˆ°æ‰€æœ‰å…¥åº¦ä¸º0çš„é¡¶ç‚¹ / Find all vertices with in-degree 0
        for &vertex in self.adj.keys() {
            if in_degree.get(&vertex).unwrap_or(&0) == &0 {
                queue.push_back(vertex);
            }
        }

        while let Some(vertex) = queue.pop_front() {
            result.push(vertex);

            if let Some(neighbors) = self.adj.get(&vertex) {
                for &neighbor in neighbors {
                    if let Some(degree) = in_degree.get_mut(&neighbor) {
                        *degree -= 1;
                        if *degree == 0 {
                            queue.push_back(neighbor);
                        }
                    }
                }
            }
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰ç¯ / Check for cycles
        if result.len() == self.adj.len() {
            Some(result)
        } else {
            None
        }
    }
}

fn main() {
    let mut graph = Graph::new();

    // æ·»åŠ è¾¹ / Add edges
    graph.add_edge(0, 1);
    graph.add_edge(0, 2);
    graph.add_edge(1, 3);
    graph.add_edge(2, 3);
    graph.add_edge(3, 4);

    if let Some(order) = graph.topological_sort() {
        println!("Topological order: {:?}", order);
    } else {
        println!("Graph contains a cycle");
    }
}
```

## åºè®ºçš„é«˜çº§ä¸»é¢˜ / Advanced Topics in Order Theory

### æ ¼è®º / Lattice Theory

**å®šä¹‰ 3.1** (æ ¼) / **Definition 3.1** (Lattice)
è®¾ $(L, \leq)$ ä¸ºååºé›†ï¼Œå¦‚æœä»»æ„ä¸¤ä¸ªå…ƒç´ éƒ½æœ‰ä¸Šç¡®ç•Œå’Œä¸‹ç¡®ç•Œï¼Œåˆ™ç§° $L$ ä¸º**æ ¼**ã€‚
Let $(L, \leq)$ be a partially ordered set. If any two elements have both supremum and infimum, then $L$ is called a **lattice**.

**å®šç† 3.1** (æ ¼çš„åŸºæœ¬æ€§è´¨) / **Theorem 3.1** (Basic Properties of Lattices)
è®¾ $L$ ä¸ºæ ¼ï¼Œåˆ™ï¼š
Let $L$ be a lattice, then:

1. ç»“åˆå¾‹ / Associativity: $(a \vee b) \vee c = a \vee (b \vee c)$
2. äº¤æ¢å¾‹ / Commutativity: $a \vee b = b \vee a$
3. å¸æ”¶å¾‹ / Absorption: $a \vee (a \wedge b) = a$

### å®Œå…¨æ ¼ / Complete Lattices

**å®šä¹‰ 3.2** (å®Œå…¨æ ¼) / **Definition 3.2** (Complete Lattice)
è®¾ $L$ ä¸ºæ ¼ï¼Œå¦‚æœ $L$ çš„ä»»æ„å­é›†éƒ½æœ‰ä¸Šç¡®ç•Œå’Œä¸‹ç¡®ç•Œï¼Œåˆ™ç§° $L$ ä¸º**å®Œå…¨æ ¼**ã€‚
Let $L$ be a lattice. If any subset of $L$ has both supremum and infimum, then $L$ is called a **complete lattice**.

**å®šç† 3.2** (Knaster-Tarskiä¸åŠ¨ç‚¹å®šç†) / **Theorem 3.2** (Knaster-Tarski Fixed Point Theorem)
è®¾ $L$ ä¸ºå®Œå…¨æ ¼ï¼Œ$f: L \to L$ ä¸ºå•è°ƒå‡½æ•°ï¼Œåˆ™ $f$ æœ‰æœ€å°ä¸åŠ¨ç‚¹å’Œæœ€å¤§ä¸åŠ¨ç‚¹ã€‚
Let $L$ be a complete lattice and $f: L \to L$ be a monotone function. Then $f$ has a least fixed point and a greatest fixed point.

## å®ç°ç¤ºä¾‹ / Implementation Examples

### åŒºé—´æ ‘ / Interval Tree

```rust
use std::cmp::{max, min};

#[derive(Debug, Clone, PartialEq)]
struct Interval {
    start: i32,
    end: i32,
}

impl Interval {
    fn new(start: i32, end: i32) -> Self {
        Interval { start, end }
    }

    fn overlaps(&self, other: &Interval) -> bool {
        self.start <= other.end && other.start <= self.end
    }
}

struct IntervalTreeNode {
    interval: Interval,
    max_end: i32,
    left: Option<Box<IntervalTreeNode>>,
    right: Option<Box<IntervalTreeNode>>,
}

impl IntervalTreeNode {
    fn new(interval: Interval) -> Self {
        IntervalTreeNode {
            max_end: interval.end,
            interval,
            left: None,
            right: None,
        }
    }

    fn insert(&mut self, interval: Interval) {
        if interval.start < self.interval.start {
            if let Some(ref mut left) = self.left {
                left.insert(interval);
            } else {
                self.left = Some(Box::new(IntervalTreeNode::new(interval)));
            }
        } else {
            if let Some(ref mut right) = self.right {
                right.insert(interval);
            } else {
                self.right = Some(Box::new(IntervalTreeNode::new(interval)));
            }
        }

        self.update_max_end();
    }

    fn update_max_end(&mut self) {
        self.max_end = self.interval.end;

        if let Some(ref left) = self.left {
            self.max_end = max(self.max_end, left.max_end);
        }

        if let Some(ref right) = self.right {
            self.max_end = max(self.max_end, right.max_end);
        }
    }

    fn search_overlapping(&self, query: &Interval) -> Vec<Interval> {
        let mut result = Vec::new();
        self.search_overlapping_recursive(query, &mut result);
        result
    }

    fn search_overlapping_recursive(&self, query: &Interval, result: &mut Vec<Interval>) {
        if self.interval.overlaps(query) {
            result.push(self.interval.clone());
        }

        if let Some(ref left) = self.left {
            if left.max_end >= query.start {
                left.search_overlapping_recursive(query, result);
            }
        }

        if let Some(ref right) = self.right {
            if self.interval.start <= query.end {
                right.search_overlapping_recursive(query, result);
            }
        }
    }
}

struct IntervalTree {
    root: Option<Box<IntervalTreeNode>>,
}

impl IntervalTree {
    fn new() -> Self {
        IntervalTree { root: None }
    }

    fn insert(&mut self, interval: Interval) {
        if let Some(ref mut root) = self.root {
            root.insert(interval);
        } else {
            self.root = Some(Box::new(IntervalTreeNode::new(interval)));
        }
    }

    fn search_overlapping(&self, query: &Interval) -> Vec<Interval> {
        if let Some(ref root) = self.root {
            root.search_overlapping(query)
        } else {
            Vec::new()
        }
    }
}

fn main() {
    let mut tree = IntervalTree::new();

    tree.insert(Interval::new(15, 20));
    tree.insert(Interval::new(10, 30));
    tree.insert(Interval::new(17, 19));
    tree.insert(Interval::new(5, 20));
    tree.insert(Interval::new(12, 15));
    tree.insert(Interval::new(30, 40));

    let query = Interval::new(6, 7);
    let overlapping = tree.search_overlapping(&query);

    println!("Intervals overlapping with {:?}:", query);
    for interval in overlapping {
        println!("  {:?}", interval);
    }
}
```

## å‚è€ƒæ–‡çŒ® / References

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**åºè®ºä¸æ ¼è®ºåŸºç¡€ / Order Theory and Lattice Theory Foundations**:

1. [DaveyPriestley2002] Davey, B. A., & Priestley, H. A. (2002). *Introduction to Lattices and Order* (2nd Edition). Cambridge University Press. ISBN: 978-0521784511.
   - åºè®ºå’Œæ ¼è®ºçš„æ ‡å‡†æ•™æï¼Œå¹¿æ³›åº”ç”¨äºè®¡ç®—æœºç§‘å­¦ã€‚è¯¦ç»†ä»‹ç»äº†ååºé›†ã€æ ¼ã€å®Œå…¨æ ¼å’Œä¸åŠ¨ç‚¹ç†è®ºã€‚

2. [Birkhoff1967] Birkhoff, G. (1967). *Lattice Theory* (3rd Edition). American Mathematical Society.
   - æ ¼è®ºçš„ç»å…¸è‘—ä½œï¼Œæ·±å…¥è®¨è®ºæ ¼çš„ä»£æ•°ç»“æ„å’Œè¡¨ç¤ºç†è®ºã€‚å®šä¹‰äº†åˆ†é…æ ¼ã€æ¨¡æ ¼ç­‰é‡è¦æ¦‚å¿µã€‚

3. [GierzEtAl2003] Gierz, G., Hofmann, K. H., Keimel, K., Lawson, J. D., Mislove, M., & Scott, D. S. (2003). *Continuous Lattices and Domains*. Cambridge University Press. ISBN: 978-0521803380.
   - Domainç†è®ºçš„æƒå¨è‘—ä½œï¼Œåº”ç”¨äºç¨‹åºè¯­ä¹‰å­¦ã€‚è¯¦ç»†ä»‹ç»äº†è¿ç»­æ ¼ã€ä»£æ•°æ ¼å’ŒScottåŸŸã€‚

**ç®—æ³•ä¸æ•°æ®ç»“æ„ / Algorithms and Data Structures**:

1. [CLRS2009] Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd Edition). MIT Press. ISBN: 978-0262033848.
   - ç®—æ³•å¯¼è®ºï¼Œè¯¦ç»†ä»‹ç»äº†åŸºäºåºå…³ç³»çš„ç®—æ³•ï¼ŒåŒ…æ‹¬æ’åºã€ä¼˜å…ˆé˜Ÿåˆ—å’Œæ‹“æ‰‘æ’åºã€‚

2. [Knuth1998-Vol3] Knuth, D. E. (1998). *The Art of Computer Programming, Volume 3: Sorting and Searching* (2nd Edition). Addison-Wesley. ISBN: 978-0201896855.
   - TAOCPç¬¬3å·ï¼Œæ’åºå’Œæœç´¢ç®—æ³•çš„æƒå¨å‚è€ƒï¼Œè¯¦ç»†åˆ†æäº†å„ç§åŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•ã€‚

3. [Sedgewick2011] Sedgewick, R., & Wayne, K. (2011). *Algorithms* (4th Edition). Addison-Wesley. ISBN: 978-0321573513.
   - é¢å‘å®è·µçš„ç®—æ³•æ•™æï¼ŒåŒ…å«ä¼˜å…ˆé˜Ÿåˆ—ã€å †æ’åºå’Œæ‹“æ‰‘æ’åºçš„å®ç°ã€‚

**è®¡ç®—ç†è®ºåº”ç”¨ / Computational Theory Applications**:

1. [Sipser2012] Sipser, M. (2012). *Introduction to the Theory of Computation* (3rd Edition). Cengage Learning. ISBN: 978-1133187790.
   - è®¡ç®—ç†è®ºå¯¼å¼•ï¼Œè®¨è®ºäº†åºå…³ç³»åœ¨è‡ªåŠ¨æœºç†è®ºå’Œå½¢å¼è¯­è¨€ä¸­çš„åº”ç”¨ã€‚

**å»¶ä¼¸é˜…è¯» / Further Reading**:

1. SchrÃ¶der, B. S. W. (2002). *Ordered Sets: An Introduction*. BirkhÃ¤user.
   - åºé›†ç†è®ºçš„ç³»ç»Ÿæ€§ä»‹ç»ï¼Œé€‚åˆè¿›é˜¶å­¦ä¹ ã€‚

2. MacLane, S. (1998). *Categories for the Working Mathematician* (2nd Edition). Springer.
   - èŒƒç•´è®ºæ•™æï¼Œä»èŒƒç•´è®ºè§’åº¦ç†è§£åºå…³ç³»å’Œæ ¼ç»“æ„ã€‚

3. Abramsky, S., & Jung, A. (1994). "Domain theory". In *Handbook of Logic in Computer Science*, Volume 3. Oxford University Press.
    - Domainç†è®ºçš„ç»¼è¿°æ€§ç« èŠ‚ï¼Œè¯¦ç»†ä»‹ç»äº†ç¨‹åºè¯­ä¹‰å­¦ä¸­çš„åºè®ºåº”ç”¨ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - Order Theory**: <https://en.wikipedia.org/wiki/Order_theory>
   - åºè®ºçš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«ååºã€å…¨åºã€è‰¯åºç­‰æ ¸å¿ƒæ¦‚å¿µï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Partially Ordered Set**: <https://en.wikipedia.org/wiki/Partially_ordered_set>
   - ååºé›†çš„Wikipediaæ¡ç›®ï¼Œè¯¦ç»†ä»‹ç»ååºå…³ç³»çš„å®šä¹‰å’Œæ€§è´¨ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Lattice (Order)**: <https://en.wikipedia.org/wiki/Lattice_(order)>
   - æ ¼çš„Wikipediaæ¡ç›®ï¼Œä»‹ç»æ ¼çš„å®šä¹‰å’Œæ€§è´¨ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
**æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£æä¾›äº†åºè®ºçš„åŸºç¡€ç†è®ºåŠå…¶åœ¨ç®—æ³•ä¸­çš„åº”ç”¨ï¼ŒåŒ…æ‹¬ååºã€å…¨åºã€è‰¯åºå…³ç³»ï¼Œä»¥åŠå®ƒä»¬åœ¨æ’åºç®—æ³•ã€ä¼˜å…ˆé˜Ÿåˆ—ã€æ‹“æ‰‘æ’åºç­‰ç®—æ³•ä¸­çš„å…·ä½“åº”ç”¨ã€‚*
