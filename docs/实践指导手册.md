# å½¢å¼åŒ–ç®—æ³•å®è·µæŒ‡å¯¼æ‰‹å†Œ

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## æ¦‚è¿°

æœ¬æ‰‹å†Œä¸ºå½¢å¼åŒ–ç®—æ³•é¡¹ç›®æä¾›å…¨é¢çš„å®è·µæŒ‡å¯¼ï¼ŒåŒ…æ‹¬é¡¹ç›®æ¨¡æ¿ã€æœ€ä½³å®è·µã€å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆï¼Œå¸®åŠ©å­¦ä¹ è€…ä»ç†è®ºåˆ°å®è·µçš„å®Œæ•´è½¬æ¢ã€‚

## å®è·µæŒ‡å¯¼åŸåˆ™

### 1. ç†è®ºå®è·µç»“åˆ

- æ¯ä¸ªç†è®ºæ¦‚å¿µéƒ½æœ‰å¯¹åº”çš„å®è·µç»ƒä¹ 
- é€šè¿‡ä»£ç å®ç°åŠ æ·±ç†è®ºç†è§£
- ç”¨å®é™…æ¡ˆä¾‹éªŒè¯ç†è®ºæ­£ç¡®æ€§

### 2. å¾ªåºæ¸è¿›

- ä»ç®€å•ç¤ºä¾‹å¼€å§‹
- é€æ­¥å¢åŠ å¤æ‚åº¦
- ç¡®ä¿æ¯ä¸ªæ­¥éª¤éƒ½èƒ½ç†è§£

### 3. é—®é¢˜é©±åŠ¨

- ä»¥å®é™…é—®é¢˜ä¸ºå¯¼å‘
- é€šè¿‡è§£å†³é—®é¢˜å­¦ä¹ ç†è®º
- åŸ¹å…»é—®é¢˜è§£å†³èƒ½åŠ›

## é¡¹ç›®æ¨¡æ¿

### 1. åŸºç¡€ç®—æ³•é¡¹ç›®æ¨¡æ¿

```rust
// åŸºç¡€ç®—æ³•é¡¹ç›®æ¨¡æ¿
// æ–‡ä»¶å: basic_algorithm_project.rs

use std::collections::HashMap;
use std::error::Error;
use std::fmt;

// é”™è¯¯ç±»å‹å®šä¹‰
#[derive(Debug)]
pub enum AlgorithmError {
    InvalidInput(String),
    ComputationError(String),
    OverflowError,
}

impl fmt::Display for AlgorithmError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AlgorithmError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),
            AlgorithmError::ComputationError(msg) => write!(f, "Computation error: {}", msg),
            AlgorithmError::OverflowError => write!(f, "Overflow error"),
        }
    }
}

impl Error for AlgorithmError {}

// ç®—æ³•æ¥å£å®šä¹‰
pub trait Algorithm<T, R> {
    fn execute(&self, input: T) -> Result<R, AlgorithmError>;
    fn validate_input(&self, input: &T) -> Result<(), AlgorithmError>;
    fn get_complexity(&self) -> ComplexityInfo;
}

// å¤æ‚åº¦ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct ComplexityInfo {
    pub time_complexity: String,
    pub space_complexity: String,
    pub best_case: String,
    pub worst_case: String,
    pub average_case: String,
}

// æ€§èƒ½æµ‹è¯•å·¥å…·
pub struct PerformanceTester {
    pub iterations: usize,
    pub warmup_runs: usize,
}

impl PerformanceTester {
    pub fn new() -> Self {
        Self {
            iterations: 1000,
            warmup_runs: 100,
        }
    }

    pub fn benchmark<F, T>(&self, algorithm: F, input: T) -> Result<BenchmarkResult, AlgorithmError>
    where
        F: Fn(T) -> Result<(), AlgorithmError>,
    {
        // é¢„çƒ­
        for _ in 0..self.warmup_runs {
            algorithm(input.clone())?;
        }

        // æ­£å¼æµ‹è¯•
        let start = std::time::Instant::now();
        for _ in 0..self.iterations {
            algorithm(input.clone())?;
        }
        let duration = start.elapsed();

        Ok(BenchmarkResult {
            total_time: duration,
            average_time: duration / self.iterations as u32,
            iterations: self.iterations,
        })
    }
}

#[derive(Debug)]
pub struct BenchmarkResult {
    pub total_time: std::time::Duration,
    pub average_time: std::time::Duration,
    pub iterations: usize,
}

// ç¤ºä¾‹ç®—æ³•å®ç°
pub struct QuickSort;

impl Algorithm<Vec<i32>, Vec<i32>> for QuickSort {
    fn execute(&self, mut input: Vec<i32>) -> Result<Vec<i32>, AlgorithmError> {
        self.validate_input(&input)?;

        if input.len() <= 1 {
            return Ok(input);
        }

        self.quicksort(&mut input, 0, input.len() - 1)?;
        Ok(input)
    }

    fn validate_input(&self, input: &Vec<i32>) -> Result<(), AlgorithmError> {
        if input.is_empty() {
            return Err(AlgorithmError::InvalidInput("Empty input".to_string()));
        }
        Ok(())
    }

    fn get_complexity(&self) -> ComplexityInfo {
        ComplexityInfo {
            time_complexity: "O(n log n)".to_string(),
            space_complexity: "O(log n)".to_string(),
            best_case: "O(n log n)".to_string(),
            worst_case: "O(nÂ²)".to_string(),
            average_case: "O(n log n)".to_string(),
        }
    }
}

impl QuickSort {
    fn quicksort(&self, arr: &mut [i32], low: usize, high: usize) -> Result<(), AlgorithmError> {
        if low < high {
            let pivot = self.partition(arr, low, high)?;
            if pivot > 0 {
                self.quicksort(arr, low, pivot - 1)?;
            }
            self.quicksort(arr, pivot + 1, high)?;
        }
        Ok(())
    }

    fn partition(&self, arr: &mut [i32], low: usize, high: usize) -> Result<usize, AlgorithmError> {
        let pivot = arr[high];
        let mut i = low;

        for j in low..high {
            if arr[j] <= pivot {
                arr.swap(i, j);
                i += 1;
            }
        }

        arr.swap(i, high);
        Ok(i)
    }
}

// æµ‹è¯•æ¨¡å—
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_quicksort_empty() {
        let sorter = QuickSort;
        let result = sorter.execute(vec![]);
        assert!(result.is_err());
    }

    #[test]
    fn test_quicksort_single() {
        let sorter = QuickSort;
        let result = sorter.execute(vec![42]);
        assert_eq!(result.unwrap(), vec![42]);
    }

    #[test]
    fn test_quicksort_multiple() {
        let sorter = QuickSort;
        let input = vec![64, 34, 25, 12, 22, 11, 90];
        let result = sorter.execute(input);
        assert_eq!(result.unwrap(), vec![11, 12, 22, 25, 34, 64, 90]);
    }

    #[test]
    fn test_quicksort_already_sorted() {
        let sorter = QuickSort;
        let input = vec![1, 2, 3, 4, 5];
        let result = sorter.execute(input);
        assert_eq!(result.unwrap(), vec![1, 2, 3, 4, 5]);
    }

    #[test]
    fn test_quicksort_reverse_sorted() {
        let sorter = QuickSort;
        let input = vec![5, 4, 3, 2, 1];
        let result = sorter.execute(input);
        assert_eq!(result.unwrap(), vec![1, 2, 3, 4, 5]);
    }
}

// ä¸»å‡½æ•°ç¤ºä¾‹
fn main() -> Result<(), Box<dyn Error>> {
    let sorter = QuickSort;
    let input = vec![64, 34, 25, 12, 22, 11, 90];

    println!("åŸå§‹æ•°ç»„: {:?}", input);

    let sorted = sorter.execute(input)?;
    println!("æ’åºå: {:?}", sorted);

    let complexity = sorter.get_complexity();
    println!("å¤æ‚åº¦ä¿¡æ¯: {:?}", complexity);

    // æ€§èƒ½æµ‹è¯•
    let tester = PerformanceTester::new();
    let benchmark_result = tester.benchmark(|arr| {
        let sorter = QuickSort;
        sorter.execute(arr)
    }, vec![64, 34, 25, 12, 22, 11, 90])?;

    println!("æ€§èƒ½æµ‹è¯•ç»“æœ: {:?}", benchmark_result);

    Ok(())
}
```

### 2. é«˜çº§ç®—æ³•é¡¹ç›®æ¨¡æ¿

```rust
// é«˜çº§ç®—æ³•é¡¹ç›®æ¨¡æ¿
// æ–‡ä»¶å: advanced_algorithm_project.rs

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// å¹¶è¡Œç®—æ³•æ¥å£
pub trait ParallelAlgorithm<T, R> {
    fn execute_parallel(&self, input: T, num_threads: usize) -> Result<R, AlgorithmError>;
    fn execute_sequential(&self, input: T) -> Result<R, AlgorithmError>;
    fn get_speedup(&self, input: T, num_threads: usize) -> Result<f64, AlgorithmError>;
}

// åˆ†å¸ƒå¼ç®—æ³•æ¥å£
pub trait DistributedAlgorithm<T, R> {
    fn execute_distributed(&self, input: T, nodes: Vec<String>) -> Result<R, AlgorithmError>;
    fn get_communication_cost(&self, input: T, nodes: Vec<String>) -> Result<usize, AlgorithmError>;
}

// éšæœºç®—æ³•æ¥å£
pub trait RandomizedAlgorithm<T, R> {
    fn execute_randomized(&self, input: T, seed: Option<u64>) -> Result<R, AlgorithmError>;
    fn get_success_probability(&self, input: T) -> Result<f64, AlgorithmError>;
}

// è¿‘ä¼¼ç®—æ³•æ¥å£
pub trait ApproximationAlgorithm<T, R> {
    fn execute_approximation(&self, input: T, epsilon: f64) -> Result<R, AlgorithmError>;
    fn get_approximation_ratio(&self, input: T) -> Result<f64, AlgorithmError>;
}

// å¹¶è¡Œå¿«é€Ÿæ’åºå®ç°
pub struct ParallelQuickSort;

impl ParallelAlgorithm<Vec<i32>, Vec<i32>> for ParallelQuickSort {
    fn execute_parallel(&self, mut input: Vec<i32>, num_threads: usize) -> Result<Vec<i32>, AlgorithmError> {
        if input.len() <= 1 {
            return Ok(input);
        }

        let chunk_size = input.len() / num_threads;
        let mut handles = vec![];
        let input_arc = Arc::new(Mutex::new(input));

        for i in 0..num_threads {
            let start = i * chunk_size;
            let end = if i == num_threads - 1 {
                input_arc.lock().unwrap().len()
            } else {
                (i + 1) * chunk_size
            };

            let input_clone = Arc::clone(&input_arc);
            let handle = thread::spawn(move || {
                let mut local_input = input_clone.lock().unwrap()[start..end].to_vec();
                let sorter = QuickSort;
                sorter.execute(local_input)
            });
            handles.push(handle);
        }

        let mut results = vec![];
        for handle in handles {
            let result = handle.join().unwrap()?;
            results.extend(result);
        }

        // åˆå¹¶ç»“æœ
        let final_sorter = QuickSort;
        final_sorter.execute(results)
    }

    fn execute_sequential(&self, input: Vec<i32>) -> Result<Vec<i32>, AlgorithmError> {
        let sorter = QuickSort;
        sorter.execute(input)
    }

    fn get_speedup(&self, input: Vec<i32>, num_threads: usize) -> Result<f64, AlgorithmError> {
        let start = std::time::Instant::now();
        self.execute_sequential(input.clone())?;
        let sequential_time = start.elapsed();

        let start = std::time::Instant::now();
        self.execute_parallel(input, num_threads)?;
        let parallel_time = start.elapsed();

        Ok(sequential_time.as_secs_f64() / parallel_time.as_secs_f64())
    }
}

// éšæœºç®—æ³•å®ç°
pub struct RandomizedQuickSort;

impl RandomizedAlgorithm<Vec<i32>, Vec<i32>> for RandomizedQuickSort {
    fn execute_randomized(&self, mut input: Vec<i32>, seed: Option<u64>) -> Result<Vec<i32>, AlgorithmError> {
        if let Some(s) = seed {
            // è®¾ç½®éšæœºç§å­
            // è¿™é‡Œéœ€è¦å®é™…çš„éšæœºæ•°ç”Ÿæˆå™¨å®ç°
        }

        if input.len() <= 1 {
            return Ok(input);
        }

        self.randomized_quicksort(&mut input, 0, input.len() - 1)?;
        Ok(input)
    }

    fn get_success_probability(&self, input: Vec<i32>) -> Result<f64, AlgorithmError> {
        // åŸºäºè¾“å…¥å¤§å°è®¡ç®—æˆåŠŸæ¦‚ç‡
        let n = input.len();
        if n <= 1 {
            return Ok(1.0);
        }

        // éšæœºå¿«é€Ÿæ’åºçš„æœŸæœ›æ—¶é—´å¤æ‚åº¦æ˜¯O(n log n)
        // æˆåŠŸæ¦‚ç‡æ¥è¿‘1.0
        Ok(1.0 - 1.0 / (n as f64).ln())
    }
}

impl RandomizedQuickSort {
    fn randomized_quicksort(&self, arr: &mut [i32], low: usize, high: usize) -> Result<(), AlgorithmError> {
        if low < high {
            let pivot = self.randomized_partition(arr, low, high)?;
            if pivot > 0 {
                self.randomized_quicksort(arr, low, pivot - 1)?;
            }
            self.randomized_quicksort(arr, pivot + 1, high)?;
        }
        Ok(())
    }

    fn randomized_partition(&self, arr: &mut [i32], low: usize, high: usize) -> Result<usize, AlgorithmError> {
        // éšæœºé€‰æ‹©æ¢è½´
        let random_index = low + (high - low) / 2; // ç®€åŒ–å®ç°
        arr.swap(random_index, high);

        let pivot = arr[high];
        let mut i = low;

        for j in low..high {
            if arr[j] <= pivot {
                arr.swap(i, j);
                i += 1;
            }
        }

        arr.swap(i, high);
        Ok(i)
    }
}

// æµ‹è¯•æ¨¡å—
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parallel_quicksort() {
        let sorter = ParallelQuickSort;
        let input = vec![64, 34, 25, 12, 22, 11, 90];
        let result = sorter.execute_parallel(input, 2);
        assert!(result.is_ok());
    }

    #[test]
    fn test_randomized_quicksort() {
        let sorter = RandomizedQuickSort;
        let input = vec![64, 34, 25, 12, 22, 11, 90];
        let result = sorter.execute_randomized(input, Some(42));
        assert!(result.is_ok());
    }

    #[test]
    fn test_speedup() {
        let sorter = ParallelQuickSort;
        let input = vec![64, 34, 25, 12, 22, 11, 90];
        let speedup = sorter.get_speedup(input, 2);
        assert!(speedup.is_ok());
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let input = vec![64, 34, 25, 12, 22, 11, 90];

    // å¹¶è¡Œæ’åº
    let parallel_sorter = ParallelQuickSort;
    let parallel_result = parallel_sorter.execute_parallel(input.clone(), 4)?;
    println!("å¹¶è¡Œæ’åºç»“æœ: {:?}", parallel_result);

    // éšæœºæ’åº
    let randomized_sorter = RandomizedQuickSort;
    let randomized_result = randomized_sorter.execute_randomized(input.clone(), Some(42))?;
    println!("éšæœºæ’åºç»“æœ: {:?}", randomized_result);

    // æ€§èƒ½æ¯”è¾ƒ
    let speedup = parallel_sorter.get_speedup(input.clone(), 4)?;
    println!("å¹¶è¡ŒåŠ é€Ÿæ¯”: {:.2}", speedup);

    Ok(())
}
```

## æœ€ä½³å®è·µæŒ‡å—

### 1. ä»£ç ç»„ç»‡æœ€ä½³å®è·µ

```rust
// é¡¹ç›®ç»“æ„æœ€ä½³å®è·µ
// æ–‡ä»¶å: project_structure.rs

// 1. æ¨¡å—ç»„ç»‡
pub mod algorithms {
    pub mod sorting {
        pub mod quicksort;
        pub mod mergesort;
        pub mod heapsort;
    }

    pub mod searching {
        pub mod binary_search;
        pub mod linear_search;
        pub mod hash_search;
    }

    pub mod graph {
        pub mod bfs;
        pub mod dfs;
        pub mod dijkstra;
    }
}

pub mod data_structures {
    pub mod tree;
    pub mod heap;
    pub mod hash_map;
}

pub mod utils {
    pub mod performance;
    pub mod testing;
    pub mod validation;
}

// 2. é”™è¯¯å¤„ç†æœ€ä½³å®è·µ
#[derive(Debug, thiserror::Error)]
pub enum AlgorithmError {
    #[error("Invalid input: {0}")]
    InvalidInput(String),

    #[error("Computation error: {0}")]
    ComputationError(String),

    #[error("Overflow error")]
    OverflowError,

    #[error("Timeout error")]
    TimeoutError,
}

// 3. é…ç½®ç®¡ç†æœ€ä½³å®è·µ
#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
pub struct AlgorithmConfig {
    pub max_iterations: usize,
    pub timeout_ms: u64,
    pub parallel_threads: usize,
    pub memory_limit_mb: usize,
}

impl Default for AlgorithmConfig {
    fn default() -> Self {
        Self {
            max_iterations: 1000,
            timeout_ms: 5000,
            parallel_threads: 4,
            memory_limit_mb: 1024,
        }
    }
}

// 4. æ—¥å¿—è®°å½•æœ€ä½³å®è·µ
use log::{info, warn, error, debug};

pub struct AlgorithmLogger {
    pub name: String,
    pub level: log::Level,
}

impl AlgorithmLogger {
    pub fn new(name: String) -> Self {
        Self {
            name,
            level: log::Level::Info,
        }
    }

    pub fn log_execution_start(&self, input_size: usize) {
        info!("Algorithm {} started with input size: {}", self.name, input_size);
    }

    pub fn log_execution_end(&self, duration: std::time::Duration, result_size: usize) {
        info!("Algorithm {} completed in {:?} with result size: {}",
              self.name, duration, result_size);
    }

    pub fn log_error(&self, error: &AlgorithmError) {
        error!("Algorithm {} failed: {}", self.name, error);
    }
}

// 5. æ€§èƒ½ç›‘æ§æœ€ä½³å®è·µ
pub struct PerformanceMonitor {
    pub start_time: std::time::Instant,
    pub memory_usage: usize,
    pub iterations: usize,
}

impl PerformanceMonitor {
    pub fn new() -> Self {
        Self {
            start_time: std::time::Instant::now(),
            memory_usage: 0,
            iterations: 0,
        }
    }

    pub fn record_iteration(&mut self) {
        self.iterations += 1;
    }

    pub fn record_memory_usage(&mut self, usage: usize) {
        self.memory_usage = usage;
    }

    pub fn get_metrics(&self) -> PerformanceMetrics {
        PerformanceMetrics {
            execution_time: self.start_time.elapsed(),
            memory_usage: self.memory_usage,
            iterations: self.iterations,
        }
    }
}

#[derive(Debug)]
pub struct PerformanceMetrics {
    pub execution_time: std::time::Duration,
    pub memory_usage: usize,
    pub iterations: usize,
}
```

### 2. æµ‹è¯•æœ€ä½³å®è·µ

```rust
// æµ‹è¯•æœ€ä½³å®è·µ
// æ–‡ä»¶å: testing_best_practices.rs

use super::*;

// 1. å•å…ƒæµ‹è¯•æœ€ä½³å®è·µ
#[cfg(test)]
mod unit_tests {
    use super::*;

    // æµ‹è¯•ç”¨ä¾‹ç»„ç»‡
    mod quicksort_tests {
        use super::*;

        #[test]
        fn test_empty_input() {
            let sorter = QuickSort;
            let result = sorter.execute(vec![]);
            assert!(result.is_err());
        }

        #[test]
        fn test_single_element() {
            let sorter = QuickSort;
            let result = sorter.execute(vec![42]);
            assert_eq!(result.unwrap(), vec![42]);
        }

        #[test]
        fn test_multiple_elements() {
            let sorter = QuickSort;
            let input = vec![64, 34, 25, 12, 22, 11, 90];
            let result = sorter.execute(input);
            assert_eq!(result.unwrap(), vec![11, 12, 22, 25, 34, 64, 90]);
        }

        #[test]
        fn test_already_sorted() {
            let sorter = QuickSort;
            let input = vec![1, 2, 3, 4, 5];
            let result = sorter.execute(input);
            assert_eq!(result.unwrap(), vec![1, 2, 3, 4, 5]);
        }

        #[test]
        fn test_reverse_sorted() {
            let sorter = QuickSort;
            let input = vec![5, 4, 3, 2, 1];
            let result = sorter.execute(input);
            assert_eq!(result.unwrap(), vec![1, 2, 3, 4, 5]);
        }

        #[test]
        fn test_duplicate_elements() {
            let sorter = QuickSort;
            let input = vec![3, 1, 3, 2, 1];
            let result = sorter.execute(input);
            assert_eq!(result.unwrap(), vec![1, 1, 2, 3, 3]);
        }
    }

    // æ€§èƒ½æµ‹è¯•
    mod performance_tests {
        use super::*;

        #[test]
        fn test_performance_small_input() {
            let sorter = QuickSort;
            let input = (1..=100).collect::<Vec<i32>>();
            let start = std::time::Instant::now();
            let result = sorter.execute(input);
            let duration = start.elapsed();

            assert!(result.is_ok());
            assert!(duration.as_millis() < 100); // åº”è¯¥åœ¨100mså†…å®Œæˆ
        }

        #[test]
        fn test_performance_large_input() {
            let sorter = QuickSort;
            let input = (1..=10000).collect::<Vec<i32>>();
            let start = std::time::Instant::now();
            let result = sorter.execute(input);
            let duration = start.elapsed();

            assert!(result.is_ok());
            assert!(duration.as_millis() < 1000); // åº”è¯¥åœ¨1så†…å®Œæˆ
        }
    }
}

// 2. é›†æˆæµ‹è¯•æœ€ä½³å®è·µ
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[test]
    fn test_algorithm_pipeline() {
        let input = vec![64, 34, 25, 12, 22, 11, 90];

        // æ’åº
        let sorter = QuickSort;
        let sorted = sorter.execute(input).unwrap();

        // æœç´¢
        let searcher = BinarySearch;
        let found = searcher.execute((sorted.clone(), 25)).unwrap();

        assert!(found);
    }

    #[test]
    fn test_parallel_algorithm_pipeline() {
        let input = vec![64, 34, 25, 12, 22, 11, 90];

        // å¹¶è¡Œæ’åº
        let parallel_sorter = ParallelQuickSort;
        let sorted = parallel_sorter.execute_parallel(input, 4).unwrap();

        // éªŒè¯ç»“æœ
        for i in 1..sorted.len() {
            assert!(sorted[i-1] <= sorted[i]);
        }
    }
}

// 3. å±æ€§æµ‹è¯•æœ€ä½³å®è·µ
#[cfg(test)]
mod property_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn test_quicksort_properties(input in prop::collection::vec(prop::num::i32::ANY, 0..1000)) {
            let sorter = QuickSort;
            let result = sorter.execute(input.clone());

            if result.is_ok() {
                let sorted = result.unwrap();

                // å±æ€§1: ç»“æœé•¿åº¦ä¸è¾“å…¥ç›¸åŒ
                prop_assert_eq!(sorted.len(), input.len());

                // å±æ€§2: ç»“æœæ˜¯æœ‰åºçš„
                for i in 1..sorted.len() {
                    prop_assert!(sorted[i-1] <= sorted[i]);
                }

                // å±æ€§3: ç»“æœåŒ…å«æ‰€æœ‰è¾“å…¥å…ƒç´ 
                let mut input_sorted = input.clone();
                input_sorted.sort();
                prop_assert_eq!(sorted, input_sorted);
            }
        }
    }
}

// 4. åŸºå‡†æµ‹è¯•æœ€ä½³å®è·µ
#[cfg(test)]
mod benchmark_tests {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn benchmark_quicksort(c: &mut Criterion) {
        let mut group = c.benchmark_group("quicksort");

        for size in [100, 1000, 10000].iter() {
            group.bench_with_input(
                criterion::BenchmarkId::new("quicksort", size),
                size,
                |b, &size| {
                    let input = (1..=size).collect::<Vec<i32>>();
                    b.iter(|| {
                        let sorter = QuickSort;
                        black_box(sorter.execute(black_box(input.clone())))
                    })
                },
            );
        }

        group.finish();
    }

    criterion_group!(benches, benchmark_quicksort);
    criterion_main!(benches);
}
```

## å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 1. æ€§èƒ½é—®é¢˜

**é—®é¢˜ï¼š** ç®—æ³•æ‰§è¡Œæ—¶é—´è¿‡é•¿
**è§£å†³æ–¹æ¡ˆï¼š**

```rust
// ä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·
use std::time::Instant;

pub fn profile_algorithm<F, T>(algorithm: F, input: T) -> Result<(), AlgorithmError>
where
    F: Fn(T) -> Result<(), AlgorithmError>,
{
    let start = Instant::now();
    let result = algorithm(input);
    let duration = start.elapsed();

    println!("ç®—æ³•æ‰§è¡Œæ—¶é—´: {:?}", duration);
    result
}

// ä¼˜åŒ–å»ºè®®
pub fn optimize_algorithm(input: Vec<i32>) -> Result<Vec<i32>, AlgorithmError> {
    // 1. é¢„åˆ†é…å®¹é‡
    let mut result = Vec::with_capacity(input.len());

    // 2. ä½¿ç”¨æ›´é«˜æ•ˆçš„ç®—æ³•
    if input.len() < 50 {
        // å°æ•°æ®é›†ä½¿ç”¨æ’å…¥æ’åº
        insertion_sort(input)
    } else {
        // å¤§æ•°æ®é›†ä½¿ç”¨å¿«é€Ÿæ’åº
        quicksort(input)
    }
}
```

### 2. å†…å­˜é—®é¢˜

**é—®é¢˜ï¼š** å†…å­˜ä½¿ç”¨è¿‡å¤š
**è§£å†³æ–¹æ¡ˆï¼š**

```rust
// å†…å­˜ä¼˜åŒ–ç­–ç•¥
pub fn memory_efficient_sort(mut input: Vec<i32>) -> Result<Vec<i32>, AlgorithmError> {
    // 1. åŸåœ°æ’åºï¼Œé¿å…é¢å¤–å†…å­˜åˆ†é…
    input.sort();
    Ok(input)
}

// 2. ä½¿ç”¨è¿­ä»£å™¨é¿å…ä¸­é—´åˆ†é…
pub fn iterator_based_processing(input: Vec<i32>) -> Result<Vec<i32>, AlgorithmError> {
    let result: Vec<i32> = input
        .into_iter()
        .filter(|&x| x > 0)
        .map(|x| x * 2)
        .collect();
    Ok(result)
}
```

### 3. é”™è¯¯å¤„ç†é—®é¢˜

**é—®é¢˜ï¼š** é”™è¯¯å¤„ç†ä¸å®Œå–„
**è§£å†³æ–¹æ¡ˆï¼š**

```rust
// å®Œå–„çš„é”™è¯¯å¤„ç†
pub fn robust_algorithm(input: Vec<i32>) -> Result<Vec<i32>, AlgorithmError> {
    // 1. è¾“å…¥éªŒè¯
    if input.is_empty() {
        return Err(AlgorithmError::InvalidInput("Empty input".to_string()));
    }

    if input.len() > 1_000_000 {
        return Err(AlgorithmError::InvalidInput("Input too large".to_string()));
    }

    // 2. è¾¹ç•Œæ£€æŸ¥
    for &value in &input {
        if value < i32::MIN || value > i32::MAX {
            return Err(AlgorithmError::InvalidInput("Value out of range".to_string()));
        }
    }

    // 3. æ‰§è¡Œç®—æ³•
    match quicksort(input) {
        Ok(result) => Ok(result),
        Err(e) => Err(AlgorithmError::ComputationError(e.to_string())),
    }
}
```

## é¡¹ç›®éƒ¨ç½²æŒ‡å—

### 1. å¼€å‘ç¯å¢ƒé…ç½®

```bash
# 1. å®‰è£…Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 2. é…ç½®å¼€å‘ç¯å¢ƒ
rustup default stable
rustup component add rustfmt
rustup component add clippy

# 3. å®‰è£…å¼€å‘å·¥å…·
cargo install cargo-watch
cargo install cargo-expand
cargo install cargo-audit
```

### 2. é¡¹ç›®ç»“æ„é…ç½®

```toml
# Cargo.toml
[package]
name = "formal-algorithm-project"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
log = "0.4"
env_logger = "0.9"

[dev-dependencies]
criterion = "0.4"
proptest = "1.0"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
```

### 3. æŒç»­é›†æˆé…ç½®

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        components: rustfmt, clippy

    - name: Run tests
      run: cargo test

    - name: Run clippy
      run: cargo clippy -- -D warnings

    - name: Run fmt
      run: cargo fmt -- --check
```

## æ€»ç»“

æœ¬å®è·µæŒ‡å¯¼æ‰‹å†Œæä¾›äº†ä»åŸºç¡€åˆ°é«˜çº§çš„å®Œæ•´å®è·µæŒ‡å¯¼ï¼ŒåŒ…æ‹¬é¡¹ç›®æ¨¡æ¿ã€æœ€ä½³å®è·µã€å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆå’Œéƒ¨ç½²æŒ‡å—ã€‚é€šè¿‡éµå¾ªè¿™äº›æŒ‡å¯¼ï¼Œå­¦ä¹ è€…èƒ½å¤Ÿï¼š

1. **å»ºç«‹æ­£ç¡®çš„é¡¹ç›®ç»“æ„**ï¼šæ¨¡å—åŒ–ç»„ç»‡ï¼Œæ¸…æ™°çš„ä¾èµ–å…³ç³»
2. **å®ç°é«˜è´¨é‡çš„ä»£ç **ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†ï¼Œå…¨é¢çš„æµ‹è¯•è¦†ç›–
3. **ä¼˜åŒ–ç®—æ³•æ€§èƒ½**ï¼šæ€§èƒ½ç›‘æ§ï¼Œå†…å­˜ä¼˜åŒ–ï¼Œå¹¶è¡Œå¤„ç†
4. **éƒ¨ç½²å’Œç»´æŠ¤é¡¹ç›®**ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•ï¼ŒæŒç»­é›†æˆï¼Œç”Ÿäº§éƒ¨ç½²

é€šè¿‡ç³»ç»Ÿæ€§çš„å®è·µæŒ‡å¯¼ï¼Œå­¦ä¹ è€…èƒ½å¤Ÿå°†ç†è®ºçŸ¥è¯†è½¬åŒ–ä¸ºå®é™…èƒ½åŠ›ï¼Œæˆä¸ºå½¢å¼åŒ–ç®—æ³•é¢†åŸŸçš„å®è·µä¸“å®¶ã€‚
