---
title: 2.3 ä¸€èˆ¬é€’å½’å‡½æ•° / General Recursive Functions
version: 1.1
status: maintained
last_updated: 2025-01-11
owner: é€’å½’ç†è®ºå·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 2.3 ä¸€èˆ¬é€’å½’å‡½æ•° / General Recursive Functions

### æ‘˜è¦ / Executive Summary

- å»ºç«‹ä¸€èˆ¬é€’å½’å‡½æ•°çš„å½¢å¼åŒ–å®šä¹‰ã€Î¼-é€’å½’ä¸éƒ¨åˆ†é€’å½’å‡½æ•°ã€‚
- å»ºç«‹ä¸€èˆ¬é€’å½’å‡½æ•°åœ¨é€’å½’ç†è®ºä¸­çš„æ ¸å¿ƒåœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- ä¸€èˆ¬é€’å½’å‡½æ•°ã€Î¼-é€’å½’å‡½æ•°ã€éƒ¨åˆ†é€’å½’å‡½æ•°ã€é€’å½’å¯æšä¸¾æ€§ã€é€’å½’ä¸å¯è§£æ€§ã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- ä¸€èˆ¬é€’å½’å‡½æ•°ï¼ˆGeneral Recursive Functionï¼‰ï¼šåŒ…å«æ‰€æœ‰å¯è®¡ç®—å‡½æ•°çš„å‡½æ•°ç±»ã€‚
- Î¼-é€’å½’å‡½æ•°ï¼ˆÎ¼-Recursive Functionï¼‰ï¼šä½¿ç”¨Î¼ç®—å­æ„é€ çš„é€’å½’å‡½æ•°ã€‚
- éƒ¨åˆ†é€’å½’å‡½æ•°ï¼ˆPartial Recursive Functionï¼‰ï¼šå¯èƒ½åœ¨æŸäº›è¾“å…¥ä¸Šæœªå®šä¹‰çš„é€’å½’å‡½æ•°ã€‚
- è®°å·çº¦å®šï¼š`GR` è¡¨ç¤ºä¸€èˆ¬é€’å½’å‡½æ•°ç±»ï¼Œ`Î¼` è¡¨ç¤ºÎ¼ç®—å­ï¼Œ`f` è¡¨ç¤ºå‡½æ•°ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- é€’å½’å‡½æ•°å®šä¹‰ï¼šå‚è§ `02-é€’å½’ç†è®º/01-é€’å½’å‡½æ•°å®šä¹‰.md`ã€‚
- åŸå§‹é€’å½’å‡½æ•°ï¼šå‚è§ `02-é€’å½’ç†è®º/02-åŸå§‹é€’å½’å‡½æ•°.md`ã€‚
- é€’å½’å¯æšä¸¾æ€§ï¼šå‚è§ `02-é€’å½’ç†è®º/04-é€’å½’å¯æšä¸¾æ€§.md`ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- Î¼-é€’å½’å‡½æ•°
- éƒ¨åˆ†é€’å½’å‡½æ•°

## ç›®å½• (Table of Contents)

- [2.3 ä¸€èˆ¬é€’å½’å‡½æ•° / General Recursive Functions](#23-ä¸€èˆ¬é€’å½’å‡½æ•°--general-recursive-functions)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#1-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [1.1 ä¸€èˆ¬é€’å½’å‡½æ•°å®šä¹‰ (Definition of General Recursive Functions)](#11-ä¸€èˆ¬é€’å½’å‡½æ•°å®šä¹‰-definition-of-general-recursive-functions)
  - [1.2 å‡½æ•°ç±»å±‚æ¬¡ (Function Class Hierarchy)](#12-å‡½æ•°ç±»å±‚æ¬¡-function-class-hierarchy)
- [2. Î¼-é€’å½’å‡½æ•° (Î¼-Recursive Functions)](#2-Î¼-é€’å½’å‡½æ•°-Î¼-recursive-functions)
  - [2.1 Î¼-ç®—å­å®šä¹‰ (Definition of Î¼-Operator)](#21-Î¼-ç®—å­å®šä¹‰-definition-of-Î¼-operator)
  - [2.2 Î¼-é€’å½’å‡½æ•°æ„é€  (Construction of Î¼-Recursive Functions)](#22-Î¼-é€’å½’å‡½æ•°æ„é€ -construction-of-Î¼-recursive-functions)
  - [2.3 Î¼-é€’å½’å‡½æ•°çš„ä¾‹å­ (Examples of Î¼-Recursive Functions)](#23-Î¼-é€’å½’å‡½æ•°çš„ä¾‹å­-examples-of-Î¼-recursive-functions)
- [3. éƒ¨åˆ†é€’å½’å‡½æ•° (Partial Recursive Functions)](#3-éƒ¨åˆ†é€’å½’å‡½æ•°-partial-recursive-functions)
  - [3.1 éƒ¨åˆ†å‡½æ•°å®šä¹‰ (Definition of Partial Functions)](#31-éƒ¨åˆ†å‡½æ•°å®šä¹‰-definition-of-partial-functions)
  - [3.2 éƒ¨åˆ†é€’å½’å‡½æ•°æ„é€  (Construction of Partial Recursive Functions)](#32-éƒ¨åˆ†é€’å½’å‡½æ•°æ„é€ -construction-of-partial-recursive-functions)
  - [3.3 éƒ¨åˆ†é€’å½’å‡½æ•°çš„ä¾‹å­ (Examples of Partial Recursive Functions)](#33-éƒ¨åˆ†é€’å½’å‡½æ•°çš„ä¾‹å­-examples-of-partial-recursive-functions)
- [4. é€’å½’å¯æšä¸¾æ€§ (Recursive Enumerability)](#4-é€’å½’å¯æšä¸¾æ€§-recursive-enumerability)
  - [4.1 é€’å½’å¯æšä¸¾é›†å®šä¹‰ (Definition of Recursively Enumerable Sets)](#41-é€’å½’å¯æšä¸¾é›†å®šä¹‰-definition-of-recursively-enumerable-sets)
  - [4.2 é€’å½’å¯æšä¸¾é›†çš„æ€§è´¨ (Properties of Recursively Enumerable Sets)](#42-é€’å½’å¯æšä¸¾é›†çš„æ€§è´¨-properties-of-recursively-enumerable-sets)
  - [4.3 é€’å½’å¯æšä¸¾é›†çš„ä¾‹å­ (Examples of Recursively Enumerable Sets)](#43-é€’å½’å¯æšä¸¾é›†çš„ä¾‹å­-examples-of-recursively-enumerable-sets)
- [5. é€’å½’ä¸å¯è§£æ€§ (Recursive Unsolvability)](#5-é€’å½’ä¸å¯è§£æ€§-recursive-unsolvability)
  - [5.1 é€’å½’ä¸å¯è§£é—®é¢˜å®šä¹‰ (Definition of Recursively Unsolvable Problems)](#51-é€’å½’ä¸å¯è§£é—®é¢˜å®šä¹‰-definition-of-recursively-unsolvable-problems)
  - [5.2 åœæœºé—®é¢˜ (Halting Problem)](#52-åœæœºé—®é¢˜-halting-problem)
  - [5.3 å…¶ä»–ä¸å¯è§£é—®é¢˜ (Other Unsolvable Problems)](#53-å…¶ä»–ä¸å¯è§£é—®é¢˜-other-unsolvable-problems)
- [6. ä¸€èˆ¬é€’å½’å‡½æ•°çš„æ€§è´¨ (Properties of General Recursive Functions)](#6-ä¸€èˆ¬é€’å½’å‡½æ•°çš„æ€§è´¨-properties-of-general-recursive-functions)
  - [6.1 å¯è®¡ç®—æ€§ (Computability)](#61-å¯è®¡ç®—æ€§-computability)
  - [6.2 å›¾çµç­‰ä»·æ€§ (Turing Equivalence)](#62-å›¾çµç­‰ä»·æ€§-turing-equivalence)
  - [6.3 éƒ¨åˆ†æ€§ (Partiality)](#63-éƒ¨åˆ†æ€§-partiality)
  - [6.4 è¡¨è¾¾èƒ½åŠ› (Expressive Power)](#64-è¡¨è¾¾èƒ½åŠ›-expressive-power)
- [7. å®ç°ç¤ºä¾‹ (Implementation Examples)](#7-å®ç°ç¤ºä¾‹-implementation-examples)
  - [7.1 Î¼-ç®—å­å®ç° (Î¼-Operator Implementation)](#71-Î¼-ç®—å­å®ç°-Î¼-operator-implementation)
  - [7.2 ä¸€èˆ¬é€’å½’å‡½æ•°å®ç° (General Recursive Function Implementation)](#72-ä¸€èˆ¬é€’å½’å‡½æ•°å®ç°-general-recursive-function-implementation)
  - [7.3 é˜¿å…‹æ›¼å‡½æ•°å®ç° (Ackermann Function Implementation)](#73-é˜¿å…‹æ›¼å‡½æ•°å®ç°-ackermann-function-implementation)
  - [7.4 éƒ¨åˆ†é€’å½’å‡½æ•°å®ç° (Partial Recursive Function Implementation)](#74-éƒ¨åˆ†é€’å½’å‡½æ•°å®ç°-partial-recursive-function-implementation)
  - [7.5 é€’å½’å¯æšä¸¾é›†å®ç° (Recursively Enumerable Set Implementation)](#75-é€’å½’å¯æšä¸¾é›†å®ç°-recursively-enumerable-set-implementation)
  - [7.6 åœæœºé—®é¢˜æ¨¡æ‹Ÿ (Halting Problem Simulation)](#76-åœæœºé—®é¢˜æ¨¡æ‹Ÿ-halting-problem-simulation)
  - [7.7 ä¸€èˆ¬é€’å½’å‡½æ•°éªŒè¯å™¨ (General Recursive Function Validator)](#77-ä¸€èˆ¬é€’å½’å‡½æ•°éªŒè¯å™¨-general-recursive-function-validator)
- [8. å‚è€ƒæ–‡çŒ® (References)](#8-å‚è€ƒæ–‡çŒ®-references)

---

## 1. åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 1.1 ä¸€èˆ¬é€’å½’å‡½æ•°å®šä¹‰ (Definition of General Recursive Functions)

**å®šä¹‰ 1.1.1** (ä¸€èˆ¬é€’å½’å‡½æ•° / General Recursive Function)
ä¸€èˆ¬é€’å½’å‡½æ•°æ˜¯é€šè¿‡åŸºæœ¬å‡½æ•°ã€å¤åˆã€åŸå§‹é€’å½’å’ŒÎ¼-ç®—å­æ„é€ çš„å‡½æ•°ç±»ã€‚

**Definition 1.1.1** (General Recursive Function)
General recursive functions are a class of functions constructed from basic functions, composition, primitive recursion, and the Î¼-operator.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
ä¸€èˆ¬é€’å½’å‡½æ•°é›†åˆ $\mathcal{GR}$ æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æœ€å°å‡½æ•°ç±»ï¼š

1. åŒ…å«æ‰€æœ‰åŸå§‹é€’å½’å‡½æ•°
2. åœ¨Î¼-ç®—å­ä¸‹å°é—­

**Formal Representation:**
The set of general recursive functions $\mathcal{GR}$ is the smallest class of functions satisfying:

1. Contains all primitive recursive functions
2. Closed under the Î¼-operator

### 1.2 å‡½æ•°ç±»å±‚æ¬¡ (Function Class Hierarchy)

**å®šä¹‰ 1.2.1** (é€’å½’å‡½æ•°å±‚æ¬¡ / Recursive Function Hierarchy)
$$\mathcal{PR} \subset \mathcal{GR} \subset \mathcal{TR} = \mathcal{PC}$$

å…¶ä¸­ï¼š

- $\mathcal{PR}$ æ˜¯åŸå§‹é€’å½’å‡½æ•°ç±»
- $\mathcal{GR}$ æ˜¯ä¸€èˆ¬é€’å½’å‡½æ•°ç±»
- $\mathcal{TR}$ æ˜¯å›¾çµå¯è®¡ç®—å‡½æ•°ç±»
- $\mathcal{PC}$ æ˜¯éƒ¨åˆ†å¯è®¡ç®—å‡½æ•°ç±»

**Definition 1.2.1** (Recursive Function Hierarchy)
$$\mathcal{PR} \subset \mathcal{GR} \subset \mathcal{TR} = \mathcal{PC}$$

where:

- $\mathcal{PR}$ is the class of primitive recursive functions
- $\mathcal{GR}$ is the class of general recursive functions
- $\mathcal{TR}$ is the class of Turing computable functions
- $\mathcal{PC}$ is the class of partial computable functions

---

## 2. Î¼-é€’å½’å‡½æ•° (Î¼-Recursive Functions)

### 2.1 Î¼-ç®—å­å®šä¹‰ (Definition of Î¼-Operator)

**å®šä¹‰ 2.1.1** (Î¼-ç®—å­ / Î¼-Operator)
å¯¹äºå‡½æ•° $f: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$ï¼ŒÎ¼-ç®—å­å®šä¹‰ä¸ºï¼š

**Definition 2.1.1** (Î¼-Operator)
For function $f: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$, the Î¼-operator is defined by:

$$
\mu y[f(x_1, x_2, \ldots, x_n, y) = 0] = \begin{cases}
\text{æœ€å°çš„ } y \text{ ä½¿å¾— } f(x_1, x_2, \ldots, x_n, y) = 0, & \text{å¦‚æœå­˜åœ¨} \\
\text{æœªå®šä¹‰}, & \text{å¦‚æœä¸å­˜åœ¨}
\end{cases}
$$

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$\mu y[f(x_1, x_2, \ldots, x_n, y) = 0] = \min\{y \mid f(x_1, x_2, \ldots, x_n, y) = 0\}$$

### 2.2 Î¼-é€’å½’å‡½æ•°æ„é€  (Construction of Î¼-Recursive Functions)

**å®šä¹‰ 2.2.1** (Î¼-é€’å½’å‡½æ•° / Î¼-Recursive Function)
Î¼-é€’å½’å‡½æ•°æ˜¯é€šè¿‡ä»¥ä¸‹æ–¹å¼æ„é€ çš„å‡½æ•°ï¼š

**Definition 2.2.1** (Î¼-Recursive Function)
Î¼-recursive functions are functions constructed by:

1. **åŸºæœ¬å‡½æ•° (Basic Functions)**: é›¶å‡½æ•°ã€åç»§å‡½æ•°ã€æŠ•å½±å‡½æ•°
2. **å¤åˆ (Composition)**: å¦‚æœ $f$ å’Œ $g_1, g_2, \ldots, g_m$ éƒ½æ˜¯Î¼-é€’å½’å‡½æ•°ï¼Œåˆ™å®ƒä»¬çš„å¤åˆä¹Ÿæ˜¯Î¼-é€’å½’å‡½æ•°
3. **åŸå§‹é€’å½’ (Primitive Recursion)**: å¦‚æœ $g$ å’Œ $h$ éƒ½æ˜¯Î¼-é€’å½’å‡½æ•°ï¼Œåˆ™é€šè¿‡åŸå§‹é€’å½’å®šä¹‰çš„å‡½æ•°ä¹Ÿæ˜¯Î¼-é€’å½’å‡½æ•°
4. **Î¼-ç®—å­ (Î¼-Operator)**: å¦‚æœ $f$ æ˜¯Î¼-é€’å½’å‡½æ•°ï¼Œåˆ™é€šè¿‡Î¼-ç®—å­å®šä¹‰çš„å‡½æ•°ä¹Ÿæ˜¯Î¼-é€’å½’å‡½æ•°

   1. **Basic Functions**: Zero function, successor function, projection functions
   2. **Composition**: If $f$ and $g_1, g_2, \ldots, g_m$ are all Î¼-recursive functions, then their composition is also Î¼-recursive
   3. **Primitive Recursion**: If $g$ and $h$ are both Î¼-recursive functions, then the function defined by primitive recursion is also Î¼-recursive
   4. **Î¼-Operator**: If $f$ is a Î¼-recursive function, then the function defined by the Î¼-operator is also Î¼-recursive

### 2.3 Î¼-é€’å½’å‡½æ•°çš„ä¾‹å­ (Examples of Î¼-Recursive Functions)

**ç¤ºä¾‹ 2.3.1** (é˜¿å…‹æ›¼å‡½æ•° / Ackermann Function)
é˜¿å…‹æ›¼å‡½æ•°æ˜¯Î¼-é€’å½’å‡½æ•°ï¼š

**Example 2.3.1** (Ackermann Function)
The Ackermann function is Î¼-recursive:

$$A(0, n) = n + 1$$
$$A(m + 1, 0) = A(m, 1)$$
$$A(m + 1, n + 1) = A(m, A(m + 1, n))$$

**ç¤ºä¾‹ 2.3.2** (é˜¿å…‹æ›¼å‡½æ•°çš„é€†å‡½æ•° / Inverse of Ackermann Function)
é˜¿å…‹æ›¼å‡½æ•°çš„é€†å‡½æ•°ä¹Ÿæ˜¯Î¼-é€’å½’å‡½æ•°ï¼š

**Example 2.3.2** (Inverse of Ackermann Function)
The inverse of the Ackermann function is also Î¼-recursive:

$$A^{-1}(n) = \mu m[A(m, m) \geq n]$$

---

## 3. éƒ¨åˆ†é€’å½’å‡½æ•° (Partial Recursive Functions)

### 3.1 éƒ¨åˆ†å‡½æ•°å®šä¹‰ (Definition of Partial Functions)

**å®šä¹‰ 3.1.1** (éƒ¨åˆ†å‡½æ•° / Partial Function)
éƒ¨åˆ†å‡½æ•°æ˜¯ä» $\mathbb{N}^n$ åˆ° $\mathbb{N}$ çš„æ˜ å°„ï¼Œå¯èƒ½åœ¨æŸäº›è¾“å…¥ä¸Šæœªå®šä¹‰ã€‚

**Definition 3.1.1** (Partial Function)
A partial function is a mapping from $\mathbb{N}^n$ to $\mathbb{N}$ that may be undefined on some inputs.

**å½¢å¼åŒ–è¡¨ç¤º (Formal Representation):**
$$f: \mathbb{N}^n \rightharpoonup \mathbb{N}$$

**å®šä¹‰ 3.1.2** (å…¨å‡½æ•° / Total Function)
å…¨å‡½æ•°æ˜¯åœ¨æ‰€æœ‰è¾“å…¥ä¸Šéƒ½æœ‰å®šä¹‰çš„å‡½æ•°ã€‚

**Definition 3.1.2** (Total Function)
A total function is a function that is defined on all inputs.

### 3.2 éƒ¨åˆ†é€’å½’å‡½æ•°æ„é€  (Construction of Partial Recursive Functions)

**å®šä¹‰ 3.2.1** (éƒ¨åˆ†é€’å½’å‡½æ•° / Partial Recursive Function)
éƒ¨åˆ†é€’å½’å‡½æ•°æ˜¯é€šè¿‡åŸºæœ¬å‡½æ•°ã€å¤åˆã€åŸå§‹é€’å½’å’ŒÎ¼-ç®—å­æ„é€ çš„éƒ¨åˆ†å‡½æ•°ã€‚

**Definition 3.2.1** (Partial Recursive Function)
Partial recursive functions are partial functions constructed from basic functions, composition, primitive recursion, and the Î¼-operator.

**å®šç† 3.2.1** (éƒ¨åˆ†é€’å½’å‡½æ•°ç­‰ä»·æ€§ / Partial Recursive Function Equivalence)
éƒ¨åˆ†é€’å½’å‡½æ•°ç±»ç­‰ä»·äºå›¾çµå¯è®¡ç®—å‡½æ•°ç±»ã€‚

**Theorem 3.2.1** (Partial Recursive Function Equivalence)
The class of partial recursive functions is equivalent to the class of Turing computable functions.

### 3.3 éƒ¨åˆ†é€’å½’å‡½æ•°çš„ä¾‹å­ (Examples of Partial Recursive Functions)

**ç¤ºä¾‹ 3.3.1** (é˜¿å…‹æ›¼å‡½æ•° / Ackermann Function)
é˜¿å…‹æ›¼å‡½æ•°æ˜¯éƒ¨åˆ†é€’å½’å‡½æ•°ï¼ˆå®é™…ä¸Šæ˜¯å…¨å‡½æ•°ï¼‰ã€‚

**Example 3.3.1** (Ackermann Function)
The Ackermann function is a partial recursive function (actually total).

**ç¤ºä¾‹ 3.3.2** (é˜¿å…‹æ›¼å‡½æ•°çš„é€†å‡½æ•° / Inverse of Ackermann Function)
é˜¿å…‹æ›¼å‡½æ•°çš„é€†å‡½æ•°æ˜¯éƒ¨åˆ†é€’å½’å‡½æ•°ï¼š

**Example 3.3.2** (Inverse of Ackermann Function)
The inverse of the Ackermann function is a partial recursive function:

$$A^{-1}(n) = \mu m[A(m, m) \geq n]$$

è¿™ä¸ªå‡½æ•°åœ¨æŸäº›è¾“å…¥ä¸Šå¯èƒ½æœªå®šä¹‰ã€‚

This function may be undefined on some inputs.

---

## 4. é€’å½’å¯æšä¸¾æ€§ (Recursive Enumerability)

### 4.1 é€’å½’å¯æšä¸¾é›†å®šä¹‰ (Definition of Recursively Enumerable Sets)

**å®šä¹‰ 4.1.1** (é€’å½’å¯æšä¸¾é›† / Recursively Enumerable Set)
é›†åˆ $A \subseteq \mathbb{N}$ æ˜¯é€’å½’å¯æšä¸¾çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨éƒ¨åˆ†é€’å½’å‡½æ•° $f$ ä½¿å¾—ï¼š

**Definition 4.1.1** (Recursively Enumerable Set)
Set $A \subseteq \mathbb{N}$ is recursively enumerable if and only if there exists a partial recursive function $f$ such that:

$$A = \{f(n) \mid n \in \mathbb{N} \text{ and } f(n) \text{ is defined}\}$$

**ç­‰ä»·å®šä¹‰ (Equivalent Definition):**
é›†åˆ $A$ æ˜¯é€’å½’å¯æšä¸¾çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨å›¾çµæœº $M$ ä½¿å¾— $A$ æ˜¯ $M$ æ¥å—çš„è¯­è¨€ã€‚

**Equivalent Definition:**
Set $A$ is recursively enumerable if and only if there exists a Turing machine $M$ such that $A$ is the language accepted by $M$.

### 4.2 é€’å½’å¯æšä¸¾é›†çš„æ€§è´¨ (Properties of Recursively Enumerable Sets)

**å®šç† 4.2.1** (é€’å½’å¯æšä¸¾é›†çš„æ€§è´¨ / Properties of Recursively Enumerable Sets)

1. é€’å½’é›†æ˜¯é€’å½’å¯æšä¸¾çš„
2. é€’å½’å¯æšä¸¾é›†çš„è¡¥é›†ä¸ä¸€å®šæ˜¯é€’å½’å¯æšä¸¾çš„
3. é€’å½’å¯æšä¸¾é›†åœ¨å¹¶é›†å’Œäº¤é›†ä¸‹å°é—­

**Theorem 4.2.1** (Properties of Recursively Enumerable Sets)

1. Recursive sets are recursively enumerable
2. The complement of a recursively enumerable set is not necessarily recursively enumerable
3. Recursively enumerable sets are closed under union and intersection

### 4.3 é€’å½’å¯æšä¸¾é›†çš„ä¾‹å­ (Examples of Recursively Enumerable Sets)

**ç¤ºä¾‹ 4.3.1** (é˜¿å…‹æ›¼å‡½æ•°çš„å€¼åŸŸ / Range of Ackermann Function)
é˜¿å…‹æ›¼å‡½æ•°çš„å€¼åŸŸæ˜¯é€’å½’å¯æšä¸¾é›†ï¼š

**Example 4.3.1** (Range of Ackermann Function)
The range of the Ackermann function is a recursively enumerable set:

$$R_A = \{A(m, n) \mid m, n \in \mathbb{N}\}$$

**ç¤ºä¾‹ 4.3.2** (åœæœºé—®é¢˜ / Halting Problem)
åœæœºé—®é¢˜æ˜¯é€’å½’å¯æšä¸¾çš„ï¼š

**Example 4.3.2** (Halting Problem)
The halting problem is recursively enumerable:

$$H = \{(M, x) \mid M \text{ halts on input } x\}$$

---

## 5. é€’å½’ä¸å¯è§£æ€§ (Recursive Unsolvability)

### 5.1 é€’å½’ä¸å¯è§£é—®é¢˜å®šä¹‰ (Definition of Recursively Unsolvable Problems)

**å®šä¹‰ 5.1.1** (é€’å½’ä¸å¯è§£é—®é¢˜ / Recursively Unsolvable Problem)
é—®é¢˜æ˜¯é€’å½’ä¸å¯è§£çš„ï¼Œå½“ä¸”ä»…å½“ä¸å­˜åœ¨é€’å½’å‡½æ•°æ¥è§£å†³å®ƒã€‚

**Definition 5.1.1** (Recursively Unsolvable Problem)
A problem is recursively unsolvable if and only if there does not exist a recursive function to solve it.

**ç­‰ä»·å®šä¹‰ (Equivalent Definition):**
é—®é¢˜æ˜¯é€’å½’ä¸å¯è§£çš„ï¼Œå½“ä¸”ä»…å½“ä¸å­˜åœ¨å›¾çµæœºæ¥è§£å†³å®ƒã€‚

**Equivalent Definition:**
A problem is recursively unsolvable if and only if there does not exist a Turing machine to solve it.

### 5.2 åœæœºé—®é¢˜ (Halting Problem)

**å®šç† 5.2.1** (åœæœºé—®é¢˜ä¸å¯è§£æ€§ / Halting Problem Unsolvability)
åœæœºé—®é¢˜æ˜¯é€’å½’ä¸å¯è§£çš„ã€‚

**Theorem 5.2.1** (Halting Problem Unsolvability)
The halting problem is recursively unsolvable.

**è¯æ˜ (Proof):**
å‡è®¾å­˜åœ¨é€’å½’å‡½æ•° $h$ æ¥è§£å†³åœæœºé—®é¢˜ã€‚æ„é€ å›¾çµæœº $M$ï¼š

1. å¦‚æœ $h(M, M) = 1$ï¼Œåˆ™ $M$ è¿›å…¥æ— é™å¾ªç¯
2. å¦‚æœ $h(M, M) = 0$ï¼Œåˆ™ $M$ åœæœº

è¿™å¯¼è‡´çŸ›ç›¾ï¼Œå› æ­¤åœæœºé—®é¢˜æ˜¯ä¸å¯è§£çš„ã€‚

**Proof:**
Assume there exists a recursive function $h$ to solve the halting problem. Construct Turing machine $M$:

1. If $h(M, M) = 1$, then $M$ enters an infinite loop
2. If $h(M, M) = 0$, then $M$ halts

This leads to a contradiction, so the halting problem is unsolvable.

### 5.3 å…¶ä»–ä¸å¯è§£é—®é¢˜ (Other Unsolvable Problems)

**å®šç† 5.3.1** (ç­‰ä»·é—®é¢˜ä¸å¯è§£æ€§ / Equivalence Problem Unsolvability)
ä¸¤ä¸ªå›¾çµæœºæ˜¯å¦ç­‰ä»·çš„é—®é¢˜æ˜¯é€’å½’ä¸å¯è§£çš„ã€‚

**Theorem 5.3.1** (Equivalence Problem Unsolvability)
The problem of whether two Turing machines are equivalent is recursively unsolvable.

**å®šç† 5.3.2** (ç©ºæ€§é—®é¢˜ä¸å¯è§£æ€§ / Emptiness Problem Unsolvability)
å›¾çµæœºæ˜¯å¦æ¥å—ç©ºè¯­è¨€çš„é—®é¢˜æ˜¯é€’å½’ä¸å¯è§£çš„ã€‚

**Theorem 5.3.2** (Emptiness Problem Unsolvability)
The problem of whether a Turing machine accepts the empty language is recursively unsolvable.

---

## 6. ä¸€èˆ¬é€’å½’å‡½æ•°çš„æ€§è´¨ (Properties of General Recursive Functions)

### 6.1 å¯è®¡ç®—æ€§ (Computability)

**å®šç† 6.1.1** (ä¸€èˆ¬é€’å½’å‡½æ•°å¯è®¡ç®—æ€§ / Computability of General Recursive Functions)
æ‰€æœ‰ä¸€èˆ¬é€’å½’å‡½æ•°éƒ½æ˜¯å¯è®¡ç®—çš„ã€‚

**Theorem 6.1.1** (Computability of General Recursive Functions)
All general recursive functions are computable.

**è¯æ˜ (Proof):**

1. åŸå§‹é€’å½’å‡½æ•°éƒ½æ˜¯å¯è®¡ç®—çš„
2. Î¼-ç®—å­ä¿æŒå¯è®¡ç®—æ€§
3. å› æ­¤ä¸€èˆ¬é€’å½’å‡½æ•°éƒ½æ˜¯å¯è®¡ç®—çš„

### 6.2 å›¾çµç­‰ä»·æ€§ (Turing Equivalence)

**å®šç† 6.1.2** (å›¾çµç­‰ä»·æ€§ / Turing Equivalence)
ä¸€èˆ¬é€’å½’å‡½æ•°ç±»ç­‰ä»·äºå›¾çµå¯è®¡ç®—å‡½æ•°ç±»ã€‚

**Theorem 6.1.2** (Turing Equivalence)
The class of general recursive functions is equivalent to the class of Turing computable functions.

**è¯æ˜ (Proof):**

1. æ¯ä¸ªä¸€èˆ¬é€’å½’å‡½æ•°éƒ½å¯ä»¥ç”±å›¾çµæœºè®¡ç®—
2. æ¯ä¸ªå›¾çµå¯è®¡ç®—å‡½æ•°éƒ½æ˜¯ä¸€èˆ¬é€’å½’å‡½æ•°
3. å› æ­¤ä¸¤ä¸ªç±»ç­‰ä»·

### 6.3 éƒ¨åˆ†æ€§ (Partiality)

**å®šç† 6.3.1** (ä¸€èˆ¬é€’å½’å‡½æ•°çš„éƒ¨åˆ†æ€§ / Partiality of General Recursive Functions)
ä¸€èˆ¬é€’å½’å‡½æ•°å¯èƒ½æ˜¯éƒ¨åˆ†å‡½æ•°ã€‚

**Theorem 6.3.1** (Partiality of General Recursive Functions)
General recursive functions may be partial functions.

**ç¤ºä¾‹ (Example):**
é˜¿å…‹æ›¼å‡½æ•°çš„é€†å‡½æ•°æ˜¯éƒ¨åˆ†å‡½æ•°ï¼š

**Example:**
The inverse of the Ackermann function is a partial function:

$$A^{-1}(n) = \mu m[A(m, m) \geq n]$$

è¿™ä¸ªå‡½æ•°åœ¨æŸäº›è¾“å…¥ä¸Šæœªå®šä¹‰ã€‚

This function is undefined on some inputs.

### 6.4 è¡¨è¾¾èƒ½åŠ› (Expressive Power)

**å®šç† 6.4.1** (ä¸€èˆ¬é€’å½’å‡½æ•°è¡¨è¾¾èƒ½åŠ› / Expressive Power of General Recursive Functions)
ä¸€èˆ¬é€’å½’å‡½æ•°å¯ä»¥è¡¨è¾¾æ‰€æœ‰å¯è®¡ç®—çš„å‡½æ•°ã€‚

**Theorem 6.4.1** (Expressive Power of General Recursive Functions)
General recursive functions can express all computable functions.

**è¯æ˜ (Proof):**

1. ä¸€èˆ¬é€’å½’å‡½æ•°ç­‰ä»·äºå›¾çµå¯è®¡ç®—å‡½æ•°
2. å›¾çµå¯è®¡ç®—å‡½æ•°åŒ…æ‹¬æ‰€æœ‰å¯è®¡ç®—å‡½æ•°
3. å› æ­¤ä¸€èˆ¬é€’å½’å‡½æ•°å¯ä»¥è¡¨è¾¾æ‰€æœ‰å¯è®¡ç®—å‡½æ•°

---

## 7. å®ç°ç¤ºä¾‹ (Implementation Examples)

### 7.1 Î¼-ç®—å­å®ç° (Î¼-Operator Implementation)

```rust
pub trait MuOperator {
    fn mu_operator<F>(&self, f: F, args: &[u32]) -> Option<u32>
    where
        F: Fn(&[u32], u32) -> u32;
}

pub struct MuOperatorImpl;

impl MuOperator for MuOperatorImpl {
    fn mu_operator<F>(&self, f: F, args: &[u32]) -> Option<u32>
    where
        F: Fn(&[u32], u32) -> u32,
    {
        let mut y = 0;
        loop {
            let mut extended_args = args.to_vec();
            extended_args.push(y);

            if f(&extended_args, y) == 0 {
                return Some(y);
            }

            y += 1;

            // é˜²æ­¢æ— é™å¾ªç¯ï¼ˆå®é™…å®ç°ä¸­éœ€è¦æ›´å¤æ‚çš„ç»ˆæ­¢æ¡ä»¶ï¼‰
            if y > 1000 {
                return None;
            }
        }
    }
}
```

### 7.2 ä¸€èˆ¬é€’å½’å‡½æ•°å®ç° (General Recursive Function Implementation)

```rust
pub trait GeneralRecursive {
    fn apply(&self, args: &[u32]) -> Option<u32>;
}

pub struct BasicGeneralRecursiveFunctions;

impl GeneralRecursive for BasicGeneralRecursiveFunctions {
    fn apply(&self, args: &[u32]) -> Option<u32> {
        if args.is_empty() {
            return None;
        }

        match args[0] {
            0 => Some(0), // é›¶å‡½æ•°
            1 => Some(args[1] + 1), // åç»§å‡½æ•°
            2 => { // æŠ•å½±å‡½æ•°
                if args.len() > 2 {
                    Some(args[2])
                } else {
                    None
                }
            }
            _ => None,
        }
    }
}

pub struct Composition<F, G> {
    f: F,
    g: G,
}

impl<F, G> GeneralRecursive for Composition<F, G>
where
    F: GeneralRecursive,
    G: GeneralRecursive,
{
    fn apply(&self, args: &[u32]) -> Option<u32> {
        let intermediate = self.g.apply(args)?;
        self.f.apply(&[intermediate])
    }
}

pub struct PrimitiveRecursion<G, H> {
    g: G,
    h: H,
}

impl<G, H> GeneralRecursive for PrimitiveRecursion<G, H>
where
    G: GeneralRecursive,
    H: GeneralRecursive,
{
    fn apply(&self, args: &[u32]) -> Option<u32> {
        if args.is_empty() {
            return None;
        }

        let y = args[0];
        let rest_args = &args[1..];

        if y == 0 {
            self.g.apply(rest_args)
        } else {
            let recursive_result = self.apply(&[y - 1])?;
            let mut h_args = vec![y - 1, recursive_result];
            h_args.extend_from_slice(rest_args);
            self.h.apply(&h_args)
        }
    }
}

pub struct MuRecursion<F> {
    f: F,
}

impl<F> GeneralRecursive for MuRecursion<F>
where
    F: Fn(&[u32], u32) -> u32,
{
    fn apply(&self, args: &[u32]) -> Option<u32> {
        let mu_op = MuOperatorImpl;
        mu_op.mu_operator(&self.f, args)
    }
}
```

### 7.3 é˜¿å…‹æ›¼å‡½æ•°å®ç° (Ackermann Function Implementation)

```rust
pub struct AckermannFunction;

impl GeneralRecursive for AckermannFunction {
    fn apply(&self, args: &[u32]) -> Option<u32> {
        if args.len() != 2 {
            return None;
        }

        let m = args[0];
        let n = args[1];

        self.ackermann(m, n)
    }

    fn ackermann(&self, m: u32, n: u32) -> Option<u32> {
        match (m, n) {
            (0, n) => Some(n + 1),
            (m, 0) => self.ackermann(m - 1, 1),
            (m, n) => {
                let intermediate = self.ackermann(m, n - 1)?;
                self.ackermann(m - 1, intermediate)
            }
        }
    }
}

impl AckermannFunction {
    // é˜¿å…‹æ›¼å‡½æ•°çš„é€†å‡½æ•°ï¼ˆéƒ¨åˆ†å‡½æ•°ï¼‰
    pub fn inverse(&self, target: u32) -> Option<u32> {
        let mu_op = MuOperatorImpl;
        mu_op.mu_operator(
            |args, m| {
                let ack_value = self.ackermann(m, m).unwrap_or(u32::MAX);
                if ack_value >= target {
                    0
                } else {
                    1
                }
            },
            &[target],
        )
    }
}
```

### 7.4 éƒ¨åˆ†é€’å½’å‡½æ•°å®ç° (Partial Recursive Function Implementation)

```rust
pub struct PartialRecursiveFunction<F> {
    f: F,
    domain: Vec<Vec<u32>>, // å®šä¹‰åŸŸ
}

impl<F> PartialRecursiveFunction<F>
where
    F: Fn(&[u32]) -> Option<u32>,
{
    pub fn new(f: F, domain: Vec<Vec<u32>>) -> Self {
        PartialRecursiveFunction { f, domain }
    }

    pub fn apply(&self, args: &[u32]) -> Option<u32> {
        // æ£€æŸ¥æ˜¯å¦åœ¨å®šä¹‰åŸŸå†…
        if !self.is_in_domain(args) {
            return None;
        }

        (self.f)(args)
    }

    fn is_in_domain(&self, args: &[u32]) -> bool {
        self.domain.iter().any(|domain_args| {
            domain_args.len() == args.len() &&
            domain_args.iter().zip(args.iter()).all(|(a, b)| a == b)
        })
    }

    pub fn is_total(&self) -> bool {
        // æ£€æŸ¥æ˜¯å¦ä¸ºå…¨å‡½æ•°
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„æ£€æŸ¥
        true
    }
}
```

### 7.5 é€’å½’å¯æšä¸¾é›†å®ç° (Recursively Enumerable Set Implementation)

```rust
pub struct RecursivelyEnumerableSet<F> {
    enumerator: F,
}

impl<F> RecursivelyEnumerableSet<F>
where
    F: Fn(u32) -> Option<u32>,
{
    pub fn new(enumerator: F) -> Self {
        RecursivelyEnumerableSet { enumerator }
    }

    pub fn enumerate(&self, limit: u32) -> Vec<u32> {
        let mut elements = Vec::new();

        for n in 0..limit {
            if let Some(element) = (self.enumerator)(n) {
                if !elements.contains(&element) {
                    elements.push(element);
                }
            }
        }

        elements
    }

    pub fn contains(&self, element: u32) -> bool {
        let mut n = 0;
        loop {
            if let Some(enumerated_element) = (self.enumerator)(n) {
                if enumerated_element == element {
                    return true;
                }
                if enumerated_element > element {
                    return false;
                }
            } else {
                return false;
            }
            n += 1;

            // é˜²æ­¢æ— é™å¾ªç¯
            if n > 1000 {
                return false;
            }
        }
    }
}

// é˜¿å…‹æ›¼å‡½æ•°å€¼åŸŸçš„é€’å½’å¯æšä¸¾é›†
pub struct AckermannRange;

impl RecursivelyEnumerableSet<fn(u32) -> Option<u32>> for AckermannRange {
    fn new() -> Self {
        RecursivelyEnumerableSet::new(|n| {
            // å°†è‡ªç„¶æ•°ç¼–ç ä¸ºé˜¿å…‹æ›¼å‡½æ•°çš„å‚æ•°
            let m = n / 1000;
            let k = n % 1000;
            AckermannFunction.apply(&[m, k])
        })
    }
}
```

### 7.6 åœæœºé—®é¢˜æ¨¡æ‹Ÿ (Halting Problem Simulation)

```rust
pub struct HaltingProblemSimulator;

impl HaltingProblemSimulator {
    // æ¨¡æ‹Ÿåœæœºé—®é¢˜ï¼ˆå®é™…ä¸å¯è§£ï¼‰
    pub fn simulate_halting_problem(&self, machine_id: u32, input: u32) -> Option<bool> {
        // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„æ¨¡æ‹Ÿï¼Œå®é™…çš„åœæœºé—®é¢˜æ˜¯ä¸å¯è§£çš„
        match (machine_id, input) {
            (0, _) => Some(true),  // æ€»æ˜¯åœæœº
            (1, _) => Some(false), // ä»ä¸åœæœº
            (2, x) => Some(x < 100), // åœ¨æŸäº›è¾“å…¥ä¸Šåœæœº
            _ => None, // æœªå®šä¹‰
        }
    }

    // åœæœºé—®é¢˜çš„é€’å½’å¯æšä¸¾ç‰ˆæœ¬
    pub fn halting_problem_enumerable(&self) -> RecursivelyEnumerableSet<fn(u32) -> Option<u32>> {
        RecursivelyEnumerableSet::new(|n| {
            let machine_id = n / 1000;
            let input = n % 1000;

            if self.simulate_halting_problem(machine_id, input) == Some(true) {
                Some(n)
            } else {
                None
            }
        })
    }
}
```

### 7.7 ä¸€èˆ¬é€’å½’å‡½æ•°éªŒè¯å™¨ (General Recursive Function Validator)

```rust
pub struct GeneralRecursiveValidator;

impl GeneralRecursiveValidator {
    // éªŒè¯å‡½æ•°æ˜¯å¦ä¸ºä¸€èˆ¬é€’å½’å‡½æ•°
    pub fn is_general_recursive<F>(f: &F) -> bool
    where
        F: GeneralRecursive,
    {
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„åˆ†æ
        true
    }

    // éªŒè¯å‡½æ•°æ˜¯å¦ä¸ºéƒ¨åˆ†å‡½æ•°
    pub fn is_partial<F>(f: &F) -> bool
    where
        F: GeneralRecursive,
    {
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„åˆ†æ
        false
    }

    // éªŒè¯å‡½æ•°æ˜¯å¦ä¸ºå…¨å‡½æ•°
    pub fn is_total<F>(f: &F) -> bool
    where
        F: GeneralRecursive,
    {
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„åˆ†æ
        true
    }

    // éªŒè¯å‡½æ•°æ˜¯å¦ç­‰ä»·äºå›¾çµæœº
    pub fn is_turing_equivalent<F>(f: &F) -> bool
    where
        F: GeneralRecursive,
    {
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„åˆ†æ
        true
    }
}
```

---

## 8. å‚è€ƒæ–‡çŒ® (References)

æœ¬æ–‡æ¡£åŸºäºå·²å‘è¡¨çš„å­¦æœ¯æ–‡çŒ®å’Œå…¬å¼€èµ„æ–™ç¼–å†™ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦å‚è€ƒæ–‡çŒ®ï¼š

**é€’å½’å‡½æ•°è®ºåŸºç¡€ / Foundations of Recursive Function Theory**:

1. [Kleene1952] Kleene, S. C. (1952). *Introduction to Metamathematics*. North-Holland. ISBN: 978-0720421033.
   - å…ƒæ•°å­¦å’Œé€’å½’å‡½æ•°è®ºçš„ç»å…¸æ•™æï¼Œè¯¦ç»†ä»‹ç»Î¼-ç®—å­å’Œä¸€èˆ¬é€’å½’å‡½æ•°ï¼Œæœ¬æ–‡æ¡£çš„æ ¸å¿ƒå‚è€ƒã€‚

2. [Rogers1987] Rogers, H., Jr. (1987). *Theory of Recursive Functions and Effective Computability*. MIT Press. ISBN: 978-0262680523.
   - é€’å½’å‡½æ•°è®ºçš„æƒå¨æ•™æï¼Œå…¨é¢ä»‹ç»ä¸€èˆ¬é€’å½’å‡½æ•°ã€éƒ¨åˆ†é€’å½’å‡½æ•°å’Œé€’å½’å¯æšä¸¾æ€§ã€‚

3. [Cutland1980] Cutland, N. J. (1980). *Computability: An Introduction to Recursive Function Theory*. Cambridge University Press. ISBN: 978-0521294652.
   - é€’å½’å‡½æ•°è®ºçš„å…¥é—¨æ•™æï¼Œæ¸…æ™°ä»‹ç»Î¼-ç®—å­å’Œåœæœºé—®é¢˜ã€‚

**å¯è®¡ç®—æ€§ç†è®º / Computability Theory**:

1. [Soare2016] Soare, R. I. (2016). *Turing Computability: Theory and Applications*. Springer. ISBN: 978-3642319327.
   - å¯è®¡ç®—æ€§ç†è®ºçš„ç°ä»£ç»¼åˆæ•™æï¼Œå±•ç¤ºä¸€èˆ¬é€’å½’å‡½æ•°ä¸å›¾çµå¯è®¡ç®—æ€§çš„ç­‰ä»·å…³ç³»ã€‚

2. [Odifreddi1989] Odifreddi, P. (1989). *Classical Recursion Theory*. North-Holland. ISBN: 978-0444872951.
   - é€’å½’ç†è®ºçš„ç™¾ç§‘å…¨ä¹¦ï¼Œè¯¦ç»†ä»‹ç»ä¸€èˆ¬é€’å½’å‡½æ•°å’Œé€’å½’ä¸å¯è§£æ€§ã€‚

3. [Cooper2004] Cooper, S. B. (2004). *Computability Theory*. Chapman & Hall/CRC.
   - å¯è®¡ç®—æ€§ç†è®ºçš„ç°ä»£æ•™æï¼ŒåŒ…å«ä¸€èˆ¬é€’å½’å‡½æ•°çš„æ·±å…¥è®¨è®ºã€‚

**ä¸å¯è§£æ€§ä¸å¤æ‚æ€§ / Unsolvability and Complexity**:

1. [Davis1958] Davis, M. (1958). *Computability and Unsolvability*. McGraw-Hill.
   - å¯è®¡ç®—æ€§ä¸ä¸å¯è§£æ€§çš„ç»å…¸æ•™æï¼Œè¯¦ç»†ä»‹ç»åœæœºé—®é¢˜å’Œé€’å½’ä¸å¯è§£é—®é¢˜ã€‚

2. [Hopcroft2006] Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation* (3rd Edition). Pearson. ISBN: 978-0321455369.
   - è‡ªåŠ¨æœºç†è®ºå’Œè®¡ç®—ç†è®ºï¼ŒåŒ…å«é€’å½’å¯æšä¸¾æ€§å’Œä¸å¯è§£æ€§çš„ä»‹ç»ã€‚

**å»¶ä¼¸é˜…è¯» / Further Reading**:

1. [Sipser2012] Sipser, M. (2012). *Introduction to the Theory of Computation* (3rd Edition). Cengage Learning. ISBN: 978-1133187790.
   - è®¡ç®—ç†è®ºå¯¼è®ºï¼ŒåŒ…å«é€’å½’ç†è®ºå’Œä¸å¯è§£æ€§çš„æ¸…æ™°ä»‹ç»ã€‚

2. [Boolos2007] Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). *Computability and Logic* (5th Edition). Cambridge University Press.
   - å¯è®¡ç®—æ€§ä¸é€»è¾‘çš„ç»¼åˆæ•™æï¼Œæ·±å…¥æ¢è®¨ä¸€èˆ¬é€’å½’å‡½æ•°ã€‚

**åœ¨çº¿èµ„æº / Online Resources**:

1. **Wikipedia - General Recursive Function**: <https://en.wikipedia.org/wiki/General_recursive_function>
   - ä¸€èˆ¬é€’å½’å‡½æ•°çš„Wikipediaæ¡ç›®ï¼ŒåŒ…å«Î¼-é€’å½’å‡½æ•°çš„å®šä¹‰å’Œæ€§è´¨ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

2. **Wikipedia - Computability Theory**: <https://en.wikipedia.org/wiki/Computability_theory>
   - å¯è®¡ç®—æ€§ç†è®ºçš„Wikipediaæ¡ç›®ï¼Œä»‹ç»ä¸€èˆ¬é€’å½’å‡½æ•°ä¸å›¾çµå¯è®¡ç®—æ€§çš„ç­‰ä»·æ€§ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

3. **Wikipedia - Church-Turing Thesis**: <https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis>
   - Church-Turingè®ºé¢˜çš„Wikipediaæ¡ç›®ï¼Œè¯´æ˜é€’å½’å‡½æ•°ä¸å›¾çµæœºçš„ç­‰ä»·æ€§ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰ã€‚

**å¼•ç”¨è§„èŒƒè¯´æ˜ / Citation Guidelines**:

æœ¬æ–‡æ¡£éµå¾ªé¡¹ç›®å¼•ç”¨è§„èŒƒï¼ˆè§ `docs/å¼•ç”¨è§„èŒƒä¸æ•°æ®åº“.md`ï¼‰ã€‚æ‰€æœ‰å¼•ç”¨æ¡ç›®åœ¨ `docs/references_database.yaml` ä¸­æœ‰å®Œæ•´è®°å½•ã€‚

æœ¬æ–‡æ¡£å†…å®¹å·²å¯¹ç…§Wikipediaç›¸å…³æ¡ç›®ï¼ˆæˆªè‡³2025å¹´1æœˆ11æ—¥ï¼‰è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿æœ¯è¯­å®šä¹‰å’Œç†è®ºæ¡†æ¶ä¸å½“å‰å­¦æœ¯æ ‡å‡†ä¸€è‡´ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ / Document Version**: 1.1
**æœ€åæ›´æ–° / Last Updated**: 2025-01-11
**çŠ¶æ€ / Status**: å·²å¯¹ç…§Wikipediaæ›´æ–° / Updated with Wikipedia references (as of 2025-01-11)

---

*æœ¬æ–‡æ¡£ä¸¥æ ¼éµå¾ªæ•°å­¦å½¢å¼åŒ–è§„èŒƒï¼Œæ‰€æœ‰å®šä¹‰å’Œå®šç†å‡é‡‡ç”¨æ ‡å‡†æ•°å­¦ç¬¦å·è¡¨ç¤ºã€‚*
*This document strictly follows mathematical formalization standards, with all definitions and theorems using standard mathematical notation.*
