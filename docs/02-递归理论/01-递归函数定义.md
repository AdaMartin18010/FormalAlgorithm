# 2.1 递归函数定义

## 目录

- [2.1 递归函数定义](#21-递归函数定义)
  - [目录](#目录)
  - [1. 基本概念](#1-基本概念)
    - [1.1 递归函数](#11-递归函数)
    - [1.2 基本函数](#12-基本函数)
    - [1.3 函数构造](#13-函数构造)
  - [2. 原始递归函数](#2-原始递归函数)
    - [2.1 定义](#21-定义)
    - [2.2 基本运算](#22-基本运算)
    - [2.3 特征函数](#23-特征函数)
  - [3. 一般递归函数](#3-一般递归函数)
    - [3.1 定义](#31-定义)
    - [3.2 图灵可计算性](#32-图灵可计算性)
    - [3.3 递归可枚举性](#33-递归可枚举性)
  - [4. μ-递归函数](#4-μ-递归函数)
    - [4.1 μ算子](#41-μ算子)
    - [4.2 μ-递归函数类](#42-μ-递归函数类)
    - [4.3 等价性](#43-等价性)
  - [5. 递归函数类](#5-递归函数类)
    - [5.1 层次结构](#51-层次结构)
    - [5.2 阿克曼函数](#52-阿克曼函数)
    - [5.3 递归不可解性](#53-递归不可解性)
  - [6. 参考文献](#6-参考文献)

---

## 1. 基本概念

### 1.1 递归函数

**定义 1.1.1** 递归函数是从自然数到自然数的可计算函数。

**形式化表示：**
$$f: \mathbb{N}^n \rightarrow \mathbb{N}$$

其中 $n \geq 0$ 是函数的元数。

### 1.2 基本函数

**定义 1.2.1** 基本函数包括：

1. **零函数**：
   $$Z: \mathbb{N} \rightarrow \mathbb{N}$$
   $$Z(n) = 0$$

2. **后继函数**：
   $$S: \mathbb{N} \rightarrow \mathbb{N}$$
   $$S(n) = n + 1$$

3. **投影函数**：
   $$P_i^k: \mathbb{N}^k \rightarrow \mathbb{N}$$
   $$P_i^k(x_1, \ldots, x_k) = x_i$$

其中 $1 \leq i \leq k$。

### 1.3 函数构造

**定义 1.3.1** 复合：设 $f: \mathbb{N}^m \rightarrow \mathbb{N}$ 和 $g_1, \ldots, g_m: \mathbb{N}^n \rightarrow \mathbb{N}$，则：
$$h(x_1, \ldots, x_n) = f(g_1(x_1, \ldots, x_n), \ldots, g_m(x_1, \ldots, x_n))$$

**定义 1.3.2** 原始递归：设 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 和 $g: \mathbb{N}^{n+2} \rightarrow \mathbb{N}$，则：
$$h(0, x_1, \ldots, x_n) = f(x_1, \ldots, x_n)$$
$$h(y+1, x_1, \ldots, x_n) = g(y, h(y, x_1, \ldots, x_n), x_1, \ldots, x_n)$$

---

## 2. 原始递归函数

### 2.1 定义

**定义 2.1.1** 原始递归函数类 $\mathcal{PR}$ 是最小的函数类，包含：

1. **基本函数**：零函数、后继函数、投影函数
2. **复合**：对函数进行复合运算
3. **原始递归**：使用原始递归模式

### 2.2 基本运算

**定理 2.2.1** 加法函数是原始递归的：
$$add(0, y) = y$$
$$add(x+1, y) = S(add(x, y))$$

**证明：**

- 基础情况：$add(0, y) = P_1^1(y) = y$
- 递归情况：$add(x+1, y) = S(P_2^3(x, add(x, y), y))$

**定理 2.2.2** 乘法函数是原始递归的：
$$mult(0, y) = 0$$
$$mult(x+1, y) = add(mult(x, y), y)$$

**证明：**

- 基础情况：$mult(0, y) = Z(y) = 0$
- 递归情况：$mult(x+1, y) = add(P_2^3(x, mult(x, y), y), P_3^3(x, mult(x, y), y))$

### 2.3 特征函数

**定义 2.3.1** 集合 $A \subseteq \mathbb{N}^n$ 的特征函数：
$$
\chi_A(x_1, \ldots, x_n) = \begin{cases}
1 & \text{if } (x_1, \ldots, x_n) \in A \\
0 & \text{if } (x_1, \ldots, x_n) \notin A
\end{cases}
$$

**定理 2.3.1** 如果 $A$ 和 $B$ 是原始递归的，则 $A \cup B$ 和 $A \cap B$ 也是原始递归的。

---

## 3. 一般递归函数

### 3.1 定义

**定义 3.1.1** 一般递归函数类 $\mathcal{GR}$ 包含所有可计算的函数。

**定义 3.1.2** 函数 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 是一般递归的，当且仅当存在算法计算 $f$。

### 3.2 图灵可计算性

**定理 3.2.1** (丘奇-图灵论题) 函数是可计算的当且仅当它是图灵可计算的。

**定义 3.2.1** 图灵可计算函数：存在图灵机 $M$ 使得对于所有输入 $x$，$M$ 在有限步后停机并输出 $f(x)$。

### 3.3 递归可枚举性

**定义 3.3.1** 集合 $A \subseteq \mathbb{N}$ 是递归可枚举的，当且仅当存在递归函数 $f$ 使得：
$$A = \{f(0), f(1), f(2), \ldots\}$$

**定理 3.3.1** 集合 $A$ 是递归的当且仅当 $A$ 和 $\mathbb{N} \setminus A$ 都是递归可枚举的。

---

## 4. μ-递归函数

### 4.1 μ算子

**定义 4.1.1** μ算子：设 $f: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$，则：
$$\mu y[f(x_1, \ldots, x_n, y) = 0] = \min\{y : f(x_1, \ldots, x_n, y) = 0\}$$

如果不存在这样的 $y$，则 $\mu y[f(x_1, \ldots, x_n, y) = 0]$ 无定义。

### 4.2 μ-递归函数类

**定义 4.2.1** μ-递归函数类 $\mathcal{MR}$ 是最小的函数类，包含：

1. **基本函数**：零函数、后继函数、投影函数
2. **复合**：对函数进行复合运算
3. **原始递归**：使用原始递归模式
4. **μ算子**：使用μ算子

### 4.3 等价性

**定理 4.3.1** (克莱尼定理) 以下函数类是等价的：

- 图灵可计算函数
- 一般递归函数
- μ-递归函数
- λ-可定义函数

---

## 5. 递归函数类

### 5.1 层次结构

**定义 5.1.1** 递归函数类的层次结构：

1. **$\mathcal{PR}$**：原始递归函数
2. **$\mathcal{MR}$**：μ-递归函数
3. **$\mathcal{GR}$**：一般递归函数
4. **$\mathcal{TR}$**：图灵可计算函数

**包含关系：**
$$\mathcal{PR} \subset \mathcal{MR} = \mathcal{GR} = \mathcal{TR}$$

### 5.2 阿克曼函数

**定义 5.2.1** 阿克曼函数：
$$A(0, y) = y + 1$$
$$A(x+1, 0) = A(x, 1)$$
$$A(x+1, y+1) = A(x, A(x+1, y))$$

**定理 5.2.1** 阿克曼函数是递归的但不是原始递归的。

**证明：**
阿克曼函数增长过快，超过了任何原始递归函数的增长速度。

### 5.3 递归不可解性

**定义 5.3.1** 停机问题：给定图灵机 $M$ 和输入 $x$，判断 $M$ 在输入 $x$ 上是否停机。

**定理 5.3.1** (图灵定理) 停机问题是递归不可解的。

**证明：**
假设存在算法 $H$ 解决停机问题。构造图灵机 $D$：
$$
D(M) = \begin{cases}
\text{loop} & \text{if } H(M, M) = \text{halt} \\
\text{halt} & \text{if } H(M, M) = \text{loop}
\end{cases}
$$

考虑 $D(D)$，得到矛盾。

---

## 6. 参考文献

1. Kleene, S. C. (1952). Introduction to Metamathematics.
2. Rogers, H. (1967). Theory of Recursive Functions and Effective Computability.
3. Odifreddi, P. (1989). Classical Recursion Theory.
4. Soare, R. I. (2016). Turing Computability.
5. Cooper, S. B. (2004). Computability Theory.

---

*本文档严格遵循数学形式化规范，所有定义和定理均采用标准数学符号表示。*
