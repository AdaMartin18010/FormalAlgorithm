# 2.1 递归函数定义

> 导航：`docs/形式化算法文档改进完成报告.md` · `docs/术语与符号总表.md` · `docs/跨文档索引.md`

## 目录

- [2.1 递归函数定义](#21-递归函数定义)
  - [目录](#目录)
  - [1. 基本概念](#1-基本概念)
    - [1.1 递归函数](#11-递归函数)
    - [1.2 基本函数](#12-基本函数)
    - [1.3 函数构造](#13-函数构造)
  - [2. 原始递归函数](#2-原始递归函数)
    - [2.1 定义](#21-定义)
    - [2.2 基本运算](#22-基本运算)
    - [2.3 特征函数](#23-特征函数)
  - [3. 一般递归函数](#3-一般递归函数)
    - [3.1 定义](#31-定义)
    - [3.2 图灵可计算性](#32-图灵可计算性)
    - [3.3 递归可枚举性](#33-递归可枚举性)
  - [4. μ-递归函数](#4-μ-递归函数)
    - [4.1 μ算子](#41-μ算子)
    - [4.2 μ-递归函数类](#42-μ-递归函数类)
    - [4.3 等价性](#43-等价性)
  - [5. 递归函数类](#5-递归函数类)
    - [5.1 层次结构](#51-层次结构)
    - [5.2 阿克曼函数](#52-阿克曼函数)
    - [5.3 递归不可解性](#53-递归不可解性)
  - [6. 参考文献](#6-参考文献)
    - [经典文献 / Classical References](#经典文献--classical-references)
    - [现代教材 / Modern Textbooks](#现代教材--modern-textbooks)
    - [递归函数理论 / Recursive Function Theory](#递归函数理论--recursive-function-theory)
    - [可计算性理论 / Computability Theory](#可计算性理论--computability-theory)
    - [递归可枚举性 / Recursive Enumerability](#递归可枚举性--recursive-enumerability)
    - [复杂度理论 / Complexity Theory](#复杂度理论--complexity-theory)
    - [在线资源 / Online Resources](#在线资源--online-resources)
    - [国际标准 / International Standards](#国际标准--international-standards)

---

## 1. 基本概念

### 1.1 递归函数

**定义 1.1.1** 递归函数是从自然数到自然数的可计算函数。

**形式化表示：**
$$f: \mathbb{N}^n \rightarrow \mathbb{N}$$

其中 $n \geq 0$ 是函数的元数。

**递归函数的公理化定义 / Axiomatic Definition of Recursive Functions:**

**定义 1.1.2** 递归函数类 $\mathcal{R}$ 是最小的函数类，满足以下公理：
The recursive function class $\mathcal{R}$ is the smallest function class satisfying the following axioms:

1. **基本函数公理 / Basic Function Axiom**: 所有基本函数属于 $\mathcal{R}$
2. **复合公理 / Composition Axiom**: 如果 $f, g_1, \ldots, g_m \in \mathcal{R}$，则 $f \circ (g_1, \ldots, g_m) \in \mathcal{R}$
3. **原始递归公理 / Primitive Recursion Axiom**: 如果 $f, g \in \mathcal{R}$，则通过原始递归构造的函数属于 $\mathcal{R}$
4. **最小化公理 / Minimization Axiom**: 如果 $f \in \mathcal{R}$，则通过μ算子构造的函数属于 $\mathcal{R}$

**递归函数的代数结构 / Algebraic Structure of Recursive Functions:**

**定理 1.1.1** 递归函数类在复合运算下构成一个幺半群。
**Theorem 1.1.1** The recursive function class forms a monoid under composition.

**证明 / Proof:**

1. **结合律 / Associativity**: $(f \circ g) \circ h = f \circ (g \circ h)$
2. **单位元 / Identity**: $id \circ f = f \circ id = f$，其中 $id(x) = x$

### 1.2 基本函数

**定义 1.2.1** 基本函数包括：

1. **零函数 / Zero Function**：
   $$Z: \mathbb{N} \rightarrow \mathbb{N}$$
   $$Z(n) = 0$$

2. **后继函数 / Successor Function**：
   $$S: \mathbb{N} \rightarrow \mathbb{N}$$
   $$S(n) = n + 1$$

3. **投影函数 / Projection Function**：
   $$P_i^k: \mathbb{N}^k \rightarrow \mathbb{N}$$
   $$P_i^k(x_1, \ldots, x_k) = x_i$$

其中 $1 \leq i \leq k$。

**基本函数的代数性质 / Algebraic Properties of Basic Functions:**

**定理 1.2.1** 基本函数是线性无关的。
**Theorem 1.2.1** Basic functions are linearly independent.

**证明 / Proof:**
假设存在非零系数 $a, b, c$ 使得 $a \cdot Z + b \cdot S + c \cdot P_i^k = 0$，则对所有输入都成立，矛盾。

**定理 1.2.2** 基本函数生成自由代数。
**Theorem 1.2.2** Basic functions generate a free algebra.

**证明 / Proof:**
通过构造性证明，展示任何递归函数都可以唯一地表示为基本函数的组合。

### 1.3 函数构造

**定义 1.3.1** 复合 / Composition：设 $f: \mathbb{N}^m \rightarrow \mathbb{N}$ 和 $g_1, \ldots, g_m: \mathbb{N}^n \rightarrow \mathbb{N}$，则：
$$h(x_1, \ldots, x_n) = f(g_1(x_1, \ldots, x_n), \ldots, g_m(x_1, \ldots, x_n))$$

**复合的形式化定义 / Formal Definition of Composition:**

**定义 1.3.2** 复合算子：
Composition operator:
$$\circ: \mathcal{R}^m \times \mathcal{R}^n \rightarrow \mathcal{R}$$

其中 $\mathcal{R}$ 是递归函数类。
where $\mathcal{R}$ is the recursive function class.

**定义 1.3.3** 原始递归 / Primitive Recursion：设 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 和 $g: \mathbb{N}^{n+2} \rightarrow \mathbb{N}$，则：
$$h(0, x_1, \ldots, x_n) = f(x_1, \ldots, x_n)$$
$$h(y+1, x_1, \ldots, x_n) = g(y, h(y, x_1, \ldots, x_n), x_1, \ldots, x_n)$$

**原始递归的形式化定义 / Formal Definition of Primitive Recursion:**

**定义 1.3.4** 原始递归算子：
Primitive recursion operator:
$$\text{PR}: \mathcal{R}^n \times \mathcal{R}^{n+2} \rightarrow \mathcal{R}$$

**原始递归的语义 / Semantics of Primitive Recursion:**

**定理 1.3.1** 原始递归函数是全域的（对所有输入都有定义）。
**Theorem 1.3.1** Primitive recursive functions are total (defined for all inputs).

**证明 / Proof:**
通过对递归深度进行数学归纳。
By mathematical induction on the recursion depth.

**定理 1.3.2** 原始递归函数是可计算的。
**Theorem 1.3.2** Primitive recursive functions are computable.

**证明 / Proof:**
通过构造图灵机来模拟原始递归计算。
By constructing Turing machines to simulate primitive recursive computation.

**函数构造的代数性质 / Algebraic Properties of Function Construction:**

**定理 1.3.3** 复合和原始递归算子满足结合律。
**Theorem 1.3.3** Composition and primitive recursion operators satisfy associativity.

**证明 / Proof:**
通过直接计算验证。
By direct computation verification.

---

## 2. 原始递归函数

### 2.1 定义

**定义 2.1.1** 原始递归函数类 $\mathcal{PR}$ 是最小的函数类，包含：

1. **基本函数**：零函数、后继函数、投影函数
2. **复合**：对函数进行复合运算
3. **原始递归**：使用原始递归模式

**原始递归函数的公理化定义 / Axiomatic Definition of Primitive Recursive Functions:**

**定义 2.1.2** 原始递归函数类 $\mathcal{PR}$ 是满足以下公理的最小函数类：
The primitive recursive function class $\mathcal{PR}$ is the smallest function class satisfying the following axioms:

1. **基本函数公理 / Basic Function Axiom**: $Z, S, P_i^k \in \mathcal{PR}$
2. **复合公理 / Composition Axiom**: 如果 $f \in \mathcal{PR}^m$ 和 $g_1, \ldots, g_m \in \mathcal{PR}^n$，则 $f \circ (g_1, \ldots, g_m) \in \mathcal{PR}^n$
3. **原始递归公理 / Primitive Recursion Axiom**: 如果 $f \in \mathcal{PR}^n$ 和 $g \in \mathcal{PR}^{n+2}$，则 $\text{PR}(f, g) \in \mathcal{PR}^{n+1}$

**原始递归函数的代数结构 / Algebraic Structure of Primitive Recursive Functions:**

**定理 2.1.1** $\mathcal{PR}$ 在复合运算下构成一个幺半群。
**Theorem 2.1.1** $\mathcal{PR}$ forms a monoid under composition.

**证明 / Proof:**

1. **封闭性 / Closure**: 复合公理保证封闭性
2. **结合律 / Associativity**: $(f \circ g) \circ h = f \circ (g \circ h)$
3. **单位元 / Identity**: $id \in \mathcal{PR}$ 作为单位元

### 2.2 基本运算

**定理 2.2.1** 加法函数是原始递归的：
$$add(0, y) = y$$
$$add(x+1, y) = S(add(x, y))$$

**证明 / Proof:**

- **基础情况 / Base Case**: $add(0, y) = P_1^1(y) = y$
- **递归情况 / Recursive Case**: $add(x+1, y) = S(P_2^3(x, add(x, y), y))$

**定理 2.2.2** 乘法函数是原始递归的：
$$mult(0, y) = 0$$
$$mult(x+1, y) = add(mult(x, y), y)$$

**证明 / Proof:**

- **基础情况 / Base Case**: $mult(0, y) = Z(y) = 0$
- **递归情况 / Recursive Case**: $mult(x+1, y) = add(P_2^3(x, mult(x, y), y), P_3^3(x, mult(x, y), y))$

**定理 2.2.3** 指数函数是原始递归的：
$$exp(0, y) = 1$$
$$exp(x+1, y) = mult(exp(x, y), y)$$

**证明 / Proof:**

- **基础情况 / Base Case**: $exp(0, y) = S(Z(y)) = 1$
- **递归情况 / Recursive Case**: $exp(x+1, y) = mult(P_2^3(x, exp(x, y), y), P_3^3(x, exp(x, y), y))$

**定理 2.2.4** 阶乘函数是原始递归的：
$$fact(0) = 1$$
$$fact(x+1) = mult(fact(x), S(x))$$

**证明 / Proof:**

- **基础情况 / Base Case**: $fact(0) = S(Z(0)) = 1$
- **递归情况 / Recursive Case**: $fact(x+1) = mult(P_1^2(x, fact(x)), S(P_1^2(x, fact(x))))$

**原始递归函数的增长性质 / Growth Properties of Primitive Recursive Functions:**

**定理 2.2.5** 所有原始递归函数都是可计算的。
**Theorem 2.2.5** All primitive recursive functions are computable.

**证明 / Proof:**
通过构造图灵机来模拟原始递归计算。
By constructing Turing machines to simulate primitive recursive computation.

**定理 2.2.6** 原始递归函数的增长速度是有限的。
**Theorem 2.2.6** The growth rate of primitive recursive functions is bounded.

**证明 / Proof:**
通过归纳法证明，每个原始递归函数的增长速度都被某个原始递归函数界住。
By induction, proving that the growth rate of each primitive recursive function is bounded by some primitive recursive function.

### 2.3 特征函数

**定义 2.3.1** 集合 $A \subseteq \mathbb{N}^n$ 的特征函数：
$$
\chi_A(x_1, \ldots, x_n) = \begin{cases}
1 & \text{if } (x_1, \ldots, x_n) \in A \\
0 & \text{if } (x_1, \ldots, x_n) \notin A
\end{cases}
$$

**特征函数的性质 / Properties of Characteristic Functions:**

**定理 2.3.1** 如果 $A$ 和 $B$ 是原始递归的，则 $A \cup B$ 和 $A \cap B$ 也是原始递归的。
**Theorem 2.3.1** If $A$ and $B$ are primitive recursive, then $A \cup B$ and $A \cap B$ are also primitive recursive.

**证明 / Proof:**
$$\chi_{A \cup B}(x) = \max(\chi_A(x), \chi_B(x))$$
$$\chi_{A \cap B}(x) = \min(\chi_A(x), \chi_B(x))$$

**定理 2.3.2** 如果 $A$ 是原始递归的，则 $\mathbb{N}^n \setminus A$ 也是原始递归的。
**Theorem 2.3.2** If $A$ is primitive recursive, then $\mathbb{N}^n \setminus A$ is also primitive recursive.

**证明 / Proof:**
$$\chi_{\mathbb{N}^n \setminus A}(x) = 1 - \chi_A(x)$$

**定理 2.3.3** 原始递归集合在布尔运算下构成布尔代数。
**Theorem 2.3.3** Primitive recursive sets form a Boolean algebra under Boolean operations.

**证明 / Proof:**
通过验证布尔代数的所有公理。
By verifying all axioms of Boolean algebra.

---

## 3. 一般递归函数

### 3.1 定义

**定义 3.1.1** 一般递归函数类 $\mathcal{GR}$ 包含所有可计算的函数。

**定义 3.1.2** 函数 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 是一般递归的，当且仅当存在算法计算 $f$。

**一般递归函数的公理化定义 / Axiomatic Definition of General Recursive Functions:**

**定义 3.1.3** 一般递归函数类 $\mathcal{GR}$ 是满足以下公理的最小函数类：
The general recursive function class $\mathcal{GR}$ is the smallest function class satisfying the following axioms:

1. **基本函数公理 / Basic Function Axiom**: $Z, S, P_i^k \in \mathcal{GR}$
2. **复合公理 / Composition Axiom**: 如果 $f \in \mathcal{GR}^m$ 和 $g_1, \ldots, g_m \in \mathcal{GR}^n$，则 $f \circ (g_1, \ldots, g_m) \in \mathcal{GR}^n$
3. **原始递归公理 / Primitive Recursion Axiom**: 如果 $f \in \mathcal{GR}^n$ 和 $g \in \mathcal{GR}^{n+2}$，则 $\text{PR}(f, g) \in \mathcal{GR}^{n+1}$
4. **最小化公理 / Minimization Axiom**: 如果 $f \in \mathcal{GR}^{n+1}$，则 $\mu y[f(x_1, \ldots, x_n, y) = 0] \in \mathcal{GR}^n$

**一般递归函数的代数结构 / Algebraic Structure of General Recursive Functions:**

**定理 3.1.1** $\mathcal{GR}$ 在复合运算下构成一个幺半群。
**Theorem 3.1.1** $\mathcal{GR}$ forms a monoid under composition.

**证明 / Proof:**

1. **封闭性 / Closure**: 复合公理保证封闭性
2. **结合律 / Associativity**: $(f \circ g) \circ h = f \circ (g \circ h)$
3. **单位元 / Identity**: $id \in \mathcal{GR}$ 作为单位元

**一般递归函数的性质 / Properties of General Recursive Functions:**

**定理 3.1.2** 一般递归函数可能是部分函数（不是全域的）。
**Theorem 3.1.2** General recursive functions may be partial (not total).

**证明 / Proof:**
通过构造例子，如阿克曼函数的逆函数。
By constructing examples, such as the inverse of the Ackermann function.

### 3.2 图灵可计算性

**定理 3.2.1** (丘奇-图灵论题) 函数是可计算的当且仅当它是图灵可计算的。
**Theorem 3.2.1** (Church-Turing Thesis) A function is computable if and only if it is Turing computable.

**形式化表述 / Formal Statement:**
$$\text{Computable}(f) \Leftrightarrow \exists \text{图灵机 } M: \forall x \in \text{dom}(f), M(x) = f(x)$$

**定义 3.2.1** 图灵可计算函数：存在图灵机 $M$ 使得对于所有输入 $x$，$M$ 在有限步后停机并输出 $f(x)$。
**Definition 3.2.1** Turing computable function: There exists a Turing machine $M$ such that for all inputs $x$, $M$ halts after finitely many steps and outputs $f(x)$.

**图灵可计算性的等价性 / Equivalence of Turing Computability:**

**定理 3.2.2** 以下计算模型在可计算性方面是等价的：
**Theorem 3.2.2** The following computation models are equivalent in terms of computability:

1. **图灵机模型 / Turing Machine Model**
2. **λ演算模型 / Lambda Calculus Model**
3. **递归函数模型 / Recursive Function Model**
4. **组合子逻辑模型 / Combinatory Logic Model**

**证明 / Proof:**
通过构造性证明，展示如何在这些模型之间进行相互模拟。
By constructive proof, showing how to simulate between these models.

### 3.3 递归可枚举性

**定义 3.3.1** 集合 $A \subseteq \mathbb{N}$ 是递归可枚举的，当且仅当存在递归函数 $f$ 使得：
**Definition 3.3.1** A set $A \subseteq \mathbb{N}$ is recursively enumerable if and only if there exists a recursive function $f$ such that:
$$A = \{f(0), f(1), f(2), \ldots\}$$

**递归可枚举性的等价定义 / Equivalent Definitions of Recursive Enumerability:**

**定理 3.3.1** 以下陈述等价：
**Theorem 3.3.1** The following statements are equivalent:

1. $A$ 是递归可枚举的
2. 存在图灵机 $M$ 使得 $A = L(M)$
3. 存在部分递归函数 $f$ 使得 $A = \text{dom}(f)$
4. 存在原始递归函数 $f$ 使得 $A = \{x : \exists y, f(x, y) = 0\}$

**证明 / Proof:**
通过构造性证明，展示这些定义之间的等价性。
By constructive proof, showing the equivalence between these definitions.

**递归可枚举性的性质 / Properties of Recursive Enumerability:**

**定理 3.3.2** 集合 $A$ 是递归的当且仅当 $A$ 和 $\mathbb{N} \setminus A$ 都是递归可枚举的。
**Theorem 3.3.2** A set $A$ is recursive if and only if both $A$ and $\mathbb{N} \setminus A$ are recursively enumerable.

**证明 / Proof:**

- **必要性 / Necessity**: 如果 $A$ 是递归的，则存在算法枚举 $A$ 和 $\mathbb{N} \setminus A$
- **充分性 / Sufficiency**: 通过交错枚举 $A$ 和 $\mathbb{N} \setminus A$ 来构造 $A$ 的判定算法

**定理 3.3.3** 递归可枚举集合在并集和交集下封闭。
**Theorem 3.3.3** Recursively enumerable sets are closed under union and intersection.

**证明 / Proof:**
通过构造性证明，展示如何从 $A$ 和 $B$ 的枚举器构造 $A \cup B$ 和 $A \cap B$ 的枚举器。
By constructive proof, showing how to construct enumerators for $A \cup B$ and $A \cap B$ from enumerators of $A$ and $B$.

**递归可枚举性的层次结构 / Hierarchy of Recursive Enumerability:**

**定义 3.3.2** 递归可枚举度的层次结构：
**Definition 3.3.2** Hierarchy of recursively enumerable degrees:

1. **$\mathcal{R}$**: 递归集合
2. **$\mathcal{RE}$**: 递归可枚举集合
3. **$\mathcal{RE} \setminus \mathcal{R}$**: 递归可枚举但非递归集合

**包含关系 / Inclusion Relations:**
$$\mathcal{R} \subset \mathcal{RE} \subset \mathcal{P}(\mathbb{N})$$

---

## 4. μ-递归函数

### 4.1 μ算子

**定义 4.1.1** μ算子：设 $f: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$，则：
$$\mu y[f(x_1, \ldots, x_n, y) = 0] = \min\{y : f(x_1, \ldots, x_n, y) = 0\}$$

如果不存在这样的 $y$，则 $\mu y[f(x_1, \ldots, x_n, y) = 0]$ 无定义。

**μ算子的严格定义 / Strict Definition of μ-Operator:**

**定义 4.1.2** μ算子是一个函数：
The μ-operator is a function:
$$\mu: \mathcal{F}^{n+1} \rightarrow \mathcal{F}^n$$

其中 $\mathcal{F}$ 是函数类。
where $\mathcal{F}$ is the function class.

**μ算子的语义 / Semantics of μ-Operator:**

**定义 4.1.3** 对于函数 $f: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$，μ算子定义为：
For function $f: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$, the μ-operator is defined as:
$$
(\mu y[f])(x_1, \ldots, x_n) = \begin{cases}
\min\{y : f(x_1, \ldots, x_n, y) = 0\} & \text{if such } y \text{ exists} \\
\text{undefined} & \text{otherwise}
\end{cases}
$$

**μ算子的性质 / Properties of μ-Operator:**

**定理 4.1.1** μ算子保持单调性。
**Theorem 4.1.1** The μ-operator preserves monotonicity.

**证明 / Proof:**
如果 $f(x, y) \leq g(x, y)$ 对所有 $x, y$ 成立，则 $\mu y[f(x, y) = 0] \geq \mu y[g(x, y) = 0]$。

**定理 4.1.2** μ算子不保持连续性。
**Theorem 4.1.2** The μ-operator does not preserve continuity.

**证明 / Proof:**
通过构造反例，展示μ算子可以将连续函数转换为不连续函数。
By constructing counterexamples, showing that the μ-operator can transform continuous functions into discontinuous ones.

### 4.2 μ-递归函数类

**定义 4.2.1** μ-递归函数类 $\mathcal{MR}$ 是最小的函数类，包含：

1. **基本函数**：零函数、后继函数、投影函数
2. **复合**：对函数进行复合运算
3. **原始递归**：使用原始递归模式
4. **μ算子**：使用μ算子

**μ-递归函数的公理化定义 / Axiomatic Definition of μ-Recursive Functions:**

**定义 4.2.2** μ-递归函数类 $\mathcal{MR}$ 是满足以下公理的最小函数类：
The μ-recursive function class $\mathcal{MR}$ is the smallest function class satisfying the following axioms:

1. **基本函数公理 / Basic Function Axiom**: $Z, S, P_i^k \in \mathcal{MR}$
2. **复合公理 / Composition Axiom**: 如果 $f \in \mathcal{MR}^m$ 和 $g_1, \ldots, g_m \in \mathcal{MR}^n$，则 $f \circ (g_1, \ldots, g_m) \in \mathcal{MR}^n$
3. **原始递归公理 / Primitive Recursion Axiom**: 如果 $f \in \mathcal{MR}^n$ 和 $g \in \mathcal{MR}^{n+2}$，则 $\text{PR}(f, g) \in \mathcal{MR}^{n+1}$
4. **μ算子公理 / μ-Operator Axiom**: 如果 $f \in \mathcal{MR}^{n+1}$，则 $\mu y[f(x_1, \ldots, x_n, y) = 0] \in \mathcal{MR}^n$

**μ-递归函数的代数结构 / Algebraic Structure of μ-Recursive Functions:**

**定理 4.2.1** $\mathcal{MR}$ 在复合运算下构成一个幺半群。
**Theorem 4.2.1** $\mathcal{MR}$ forms a monoid under composition.

**证明 / Proof:**

1. **封闭性 / Closure**: 复合公理保证封闭性
2. **结合律 / Associativity**: $(f \circ g) \circ h = f \circ (g \circ h)$
3. **单位元 / Identity**: $id \in \mathcal{MR}$ 作为单位元

**μ-递归函数的性质 / Properties of μ-Recursive Functions:**

**定理 4.2.2** μ-递归函数可能是部分函数（不是全域的）。
**Theorem 4.2.2** μ-recursive functions may be partial (not total).

**证明 / Proof:**
通过构造例子，如阿克曼函数的逆函数。
By constructing examples, such as the inverse of the Ackermann function.

**定理 4.2.3** 所有μ-递归函数都是可计算的。
**Theorem 4.2.3** All μ-recursive functions are computable.

**证明 / Proof:**
通过构造图灵机来模拟μ-递归计算。
By constructing Turing machines to simulate μ-recursive computation.

### 4.3 等价性

**定理 4.3.1** (克莱尼定理) 以下函数类是等价的：
**Theorem 4.3.1** (Kleene's Theorem) The following function classes are equivalent:

- 图灵可计算函数 / Turing computable functions
- 一般递归函数 / General recursive functions
- μ-递归函数 / μ-recursive functions
- λ-可定义函数 / λ-definable functions

**克莱尼定理的证明 / Proof of Kleene's Theorem:**

**引理 4.3.1** 图灵可计算函数 ⊆ μ-递归函数
**Lemma 4.3.1** Turing computable functions ⊆ μ-recursive functions

**证明 / Proof:**
通过构造性证明，展示如何用μ-递归函数模拟图灵机计算。
By constructive proof, showing how to simulate Turing machine computation using μ-recursive functions.

**引理 4.3.2** μ-递归函数 ⊆ 图灵可计算函数
**Lemma 4.3.2** μ-recursive functions ⊆ Turing computable functions

**证明 / Proof:**
通过构造性证明，展示如何用图灵机模拟μ-递归计算。
By constructive proof, showing how to simulate μ-recursive computation using Turing machines.

**μ-递归函数的完备性 / Completeness of μ-Recursive Functions:**

**定理 4.3.2** (μ-递归函数完备性) 所有可计算函数都是μ-递归的。
**Theorem 4.3.2** (Completeness of μ-Recursive Functions) All computable functions are μ-recursive.

**证明 / Proof:**
通过丘奇-图灵论题和克莱尼定理。
By Church-Turing thesis and Kleene's theorem.

**μ-递归函数的例子 / Examples of μ-Recursive Functions:**

**例 4.3.1** 减法函数：
Subtraction function:
$$\text{sub}(x, y) = \mu z[\text{add}(y, z) = x]$$

**例 4.3.2** 整数除法：
Integer division:
$$\text{div}(x, y) = \mu z[\text{mult}(y, z) \geq x]$$

**例 4.3.3** 平方根：
Square root:
$$\text{sqrt}(x) = \mu y[\text{mult}(y, y) \geq x]$$

**μ-递归函数的层次结构 / Hierarchy of μ-Recursive Functions:**

**定义 4.3.1** μ-递归函数层次：
**Definition 4.3.1** Hierarchy of μ-recursive functions:

1. **$\mathcal{PR}$**: 原始递归函数
2. **$\mathcal{MR}$**: μ-递归函数
3. **$\mathcal{GR}$**: 一般递归函数

**包含关系 / Inclusion Relations:**
$$\mathcal{PR} \subset \mathcal{MR} = \mathcal{GR}$$

---

## 5. 递归函数类

### 5.1 层次结构

**定义 5.1.1** 递归函数类的层次结构：

1. **$\mathcal{PR}$**：原始递归函数
2. **$\mathcal{MR}$**：μ-递归函数
3. **$\mathcal{GR}$**：一般递归函数
4. **$\mathcal{TR}$**：图灵可计算函数

**包含关系：**
$$\mathcal{PR} \subset \mathcal{MR} = \mathcal{GR} = \mathcal{TR}$$

**递归函数类的代数结构 / Algebraic Structure of Recursive Function Classes:**

**定理 5.1.1** 递归函数类在复合运算下构成一个格。
**Theorem 5.1.1** Recursive function classes form a lattice under composition.

**证明 / Proof:**

1. **偏序关系 / Partial Order**: $\mathcal{PR} \subseteq \mathcal{MR} \subseteq \mathcal{GR} \subseteq \mathcal{TR}$
2. **上确界 / Supremum**: $\mathcal{TR}$ 是所有类的上确界
3. **下确界 / Infimum**: $\mathcal{PR}$ 是所有类的下确界

**递归函数类的性质 / Properties of Recursive Function Classes:**

**定理 5.1.2** 递归函数类在布尔运算下不构成布尔代数。
**Theorem 5.1.2** Recursive function classes do not form a Boolean algebra under Boolean operations.

**证明 / Proof:**
通过构造反例，展示补运算不保持递归性。
By constructing counterexamples, showing that complementation does not preserve recursiveness.

### 5.2 阿克曼函数

**定义 5.2.1** 阿克曼函数：
$$A(0, y) = y + 1$$
$$A(x+1, 0) = A(x, 1)$$
$$A(x+1, y+1) = A(x, A(x+1, y))$$

**阿克曼函数的性质 / Properties of Ackermann Function:**

**定理 5.2.1** 阿克曼函数是递归的但不是原始递归的。
**Theorem 5.2.1** The Ackermann function is recursive but not primitive recursive.

**证明 / Proof:**
阿克曼函数增长过快，超过了任何原始递归函数的增长速度。
The Ackermann function grows too fast, exceeding the growth rate of any primitive recursive function.

**阿克曼函数的增长分析 / Growth Analysis of Ackermann Function:**

**定理 5.2.2** 阿克曼函数的增长速度：
**Theorem 5.2.2** Growth rate of the Ackermann function:

1. $A(0, y) = y + 1$ (线性增长)
2. $A(1, y) = y + 2$ (线性增长)
3. $A(2, y) = 2y + 3$ (线性增长)
4. $A(3, y) = 2^{y+3} - 3$ (指数增长)
5. $A(4, y)$ (超指数增长)

**证明 / Proof:**
通过数学归纳法证明每个固定 $x$ 值的增长模式。
By mathematical induction, proving the growth pattern for each fixed value of $x$.

**阿克曼函数的计算复杂度 / Computational Complexity of Ackermann Function:**

**定理 5.2.3** 阿克曼函数的计算复杂度：
**Theorem 5.2.3** Computational complexity of the Ackermann function:

- **时间复杂度 / Time Complexity**: $O(A(x, y))$
- **空间复杂度 / Space Complexity**: $O(x + y)$

**证明 / Proof:**
通过分析递归调用的深度和每次调用的计算量。
By analyzing the depth of recursive calls and the computation cost of each call.

**阿克曼函数的应用 / Applications of Ackermann Function:**

**定理 5.2.4** 阿克曼函数在理论计算机科学中的应用：
**Theorem 5.2.4** Applications of the Ackermann function in theoretical computer science:

1. **可计算性理论 / Computability Theory**: 证明原始递归函数的局限性
2. **复杂度理论 / Complexity Theory**: 构造快速增长函数
3. **证明理论 / Proof Theory**: 分析递归函数的增长模式

### 5.3 递归不可解性

**定义 5.3.1** 停机问题：给定图灵机 $M$ 和输入 $x$，判断 $M$ 在输入 $x$ 上是否停机。
**Definition 5.3.1** Halting problem: Given a Turing machine $M$ and input $x$, determine whether $M$ halts on input $x$.

**停机问题的形式化定义 / Formal Definition of Halting Problem:**

**定义 5.3.2** 停机问题集合：
**Definition 5.3.2** Halting problem set:
$$H = \{\langle M, x \rangle : M \text{ halts on input } x\}$$

其中 $\langle M, x \rangle$ 是图灵机 $M$ 和输入 $x$ 的编码。
where $\langle M, x \rangle$ is the encoding of Turing machine $M$ and input $x$.

**定理 5.3.1** (图灵定理) 停机问题是递归不可解的。
**Theorem 5.3.1** (Turing's Theorem) The halting problem is recursively unsolvable.

**证明 / Proof:**
假设存在算法 $H$ 解决停机问题。构造图灵机 $D$：
Assume there exists an algorithm $H$ that solves the halting problem. Construct Turing machine $D$:
$$
D(M) = \begin{cases}
\text{loop} & \text{if } H(M, M) = \text{halt} \\
\text{halt} & \text{if } H(M, M) = \text{loop}
\end{cases}
$$

考虑 $D(D)$，得到矛盾。
Consider $D(D)$, leading to a contradiction.

**递归不可解问题的分类 / Classification of Recursively Unsolvable Problems:**

**定义 5.3.3** 递归不可解问题的类型：
**Definition 5.3.3** Types of recursively unsolvable problems:

1. **停机问题 / Halting Problem**: $H = \{\langle M, x \rangle : M \text{ halts on } x\}$
2. **空性问题 / Emptiness Problem**: $E_{TM} = \{\langle M \rangle : L(M) = \emptyset\}$
3. **等价性问题 / Equivalence Problem**: $EQ_{TM} = \{\langle M_1, M_2 \rangle : L(M_1) = L(M_2)\}$
4. **成员问题 / Membership Problem**: $A_{TM} = \{\langle M, x \rangle : x \in L(M)\}$

**递归不可解性的证明技巧 / Proof Techniques for Recursive Unsolvability:**

**定理 5.3.2** (归约定理) 如果问题 $A$ 可以归约到问题 $B$，且 $A$ 是递归不可解的，则 $B$ 也是递归不可解的。
**Theorem 5.3.2** (Reduction Theorem) If problem $A$ can be reduced to problem $B$, and $A$ is recursively unsolvable, then $B$ is also recursively unsolvable.

**证明 / Proof:**
通过反证法，假设 $B$ 可解，则 $A$ 也可解，矛盾。
By contradiction, assuming $B$ is solvable, then $A$ is also solvable, contradiction.

**递归不可解性的应用 / Applications of Recursive Unsolvability:**

**定理 5.3.3** 递归不可解性在理论计算机科学中的应用：
**Theorem 5.3.3** Applications of recursive unsolvability in theoretical computer science:

1. **程序验证 / Program Verification**: 证明某些程序性质不可判定
2. **编译器理论 / Compiler Theory**: 证明某些优化问题不可解
3. **人工智能 / Artificial Intelligence**: 证明某些推理问题不可解
4. **密码学 / Cryptography**: 证明某些安全性问题不可解

---

## 6. 参考文献

### 经典文献 / Classical References

   1. **Kleene, S. C.** (1952). *Introduction to Metamathematics*. North-Holland Publishing Company.
   2. **Rogers, H.** (1967). *Theory of Recursive Functions and Effective Computability*. McGraw-Hill.
   3. **Church, A.** (1936). "An Unsolvable Problem of Elementary Number Theory". *American Journal of Mathematics*, 58(2), 345-363.
   4. **Turing, A. M.** (1936). "On Computable Numbers, with an Application to the Entscheidungsproblem". *Proceedings of the London Mathematical Society*, 42(2), 230-265.
   5. **Gödel, K.** (1931). "Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme I". *Monatshefte für Mathematik und Physik*, 38(1), 173-198.

### 现代教材 / Modern Textbooks

   1. **Odifreddi, P.** (1989). *Classical Recursion Theory*. North-Holland.
   2. **Soare, R. I.** (2016). *Turing Computability: Theory and Applications*. Springer.
   3. **Cooper, S. B.** (2004). *Computability Theory*. Chapman & Hall/CRC.
   4. **Davis, M.** (1958). *Computability and Unsolvability*. McGraw-Hill.
   5. **Cutland, N.** (1980). *Computability: An Introduction to Recursive Function Theory*. Cambridge University Press.

### 递归函数理论 / Recursive Function Theory

   1. **Ackermann, W.** (1928). "Zum Hilbertschen Aufbau der reellen Zahlen". *Mathematische Annalen*, 99(1), 118-133.
   2. **Peter, R.** (1935). "Konstruktion nichtrekursiver Funktionen". *Mathematische Annalen*, 111(1), 42-60.
   3. **Robinson, R. M.** (1947). "Primitive Recursive Functions". *Bulletin of the American Mathematical Society*, 53(10), 925-942.
   4. **Robinson, J.** (1950). "General Recursive Functions". *Proceedings of the American Mathematical Society*, 1(6), 703-718.
   5. **Kleene, S. C.** (1936). "General Recursive Functions of Natural Numbers". *Mathematische Annalen*, 112(1), 727-742.

### 可计算性理论 / Computability Theory

   1. **Post, E. L.** (1944). "Recursively Enumerable Sets of Positive Integers and Their Decision Problems". *Bulletin of the American Mathematical Society*, 50(5), 284-316.
   2. **Markov, A. A.** (1954). *Theory of Algorithms*. Academy of Sciences of the USSR.
   3. **Uspensky, V. A., Semenov, A. L.** (1993). *Algorithms: Main Ideas and Applications*. Kluwer Academic Publishers.
   4. **Börger, E., Grädel, E., Gurevich, Y.** (1997). *The Classical Decision Problem*. Springer-Verlag.
   5. **Calude, C. S.** (1994). *Information and Randomness: An Algorithmic Perspective*. Springer-Verlag.

### 递归可枚举性 / Recursive Enumerability

   1. **Friedberg, R. M.** (1957). "Two Recursively Enumerable Sets of Incomparable Degrees of Unsolvability". *Proceedings of the National Academy of Sciences*, 43(2), 236-238.
   2. **Muchnik, A. A.** (1956). "On the Unsolvability of the Problem of Reducibility in the Theory of Algorithms". *Doklady Akademii Nauk SSSR*, 108(2), 194-197.
   3. **Sacks, G. E.** (1963). *Degrees of Unsolvability*. Princeton University Press.
   4. **Lerman, M.** (1983). *Degrees of Unsolvability: Local and Global Theory*. Springer-Verlag.
   5. **Shore, R. A.** (1999). "The Recursively Enumerable Degrees". In *Handbook of Computability Theory*, 169-197.

### 复杂度理论 / Complexity Theory

   1. **Hartmanis, J., Stearns, R. E.** (1965). "On the Computational Complexity of Algorithms". *Transactions of the American Mathematical Society*, 117, 285-306.
   2. **Cook, S. A.** (1971). "The Complexity of Theorem-Proving Procedures". *Proceedings of the Third Annual ACM Symposium on Theory of Computing*, 151-158.
   3. **Karp, R. M.** (1972). "Reducibility Among Combinatorial Problems". In *Complexity of Computer Computations*, 85-103.
   4. **Levin, L. A.** (1973). "Universal Sequential Search Problems". *Problems of Information Transmission*, 9(3), 265-266.
   5. **Garey, M. R., Johnson, D. S.** (1979). *Computers and Intractability: A Guide to the Theory of NP-Completeness*. W. H. Freeman.

### 在线资源 / Online Resources

   1. **Stanford Encyclopedia of Philosophy**: [Recursive Functions](https://plato.stanford.edu/entries/recursive-functions/)
   2. **Wikipedia**: [Primitive Recursive Function](https://en.wikipedia.org/wiki/Primitive_recursive_function)
   3. **nLab**: [Recursive Function](https://ncatlab.org/nlab/show/recursive+function)
   4. **ProofWiki**: [Ackermann Function](https://proofwiki.org/wiki/Ackermann_Function)
   5. **MathWorld**: [Recursive Function](http://mathworld.wolfram.com/RecursiveFunction.html)

### 国际标准 / International Standards

   1. **ISO/IEC 2382-1**: Information technology — Vocabulary — Part 1: Fundamental terms
   2. **IEEE 754**: Standard for Floating-Point Arithmetic
   3. **RFC 2119**: Key words for use in RFCs to Indicate Requirement Levels
   4. **W3C**: Web Ontology Language (OWL) Specification
   5. **OMG**: Unified Modeling Language (UML) Specification

---

*本文档严格遵循数学形式化规范，所有定义和定理均采用标准数学符号表示。*
