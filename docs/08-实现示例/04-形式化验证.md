---
title: 8.4 å½¢å¼åŒ–éªŒè¯ / Formal Verification
version: 1.0
status: maintained
last_updated: 2025-01-11
owner: å®ç°ç¤ºä¾‹å·¥ä½œç»„
---

> ğŸ“Š **é¡¹ç›®å…¨é¢æ¢³ç†**ï¼šè¯¦ç»†çš„é¡¹ç›®ç»“æ„ã€æ¨¡å—è¯¦è§£å’Œå­¦ä¹ è·¯å¾„ï¼Œè¯·å‚é˜… [`é¡¹ç›®å…¨é¢æ¢³ç†-2025.md`](../é¡¹ç›®å…¨é¢æ¢³ç†-2025.md)

## 8.4 å½¢å¼åŒ–éªŒè¯ / Formal Verification

> è¯´æ˜ï¼šæœ¬æ–‡ä»¶ä¸­çš„å·¥å…·ä¸ CI é…ç½®ä»…ç”¨äºçŸ¥è¯†å±•ç¤ºä¸æ¦‚å¿µè¯´æ˜ï¼Œå½“å‰ä»“åº“ä¸åŒ…å«å®é™… CI å·¥ä½œæµä¸å¯è¿è¡Œå·¥ç¨‹éª¨æ¶ã€‚è‹¥éœ€å·¥ç¨‹åŒ–æ¼”ç¤ºï¼Œè¯·åœ¨æœ¬åœ°æŒ‰ç¤ºä¾‹ç‰‡æ®µè‡ªè¡Œåˆ›å»ºæœ€å°é¡¹ç›®ã€‚

### æ‘˜è¦ / Executive Summary

- ç»Ÿä¸€å½¢å¼åŒ–éªŒè¯çš„å®ç°æ–¹æ³•ä¸å·¥å…·ä½¿ç”¨è§„èŒƒã€‚
- å»ºç«‹å½¢å¼åŒ–éªŒè¯åœ¨ç®—æ³•å·¥ç¨‹ä¸­çš„å®è·µåœ°ä½ã€‚

### å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary

- å½¢å¼åŒ–éªŒè¯ã€å®šç†è¯æ˜ã€æ¨¡å‹æ£€æŸ¥ã€é™æ€åˆ†æã€éªŒè¯å·¥å…·ã€CI/CDã€‚
- æœ¯è¯­å¯¹é½ä¸å¼•ç”¨è§„èŒƒï¼š`docs/æœ¯è¯­ä¸ç¬¦å·æ€»è¡¨.md`ï¼Œ`01-åŸºç¡€ç†è®º/00-æ’°å†™è§„èŒƒä¸å¼•ç”¨æŒ‡å—.md`

### æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology & Notation

- å½¢å¼åŒ–éªŒè¯ï¼ˆFormal Verificationï¼‰ï¼šä½¿ç”¨å½¢å¼åŒ–æ–¹æ³•éªŒè¯ç¨‹åºæ­£ç¡®æ€§ã€‚
- å®šç†è¯æ˜ï¼ˆTheorem Provingï¼‰ï¼šä½¿ç”¨é€»è¾‘æ¨ç†è¯æ˜å®šç†ã€‚
- æ¨¡å‹æ£€æŸ¥ï¼ˆModel Checkingï¼‰ï¼šé€šè¿‡ç©·ä¸¾æœç´¢éªŒè¯ç³»ç»Ÿæ€§è´¨ã€‚
- é™æ€åˆ†æï¼ˆStatic Analysisï¼‰ï¼šåœ¨ä¸è¿è¡Œç¨‹åºçš„æƒ…å†µä¸‹åˆ†æç¨‹åºã€‚
- è®°å·çº¦å®šï¼š`P` è¡¨ç¤ºå‰ç½®æ¡ä»¶ï¼Œ`Q` è¡¨ç¤ºåç½®æ¡ä»¶ï¼Œ`âŠ¢` è¡¨ç¤ºå¯è¯æ˜ã€‚

### äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References

- ç®—æ³•éªŒè¯ï¼šå‚è§ `09-ç®—æ³•ç†è®º/04-é«˜çº§ç®—æ³•ç†è®º/03-ç®—æ³•éªŒè¯ç†è®º.md`ã€‚
- è¯æ˜ç³»ç»Ÿï¼šå‚è§ `03-å½¢å¼åŒ–è¯æ˜/01-è¯æ˜ç³»ç»Ÿ.md`ã€‚
- å®ç°ç¤ºä¾‹ï¼šå‚è§ `08-å®ç°ç¤ºä¾‹/` ç›¸å…³æ–‡æ¡£ã€‚

### å¿«é€Ÿå¯¼èˆª / Quick Links

- åŸºæœ¬æ¦‚å¿µ
- éªŒè¯æ–¹æ³•
- å·¥å…·ä½¿ç”¨

## ç›®å½• (Table of Contents)

- [8.4 å½¢å¼åŒ–éªŒè¯ / Formal Verification](#84-å½¢å¼åŒ–éªŒè¯--formal-verification)
  - [æ‘˜è¦ / Executive Summary](#æ‘˜è¦--executive-summary)
  - [å…³é”®æœ¯è¯­ä¸ç¬¦å· / Glossary](#å…³é”®æœ¯è¯­ä¸ç¬¦å·--glossary)
  - [æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ / Terminology \& Notation](#æœ¯è¯­ä¸ç¬¦å·è§„èŒƒ--terminology--notation)
  - [äº¤å‰å¼•ç”¨å¯¼èˆª / Cross-References](#äº¤å‰å¼•ç”¨å¯¼èˆª--cross-references)
  - [å¿«é€Ÿå¯¼èˆª / Quick Links](#å¿«é€Ÿå¯¼èˆª--quick-links)
- [ç›®å½• (Table of Contents)](#ç›®å½•-table-of-contents)
- [4.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)](#41-åŸºæœ¬æ¦‚å¿µ-basic-concepts)
  - [4.1.1 å½¢å¼åŒ–éªŒè¯å®šä¹‰ (Definition of Formal Verification)](#411-å½¢å¼åŒ–éªŒè¯å®šä¹‰-definition-of-formal-verification)
  - [4.1.2 éªŒè¯æ–¹æ³•åˆ†ç±» (Classification of Verification Methods)](#412-éªŒè¯æ–¹æ³•åˆ†ç±»-classification-of-verification-methods)
  - [4.1.3 éªŒè¯å±‚æ¬¡ (Verification Levels)](#413-éªŒè¯å±‚æ¬¡-verification-levels)
- [4.2 éªŒè¯æ–¹æ³• (Verification Methods)](#42-éªŒè¯æ–¹æ³•-verification-methods)
  - [4.2.1 å®šç†è¯æ˜ (Theorem Proving)](#421-å®šç†è¯æ˜-theorem-proving)
  - [4.2.2 æ¨¡å‹æ£€æŸ¥ (Model Checking)](#422-æ¨¡å‹æ£€æŸ¥-model-checking)
  - [4.2.3 æŠ½è±¡è§£é‡Š (Abstract Interpretation)](#423-æŠ½è±¡è§£é‡Š-abstract-interpretation)
- [4.3 å·¥å…·ç³»ç»Ÿ (Tool Systems)](#43-å·¥å…·ç³»ç»Ÿ-tool-systems)
  - [4.3.1 å®šç†è¯æ˜å™¨ (Theorem Provers)](#431-å®šç†è¯æ˜å™¨-theorem-provers)
  - [4.3.2 æ¨¡å‹æ£€æŸ¥å™¨ (Model Checkers)](#432-æ¨¡å‹æ£€æŸ¥å™¨-model-checkers)
  - [4.3.3 é™æ€åˆ†æå·¥å…· (Static Analysis Tools)](#433-é™æ€åˆ†æå·¥å…·-static-analysis-tools)
- [4.4 å®ç°ç¤ºä¾‹ (Implementation Examples)](#44-å®ç°ç¤ºä¾‹-implementation-examples)
  - [4.4.1 ç¨‹åºæ­£ç¡®æ€§éªŒè¯ (Program Correctness Verification)](#441-ç¨‹åºæ­£ç¡®æ€§éªŒè¯-program-correctness-verification)
  - [4.4.2 å®‰å…¨å±æ€§éªŒè¯ (Safety Property Verification)](#442-å®‰å…¨å±æ€§éªŒè¯-safety-property-verification)
  - [4.4.3 å½¢å¼åŒ–éªŒè¯æµ‹è¯• (Formal Verification Testing)](#443-å½¢å¼åŒ–éªŒè¯æµ‹è¯•-formal-verification-testing)
- [4.5 å‚è€ƒæ–‡çŒ® / References](#45-å‚è€ƒæ–‡çŒ®--references)
  - [å½¢å¼åŒ–éªŒè¯æ–¹æ³• / Formal Verification Methods](#å½¢å¼åŒ–éªŒè¯æ–¹æ³•--formal-verification-methods)
  - [å®šç†è¯æ˜å·¥å…· / Theorem Proving Tools](#å®šç†è¯æ˜å·¥å…·--theorem-proving-tools)
  - [å…¶ä»–ç›¸å…³æ–‡çŒ® / Other Related Literature](#å…¶ä»–ç›¸å…³æ–‡çŒ®--other-related-literature)
- [4.6 CIé›†æˆä¸è‡ªåŠ¨éªŒè¯ï¼ˆGitHub Actionsï¼‰](#46-cié›†æˆä¸è‡ªåŠ¨éªŒè¯github-actions)
  - [4.6.1 Rust å·¥ä½œæµï¼ˆci-rust.ymlï¼‰](#461-rust-å·¥ä½œæµci-rustyml)
  - [4.6.2 Haskell å·¥ä½œæµï¼ˆci-hs.ymlï¼‰](#462-haskell-å·¥ä½œæµci-hsyml)
  - [4.6.3 Lean 4 å·¥ä½œæµï¼ˆci-lean.ymlï¼‰](#463-lean-4-å·¥ä½œæµci-leanyml)

---

## 4.1 åŸºæœ¬æ¦‚å¿µ (Basic Concepts)

### 4.1.1 å½¢å¼åŒ–éªŒè¯å®šä¹‰ (Definition of Formal Verification)

**å½¢å¼åŒ–éªŒè¯å®šä¹‰ / Definition of Formal Verification:**

å½¢å¼åŒ–éªŒè¯æ˜¯ä½¿ç”¨æ•°å­¦æ–¹æ³•è¯æ˜è½¯ä»¶æˆ–ç¡¬ä»¶ç³»ç»Ÿæ»¡è¶³å…¶è§„èŒƒçš„è¿‡ç¨‹ã€‚

Formal verification is the process of using mathematical methods to prove that software or hardware systems satisfy their specifications.

**éªŒè¯ç›®æ ‡ / Verification Goals:**

1. **æ­£ç¡®æ€§ (Correctness) / Correctness:**
   - ç³»ç»Ÿè¡Œä¸ºç¬¦åˆè§„èŒƒ / System behavior conforms to specification
   - æ— é”™è¯¯æ‰§è¡Œ / Error-free execution

2. **å®‰å…¨æ€§ (Safety) / Safety:**
   - ç³»ç»Ÿä¸ä¼šè¿›å…¥å±é™©çŠ¶æ€ / System does not enter dangerous states
   - å…³é”®å±æ€§å¾—åˆ°ä¿è¯ / Critical properties are guaranteed

3. **å¯é æ€§ (Reliability) / Reliability:**
   - ç³»ç»Ÿåœ¨é¢„æœŸæ¡ä»¶ä¸‹æ­£å¸¸å·¥ä½œ / System works correctly under expected conditions
   - æ•…éšœå®¹é”™èƒ½åŠ› / Fault tolerance

### 4.1.2 éªŒè¯æ–¹æ³•åˆ†ç±» (Classification of Verification Methods)

**é™æ€éªŒè¯ (Static Verification) / Static Verification:**

åœ¨ç¨‹åºæ‰§è¡Œå‰è¿›è¡Œçš„éªŒè¯ï¼ŒåŒ…æ‹¬ç±»å‹æ£€æŸ¥ã€é™æ€åˆ†æç­‰ã€‚

Verification performed before program execution, including type checking, static analysis, etc.

**åŠ¨æ€éªŒè¯ (Dynamic Verification) / Dynamic Verification:**

åœ¨ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­è¿›è¡Œçš„éªŒè¯ï¼ŒåŒ…æ‹¬æµ‹è¯•ã€è¿è¡Œæ—¶æ£€æŸ¥ç­‰ã€‚

Verification performed during program execution, including testing, runtime checking, etc.

**å½¢å¼åŒ–éªŒè¯ (Formal Verification) / Formal Verification:**

ä½¿ç”¨æ•°å­¦æ–¹æ³•è¿›è¡Œçš„ä¸¥æ ¼éªŒè¯ï¼ŒåŒ…æ‹¬æ¨¡å‹æ£€æŸ¥ã€å®šç†è¯æ˜ç­‰ã€‚

Strict verification using mathematical methods, including model checking, theorem proving, etc.

### 4.1.3 éªŒè¯å±‚æ¬¡ (Verification Levels)

**ç³»ç»Ÿçº§éªŒè¯ (System-Level Verification) / System-Level Verification:**

éªŒè¯æ•´ä¸ªç³»ç»Ÿçš„è¡Œä¸ºæ˜¯å¦ç¬¦åˆè§„èŒƒã€‚

Verifying that the entire system behavior conforms to specifications.

**ç»„ä»¶çº§éªŒè¯ (Component-Level Verification) / Component-Level Verification:**

éªŒè¯ç³»ç»Ÿç»„ä»¶çš„æ­£ç¡®æ€§ã€‚

Verifying the correctness of system components.

**ä»£ç çº§éªŒè¯ (Code-Level Verification) / Code-Level Verification:**

éªŒè¯å…·ä½“ä»£ç å®ç°çš„æ­£ç¡®æ€§ã€‚

Verifying the correctness of specific code implementations.

---

## 4.2 éªŒè¯æ–¹æ³• (Verification Methods)

### 4.2.1 å®šç†è¯æ˜ (Theorem Proving)

**å®šç†è¯æ˜å®šä¹‰ / Definition of Theorem Proving:**

ä½¿ç”¨é€»è¾‘æ¨ç†è¯æ˜ç¨‹åºæ»¡è¶³å…¶è§„èŒƒçš„è¿‡ç¨‹ã€‚

The process of using logical reasoning to prove that programs satisfy their specifications.

**å®šç†è¯æ˜ç³»ç»Ÿ / Theorem Proving Systems:**

```lean
-- å®šç†è¯æ˜ç¤ºä¾‹ / Theorem Proving Example
theorem add_comm (a b : Nat) : a + b = b + a := by
  induction a with
  | zero => simp
  | succ a ih => simp [Nat.succ_add, ih]

-- ç¨‹åºæ­£ç¡®æ€§è¯æ˜ / Program Correctness Proof
def factorial : Nat â†’ Nat
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

theorem factorial_correct (n : Nat) : factorial n > 0 := by
  induction n with
  | zero => simp [factorial]
  | succ n ih => simp [factorial, Nat.mul_pos]
```

### 4.2.2 æ¨¡å‹æ£€æŸ¥ (Model Checking)

**æ¨¡å‹æ£€æŸ¥å®šä¹‰ / Definition of Model Checking:**

é€šè¿‡ç©·ä¸¾æœç´¢éªŒè¯æœ‰é™çŠ¶æ€ç³»ç»Ÿæ˜¯å¦æ»¡è¶³æ—¶æ€é€»è¾‘è§„èŒƒã€‚

Verifying finite state systems against temporal logic specifications through exhaustive search.

**æ¨¡å‹æ£€æŸ¥ç¤ºä¾‹ / Model Checking Example:**

```rust
/// æ¨¡å‹æ£€æŸ¥å®ç° / Model Checking Implementation
pub struct ModelChecker<S, P> {
    states: Vec<S>,
    transitions: HashMap<S, Vec<S>>,
    properties: Vec<P>,
}

impl<S: Clone + Eq + Hash, P> ModelChecker<S, P> {
    /// åˆ›å»ºæ–°çš„æ¨¡å‹æ£€æŸ¥å™¨ / Create new model checker
    pub fn new() -> Self {
        ModelChecker {
            states: Vec::new(),
            transitions: HashMap::new(),
            properties: Vec::new(),
        }
    }

    /// æ·»åŠ çŠ¶æ€ / Add state
    pub fn add_state(&mut self, state: S) {
        self.states.push(state);
    }

    /// æ·»åŠ è½¬æ¢ / Add transition
    pub fn add_transition(&mut self, from: S, to: S) {
        self.transitions.entry(from).or_insert_with(Vec::new).push(to);
    }

    /// æ£€æŸ¥å¯è¾¾æ€§ / Check reachability
    pub fn check_reachability(&self, start: &S, target: &S) -> bool {
        let mut visited = HashSet::new();
        let mut queue = VecDeque::new();
        queue.push_back(start.clone());
        visited.insert(start.clone());

        while let Some(current) = queue.pop_front() {
            if current == *target {
                return true;
            }

            if let Some(neighbors) = self.transitions.get(&current) {
                for neighbor in neighbors {
                    if !visited.contains(neighbor) {
                        visited.insert(neighbor.clone());
                        queue.push_back(neighbor.clone());
                    }
                }
            }
        }
        false
    }

    /// æ£€æŸ¥å®‰å…¨æ€§ / Check safety
    pub fn check_safety(&self, start: &S, bad_states: &[S]) -> bool {
        for bad_state in bad_states {
            if self.check_reachability(start, bad_state) {
                return false;
            }
        }
        true
    }
}
```

### 4.2.3 æŠ½è±¡è§£é‡Š (Abstract Interpretation)

**æŠ½è±¡è§£é‡Šå®šä¹‰ / Definition of Abstract Interpretation:**

é€šè¿‡æŠ½è±¡åŸŸåˆ†æç¨‹åºè¡Œä¸ºï¼Œæä¾›ç¨‹åºå±æ€§çš„ä¿å®ˆè¿‘ä¼¼ã€‚

Analyzing program behavior through abstract domains, providing conservative approximations of program properties.

**æŠ½è±¡è§£é‡Šç¤ºä¾‹ / Abstract Interpretation Example:**

```rust
/// æŠ½è±¡è§£é‡Šå®ç° / Abstract Interpretation Implementation
pub trait AbstractDomain {
    type Element;
    fn bottom() -> Self;
    fn top() -> Self;
    fn join(&self, other: &Self) -> Self;
    fn meet(&self, other: &Self) -> Self;
    fn leq(&self, other: &Self) -> bool;
}

/// åŒºé—´æŠ½è±¡åŸŸ / Interval Abstract Domain
#[derive(Debug, Clone, PartialEq)]
pub struct Interval {
    pub lower: Option<i32>,
    pub upper: Option<i32>,
}

impl AbstractDomain for Interval {
    type Element = i32;

    fn bottom() -> Self {
        Interval {
            lower: Some(1),
            upper: Some(0), // ç©ºåŒºé—´ / Empty interval
        }
    }

    fn top() -> Self {
        Interval {
            lower: None,
            upper: None,
        }
    }

    fn join(&self, other: &Self) -> Self {
        let lower = match (self.lower, other.lower) {
            (Some(a), Some(b)) => Some(a.min(b)),
            (Some(a), None) => Some(a),
            (None, Some(b)) => Some(b),
            (None, None) => None,
        };

        let upper = match (self.upper, other.upper) {
            (Some(a), Some(b)) => Some(a.max(b)),
            (Some(a), None) => Some(a),
            (None, Some(b)) => Some(b),
            (None, None) => None,
        };

        Interval { lower, upper }
    }

    fn meet(&self, other: &Self) -> Self {
        let lower = match (self.lower, other.lower) {
            (Some(a), Some(b)) => Some(a.max(b)),
            _ => None,
        };

        let upper = match (self.upper, other.upper) {
            (Some(a), Some(b)) => Some(a.min(b)),
            _ => None,
        };

        Interval { lower, upper }
    }

    fn leq(&self, other: &Self) -> bool {
        match (self.lower, other.lower) {
            (Some(a), Some(b)) if a < b => false,
            _ => match (self.upper, other.upper) {
                (Some(a), Some(b)) if a > b => false,
                _ => true,
            },
        }
    }
}

/// æŠ½è±¡è§£é‡Šå™¨ / Abstract Interpreter
pub struct AbstractInterpreter<D: AbstractDomain> {
    domain: std::marker::PhantomData<D>,
}

impl<D: AbstractDomain> AbstractInterpreter<D> {
    /// åˆ†æè¡¨è¾¾å¼ / Analyze expression
    pub fn analyze_expression(&self, expr: &Expression) -> D {
        match expr {
            Expression::Constant(n) => {
                // å…·ä½“å®ç° / Concrete implementation
                D::bottom()
            }
            Expression::Variable(_) => D::top(),
            Expression::BinaryOp(_, left, right) => {
                let left_val = self.analyze_expression(left);
                let right_val = self.analyze_expression(right);
                left_val.join(&right_val)
            }
        }
    }
}

#[derive(Debug)]
pub enum Expression {
    Constant(i32),
    Variable(String),
    BinaryOp(String, Box<Expression>, Box<Expression>),
}
```

---

## 4.3 å·¥å…·ç³»ç»Ÿ (Tool Systems)

### 4.3.1 å®šç†è¯æ˜å™¨ (Theorem Provers)

**Coqå®šç†è¯æ˜å™¨ / Coq Theorem Prover:**

```coq
(* Coqå®šç†è¯æ˜ç¤ºä¾‹ / Coq Theorem Proving Example *)
Theorem add_comm : forall n m : nat, n + m = m + n.
Proof.
  intros n m.
  induction n as [|n IHn].
  - simpl. rewrite plus_0_r. reflexivity.
  - simpl. rewrite IHn. rewrite plus_Sn_m. reflexivity.
Qed.

(* ç¨‹åºæ­£ç¡®æ€§è¯æ˜ / Program Correctness Proof *)
Fixpoint factorial (n : nat) : nat :=
  match n with
  | 0 => 1
  | S n' => n * factorial n'
  end.

Theorem factorial_positive : forall n : nat, factorial n > 0.
Proof.
  induction n as [|n IHn].
  - simpl. apply gt_Sn_O.
  - simpl. apply mult_gt_0.
    + apply IHn.
    + apply gt_Sn_O.
Qed.
```

**Isabelleå®šç†è¯æ˜å™¨ / Isabelle Theorem Prover:**

```isabelle
(* Isabelleå®šç†è¯æ˜ç¤ºä¾‹ / Isabelle Theorem Proving Example *)
lemma add_comm: "n + m = m + (n::nat)"
  by (induct n) simp_all

lemma factorial_positive: "factorial n > (0::nat)"
  by (induct n) (simp_all add: mult_gt_0)

(* ç¨‹åºéªŒè¯ / Program Verification *)
fun factorial :: "nat â‡’ nat" where
  "factorial 0 = 1"
| "factorial (Suc n) = Suc n * factorial n"

lemma factorial_correct: "factorial n > 0"
  by (induct n) simp_all
```

### 4.3.2 æ¨¡å‹æ£€æŸ¥å™¨ (Model Checkers)

**SPINæ¨¡å‹æ£€æŸ¥å™¨ / SPIN Model Checker:**

```promela
/* SPINæ¨¡å‹æ£€æŸ¥ç¤ºä¾‹ / SPIN Model Checking Example */
mtype = { request, grant, release };

chan channel = [1] of { mtype };

active proctype Client() {
    do
    :: channel ! request;
       channel ? grant;
       /* ä¸´ç•ŒåŒº / Critical section */
       channel ! release
    od
}

active proctype Server() {
    bool busy = false;
    do
    :: channel ? request;
       if
       :: !busy ->
          busy = true;
          channel ! grant;
          channel ? release;
          busy = false
       :: busy ->
          /* æ‹’ç»è¯·æ±‚ / Reject request */
          skip
       fi
    od
}

/* å®‰å…¨æ€§å±æ€§ / Safety Property */
ltl safety { [] (busy -> [] !busy) }
```

**NuSMVæ¨¡å‹æ£€æŸ¥å™¨ / NuSMV Model Checker:**

```smv
-- NuSMVæ¨¡å‹æ£€æŸ¥ç¤ºä¾‹ / NuSMV Model Checking Example
MODULE main
VAR
  state : {idle, busy, error};
  request : boolean;
  grant : boolean;

ASSIGN
  init(state) := idle;
  init(request) := FALSE;
  init(grant) := FALSE;

  next(state) := case
    state = idle & request : busy;
    state = busy & grant : idle;
    state = busy & !grant : error;
    TRUE : state;
  esac;

  next(request) := case
    state = idle : {TRUE, FALSE};
    TRUE : request;
  esac;

  next(grant) := case
    state = busy : {TRUE, FALSE};
    TRUE : grant;
  esac;

-- å®‰å…¨æ€§è§„èŒƒ / Safety Specification
SPEC AG (state = busy -> AF state = idle)
SPEC AG (state = error -> AG state = error)
```

### 4.3.3 é™æ€åˆ†æå·¥å…· (Static Analysis Tools)

**é™æ€åˆ†æå™¨å®ç° / Static Analyzer Implementation:**

```rust
/// é™æ€åˆ†æå™¨ / Static Analyzer
pub struct StaticAnalyzer {
    cfg: ControlFlowGraph,
    analysis_results: HashMap<String, AnalysisResult>,
}

impl StaticAnalyzer {
    /// åˆ›å»ºæ–°çš„é™æ€åˆ†æå™¨ / Create new static analyzer
    pub fn new(cfg: ControlFlowGraph) -> Self {
        StaticAnalyzer {
            cfg,
            analysis_results: HashMap::new(),
        }
    }

    /// æ•°æ®æµåˆ†æ / Data Flow Analysis
    pub fn data_flow_analysis(&mut self) -> HashMap<String, AnalysisResult> {
        let mut results = HashMap::new();

        // åˆå§‹åŒ– / Initialization
        for node in &self.cfg.nodes {
            results.insert(node.id.clone(), AnalysisResult::new());
        }

        // è¿­ä»£åˆ†æ / Iterative analysis
        let mut changed = true;
        while changed {
            changed = false;
            for node in &self.cfg.nodes {
                let old_result = results.get(&node.id).unwrap().clone();
                let new_result = self.analyze_node(node, &results);

                if new_result != old_result {
                    results.insert(node.id.clone(), new_result);
                    changed = true;
                }
            }
        }

        results
    }

    /// åˆ†æèŠ‚ç‚¹ / Analyze node
    fn analyze_node(&self, node: &CFGNode, results: &HashMap<String, AnalysisResult>) -> AnalysisResult {
        // å…·ä½“åˆ†æé€»è¾‘ / Concrete analysis logic
        AnalysisResult::new()
    }

    /// æ£€æµ‹æ­»ä»£ç  / Detect dead code
    pub fn detect_dead_code(&self) -> Vec<String> {
        let mut dead_code = Vec::new();

        for node in &self.cfg.nodes {
            if !self.is_reachable(node) {
                dead_code.push(node.id.clone());
            }
        }

        dead_code
    }

    /// æ£€æµ‹æœªåˆå§‹åŒ–å˜é‡ / Detect uninitialized variables
    pub fn detect_uninitialized_variables(&self) -> Vec<String> {
        let mut uninitialized = Vec::new();

        // åˆ†æå˜é‡ä½¿ç”¨ / Analyze variable usage
        for node in &self.cfg.nodes {
            for var in &node.used_variables {
                if !self.is_initialized(var, node) {
                    uninitialized.push(var.clone());
                }
            }
        }

        uninitialized
    }
}

/// æ§åˆ¶æµå›¾ / Control Flow Graph
pub struct ControlFlowGraph {
    pub nodes: Vec<CFGNode>,
    pub edges: Vec<CFGEdge>,
}

#[derive(Debug, Clone)]
pub struct CFGNode {
    pub id: String,
    pub statements: Vec<Statement>,
    pub used_variables: Vec<String>,
    pub defined_variables: Vec<String>,
}

#[derive(Debug)]
pub struct CFGEdge {
    pub from: String,
    pub to: String,
    pub condition: Option<Expression>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct AnalysisResult {
    pub reaching_definitions: HashSet<String>,
    pub live_variables: HashSet<String>,
    pub available_expressions: HashSet<String>,
}

impl AnalysisResult {
    fn new() -> Self {
        AnalysisResult {
            reaching_definitions: HashSet::new(),
            live_variables: HashSet::new(),
            available_expressions: HashSet::new(),
        }
    }
}

#[derive(Debug)]
pub enum Statement {
    Assignment(String, Expression),
    If(Expression, Vec<Statement>, Vec<Statement>),
    While(Expression, Vec<Statement>),
    Call(String, Vec<Expression>),
}

#[derive(Debug)]
pub enum Expression {
    Variable(String),
    Constant(i32),
    BinaryOp(String, Box<Expression>, Box<Expression>),
}
```

---

## 4.4 å®ç°ç¤ºä¾‹ (Implementation Examples)

### 4.4.1 ç¨‹åºæ­£ç¡®æ€§éªŒè¯ (Program Correctness Verification)

```rust
/// ç¨‹åºæ­£ç¡®æ€§éªŒè¯ / Program Correctness Verification
pub struct ProgramVerifier {
    specifications: HashMap<String, Specification>,
    implementations: HashMap<String, Implementation>,
}

impl ProgramVerifier {
    /// éªŒè¯æ’åºç®—æ³• / Verify sorting algorithm
    pub fn verify_sorting_algorithm(&self, algorithm: &str) -> VerificationResult {
        let spec = self.specifications.get(algorithm).unwrap();
        let impl = self.implementations.get(algorithm).unwrap();

        // éªŒè¯æ’åºæ­£ç¡®æ€§ / Verify sorting correctness
        let correctness = self.verify_sorting_correctness(spec, impl);

        // éªŒè¯æ’åºç¨³å®šæ€§ / Verify sorting stability
        let stability = self.verify_sorting_stability(spec, impl);

        // éªŒè¯æ—¶é—´å¤æ‚åº¦ / Verify time complexity
        let complexity = self.verify_time_complexity(spec, impl);

        VerificationResult {
            algorithm: algorithm.to_string(),
            correctness,
            stability,
            complexity,
        }
    }

    /// éªŒè¯æ’åºæ­£ç¡®æ€§ / Verify sorting correctness
    fn verify_sorting_correctness(&self, spec: &Specification, impl: &Implementation) -> bool {
        // ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ / Generate test cases
        let test_cases = self.generate_test_cases();

        for test_case in test_cases {
            let input = test_case.input;
            let expected = spec.sort(&input);
            let actual = impl.sort(&input);

            if !self.is_sorted(&actual) || actual != expected {
                return false;
            }
        }

        true
    }

    /// éªŒè¯æ’åºç¨³å®šæ€§ / Verify sorting stability
    fn verify_sorting_stability(&self, spec: &Specification, impl: &Implementation) -> bool {
        // ç”ŸæˆåŒ…å«é‡å¤å…ƒç´ çš„æµ‹è¯•ç”¨ä¾‹ / Generate test cases with duplicate elements
        let test_cases = self.generate_stability_test_cases();

        for test_case in test_cases {
            let input = test_case.input;
            let result = impl.sort(&input);

            if !self.is_stable_sort(&input, &result) {
                return false;
            }
        }

        true
    }

    /// éªŒè¯æ—¶é—´å¤æ‚åº¦ / Verify time complexity
    fn verify_time_complexity(&self, spec: &Specification, impl: &Implementation) -> bool {
        // åˆ†æç®—æ³•å¤æ‚åº¦ / Analyze algorithm complexity
        let complexity = self.analyze_complexity(impl);
        let expected_complexity = spec.expected_complexity();

        complexity == expected_complexity
    }

    /// æ£€æŸ¥æ˜¯å¦å·²æ’åº / Check if sorted
    fn is_sorted(&self, list: &[i32]) -> bool {
        for i in 1..list.len() {
            if list[i-1] > list[i] {
                return false;
            }
        }
        true
    }

    /// æ£€æŸ¥æ˜¯å¦ç¨³å®šæ’åº / Check if stable sort
    fn is_stable_sort(&self, original: &[i32], sorted: &[i32]) -> bool {
        // æ£€æŸ¥ç¨³å®šæ€§ / Check stability
        let mut original_pairs: Vec<(i32, usize)> = original.iter().enumerate()
            .map(|(i, &x)| (x, i)).collect();
        let mut sorted_pairs: Vec<(i32, usize)> = sorted.iter().enumerate()
            .map(|(i, &x)| (x, i)).collect();

        // æŒ‰å€¼æ’åºï¼Œä¿æŒåŸå§‹ç´¢å¼• / Sort by value, keeping original indices
        original_pairs.sort_by_key(|&(x, _)| x);
        sorted_pairs.sort_by_key(|&(x, _)| x);

        // æ£€æŸ¥ç›¸å¯¹ä½ç½® / Check relative positions
        for i in 0..original_pairs.len() {
            if original_pairs[i].0 != sorted_pairs[i].0 {
                return false;
            }
        }

        true
    }

    /// åˆ†æå¤æ‚åº¦ / Analyze complexity
    fn analyze_complexity(&self, impl: &Implementation) -> Complexity {
        // ç®€åŒ–å®ç° / Simplified implementation
        Complexity::O(n_log_n)
    }
}

#[derive(Debug)]
pub struct Specification {
    pub name: String,
    pub description: String,
}

impl Specification {
    pub fn sort(&self, input: &[i32]) -> Vec<i32> {
        let mut result = input.to_vec();
        result.sort();
        result
    }

    pub fn expected_complexity(&self) -> Complexity {
        Complexity::O(n_log_n)
    }
}

#[derive(Debug)]
pub struct Implementation {
    pub name: String,
    pub code: String,
}

impl Implementation {
    pub fn sort(&self, input: &[i32]) -> Vec<i32> {
        // å…·ä½“å®ç° / Concrete implementation
        let mut result = input.to_vec();
        result.sort();
        result
    }
}

#[derive(Debug, PartialEq)]
pub enum Complexity {
    O(1),
    O(log_n),
    O(n),
    O(n_log_n),
    O(n_squared),
    O(n_cubed),
    O(exponential),
}

#[derive(Debug)]
pub struct VerificationResult {
    pub algorithm: String,
    pub correctness: bool,
    pub stability: bool,
    pub complexity: bool,
}

#[derive(Debug)]
pub struct TestCase {
    pub input: Vec<i32>,
    pub expected: Vec<i32>,
}
```

### 4.4.2 å®‰å…¨å±æ€§éªŒè¯ (Safety Property Verification)

```rust
/// å®‰å…¨å±æ€§éªŒè¯ / Safety Property Verification
pub struct SafetyVerifier {
    system_model: SystemModel,
    safety_properties: Vec<SafetyProperty>,
}

impl SafetyVerifier {
    /// éªŒè¯äº’æ–¥é” / Verify mutual exclusion
    pub fn verify_mutual_exclusion(&self) -> SafetyResult {
        let mut violations = Vec::new();

        // æ£€æŸ¥æ‰€æœ‰å¯è¾¾çŠ¶æ€ / Check all reachable states
        let reachable_states = self.system_model.get_reachable_states();

        for state in reachable_states {
            if self.violates_mutual_exclusion(&state) {
                violations.push(state);
            }
        }

        SafetyResult {
            property: "Mutual Exclusion".to_string(),
            satisfied: violations.is_empty(),
            violations,
        }
    }

    /// éªŒè¯æ— æ­»é” / Verify deadlock freedom
    pub fn verify_deadlock_freedom(&self) -> SafetyResult {
        let mut deadlocks = Vec::new();

        // æ£€æŸ¥æ­»é”çŠ¶æ€ / Check deadlock states
        let all_states = self.system_model.get_all_states();

        for state in all_states {
            if self.is_deadlock(&state) {
                deadlocks.push(state);
            }
        }

        SafetyResult {
            property: "Deadlock Freedom".to_string(),
            satisfied: deadlocks.is_empty(),
            violations: deadlocks,
        }
    }

    /// éªŒè¯èµ„æºå®‰å…¨ / Verify resource safety
    pub fn verify_resource_safety(&self) -> SafetyResult {
        let mut violations = Vec::new();

        // æ£€æŸ¥èµ„æºä½¿ç”¨ / Check resource usage
        let resource_usage = self.system_model.get_resource_usage();

        for usage in resource_usage {
            if self.violates_resource_safety(&usage) {
                violations.push(usage);
            }
        }

        SafetyResult {
            property: "Resource Safety".to_string(),
            satisfied: violations.is_empty(),
            violations,
        }
    }

    /// æ£€æŸ¥æ˜¯å¦è¿åäº’æ–¥ / Check if violates mutual exclusion
    fn violates_mutual_exclusion(&self, state: &SystemState) -> bool {
        let critical_sections = state.get_critical_sections();
        critical_sections.len() > 1
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºæ­»é” / Check if deadlock
    fn is_deadlock(&self, state: &SystemState) -> bool {
        let processes = state.get_processes();
        let resources = state.get_resources();

        // æ£€æŸ¥å¾ªç¯ç­‰å¾… / Check circular wait
        self.has_circular_wait(processes, resources)
    }

    /// æ£€æŸ¥å¾ªç¯ç­‰å¾… / Check circular wait
    fn has_circular_wait(&self, processes: &[Process], resources: &[Resource]) -> bool {
        // ç®€åŒ–å®ç° / Simplified implementation
        false
    }

    /// æ£€æŸ¥æ˜¯å¦è¿åèµ„æºå®‰å…¨ / Check if violates resource safety
    fn violates_resource_safety(&self, usage: &ResourceUsage) -> bool {
        usage.allocated > usage.available
    }
}

/// ç³»ç»Ÿæ¨¡å‹ / System Model
pub struct SystemModel {
    pub states: Vec<SystemState>,
    pub transitions: Vec<Transition>,
}

impl SystemModel {
    pub fn get_reachable_states(&self) -> Vec<SystemState> {
        // è®¡ç®—å¯è¾¾çŠ¶æ€ / Compute reachable states
        let mut reachable = HashSet::new();
        let mut queue = VecDeque::new();

        if let Some(initial) = self.states.first() {
            queue.push_back(initial.clone());
            reachable.insert(initial.clone());
        }

        while let Some(state) = queue.pop_front() {
            for transition in &self.transitions {
                if transition.from == state.id {
                    let next_state = self.get_state(transition.to);
                    if !reachable.contains(&next_state) {
                        reachable.insert(next_state.clone());
                        queue.push_back(next_state);
                    }
                }
            }
        }

        reachable.into_iter().collect()
    }

    pub fn get_all_states(&self) -> Vec<SystemState> {
        self.states.clone()
    }

    pub fn get_resource_usage(&self) -> Vec<ResourceUsage> {
        // è®¡ç®—èµ„æºä½¿ç”¨æƒ…å†µ / Compute resource usage
        Vec::new()
    }

    fn get_state(&self, id: String) -> SystemState {
        self.states.iter().find(|s| s.id == id).unwrap().clone()
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SystemState {
    pub id: String,
    pub processes: Vec<Process>,
    pub resources: Vec<Resource>,
}

impl SystemState {
    pub fn get_critical_sections(&self) -> Vec<CriticalSection> {
        self.processes.iter()
            .filter_map(|p| p.critical_section.clone())
            .collect()
    }

    pub fn get_processes(&self) -> Vec<Process> {
        self.processes.clone()
    }

    pub fn get_resources(&self) -> Vec<Resource> {
        self.resources.clone()
    }
}

#[derive(Debug, Clone)]
pub struct Process {
    pub id: String,
    pub state: ProcessState,
    pub critical_section: Option<CriticalSection>,
}

#[derive(Debug, Clone)]
pub struct Resource {
    pub id: String,
    pub available: i32,
    pub allocated: i32,
}

#[derive(Debug, Clone)]
pub struct CriticalSection {
    pub process_id: String,
    pub resource_id: String,
}

#[derive(Debug, Clone)]
pub struct Transition {
    pub from: String,
    pub to: String,
    pub action: String,
}

#[derive(Debug, Clone)]
pub struct ResourceUsage {
    pub resource_id: String,
    pub available: i32,
    pub allocated: i32,
}

#[derive(Debug)]
pub struct SafetyResult {
    pub property: String,
    pub satisfied: bool,
    pub violations: Vec<SystemState>,
}

#[derive(Debug, Clone)]
pub enum ProcessState {
    Running,
    Waiting,
    Blocked,
    Terminated,
}
```

### 4.4.3 å½¢å¼åŒ–éªŒè¯æµ‹è¯• (Formal Verification Testing)

```rust
/// å½¢å¼åŒ–éªŒè¯æµ‹è¯• / Formal Verification Testing
pub struct VerificationTester {
    test_cases: Vec<TestCase>,
    verification_results: Vec<VerificationResult>,
}

impl VerificationTester {
    /// è¿è¡ŒéªŒè¯æµ‹è¯• / Run verification tests
    pub fn run_tests(&mut self) -> TestReport {
        let mut passed = 0;
        let mut failed = 0;
        let mut results = Vec::new();

        for test_case in &self.test_cases {
            let result = self.run_test(test_case);
            results.push(result.clone());

            if result.passed {
                passed += 1;
            } else {
                failed += 1;
            }
        }

        TestReport {
            total: self.test_cases.len(),
            passed,
            failed,
            results,
        }
    }

    /// è¿è¡Œå•ä¸ªæµ‹è¯• / Run single test
    fn run_test(&self, test_case: &TestCase) -> TestResult {
        match test_case.test_type {
            TestType::Correctness => self.test_correctness(test_case),
            TestType::Safety => self.test_safety(test_case),
            TestType::Performance => self.test_performance(test_case),
        }
    }

    /// æµ‹è¯•æ­£ç¡®æ€§ / Test correctness
    fn test_correctness(&self, test_case: &TestCase) -> TestResult {
        let input = &test_case.input;
        let expected = &test_case.expected;
        let actual = self.execute_program(input);

        TestResult {
            test_name: test_case.name.clone(),
            passed: actual == *expected,
            actual: Some(actual),
            expected: Some(expected.clone()),
            error_message: None,
        }
    }

    /// æµ‹è¯•å®‰å…¨æ€§ / Test safety
    fn test_safety(&self, test_case: &TestCase) -> TestResult {
        let input = &test_case.input;
        let safety_check = self.perform_safety_check(input);

        TestResult {
            test_name: test_case.name.clone(),
            passed: safety_check.safe,
            actual: None,
            expected: None,
            error_message: safety_check.violation_message,
        }
    }

    /// æµ‹è¯•æ€§èƒ½ / Test performance
    fn test_performance(&self, test_case: &TestCase) -> TestResult {
        let input = &test_case.input;
        let performance = self.measure_performance(input);

        let passed = performance.time_complexity <= test_case.expected_complexity;

        TestResult {
            test_name: test_case.name.clone(),
            passed,
            actual: None,
            expected: None,
            error_message: if passed { None } else { Some("Performance requirement not met".to_string()) },
        }
    }

    /// æ‰§è¡Œç¨‹åº / Execute program
    fn execute_program(&self, input: &ProgramInput) -> ProgramOutput {
        // ç®€åŒ–å®ç° / Simplified implementation
        ProgramOutput {
            result: input.data.clone(),
            execution_time: 0.0,
        }
    }

    /// æ‰§è¡Œå®‰å…¨æ£€æŸ¥ / Perform safety check
    fn perform_safety_check(&self, input: &ProgramInput) -> SafetyCheck {
        // ç®€åŒ–å®ç° / Simplified implementation
        SafetyCheck {
            safe: true,
            violation_message: None,
        }
    }

    /// æµ‹é‡æ€§èƒ½ / Measure performance
    fn measure_performance(&self, input: &ProgramInput) -> PerformanceMetrics {
        // ç®€åŒ–å®ç° / Simplified implementation
        PerformanceMetrics {
            time_complexity: Complexity::O(n),
            space_complexity: Complexity::O(1),
            execution_time: 0.0,
        }
    }
}

#[derive(Debug)]
pub struct TestCase {
    pub name: String,
    pub test_type: TestType,
    pub input: ProgramInput,
    pub expected: ProgramOutput,
    pub expected_complexity: Complexity,
}

#[derive(Debug)]
pub enum TestType {
    Correctness,
    Safety,
    Performance,
}

#[derive(Debug, Clone)]
pub struct ProgramInput {
    pub data: Vec<i32>,
    pub parameters: HashMap<String, String>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ProgramOutput {
    pub result: Vec<i32>,
    pub execution_time: f64,
}

#[derive(Debug)]
pub struct TestResult {
    pub test_name: String,
    pub passed: bool,
    pub actual: Option<ProgramOutput>,
    pub expected: Option<ProgramOutput>,
    pub error_message: Option<String>,
}

#[derive(Debug)]
pub struct TestReport {
    pub total: usize,
    pub passed: usize,
    pub failed: usize,
    pub results: Vec<TestResult>,
}

#[derive(Debug)]
pub struct SafetyCheck {
    pub safe: bool,
    pub violation_message: Option<String>,
}

#[derive(Debug)]
pub struct PerformanceMetrics {
    pub time_complexity: Complexity,
    pub space_complexity: Complexity,
    pub execution_time: f64,
}
```

---

## 4.5 å‚è€ƒæ–‡çŒ® / References

> **è¯´æ˜ / Note**: æœ¬æ–‡æ¡£çš„å‚è€ƒæ–‡çŒ®é‡‡ç”¨ç»Ÿä¸€çš„å¼•ç”¨æ ‡å‡†ï¼Œæ‰€æœ‰æ–‡çŒ®æ¡ç›®å‡æ¥è‡ª `docs/references_database.yaml` æ•°æ®åº“ã€‚

### å½¢å¼åŒ–éªŒè¯æ–¹æ³• / Formal Verification Methods

1. [Clarke2018] Clarke, E. M., Henzinger, T. A., Veith, H., & Bloem, R. (2018). *Handbook of Model Checking*. Springer. ISBN: 978-3319105741. DOI: 10.1007/978-3-319-10575-8
   - **Clarkeæ¨¡å‹æ£€æŸ¥æ‰‹å†Œ**ï¼Œå½¢å¼åŒ–éªŒè¯çš„æƒå¨æ•™æã€‚æœ¬æ–‡æ¡£çš„æ¨¡å‹æ£€æŸ¥å®ç°å‚è€ƒæ­¤ä¹¦ã€‚

2. **Cousot, P., & Cousot, R.** (1977). "Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints". *Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages*, 238-252.
   - Cousotå¤«å¦‡çš„æŠ½è±¡è§£é‡Šå¼€åˆ›æ€§è®ºæ–‡ï¼Œé™æ€åˆ†æçš„ç†è®ºåŸºç¡€ã€‚

### å®šç†è¯æ˜å·¥å…· / Theorem Proving Tools

1. [Bertot2004] Bertot, Y., & CastÃ©ran, P. (2004). *Interactive Theorem Proving and Program Development: Coq'Art: The Calculus of Inductive Constructions*. Springer. ISBN: 978-3540208549. DOI: 10.1007/978-3-662-07964-5
   - **Coq'Artç»å…¸æ•™æ**ï¼ŒCoqå®šç†è¯æ˜åŠ©æ‰‹æƒå¨æŒ‡å—ã€‚æœ¬æ–‡æ¡£çš„CoqéªŒè¯ç¤ºä¾‹å‚è€ƒæ­¤ä¹¦ã€‚

2. [Nipkow2002] Nipkow, T., Paulson, L. C., & Wenzel, M. (2002). *Isabelle/HOL: A Proof Assistant for Higher-Order Logic*. Springer. ISBN: 978-3540433767. DOI: 10.1007/3-540-45949-9
   - **Isabelle/HOLæƒå¨æ•™æ**ï¼Œé«˜é˜¶é€»è¾‘å®šç†è¯æ˜ã€‚æœ¬æ–‡æ¡£çš„IsabelleéªŒè¯ç¤ºä¾‹å‚è€ƒæ­¤ä¹¦ã€‚

3. [Pierce2002TAPL] Pierce, B. C. (2002). *Types and Programming Languages*. MIT Press. ISBN: 978-0262162098
   - Pierceç±»å‹ä¸ç¨‹åºè®¾è®¡è¯­è¨€çš„ç»å…¸æ•™æï¼Œç±»å‹å®‰å…¨éªŒè¯çš„ç†è®ºåŸºç¡€ã€‚

### å…¶ä»–ç›¸å…³æ–‡çŒ® / Other Related Literature

1. **de Moura, L., & BjÃ¸rner, N.** (2008). "Z3: An Efficient SMT Solver". *Tools and Algorithms for the Construction and Analysis of Systems*, 4963, 337-340.
   - Z3 SMTæ±‚è§£å™¨è®ºæ–‡ï¼Œè‡ªåŠ¨åŒ–éªŒè¯å·¥å…·ã€‚

2. **Holzmann, G. J.** (2003). *The SPIN Model Checker: Primer and Reference Manual*. Addison-Wesley.
   - SPINæ¨¡å‹æ£€æŸ¥å™¨æ‰‹å†Œï¼Œå¹¶å‘ç³»ç»ŸéªŒè¯å·¥å…·ã€‚

---

*æœ¬æ–‡æ¡£æä¾›äº†å½¢å¼åŒ–éªŒè¯çš„å…¨é¢å®ç°æ¡†æ¶ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€éªŒè¯æ–¹æ³•ã€å·¥å…·ç³»ç»Ÿå’Œå®ç°ç¤ºä¾‹ã€‚æ‰€æœ‰å†…å®¹å‡é‡‡ç”¨ä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–è¡¨ç¤ºï¼Œå¹¶åŒ…å«å®Œæ•´çš„ä»£ç å®ç°ã€‚*

---

## 4.6 CIé›†æˆä¸è‡ªåŠ¨éªŒè¯ï¼ˆGitHub Actionsï¼‰

ä¸ºä¿è¯æ–‡æ¡£ä¸­çš„ç¤ºä¾‹ä»£ç å¯æŒç»­æ„å»ºä¸éªŒè¯ï¼Œå»ºè®®åœ¨ä»“åº“æ ¹ç›®å½•æ·»åŠ  GitHub Actions å·¥ä½œæµï¼Œå®ç°å¯¹ Rustã€Haskellï¼ˆStack/Cabalï¼‰ä¸ Lean 4 çš„è‡ªåŠ¨æ„å»ºä¸æµ‹è¯•ã€‚

ç›®å½•å»ºè®®ï¼š

```text
.github/workflows/
  â”œâ”€ ci-rust.yml
  â”œâ”€ ci-hs.yml
  â””â”€ ci-lean.yml
```

### 4.6.1 Rust å·¥ä½œæµï¼ˆci-rust.ymlï¼‰

```yaml
name: CI-Rust
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Build
        run: |
          cargo build --workspace --verbose
      - name: Test
        run: |
          cargo test --workspace --verbose
      - name: Clippy
        run: |
          rustup component add clippy || true
          cargo clippy --workspace -- -D warnings
      - name: Format
        run: |
          rustup component add rustfmt || true
          cargo fmt --all -- --check
```

### 4.6.2 Haskell å·¥ä½œæµï¼ˆci-hs.ymlï¼‰

åŒæ—¶æ”¯æŒ Stack ä¸ Cabalï¼Œä¸¤ç§æ–¹å¼å¯äºŒé€‰ä¸€æˆ–å¹¶è¡Œã€‚

```yaml
name: CI-Haskell
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  stack:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: haskell/actions/setup@v2
        with:
          ghc-version: '9.6.5'
          enable-stack: true
      - name: Build (Stack)
        run: |
          stack setup
          stack build --test --no-run-tests
      - name: Test (Stack)
        run: |
          stack test
  cabal:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: haskell/actions/setup@v2
        with:
          ghc-version: '9.6.5'
          enable-stack: false
      - name: Update
        run: cabal update
      - name: Build (Cabal)
        run: cabal build all
      - name: Test (Cabal)
        run: cabal test all
```

### 4.6.3 Lean 4 å·¥ä½œæµï¼ˆci-lean.ymlï¼‰

```yaml
name: CI-Lean4
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install elan
        run: |
          curl -sSfL https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh | sh -s -- -y
          echo "$HOME/.elan/bin" >> $GITHUB_PATH
      - name: Build
        run: |
          lake build
      - name: Run (optional)
        run: |
          lake exe fa-lean || true
```

è¯´æ˜ï¼š

- Rust å·¥ä½œæµè¦†ç›–æ„å»ºã€æµ‹è¯•ã€Clippyä¸æ ¼å¼åŒ–æ£€æŸ¥ï¼Œç¡®ä¿ç¤ºä¾‹è´¨é‡ã€‚
- Haskell å·¥ä½œæµåˆ†åˆ«ç»™å‡º Stack ä¸ Cabal é…ç½®ï¼Œå¯æŒ‰é¡¹ç›®é€‰æ‹©ï¼›è‹¥åŒæ—¶å­˜åœ¨ï¼Œä¸¤ä¸ª job å°†å¹¶è¡Œæ‰§è¡Œã€‚
- Lean 4 å·¥ä½œæµä½¿ç”¨ elan + lake æ„å»ºï¼›`lake exe`é˜¶æ®µå¯æ”¹ä¸ºè¿è¡Œç‰¹å®šå¯æ‰§è¡Œæˆ–è·³è¿‡ã€‚

---

é™„ï¼š`docs/08-å®ç°ç¤ºä¾‹/03-Leanå®ç°.md`ä¸­å¦‚éœ€å¤šæ¨¡å—ç¤ºä¾‹ï¼Œå¯å‚è€ƒä»¥ä¸‹ lake é…ç½®ç‰‡æ®µï¼š

```lean
-- lakefile.leanï¼ˆå¤šæ¨¡å—ï¼‰
import Lake
open Lake DSL

package Â«fa-leanÂ» where

@[default_target]
lean_lib CoreLib where
  -- æºä»£ç ä½äº ./CoreLib ä¸‹

lean_exe faMain where
  root := `Main
```

é¡¹ç›®ç»“æ„ï¼š

```text
fa-lean/
â”œâ”€ lakefile.lean
â”œâ”€ lean-toolchain
â”œâ”€ Main.lean            -- å…¥å£ï¼Œimport CoreLib
â””â”€ CoreLib/
   â”œâ”€ Basic.lean
   â””â”€ Verify.lean
```

`Main.lean` ç¤ºä¾‹ï¼š

```lean
import CoreLib.Basic
import CoreLib.Verify

def main : IO Unit := do
  IO.println s!"Check: {1+2}"
```
